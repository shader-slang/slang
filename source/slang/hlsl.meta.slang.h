SLANG_RAW("// Slang HLSL compatibility library\n")
SLANG_RAW("\n")
SLANG_RAW("typedef uint UINT;\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("__magic_type(HLSLAppendStructuredBufferType)\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_HLSLAppendStructuredBufferType
)
SLANG_RAW(")\n")
SLANG_RAW("struct AppendStructuredBuffer\n")
SLANG_RAW("{\n")
SLANG_RAW("    void Append(T value);\n")
SLANG_RAW("\n")
SLANG_RAW("    void GetDimensions(\n")
SLANG_RAW("        out uint numStructs,\n")
SLANG_RAW("        out uint stride);\n")
SLANG_RAW("};\n")
SLANG_RAW("\n")
SLANG_RAW("__magic_type(HLSLByteAddressBufferType)\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_HLSLByteAddressBufferType
)
SLANG_RAW(")\n")
SLANG_RAW("struct ByteAddressBuffer\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_intrinsic(glsl, \"$1 = $0._data.length() * 4\")\n")
SLANG_RAW("    void GetDimensions(\n")
SLANG_RAW("        out uint dim);\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(glsl, \"$0._data[$1/4]\")\n")
SLANG_RAW("    uint Load(int location);\n")
SLANG_RAW("\n")
SLANG_RAW("    uint Load(int location, out uint status);\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(glsl, \"uvec2($0._data[$1/4], $0._data[$1/4+1])\")\n")
SLANG_RAW("    uint2 Load2(int location);\n")
SLANG_RAW("\n")
SLANG_RAW("    uint2 Load2(int location, out uint status);\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(glsl, \"uvec3($0._data[$1/4], $0._data[$1/4+1], $0._data[$1/4+2])\")\n")
SLANG_RAW("    uint3 Load3(int location);\n")
SLANG_RAW("\n")
SLANG_RAW("    uint3 Load3(int location, out uint status);\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(glsl, \"uvec4($0._data[$1/4], $0._data[$1/4+1], $0._data[$1/4+2], $0._data[$1/4+3])\")\n")
SLANG_RAW("    uint4 Load4(int location);\n")
SLANG_RAW("\n")
SLANG_RAW("    uint4 Load4(int location, out uint status);\n")
SLANG_RAW("};\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("__magic_type(HLSLStructuredBufferType)\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_HLSLStructuredBufferType
)
SLANG_RAW(")\n")
SLANG_RAW("struct StructuredBuffer\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_intrinsic(glsl, \"$1 = $0._data.length(); $2 = 0\")\n")
SLANG_RAW("    void GetDimensions(\n")
SLANG_RAW("        out uint numStructs,\n")
SLANG_RAW("        out uint stride);\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(glsl, \"$0._data[$1]\") \n")
SLANG_RAW("    T Load(int location);\n")
SLANG_RAW("    T Load(int location, out uint status);\n")
SLANG_RAW("\n")
SLANG_RAW("    __subscript(uint index) -> T\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_intrinsic(glsl, \"$0._data[$1]\")\n")
SLANG_RAW("        get;\n")
SLANG_RAW("    };\n")
SLANG_RAW("};\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("__magic_type(HLSLConsumeStructuredBufferType)\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_HLSLConsumeStructuredBufferType
)
SLANG_RAW(")\n")
SLANG_RAW("struct ConsumeStructuredBuffer\n")
SLANG_RAW("{\n")
SLANG_RAW("    T Consume();\n")
SLANG_RAW("\n")
SLANG_RAW("    void GetDimensions(\n")
SLANG_RAW("        out uint numStructs,\n")
SLANG_RAW("        out uint stride);\n")
SLANG_RAW("};\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T, let N : int>\n")
SLANG_RAW("__magic_type(HLSLInputPatchType)\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_HLSLInputPatchType
)
SLANG_RAW(")\n")
SLANG_RAW("struct InputPatch\n")
SLANG_RAW("{\n")
SLANG_RAW("    __subscript(uint index) -> T;\n")
SLANG_RAW("};\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T, let N : int>\n")
SLANG_RAW("__magic_type(HLSLOutputPatchType)\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_HLSLOutputPatchType
)
SLANG_RAW(")\n")
SLANG_RAW("struct OutputPatch\n")
SLANG_RAW("{\n")
SLANG_RAW("    __subscript(uint index) -> T;\n")
SLANG_RAW("};\n")
SLANG_RAW("\n")

static const struct {
    IROp op;
    char const* name;
} kMutableByteAddressBufferCases[] =
{
    { kIROp_HLSLRWByteAddressBufferType,                "RWByteAddressBuffer" },
    { kIROp_HLSLRasterizerOrderedByteAddressBufferType, "RasterizerOrderedByteAddressBuffer" },
};
for(auto item : kMutableByteAddressBufferCases) {
SLANG_RAW("#line 105 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("__magic_type(HLSL")
SLANG_SPLICE(item.name
)
SLANG_RAW("Type)\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(item.op
)
SLANG_RAW(")\n")
SLANG_RAW("struct ")
SLANG_SPLICE(item.name
)
SLANG_RAW("\n")
SLANG_RAW("{\n")
SLANG_RAW("    // Note(tfoley): supports all operations from `ByteAddressBuffer`\n")
SLANG_RAW("    // TODO(tfoley): can this be made a sub-type?\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(glsl, \"$1 = $0._data.length() * 4\")\n")
SLANG_RAW("    void GetDimensions(\n")
SLANG_RAW("        out uint dim);\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(glsl, \"$0._data[$1/4]\")\n")
SLANG_RAW("    uint Load(int location);\n")
SLANG_RAW("\n")
SLANG_RAW("    uint Load(int location, out uint status);\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(glsl, \"uvec2($0._data[$1/4], $0._data[$1/4+1])\")\n")
SLANG_RAW("    uint2 Load2(int location);\n")
SLANG_RAW("\n")
SLANG_RAW("    uint2 Load2(int location, out uint status);\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(glsl, \"uvec3($0._data[$1/4], $0._data[$1/4+1], $0._data[$1/4+2])\")\n")
SLANG_RAW("    uint3 Load3(int location);\n")
SLANG_RAW("\n")
SLANG_RAW("    uint3 Load3(int location, out uint status);\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(glsl, \"uvec4($0._data[$1/4], $0._data[$1/4+1], $0._data[$1/4+2], $0._data[$1/4+3])\")\n")
SLANG_RAW("    uint4 Load4(int location);\n")
SLANG_RAW("\n")
SLANG_RAW("    uint4 Load4(int location, out uint status);\n")
SLANG_RAW("\n")
SLANG_RAW("    // Added operations:\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(glsl, \"($3 = atomicAdd($0._data[$1/4], $2))\")\n")
SLANG_RAW("    void InterlockedAdd(\n")
SLANG_RAW("        UINT dest,\n")
SLANG_RAW("        UINT value,\n")
SLANG_RAW("        out UINT original_value);\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(glsl, \"atomicAdd($0._data[$1/4], $2)\")\n")
SLANG_RAW("    void InterlockedAdd(\n")
SLANG_RAW("        UINT dest,\n")
SLANG_RAW("        UINT value);\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(glsl, \"($3 = atomicAnd($0._data[$1/4], $2))\")\n")
SLANG_RAW("    void InterlockedAnd(\n")
SLANG_RAW("        UINT dest,\n")
SLANG_RAW("        UINT value,\n")
SLANG_RAW("        out UINT original_value);\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(glsl, \"atomicAnd($0._data[$1/4], $2)\")\n")
SLANG_RAW("    void InterlockedAnd(\n")
SLANG_RAW("        UINT dest,\n")
SLANG_RAW("        UINT value);\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(glsl, \"($4 = atomicCompSwap($0._data[$1/4], $2, $3))\")\n")
SLANG_RAW("    void InterlockedCompareExchange(\n")
SLANG_RAW("        UINT dest,\n")
SLANG_RAW("        UINT compare_value,\n")
SLANG_RAW("        UINT value,\n")
SLANG_RAW("        out UINT original_value);\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(glsl, \"atomicCompSwap($0._data[$1/4], $2, $3)\")\n")
SLANG_RAW("    void InterlockedCompareStore(\n")
SLANG_RAW("        UINT dest,\n")
SLANG_RAW("        UINT compare_value,\n")
SLANG_RAW("        UINT value);\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(glsl, \"($3 = atomicExchange($0._data[$1/4], $2))\")\n")
SLANG_RAW("    void InterlockedExchange(\n")
SLANG_RAW("        UINT dest,\n")
SLANG_RAW("        UINT value,\n")
SLANG_RAW("        out UINT original_value);\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(glsl, \"($3 = atomicMax($0._data[$1/4], $2))\")\n")
SLANG_RAW("    void InterlockedMax(\n")
SLANG_RAW("        UINT dest,\n")
SLANG_RAW("        UINT value,\n")
SLANG_RAW("        out UINT original_value);\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(glsl, \"atomicMax($0._data[$1/4], $2)\")\n")
SLANG_RAW("    void InterlockedMax(\n")
SLANG_RAW("        UINT dest,\n")
SLANG_RAW("        UINT value);\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(glsl, \"($3 = atomicMin($0._data[$1/4], $2))\")\n")
SLANG_RAW("    void InterlockedMin(\n")
SLANG_RAW("        UINT dest,\n")
SLANG_RAW("        UINT value,\n")
SLANG_RAW("        out UINT original_value);\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(glsl, \"atomicMin($0._data[$1/4], $2)\")\n")
SLANG_RAW("    void InterlockedMin(\n")
SLANG_RAW("        UINT dest,\n")
SLANG_RAW("        UINT value);\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(glsl, \"($3 = atomicOr($0._data[$1/4], $2))\")\n")
SLANG_RAW("    void InterlockedOr(\n")
SLANG_RAW("        UINT dest,\n")
SLANG_RAW("        UINT value,\n")
SLANG_RAW("        out UINT original_value);\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(glsl, \"atomicOr($0._data[$1/4], $2)\")\n")
SLANG_RAW("    void InterlockedOr(\n")
SLANG_RAW("        UINT dest,\n")
SLANG_RAW("        UINT value);\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(glsl, \"($3 = atomicXor($0._data[$1/4], $2))\")\n")
SLANG_RAW("    void InterlockedXor(\n")
SLANG_RAW("        UINT dest,\n")
SLANG_RAW("        UINT value,\n")
SLANG_RAW("        out UINT original_value);\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(glsl, \"atomicXor($0._data[$1/4], $2)\")\n")
SLANG_RAW("    void InterlockedXor(\n")
SLANG_RAW("        UINT dest,\n")
SLANG_RAW("        UINT value);\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(glsl, \"$0._data[$1/4] = $2\")\n")
SLANG_RAW("    void Store(\n")
SLANG_RAW("        uint address,\n")
SLANG_RAW("        uint value);\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(glsl, \"$0._data[$1/4] = $2.x, $0._data[$1/4+1] = $2.y\")\n")
SLANG_RAW("    void Store2(\n")
SLANG_RAW("        uint address,\n")
SLANG_RAW("        uint2 value);\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(glsl, \"$0._data[$1/4] = $2.x, $0._data[$1/4+1] = $2.y, $0._data[$1/4+2] = $2.z\")\n")
SLANG_RAW("    void Store3(\n")
SLANG_RAW("        uint address,\n")
SLANG_RAW("        uint3 value);\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(glsl, \"$0._data[$1/4] = $2.x, $0._data[$1/4+1] = $2.y, $0._data[$1/4+2] = $2.z, $0._data[$1/4+3] = $2.w\")\n")
SLANG_RAW("    void Store4(\n")
SLANG_RAW("        uint address,\n")
SLANG_RAW("        uint4 value);\n")
SLANG_RAW("};\n")
SLANG_RAW("\n")

}
SLANG_RAW("#line 248 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")

static const struct {
    IROp op;
    char const* name;
} kMutableStructuredBufferCases[] =
{
    { kIROp_HLSLRWStructuredBufferType,                "RWStructuredBuffer" }, 
    { kIROp_HLSLRasterizerOrderedStructuredBufferType, "RasterizerOrderedStructuredBuffer" },
};
for(auto item : kMutableStructuredBufferCases) {
SLANG_RAW("#line 260 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("__magic_type(HLSL")
SLANG_SPLICE(item.name
)
SLANG_RAW("Type)\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(item.op
)
SLANG_RAW(")\n")
SLANG_RAW("struct ")
SLANG_SPLICE(item.name
)
SLANG_RAW("\n")
SLANG_RAW("{\n")
SLANG_RAW("    uint DecrementCounter();\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(glsl, \"$1 = $0._data.length(); $2 = 0\")\n")
SLANG_RAW("    void GetDimensions(\n")
SLANG_RAW("        out uint numStructs,\n")
SLANG_RAW("        out uint stride);\n")
SLANG_RAW("\n")
SLANG_RAW("    uint IncrementCounter();\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(glsl, \"$0._data[$1]\")\n")
SLANG_RAW("    T Load(int location);\n")
SLANG_RAW("    T Load(int location, out uint status);\n")
SLANG_RAW("\n")
SLANG_RAW("    __subscript(uint index) -> T\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_intrinsic(glsl, \"$0._data[$1]\")\n")
SLANG_RAW("        ref;\n")
SLANG_RAW("    }\n")
SLANG_RAW("};\n")
SLANG_RAW("\n")

}
SLANG_RAW("#line 290 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("__magic_type(HLSLPointStreamType)\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_HLSLPointStreamType
)
SLANG_RAW(")\n")
SLANG_RAW("struct PointStream\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_intrinsic(glsl, \"EmitVertex()\")\n")
SLANG_RAW("    void Append(T value);\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(glsl, \"EndPrimitive()\")\n")
SLANG_RAW("    void RestartStrip();\n")
SLANG_RAW("};\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("__magic_type(HLSLLineStreamType)\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_HLSLLineStreamType
)
SLANG_RAW(")\n")
SLANG_RAW("struct LineStream\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_intrinsic(glsl, \"EmitVertex()\")\n")
SLANG_RAW("    void Append(T value);\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(glsl, \"EndPrimitive()\")\n")
SLANG_RAW("    void RestartStrip();\n")
SLANG_RAW("};\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("__magic_type(HLSLTriangleStreamType)\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_HLSLTriangleStreamType
)
SLANG_RAW(")\n")
SLANG_RAW("struct TriangleStream\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_intrinsic(glsl, \"EmitVertex()\")\n")
SLANG_RAW("    void Append(T value);\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(glsl, \"EndPrimitive()\")\n")
SLANG_RAW("    void RestartStrip();\n")
SLANG_RAW("};\n")
SLANG_RAW("\n")
SLANG_RAW("// Note(tfoley): Trying to systematically add all the HLSL builtins\n")
SLANG_RAW("\n")
SLANG_RAW("// Try to terminate the current draw or dispatch call (HLSL SM 4.0)\n")
SLANG_RAW("void abort();\n")
SLANG_RAW("\n")
SLANG_RAW("// Absolute value (HLSL SM 1.0)\n")
SLANG_RAW("__generic<T : __BuiltinSignedArithmeticType> T abs(T x);\n")
SLANG_RAW("__generic<T : __BuiltinSignedArithmeticType, let N : int> vector<T,N> abs(vector<T,N> x);\n")
SLANG_RAW("__generic<T : __BuiltinSignedArithmeticType, let N : int, let M : int> matrix<T,N,M> abs(matrix<T,N,M> x);\n")
SLANG_RAW("\n")
SLANG_RAW("// Inverse cosine (HLSL SM 1.0)\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType> T acos(T x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int> vector<T,N> acos(vector<T,N> x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int> matrix<T,N,M> acos(matrix<T,N,M> x);\n")
SLANG_RAW("\n")
SLANG_RAW("// Test if all components are non-zero (HLSL SM 1.0)\n")
SLANG_RAW("__generic<T : __BuiltinType> bool all(T x);\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int> bool all(vector<T,N> x);\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int, let M : int> bool all(matrix<T,N,M> x);\n")
SLANG_RAW("\n")
SLANG_RAW("// Barrier for writes to all memory spaces (HLSL SM 5.0)\n")
SLANG_RAW("__target_intrinsic(glsl, \"memoryBarrier(), groupMemoryBarrier(), memoryBarrierImage(), memoryBarrierBuffer()\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"__threadfence()\")\n")
SLANG_RAW("void AllMemoryBarrier();\n")
SLANG_RAW("\n")
SLANG_RAW("// Thread-group sync and barrier for writes to all memory spaces (HLSL SM 5.0)\n")
SLANG_RAW("__target_intrinsic(glsl, \"memoryBarrier(), groupMemoryBarrier(), memoryBarrierImage(), memoryBarrierBuffer(), barrier()\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"__syncthreads()\")\n")
SLANG_RAW("void AllMemoryBarrierWithGroupSync();\n")
SLANG_RAW("\n")
SLANG_RAW("// Test if any components is non-zero (HLSL SM 1.0)\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType>\n")
SLANG_RAW("__target_intrinsic(glsl, \"bool($0)\")\n")
SLANG_RAW("bool any(T x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int>\n")
SLANG_RAW("__target_intrinsic(glsl, \"any(bvec$N0($0))\")\n")
SLANG_RAW("bool any(vector<T,N> x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int, let M : int>\n")
SLANG_RAW("// TODO: need to define GLSL mapping\n")
SLANG_RAW("bool any(matrix<T,N,M> x);\n")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("// Reinterpret bits as a double (HLSL SM 5.0)\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"packDouble2x32(uvec2($0, $1))\")\n")
SLANG_RAW("__glsl_extension(GL_ARB_gpu_shader5)\n")
SLANG_RAW("double asdouble(uint lowbits, uint highbits);\n")
SLANG_RAW("\n")
SLANG_RAW("double asdouble(uint lowbits, uint highbits);\n")
SLANG_RAW("\n")
SLANG_RAW("// Reinterpret bits as a float (HLSL SM 4.0)\n")
SLANG_RAW("\n")
SLANG_RAW("// GLSL Scalar\n")
SLANG_RAW("__target_intrinsic(glsl, \"intBitsToFloat\")\n")
SLANG_RAW("float asfloat(int x);\n")
SLANG_RAW("__target_intrinsic(glsl, \"uintBitsToFloat\")\n")
SLANG_RAW("float asfloat(uint x);\n")
SLANG_RAW("\n")
SLANG_RAW("// GLSL Vector\n")
SLANG_RAW("__generic<let N : int>\n")
SLANG_RAW("__target_intrinsic(glsl, \"intBitsToFloat\")\n")
SLANG_RAW("vector<float,N> asfloat(vector< int,N> x);\n")
SLANG_RAW("__generic<let N : int>\n")
SLANG_RAW("__target_intrinsic(glsl, \"uintBitsToFloat\")\n")
SLANG_RAW("vector<float,N> asfloat(vector<uint,N> x);\n")
SLANG_RAW("\n")
SLANG_RAW("// No op\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kCompoundIntrinsicOp_Pos
)
SLANG_RAW(")\n")
SLANG_RAW("float asfloat(float x);\n")
SLANG_RAW("__generic<let N : int>\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kCompoundIntrinsicOp_Pos
)
SLANG_RAW(")\n")
SLANG_RAW("vector<float,N> asfloat(vector<float,N> x);\n")
SLANG_RAW("__generic<let N : int, let M : int>\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kCompoundIntrinsicOp_Pos
)
SLANG_RAW(")\n")
SLANG_RAW("matrix<float,N,M> asfloat(matrix<float,N,M> x);\n")
SLANG_RAW("\n")
SLANG_RAW("// Pass thru to HLSL\n")
SLANG_RAW("float asfloat(uint x);\n")
SLANG_RAW("float asfloat(int x);\n")
SLANG_RAW("__generic<let N : int, let M : int> matrix<float,N,M> asfloat(matrix< int,N,M> x);\n")
SLANG_RAW("__generic<let N : int, let M : int> matrix<float,N,M> asfloat(matrix<uint,N,M> x);\n")
SLANG_RAW("\n")
SLANG_RAW("// Inverse sine (HLSL SM 1.0)\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType> T asin(T x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int> vector<T,N> asin(vector<T,N> x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int> matrix<T,N,M> asin(matrix<T,N,M> x);\n")
SLANG_RAW("\n")
SLANG_RAW("// Reinterpret bits as an int (HLSL SM 4.0)\n")
SLANG_RAW("\n")
SLANG_RAW("// GLSL scalar\n")
SLANG_RAW("__target_intrinsic(glsl, \"floatBitsToInt\")\n")
SLANG_RAW("int asint(float x);\n")
SLANG_RAW("__target_intrinsic(glsl, \"int($0)\")\n")
SLANG_RAW("int asint(uint x);\n")
SLANG_RAW("\n")
SLANG_RAW("// GLSL Vector\n")
SLANG_RAW("__generic<let N : int>\n")
SLANG_RAW("__target_intrinsic(glsl, \"floatBitsToInt\")\n")
SLANG_RAW("vector<int,N> asint(vector<float,N> x);\n")
SLANG_RAW("__generic<let N : int>\n")
SLANG_RAW("__target_intrinsic(glsl, \"ivec$N0($0)\")\n")
SLANG_RAW("vector<int,N> asint(vector<uint,N> x);\n")
SLANG_RAW("\n")
SLANG_RAW("// No op\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kCompoundIntrinsicOp_Pos
)
SLANG_RAW(")\n")
SLANG_RAW("int asint(int x);\n")
SLANG_RAW("__generic<let N : int>\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kCompoundIntrinsicOp_Pos
)
SLANG_RAW(")\n")
SLANG_RAW("vector<int,N> asint(vector<int,N> x);\n")
SLANG_RAW("__generic<let N : int, let M : int>\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kCompoundIntrinsicOp_Pos
)
SLANG_RAW(")\n")
SLANG_RAW("matrix<int,N,M> asint(matrix<int,N,M> x);\n")
SLANG_RAW("\n")
SLANG_RAW("// Pass thru HLSL\n")
SLANG_RAW("\n")
SLANG_RAW("int asint(float x);\n")
SLANG_RAW("int asint(uint x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let N : int> vector<int,N> asint(vector<uint,N> x);\n")
SLANG_RAW("__generic<let N : int, let M : int> matrix<int,N,M> asint(matrix<float,N,M> x);\n")
SLANG_RAW("__generic<let N : int, let M : int> matrix<int,N,M> asint(matrix<uint,N,M> x);\n")
SLANG_RAW("\n")
SLANG_RAW("// Reinterpret bits of double as a uint (HLSL SM 5.0)\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"{ uvec2 v = unpackDouble2x32($0); $1 = v.x; $2 = v.y; }\")\n")
SLANG_RAW("__glsl_extension(GL_ARB_gpu_shader5)\n")
SLANG_RAW("void asuint(double value, out uint lowbits, out uint highbits);\n")
SLANG_RAW("\n")
SLANG_RAW("void asuint(double value, out uint lowbits, out uint highbits);\n")
SLANG_RAW("\n")
SLANG_RAW("// Reinterpret bits as a uint (HLSL SM 4.0)\n")
SLANG_RAW("\n")
SLANG_RAW("// GLSL Scalar\n")
SLANG_RAW("__target_intrinsic(glsl, \"floatBitsToUint\")\n")
SLANG_RAW("uint asuint(float x);\n")
SLANG_RAW("__target_intrinsic(glsl, \"uint($0)\")\n")
SLANG_RAW("uint asuint(int x);\n")
SLANG_RAW("\n")
SLANG_RAW("// GLSL Vector\n")
SLANG_RAW("__generic<let N : int>\n")
SLANG_RAW("__target_intrinsic(glsl, \"floatBitsToUint\")\n")
SLANG_RAW("vector<uint,N> asuint(vector<float,N> x);\n")
SLANG_RAW("__generic<let N : int>\n")
SLANG_RAW("__target_intrinsic(glsl, \"uvec$N0($0)\")\n")
SLANG_RAW("vector<uint,N> asuint(vector<int,N> x);\n")
SLANG_RAW("\n")
SLANG_RAW("// No op\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kCompoundIntrinsicOp_Pos
)
SLANG_RAW(")\n")
SLANG_RAW("uint asuint(uint x);\n")
SLANG_RAW("__generic<let N : int>\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kCompoundIntrinsicOp_Pos
)
SLANG_RAW(")\n")
SLANG_RAW("vector<uint,N> asuint(vector<uint,N> x);\n")
SLANG_RAW("__generic<let N : int, let M : int>\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kCompoundIntrinsicOp_Pos
)
SLANG_RAW(")\n")
SLANG_RAW("matrix<uint,N,M> asuint(matrix<uint,N,M> x);\n")
SLANG_RAW("\n")
SLANG_RAW("// Pass thru HLSL\n")
SLANG_RAW("uint asuint(float x);\n")
SLANG_RAW("uint asuint(int x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let N : int> vector<uint,N> asuint(vector<float,N> x);\n")
SLANG_RAW("__generic<let N : int> vector<uint,N> asuint(vector<int,N> x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let N : int, let M : int> matrix<uint,N,M> asuint(matrix<float,N,M> x);\n")
SLANG_RAW("__generic<let N : int, let M : int> matrix<uint,N,M> asuint(matrix<int,N,M> x);\n")
SLANG_RAW("\n")
SLANG_RAW("// Inverse tangent (HLSL SM 1.0)\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType> T atan(T x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int> vector<T,N> atan(vector<T,N> x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int> matrix<T,N,M> atan(matrix<T,N,M> x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(glsl,\"atan($0,$1)\")\n")
SLANG_RAW("T atan2(T y, T x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(glsl,\"atan($0,$1)\")\n")
SLANG_RAW("vector<T,N> atan2(vector<T,N> y, vector<T,N> x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(glsl,\"atan($0,$1)\")\n")
SLANG_RAW("matrix<T,N,M> atan2(matrix<T,N,M> y, matrix<T,N,M> x);\n")
SLANG_RAW("\n")
SLANG_RAW("// Ceiling (HLSL SM 1.0)\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType> T ceil(T x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int> vector<T,N> ceil(vector<T,N> x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int> matrix<T,N,M> ceil(matrix<T,N,M> x);\n")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("// Check access status to tiled resource\n")
SLANG_RAW("bool CheckAccessFullyMapped(uint status);\n")
SLANG_RAW("\n")
SLANG_RAW("// Clamp (HLSL SM 1.0)\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType> T clamp(T x, T min, T max);\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int> vector<T,N> clamp(vector<T,N> x, vector<T,N> min, vector<T,N> max);\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int, let M : int> matrix<T,N,M> clamp(matrix<T,N,M> x, matrix<T,N,M> min, matrix<T,N,M> max);\n")
SLANG_RAW("\n")
SLANG_RAW("// Clip (discard) fragment conditionally\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType> void clip(T x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int> void clip(vector<T,N> x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int> void clip(matrix<T,N,M> x);\n")
SLANG_RAW("\n")
SLANG_RAW("// Cosine\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType> T cos(T x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int> vector<T,N> cos(vector<T,N> x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int> matrix<T,N,M> cos(matrix<T,N,M> x);\n")
SLANG_RAW("\n")
SLANG_RAW("// Hyperbolic cosine\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType> T cosh(T x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int> vector<T,N> cosh(vector<T,N> x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int> matrix<T,N,M> cosh(matrix<T,N,M> x);\n")
SLANG_RAW("\n")
SLANG_RAW("// Population count\n")
SLANG_RAW("__target_intrinsic(glsl, \"bitCount\")\n")
SLANG_RAW("uint countbits(uint value);\n")
SLANG_RAW("\n")
SLANG_RAW("// Cross product\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType> vector<T,3> cross(vector<T,3> x, vector<T,3> y);\n")
SLANG_RAW("\n")
SLANG_RAW("// Convert encoded color\n")
SLANG_RAW("int4 D3DCOLORtoUBYTE4(float4 x);\n")
SLANG_RAW("\n")
SLANG_RAW("// Partial-difference derivatives\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(glsl, dFdx)\n")
SLANG_RAW("T ddx(T x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(glsl, dFdx)\n")
SLANG_RAW("vector<T,N> ddx(vector<T,N> x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(glsl, dFdx)\n")
SLANG_RAW("matrix<T,N,M> ddx(matrix<T,N,M> x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__glsl_extension(GL_ARB_derivative_control)\n")
SLANG_RAW("__target_intrinsic(glsl, dFdxCoarse)\n")
SLANG_RAW("T ddx_coarse(T x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_ARB_derivative_control)\n")
SLANG_RAW("__target_intrinsic(glsl, dFdxCoarse)\n")
SLANG_RAW("vector<T,N> ddx_coarse(vector<T,N> x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__glsl_extension(GL_ARB_derivative_control)\n")
SLANG_RAW("__target_intrinsic(glsl, dFdxCoarse)\n")
SLANG_RAW("matrix<T,N,M> ddx_coarse(matrix<T,N,M> x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__glsl_extension(GL_ARB_derivative_control)\n")
SLANG_RAW("__target_intrinsic(glsl, dFdxFine)\n")
SLANG_RAW("T ddx_fine(T x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_ARB_derivative_control)\n")
SLANG_RAW("__target_intrinsic(glsl, dFdxFine)\n")
SLANG_RAW("vector<T,N> ddx_fine(vector<T,N> x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__glsl_extension(GL_ARB_derivative_control)\n")
SLANG_RAW("__target_intrinsic(glsl, dFdxFine)\n")
SLANG_RAW("matrix<T,N,M> ddx_fine(matrix<T,N,M> x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(glsl, dFdy)\n")
SLANG_RAW("T ddy(T x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(glsl, dFdy)\n")
SLANG_RAW("vector<T,N> ddy(vector<T,N> x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(glsl, dFdy)\n")
SLANG_RAW(" matrix<T,N,M> ddy(matrix<T,N,M> x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__glsl_extension(GL_ARB_derivative_control)\n")
SLANG_RAW("__target_intrinsic(glsl, dFdyCoarse)\n")
SLANG_RAW("T ddy_coarse(T x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_ARB_derivative_control)\n")
SLANG_RAW("__target_intrinsic(glsl, dFdyCoarse)\n")
SLANG_RAW("vector<T,N> ddy_coarse(vector<T,N> x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__glsl_extension(GL_ARB_derivative_control)\n")
SLANG_RAW("__target_intrinsic(glsl, dFdyCoarse)\n")
SLANG_RAW("matrix<T,N,M> ddy_coarse(matrix<T,N,M> x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__glsl_extension(GL_ARB_derivative_control)\n")
SLANG_RAW("__target_intrinsic(glsl, dFdyFine)\n")
SLANG_RAW("T ddy_fine(T x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_ARB_derivative_control)\n")
SLANG_RAW("__target_intrinsic(glsl, dFdyFine)\n")
SLANG_RAW("vector<T,N> ddy_fine(vector<T,N> x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__glsl_extension(GL_ARB_derivative_control)\n")
SLANG_RAW("__target_intrinsic(glsl, dFdyFine)\n")
SLANG_RAW("matrix<T,N,M> ddy_fine(matrix<T,N,M> x);\n")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("// Radians to degrees\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType> T degrees(T x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int> vector<T,N> degrees(vector<T,N> x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int> matrix<T,N,M> degrees(matrix<T,N,M> x);\n")
SLANG_RAW("\n")
SLANG_RAW("// Matrix determinant\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int> T determinant(matrix<T,N,N> m);\n")
SLANG_RAW("\n")
SLANG_RAW("// Barrier for device memory\n")
SLANG_RAW("__target_intrinsic(glsl, \"memoryBarrier(), memoryBarrierImage(), memoryBarrierBuffer()\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"__threadfence()\")\n")
SLANG_RAW("void DeviceMemoryBarrier();\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"memoryBarrier(), memoryBarrierImage(), memoryBarrierBuffer(), barrier()\")\n")
SLANG_RAW("__target_intrinsic(glsl, \"__syncthreads()\")\n")
SLANG_RAW("void DeviceMemoryBarrierWithGroupSync();\n")
SLANG_RAW("\n")
SLANG_RAW("// Vector distance\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int> T distance(vector<T,N> x, vector<T,N> y);\n")
SLANG_RAW("\n")
SLANG_RAW("// Vector dot product\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int> T dot(vector<T,N> x, vector<T,N> y);\n")
SLANG_RAW("\n")
SLANG_RAW("// Helper for computing distance terms for lighting (obsolete)\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType> vector<T,4> dst(vector<T,4> x, vector<T,4> y);\n")
SLANG_RAW("\n")
SLANG_RAW("// Error message\n")
SLANG_RAW("\n")
SLANG_RAW("// void errorf( string format, ... );\n")
SLANG_RAW("\n")
SLANG_RAW("// Attribute evaluation\n")
SLANG_RAW("\n")
SLANG_RAW("// TODO: The matrix cases of these functions won't actuall work\n")
SLANG_RAW("// when compiled to GLSL, since they only support scalar/vector\n")
SLANG_RAW("\n")
SLANG_RAW("// TODO: Should these be constrains to `__BuiltinFloatingPointType`?\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType>\n")
SLANG_RAW("__target_intrinsic(glsl, interpolateAtCentroid)\n")
SLANG_RAW("T EvaluateAttributeAtCentroid(T x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int>\n")
SLANG_RAW("__target_intrinsic(glsl, interpolateAtCentroid)\n")
SLANG_RAW("vector<T,N> EvaluateAttributeAtCentroid(vector<T,N> x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(glsl, interpolateAtCentroid)\n")
SLANG_RAW("matrix<T,N,M> EvaluateAttributeAtCentroid(matrix<T,N,M> x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType>\n")
SLANG_RAW("__target_intrinsic(glsl, \"interpolateAtSample($0, int($1))\")\n")
SLANG_RAW("T EvaluateAttributeAtSample(T x, uint sampleindex);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int>\n")
SLANG_RAW("__target_intrinsic(glsl, \"interpolateAtSample($0, int($1))\")\n")
SLANG_RAW("vector<T,N> EvaluateAttributeAtSample(vector<T,N> x, uint sampleindex);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(glsl, \"interpolateAtSample($0, int($1))\")\n")
SLANG_RAW("matrix<T,N,M> EvaluateAttributeAtSample(matrix<T,N,M> x, uint sampleindex);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType>\n")
SLANG_RAW("__target_intrinsic(glsl, \"interpolateAtOffset($0, vec2($1) / 16.0f)\")\n")
SLANG_RAW("T EvaluateAttributeSnapped(T x, int2 offset);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int>\n")
SLANG_RAW("__target_intrinsic(glsl, \"interpolateAtOffset($0, vec2($1) / 16.0f)\")\n")
SLANG_RAW("vector<T,N> EvaluateAttributeSnapped(vector<T,N> x, int2 offset);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(glsl, \"interpolateAtOffset($0, vec2($1) / 16.0f)\")\n")
SLANG_RAW("matrix<T,N,M> EvaluateAttributeSnapped(matrix<T,N,M> x, int2 offset);\n")
SLANG_RAW("\n")
SLANG_RAW("// Base-e exponent\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType> T exp(T x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int> vector<T,N> exp(vector<T,N> x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int> matrix<T,N,M> exp(matrix<T,N,M> x);\n")
SLANG_RAW("\n")
SLANG_RAW("// Base-2 exponent\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType> T exp2(T x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int> vector<T,N> exp2(vector<T,N> x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int> matrix<T,N,M> exp2(matrix<T,N,M> x);\n")
SLANG_RAW("\n")
SLANG_RAW("// Convert 16-bit float stored in low bits of integer\n")
SLANG_RAW("__target_intrinsic(glsl, \"unpackHalf2x16($0).x\")\n")
SLANG_RAW("float f16tof32(uint value);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let N : int>\n")
SLANG_RAW("__target_intrinsic(glsl, \"unpackHalf2x16($0).x\")\n")
SLANG_RAW("vector<float,N> f16tof32(vector<uint,N> value);\n")
SLANG_RAW("\n")
SLANG_RAW("// Convert to 16-bit float stored in low bits of integer\n")
SLANG_RAW("__target_intrinsic(glsl, \"packHalf2x16(vec2($0,0.0))\")\n")
SLANG_RAW("uint f32tof16(float value);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let N : int>\n")
SLANG_RAW("__target_intrinsic(glsl, \"packHalf2x16(vec2($0,0.0))\")\n")
SLANG_RAW("vector<uint,N> f32tof16(vector<float,N> value);\n")
SLANG_RAW("\n")
SLANG_RAW("// Flip surface normal to face forward, if needed\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int> vector<T,N> faceforward(vector<T,N> n, vector<T,N> i, vector<T,N> ng);\n")
SLANG_RAW("\n")
SLANG_RAW("// Find first set bit starting at high bit and working down\n")
SLANG_RAW("__target_intrinsic(glsl,\"findMSB\")\n")
SLANG_RAW("int firstbithigh(int value);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl,\"findMSB\")\n")
SLANG_RAW("__generic<let N : int> vector<int,N> firstbithigh(vector<int,N> value);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl,\"findMSB\")\n")
SLANG_RAW("uint firstbithigh(uint value);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl,\"findMSB\")\n")
SLANG_RAW("__generic<let N : int> vector<uint,N> firstbithigh(vector<uint,N> value);\n")
SLANG_RAW("\n")
SLANG_RAW("// Find first set bit starting at low bit and working up\n")
SLANG_RAW("__target_intrinsic(glsl,\"findLSB\")\n")
SLANG_RAW("int firstbitlow(int value);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl,\"findLSB\")\n")
SLANG_RAW("__generic<let N : int> vector<int,N> firstbitlow(vector<int,N> value);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl,\"findLSB\")\n")
SLANG_RAW("uint firstbitlow(uint value);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl,\"findLSB\")\n")
SLANG_RAW("__generic<let N : int> vector<uint,N> firstbitlow(vector<uint,N> value);\n")
SLANG_RAW("\n")
SLANG_RAW("// Floor (HLSL SM 1.0)\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType> T floor(T x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int> vector<T,N> floor(vector<T,N> x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int> matrix<T,N,M> floor(matrix<T,N,M> x);\n")
SLANG_RAW("\n")
SLANG_RAW("// Fused multiply-add for doubles\n")
SLANG_RAW("double fma(double a, double b, double c);\n")
SLANG_RAW("__generic<let N : int> vector<double, N> fma(vector<double, N> a, vector<double, N> b, vector<double, N> c);\n")
SLANG_RAW("__generic<let N : int, let M : int> matrix<double,N,M> fma(matrix<double,N,M> a, matrix<double,N,M> b, matrix<double,N,M> c);\n")
SLANG_RAW("\n")
SLANG_RAW("// Floating point remainder of x/y\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType> T fmod(T x, T y);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int> vector<T,N> fmod(vector<T,N> x, vector<T,N> y);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int> matrix<T,N,M> fmod(matrix<T,N,M> x, matrix<T,N,M> y);\n")
SLANG_RAW("\n")
SLANG_RAW("// Fractional part\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(glsl, fract)\n")
SLANG_RAW("T frac(T x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(glsl, fract)\n")
SLANG_RAW("vector<T,N> frac(vector<T,N> x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(glsl, fract)\n")
SLANG_RAW("matrix<T,N,M> frac(matrix<T,N,M> x);\n")
SLANG_RAW("\n")
SLANG_RAW("// Split float into mantissa and exponent\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType> T frexp(T x, out T exp);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int> vector<T,N> frexp(vector<T,N> x, out vector<T,N> exp);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int> matrix<T,N,M> frexp(matrix<T,N,M> x, out matrix<T,N,M> exp);\n")
SLANG_RAW("\n")
SLANG_RAW("// Texture filter width\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType> T fwidth(T x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int> vector<T,N> fwidth(vector<T,N> x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int> matrix<T,N,M> fwidth(matrix<T,N,M> x);\n")
SLANG_RAW("\n")
SLANG_RAW("// Get number of samples in render target\n")
SLANG_RAW("uint GetRenderTargetSampleCount();\n")
SLANG_RAW("\n")
SLANG_RAW("// Get position of given sample\n")
SLANG_RAW("float2 GetRenderTargetSamplePosition(int Index);\n")
SLANG_RAW("\n")
SLANG_RAW("// Group memory barrier\n")
SLANG_RAW("__target_intrinsic(glsl, \"groupMemoryBarrier\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"__threadfence_block\")\n")
SLANG_RAW("void GroupMemoryBarrier();\n")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"groupMemoryBarrier(), barrier()\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"__syncthreads()\")\n")
SLANG_RAW("void GroupMemoryBarrierWithGroupSync();\n")
SLANG_RAW("\n")
SLANG_RAW("// Atomics\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"$atomicAdd($A, $1)\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"atomicAdd(&$0, $1)\")\n")
SLANG_RAW("void InterlockedAdd(__ref  int dest,  int value);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"$atomicAdd($A, $1)\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"atomicAdd((uint*)&$0, $1)\")\n")
SLANG_RAW("void InterlockedAdd(__ref uint dest, uint value);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"($2 = $atomicAdd($A, $1))\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"($2 = atomicAdd(&$0, $1))\")\n")
SLANG_RAW("void InterlockedAdd(__ref  int dest,  int value, out  int original_value);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"($2 = $atomicAdd($A, $1))\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"($2 = (uint)atomicAdd((uint*)&$0, $1))\")\n")
SLANG_RAW("void InterlockedAdd(__ref uint dest, uint value, out uint original_value);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"$atomicAnd($A, $1)\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"atomicAnd(&$0, $1)\")\n")
SLANG_RAW("void InterlockedAnd(__ref  int dest,  int value);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"$atomicAnd($A, $1)\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"atomicAnd((int*)&$0, $1)\")\n")
SLANG_RAW("void InterlockedAnd(__ref uint dest, uint value);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"($2 = $atomicAnd($A, $1))\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"($2 = atomicAnd(&$0, $1))\")\n")
SLANG_RAW("void InterlockedAnd(__ref  int dest,  int value, out  int original_value);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"($2 = $atomicAnd($A, $1))\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"($2 = atomicAnd((int*)&$0, $1))\")\n")
SLANG_RAW("void InterlockedAnd(__ref uint dest, uint value, out uint original_value);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"($3 = $atomicCompSwap($A, $1, $2))\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"($3 = atomicCAS(&$0, $1, $2))\")\n")
SLANG_RAW("void InterlockedCompareExchange(__ref  int dest,  int compare_value,  int value, out  int original_value);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"($3 = $atomicCompSwap($A, $1, $2))\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"($3 = (uint)atomicCAS((int*)&$0, $1, $2))\")\n")
SLANG_RAW("void InterlockedCompareExchange(__ref uint dest, uint compare_value, uint value, out uint original_value);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"$atomicCompSwap($A, $1, $2)\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"atomicCAS(&$0, $1, $2)\")\n")
SLANG_RAW("void InterlockedCompareStore(__ref int dest,  int compare_value,  int value);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"$atomicCompSwap($A, $1, $2)\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"atomicCAS((int*)&$0, $1, $2)\")\n")
SLANG_RAW("void InterlockedCompareStore(__ref uint dest, uint compare_value, uint value);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"($2 = $atomicExchange($A, $1))\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"($2 = atomicExch(&$0, $1))\")\n")
SLANG_RAW("void InterlockedExchange(__ref  int dest,  int value, out  int original_value);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"($2 = $atomicExchange($A, $1))\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"($2 = (uint)atomicExch((int*)&$0, $1))\")\n")
SLANG_RAW("void InterlockedExchange(__ref uint dest, uint value, out uint original_value);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"$atomicMax($A, $1)\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"atomicMax(&$0, $1)\")\n")
SLANG_RAW("void InterlockedMax(__ref  int dest,  int value);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"$atomicMax($A, $1)\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"atomicMax((int*)&$0, $1)\")\n")
SLANG_RAW("void InterlockedMax(__ref uint dest, uint value);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"($2 = $atomicMax($A, $1))\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"($2 = atomicMax(&$0, $1))\")\n")
SLANG_RAW("void InterlockedMax(__ref  int dest,  int value, out  int original_value);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"($2 = $atomicMax($A, $1))\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"($2 = (uint)atomicMax((int*)&$0, $1))\")\n")
SLANG_RAW("void InterlockedMax(__ref uint dest, uint value, out uint original_value);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"$atomicMin($A, $1)\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"atomicMin(&$0, $1)\")\n")
SLANG_RAW("void InterlockedMin(__ref  int dest,  int value);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"$atomicMin($A, $1)\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"atomicMin((int*)&$0, $1)\")\n")
SLANG_RAW("void InterlockedMin(__ref uint dest, uint value);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"($2 = $atomicMin($A, $1))\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"($2 = atomicMin(&$0, $1))\")\n")
SLANG_RAW("void InterlockedMin(__ref  int dest,  int value, out  int original_value);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"($2 = $atomicMin($A, $1))\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"($2 = (uint)atomicMin((int*)&$0, $1))\")\n")
SLANG_RAW("void InterlockedMin(__ref uint dest, uint value, out uint original_value);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"$atomicOr($A, $1)\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"atomicOr(&$0, $1)\")\n")
SLANG_RAW("void InterlockedOr(__ref  int dest,  int value);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"$atomicOr($A, $1)\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"atomicOr((int*)&$0, $1)\")\n")
SLANG_RAW("void InterlockedOr(__ref uint dest, uint value);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"($2 = $atomicOr($A, $1))\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"($2 = atomicOr(&$0, $1))\")\n")
SLANG_RAW("void InterlockedOr(__ref  int dest,  int value, out  int original_value);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"($2 = $atomicOr($A, $1))\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"($2 = (uint)atomicOr((int*)&$0, $1))\")\n")
SLANG_RAW("void InterlockedOr(__ref uint dest, uint value, out uint original_value);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"$atomicXor($A, $1)\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"atomicXor(&$0, $1)\")\n")
SLANG_RAW("void InterlockedXor(__ref  int dest,  int value);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"$atomicXor($A, $1)\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"atomicXor((int*)&$0, $1)\")\n")
SLANG_RAW("void InterlockedXor(__ref uint dest, uint value);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"($2 = $atomicXor($A, $1))\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"($2 = atomicXor(&$0, $1))\")\n")
SLANG_RAW("void InterlockedXor(__ref  int dest,  int value, out  int original_value);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"($2 = $atomicXor($A, $1))\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"($2 = (uint)atomicXor((int*)&$0, $1))\")\n")
SLANG_RAW("void InterlockedXor(__ref uint dest, uint value, out uint original_value);\n")
SLANG_RAW("\n")
SLANG_RAW("// Is floating-point value finite?\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(glsl, \"(!(isinf($0) || isnan($0)))\")\n")
SLANG_RAW("bool isfinite(T x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(glsl, \"(!(isinf($0) || isnan($0)))\")\n")
SLANG_RAW("vector<bool,N> isfinite(vector<T,N> x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("matrix<bool,N,M> isfinite(matrix<T,N,M> x);\n")
SLANG_RAW("\n")
SLANG_RAW("// Is floating-point value infinite?\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType> bool isinf(T x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int> vector<bool,N> isinf(vector<T,N> x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int> matrix<bool,N,M> isinf(matrix<T,N,M> x);\n")
SLANG_RAW("\n")
SLANG_RAW("// Is floating-point value not-a-number?\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType> bool isnan(T x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int> vector<bool,N> isnan(vector<T,N> x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int> matrix<bool,N,M> isnan(matrix<T,N,M> x);\n")
SLANG_RAW("\n")
SLANG_RAW("// Construct float from mantissa and exponent\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(glsl, \"($0 * pow(2.0f, $1))\")\n")
SLANG_RAW("T ldexp(T x, T exp);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(glsl, \"($0 * pow(2.0f, $1))\")\n")
SLANG_RAW("vector<T,N> ldexp(vector<T,N> x, vector<T,N> exp);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("matrix<T,N,M> ldexp(matrix<T,N,M> x, matrix<T,N,M> exp);\n")
SLANG_RAW("\n")
SLANG_RAW("// Vector length\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int> T length(vector<T,N> x);\n")
SLANG_RAW("\n")
SLANG_RAW("// Linear interpolation\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(glsl, mix)\n")
SLANG_RAW("T lerp(T x, T y, T s);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(glsl, mix)\n")
SLANG_RAW("vector<T,N> lerp(vector<T,N> x, vector<T,N> y, vector<T,N> s);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(glsl, mix)\n")
SLANG_RAW("matrix<T,N,M> lerp(matrix<T,N,M> x, matrix<T,N,M> y, matrix<T,N,M> s);\n")
SLANG_RAW("\n")
SLANG_RAW("// Legacy lighting function (obsolete)\n")
SLANG_RAW("float4 lit(float n_dot_l, float n_dot_h, float m);\n")
SLANG_RAW("\n")
SLANG_RAW("// Base-e logarithm\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType> T log(T x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int> vector<T,N> log(vector<T,N> x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int> matrix<T,N,M> log(matrix<T,N,M> x);\n")
SLANG_RAW("\n")
SLANG_RAW("// Base-10 logarithm\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType> \n")
SLANG_RAW("__target_intrinsic(glsl, \"(log( $0 ) * $S0( 0.43429448190325182765112891891661) )\" )\n")
SLANG_RAW("T log10(T x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(glsl, \"(log( $0 ) * $S0(0.43429448190325182765112891891661) )\" )\n")
SLANG_RAW("vector<T,N> log10(vector<T,N> x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int> \n")
SLANG_RAW("__target_intrinsic(glsl, \"(log( $0 ) * $S0(0.43429448190325182765112891891661) )\" )\n")
SLANG_RAW("matrix<T,N,M> log10(matrix<T,N,M> x);\n")
SLANG_RAW("\n")
SLANG_RAW("// Base-2 logarithm\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType> T log2(T x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int> vector<T,N> log2(vector<T,N> x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int> matrix<T,N,M> log2(matrix<T,N,M> x);\n")
SLANG_RAW("\n")
SLANG_RAW("// multiply-add\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, fma)\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType> T mad(T mvalue, T avalue, T bvalue);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, fma)\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int> vector<T,N> mad(vector<T,N> mvalue, vector<T,N> avalue, vector<T,N> bvalue);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, fma)\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int, let M : int> matrix<T,N,M> mad(matrix<T,N,M> mvalue, matrix<T,N,M> avalue, matrix<T,N,M> bvalue);\n")
SLANG_RAW("\n")
SLANG_RAW("// maximum\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType> T max(T x, T y);\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int> vector<T,N> max(vector<T,N> x, vector<T,N> y);\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int, let M : int> matrix<T,N,M> max(matrix<T,N,M> x, matrix<T,N,M> y);\n")
SLANG_RAW("\n")
SLANG_RAW("// minimum\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType> T min(T x, T y);\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int> vector<T,N> min(vector<T,N> x, vector<T,N> y);\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int, let M : int> matrix<T,N,M> min(matrix<T,N,M> x, matrix<T,N,M> y);\n")
SLANG_RAW("\n")
SLANG_RAW("// split into integer and fractional parts (both with same sign)\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType> T modf(T x, out T ip);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int> vector<T,N> modf(vector<T,N> x, out vector<T,N> ip);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int> matrix<T,N,M> modf(matrix<T,N,M> x, out matrix<T,N,M> ip);\n")
SLANG_RAW("\n")
SLANG_RAW("// msad4 (whatever that is)\n")
SLANG_RAW("uint4 msad4(uint reference, uint2 source, uint4 accum);\n")
SLANG_RAW("\n")
SLANG_RAW("// General inner products\n")
SLANG_RAW("\n")
SLANG_RAW("// scalar-scalar\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType> T mul(T x, T y);\n")
SLANG_RAW("\n")
SLANG_RAW("// scalar-vector and vector-scalar\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int> vector<T,N> mul(vector<T,N> x, T y);\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int> vector<T,N> mul(T x, vector<T,N> y);\n")
SLANG_RAW("\n")
SLANG_RAW("// scalar-matrix and matrix-scalar\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int, let M :int> matrix<T,N,M> mul(matrix<T,N,M> x, T y);\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int, let M :int> matrix<T,N,M> mul(T x, matrix<T,N,M> y);\n")
SLANG_RAW("\n")
SLANG_RAW("// vector-vector (dot product)\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int> __intrinsic_op(dot) T mul(vector<T,N> x, vector<T,N> y);\n")
SLANG_RAW("\n")
SLANG_RAW("// vector-matrix\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int, let M : int> __intrinsic_op(mulVectorMatrix) vector<T,M> mul(vector<T,N> x, matrix<T,N,M> y);\n")
SLANG_RAW("\n")
SLANG_RAW("// matrix-vector\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int, let M : int> __intrinsic_op(mulMatrixVector) vector<T,N> mul(matrix<T,N,M> x, vector<T,M> y);\n")
SLANG_RAW("\n")
SLANG_RAW("// matrix-matrix\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let R : int, let N : int, let C : int> __intrinsic_op(mulMatrixMatrix) matrix<T,R,C> mul(matrix<T,R,N> x, matrix<T,N,C> y);\n")
SLANG_RAW("\n")
SLANG_RAW("// noise (deprecated)\n")
SLANG_RAW("float noise(float x);\n")
SLANG_RAW("__generic<let N : int> float noise(vector<float, N> x);\n")
SLANG_RAW("\n")
SLANG_RAW("/// Indicate that an index may be non-uniform at execution time.\n")
SLANG_RAW("///\n")
SLANG_RAW("/// Shader Model 5.1 and 6.x introduce support for dynamic indexing\n")
SLANG_RAW("/// of arrays of resources, but place the restriction that *by default*\n")
SLANG_RAW("/// the implementation can assume that any value used as an index into\n")
SLANG_RAW("/// such arrays will be dynamically uniform across an entire `Draw` or `Dispatch`\n")
SLANG_RAW("/// (when using instancing, the value must be uniform across all instances;\n")
SLANG_RAW("/// it does not seem that the restriction extends to draws within a multi-draw).\n")
SLANG_RAW("///\n")
SLANG_RAW("/// In order to indicate to the implementation that it cannot make the\n")
SLANG_RAW("/// uniformity assumption, a shader programmer is required to pass the index\n")
SLANG_RAW("/// to the `NonUniformResourceIndex` function before using it as an index.\n")
SLANG_RAW("/// The function superficially acts like an identity function.\n")
SLANG_RAW("///\n")
SLANG_RAW("/// Note: a future version of Slang may take responsibility for inserting calls\n")
SLANG_RAW("/// to this function as necessary in output code, rather than make this\n")
SLANG_RAW("/// the user's responsibility, so that the default behavior of the language\n")
SLANG_RAW("/// is more semantically \"correct.\"\n")
SLANG_RAW("__target_intrinsic(glsl, nonuniformEXT)\n")
SLANG_RAW("__glsl_extension(GL_EXT_nonuniform_qualifier)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("uint NonUniformResourceIndex(uint index);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, nonuniformEXT)\n")
SLANG_RAW("__glsl_extension(GL_EXT_nonuniform_qualifier)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("int NonUniformResourceIndex(int index);\n")
SLANG_RAW("\n")
SLANG_RAW("// Normalize a vector\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int> vector<T,N> normalize(vector<T,N> x);\n")
SLANG_RAW("\n")
SLANG_RAW("// Raise to a power\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType> T pow(T x, T y);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int> vector<T,N> pow(vector<T,N> x, vector<T,N> y);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int> matrix<T,N,M> pow(matrix<T,N,M> x, matrix<T,N,M> y);\n")
SLANG_RAW("\n")
SLANG_RAW("// Output message\n")
SLANG_RAW("\n")
SLANG_RAW("// void printf( string format, ... );\n")
SLANG_RAW("\n")
SLANG_RAW("// Tessellation factor fixup routines\n")
SLANG_RAW("\n")
SLANG_RAW("void Process2DQuadTessFactorsAvg(\n")
SLANG_RAW("    in  float4 RawEdgeFactors,\n")
SLANG_RAW("    in  float2 InsideScale,\n")
SLANG_RAW("    out float4 RoundedEdgeTessFactors,\n")
SLANG_RAW("    out float2 RoundedInsideTessFactors,\n")
SLANG_RAW("    out float2 UnroundedInsideTessFactors);\n")
SLANG_RAW("\n")
SLANG_RAW("void Process2DQuadTessFactorsMax(\n")
SLANG_RAW("    in  float4 RawEdgeFactors,\n")
SLANG_RAW("    in  float2 InsideScale,\n")
SLANG_RAW("    out float4 RoundedEdgeTessFactors,\n")
SLANG_RAW("    out float2 RoundedInsideTessFactors,\n")
SLANG_RAW("    out float2 UnroundedInsideTessFactors);\n")
SLANG_RAW("\n")
SLANG_RAW("void Process2DQuadTessFactorsMin(\n")
SLANG_RAW("    in  float4 RawEdgeFactors,\n")
SLANG_RAW("    in  float2 InsideScale,\n")
SLANG_RAW("    out float4 RoundedEdgeTessFactors,\n")
SLANG_RAW("    out float2 RoundedInsideTessFactors,\n")
SLANG_RAW("    out float2 UnroundedInsideTessFactors);\n")
SLANG_RAW("\n")
SLANG_RAW("void ProcessIsolineTessFactors(\n")
SLANG_RAW("    in  float RawDetailFactor,\n")
SLANG_RAW("    in  float RawDensityFactor,\n")
SLANG_RAW("    out float RoundedDetailFactor,\n")
SLANG_RAW("    out float RoundedDensityFactor);\n")
SLANG_RAW("\n")
SLANG_RAW("void ProcessQuadTessFactorsAvg(\n")
SLANG_RAW("    in  float4 RawEdgeFactors,\n")
SLANG_RAW("    in  float InsideScale,\n")
SLANG_RAW("    out float4 RoundedEdgeTessFactors,\n")
SLANG_RAW("    out float2 RoundedInsideTessFactors,\n")
SLANG_RAW("    out float2 UnroundedInsideTessFactors);\n")
SLANG_RAW("\n")
SLANG_RAW("void ProcessQuadTessFactorsMax(\n")
SLANG_RAW("    in  float4 RawEdgeFactors,\n")
SLANG_RAW("    in  float InsideScale,\n")
SLANG_RAW("    out float4 RoundedEdgeTessFactors,\n")
SLANG_RAW("    out float2 RoundedInsideTessFactors,\n")
SLANG_RAW("    out float2 UnroundedInsideTessFactors);\n")
SLANG_RAW("\n")
SLANG_RAW("void ProcessQuadTessFactorsMin(\n")
SLANG_RAW("    in  float4 RawEdgeFactors,\n")
SLANG_RAW("    in  float InsideScale,\n")
SLANG_RAW("    out float4 RoundedEdgeTessFactors,\n")
SLANG_RAW("    out float2 RoundedInsideTessFactors,\n")
SLANG_RAW("    out float2 UnroundedInsideTessFactors);\n")
SLANG_RAW("\n")
SLANG_RAW("void ProcessTriTessFactorsAvg(\n")
SLANG_RAW("    in  float3 RawEdgeFactors,\n")
SLANG_RAW("    in  float InsideScale,\n")
SLANG_RAW("    out float3 RoundedEdgeTessFactors,\n")
SLANG_RAW("    out float RoundedInsideTessFactor,\n")
SLANG_RAW("    out float UnroundedInsideTessFactor);\n")
SLANG_RAW("\n")
SLANG_RAW("void ProcessTriTessFactorsMax(\n")
SLANG_RAW("    in  float3 RawEdgeFactors,\n")
SLANG_RAW("    in  float InsideScale,\n")
SLANG_RAW("    out float3 RoundedEdgeTessFactors,\n")
SLANG_RAW("    out float RoundedInsideTessFactor,\n")
SLANG_RAW("    out float UnroundedInsideTessFactor);\n")
SLANG_RAW("\n")
SLANG_RAW("void ProcessTriTessFactorsMin(\n")
SLANG_RAW("    in  float3 RawEdgeFactors,\n")
SLANG_RAW("    in  float InsideScale,\n")
SLANG_RAW("    out float3 RoundedEdgeTessFactors,\n")
SLANG_RAW("    out float RoundedInsideTessFactors,\n")
SLANG_RAW("    out float UnroundedInsideTessFactors);\n")
SLANG_RAW("\n")
SLANG_RAW("// Degrees to radians\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType> T radians(T x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int> vector<T,N> radians(vector<T,N> x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int> matrix<T,N,M> radians(matrix<T,N,M> x);\n")
SLANG_RAW("\n")
SLANG_RAW("// Approximate reciprocal\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(glsl, \"1.0/($0)\")\n")
SLANG_RAW("T rcp(T x);\n")
SLANG_RAW("\n")
SLANG_RAW("// TODO: vector and matrix approx. reciprocals needto be deconstructed for GLSL\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int> vector<T,N> rcp(vector<T,N> x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int> matrix<T,N,M> rcp(matrix<T,N,M> x);\n")
SLANG_RAW("\n")
SLANG_RAW("// Reflect incident vector across plane with given normal\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("vector<T,N> reflect(vector<T,N> i, vector<T,N> n);\n")
SLANG_RAW("\n")
SLANG_RAW("// Refract incident vector given surface normal and index of refraction\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("vector<T,N> refract(vector<T,N> i, vector<T,N> n, float eta);\n")
SLANG_RAW("\n")
SLANG_RAW("// Reverse order of bits\n")
SLANG_RAW("__target_intrinsic(glsl, \"bitfieldReverse\")\n")
SLANG_RAW("uint reversebits(uint value);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"bitfieldReverse\")\n")
SLANG_RAW("__generic<let N : int> vector<uint,N> reversebits(vector<uint,N> value);\n")
SLANG_RAW("\n")
SLANG_RAW("// Round-to-nearest\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType> T round(T x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int> vector<T,N> round(vector<T,N> x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int> matrix<T,N,M> round(matrix<T,N,M> x);\n")
SLANG_RAW("\n")
SLANG_RAW("// Reciprocal of square root\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(glsl, \"inversesqrt($0)\")\n")
SLANG_RAW("T rsqrt(T x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(glsl, \"inversesqrt($0)\")\n")
SLANG_RAW("vector<T,N> rsqrt(vector<T,N> x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(glsl, \"inversesqrt($0)\")\n")
SLANG_RAW("matrix<T,N,M> rsqrt(matrix<T,N,M> x);\n")
SLANG_RAW("\n")
SLANG_RAW("// Clamp value to [0,1] range\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(glsl, \"clamp($0, 0, 1)\")\n")
SLANG_RAW("T saturate(T x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(glsl, \"clamp($0, 0, 1)\")\n")
SLANG_RAW("vector<T,N> saturate(vector<T,N> x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(glsl, \"clamp($0, 0, 1)\")\n")
SLANG_RAW("matrix<T,N,M> saturate(matrix<T,N,M> x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__specialized_for_target(glsl)\n")
SLANG_RAW("T saturate(T x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return clamp<T>(x, T(0), T(1));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__specialized_for_target(glsl)\n")
SLANG_RAW("vector<T,N> saturate(vector<T,N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return clamp<T,N>(x,\n")
SLANG_RAW("        vector<T,N>(T(0)),\n")
SLANG_RAW("        vector<T,N>(T(1)));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// HACK: need a helper to turn a scalar into a matrix,\n")
SLANG_RAW("// because GLSL and HLSL disagree on the semantics of\n")
SLANG_RAW("// constructing a matrix from a single scalar.\n")
SLANG_RAW("__generic<T, let N : int, let M : int>\n")
SLANG_RAW("matrix<T,N,M> __scalarToMatrix(T value);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__specialized_for_target(glsl)\n")
SLANG_RAW("matrix<T,N,M> saturate(matrix<T,N,M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return clamp<T,N,M>(x,\n")
SLANG_RAW("        __scalarToMatrix<T,N,M>(T(0)),\n")
SLANG_RAW("        __scalarToMatrix<T,N,M>(T(1)));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("// Extract sign of value\n")
SLANG_RAW("__generic<T : __BuiltinSignedArithmeticType>\n")
SLANG_RAW("__target_intrinsic(glsl, \"int(sign($0))\")\n")
SLANG_RAW("int sign(T x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinSignedArithmeticType, let N : int>\n")
SLANG_RAW("__target_intrinsic(glsl, \"ivec$N0(sign($0))\")\n")
SLANG_RAW("vector<int,N> sign(vector<T,N> x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinSignedArithmeticType, let N : int, let M : int> matrix<int,N,M> sign(matrix<T,N,M> x);\n")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("// Sine\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType> T sin(T x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int> vector<T,N> sin(vector<T,N> x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int> matrix<T,N,M> sin(matrix<T,N,M> x);\n")
SLANG_RAW("\n")
SLANG_RAW("// Sine and cosine\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(glsl, \"$1 = sin($0); $2 = cos($0);\")\n")
SLANG_RAW("void sincos(T x, out T s, out T c);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int> void sincos(vector<T,N> x, out vector<T,N> s, out vector<T,N> c);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int> void sincos(matrix<T,N,M> x, out matrix<T,N,M> s, out matrix<T,N,M> c);\n")
SLANG_RAW("\n")
SLANG_RAW("// Hyperbolic Sine\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType> T sinh(T x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int> vector<T,N> sinh(vector<T,N> x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int> matrix<T,N,M> sinh(matrix<T,N,M> x);\n")
SLANG_RAW("\n")
SLANG_RAW("// Smooth step (Hermite interpolation)\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType> T smoothstep(T min, T max, T x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int> vector<T,N> smoothstep(vector<T,N> min, vector<T,N> max, vector<T,N> x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int> matrix<T,N,M> smoothstep(matrix<T,N,M> min, matrix<T,N,M> max, matrix<T,N,M> x);\n")
SLANG_RAW("\n")
SLANG_RAW("// Square root\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType> T sqrt(T x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int> vector<T,N> sqrt(vector<T,N> x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int> matrix<T,N,M> sqrt(matrix<T,N,M> x);\n")
SLANG_RAW("\n")
SLANG_RAW("// Step function\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType> T step(T y, T x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int> vector<T,N> step(vector<T,N> y, vector<T,N> x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int> matrix<T,N,M> step(matrix<T,N,M> y, matrix<T,N,M> x);\n")
SLANG_RAW("\n")
SLANG_RAW("// Tangent\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType> T tan(T x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int> vector<T,N> tan(vector<T,N> x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int> matrix<T,N,M> tan(matrix<T,N,M> x);\n")
SLANG_RAW("\n")
SLANG_RAW("// Hyperbolic tangent\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType> T tanh(T x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int> vector<T,N> tanh(vector<T,N> x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int> matrix<T,N,M> tanh(matrix<T,N,M> x);\n")
SLANG_RAW("\n")
SLANG_RAW("// Legacy texture-fetch operations\n")
SLANG_RAW("\n")
SLANG_RAW("/*\n")
SLANG_RAW("float4 tex1D(sampler1D s, float t);\n")
SLANG_RAW("float4 tex1D(sampler1D s, float t, float ddx, float ddy);\n")
SLANG_RAW("float4 tex1Dbias(sampler1D s, float4 t);\n")
SLANG_RAW("float4 tex1Dgrad(sampler1D s, float t, float ddx, float ddy);\n")
SLANG_RAW("float4 tex1Dlod(sampler1D s, float4 t);\n")
SLANG_RAW("float4 tex1Dproj(sampler1D s, float4 t);\n")
SLANG_RAW("\n")
SLANG_RAW("float4 tex2D(sampler2D s, float2 t);\n")
SLANG_RAW("float4 tex2D(sampler2D s, float2 t, float2 ddx, float2 ddy);\n")
SLANG_RAW("float4 tex2Dbias(sampler2D s, float4 t);\n")
SLANG_RAW("float4 tex2Dgrad(sampler2D s, float2 t, float2 ddx, float2 ddy);\n")
SLANG_RAW("float4 tex2Dlod(sampler2D s, float4 t);\n")
SLANG_RAW("float4 tex2Dproj(sampler2D s, float4 t);\n")
SLANG_RAW("\n")
SLANG_RAW("float4 tex3D(sampler3D s, float3 t);\n")
SLANG_RAW("float4 tex3D(sampler3D s, float3 t, float3 ddx, float3 ddy);\n")
SLANG_RAW("float4 tex3Dbias(sampler3D s, float4 t);\n")
SLANG_RAW("float4 tex3Dgrad(sampler3D s, float3 t, float3 ddx, float3 ddy);\n")
SLANG_RAW("float4 tex3Dlod(sampler3D s, float4 t);\n")
SLANG_RAW("float4 tex3Dproj(sampler3D s, float4 t);\n")
SLANG_RAW("\n")
SLANG_RAW("float4 texCUBE(samplerCUBE s, float3 t);\n")
SLANG_RAW("float4 texCUBE(samplerCUBE s, float3 t, float3 ddx, float3 ddy);\n")
SLANG_RAW("float4 texCUBEbias(samplerCUBE s, float4 t);\n")
SLANG_RAW("float4 texCUBEgrad(samplerCUBE s, float3 t, float3 ddx, float3 ddy);\n")
SLANG_RAW("float4 texCUBElod(samplerCUBE s, float4 t);\n")
SLANG_RAW("float4 texCUBEproj(samplerCUBE s, float4 t);\n")
SLANG_RAW("*/\n")
SLANG_RAW("\n")
SLANG_RAW("// Matrix transpose\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int, let M : int> matrix<T,M,N> transpose(matrix<T,N,M> x);\n")
SLANG_RAW("\n")
SLANG_RAW("// Truncate to integer\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType> T trunc(T x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int> vector<T,N> trunc(vector<T,N> x);\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int> matrix<T,N,M> trunc(matrix<T,N,M> x);\n")
SLANG_RAW("\n")
SLANG_RAW("// Shader model 6.0 stuff\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType> T QuadReadLaneAt(T sourceValue, uint quadLaneID);\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int> vector<T,N> QuadReadLaneAt(vector<T,N> sourceValue, uint quadLaneID);\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int, let M : int> matrix<T,N,M> QuadReadLaneAt(matrix<T,N,M> sourceValue, uint quadLaneID);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType> T QuadReadAcrossX(T localValue);\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int> vector<T,N> QuadReadAcrossX(vector<T,N> localValue);\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int, let M : int> matrix<T,N,M> QuadReadAcrossX(matrix<T,N,M> localValue);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType> T QuadReadAcrossY(T localValue);\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int> vector<T,N> QuadReadAcrossY(vector<T,N> localValue);\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int, let M : int> matrix<T,N,M> QuadReadAcrossY(matrix<T,N,M> localValue);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType> T QuadReadAcrossDiagonal(T localValue);\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int> vector<T,N> QuadReadAcrossDiagonal(vector<T,N> localValue);\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int, let M : int> matrix<T,N,M> QuadReadAcrossDiagonal(matrix<T,N,M> localValue);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinIntegerType>\n")
SLANG_RAW("__target_intrinsic(cuda, \"_waveAnd(__activemask(), $0)\")\n")
SLANG_RAW("T WaveActiveBitAnd(T expr);\n")
SLANG_RAW("__generic<T : __BuiltinIntegerType, let N : int> vector<T,N> WaveActiveBitAnd(vector<T,N> expr);\n")
SLANG_RAW("__generic<T : __BuiltinIntegerType, let N : int, let M : int> matrix<T,N,M> WaveActiveBitAnd(matrix<T,N,M> expr);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinIntegerType>\n")
SLANG_RAW("__target_intrinsic(cuda, \"_waveOr(__activemask(), $0)\")\n")
SLANG_RAW("T WaveActiveBitOr(T expr);\n")
SLANG_RAW("__generic<T : __BuiltinIntegerType, let N : int> vector<T,N> WaveActiveBitOr(vector<T,N> expr);\n")
SLANG_RAW("__generic<T : __BuiltinIntegerType, let N : int, let M : int> matrix<T,N,M> WaveActiveBitOr(matrix<T,N,M> expr);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinIntegerType>\n")
SLANG_RAW("__target_intrinsic(cuda, \"_waveXor(__activemask(), $0)\")\n")
SLANG_RAW("T WaveActiveBitXor(T expr);\n")
SLANG_RAW("__generic<T : __BuiltinIntegerType, let N : int> vector<T,N> WaveActiveBitXor(vector<T,N> expr);\n")
SLANG_RAW("__generic<T : __BuiltinIntegerType, let N : int, let M : int> matrix<T,N,M> WaveActiveBitXor(matrix<T,N,M> expr);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType>\n")
SLANG_RAW("__target_intrinsic(cuda, \"_waveMax(__activemask(), $0)\")\n")
SLANG_RAW("T WaveActiveMax(T expr);\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int> vector<T,N> WaveActiveMax(vector<T,N> expr);\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int, let M : int> matrix<T,N,M> WaveActiveMax(matrix<T,N,M> expr);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType>\n")
SLANG_RAW("__target_intrinsic(cuda, \"_waveMin(__activemask(), $0)\")\n")
SLANG_RAW("T WaveActiveMin(T expr);\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int> vector<T,N> WaveActiveMin(vector<T,N> expr);\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int, let M : int> matrix<T,N,M> WaveActiveMin(matrix<T,N,M> expr);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType>\n")
SLANG_RAW("__target_intrinsic(cuda, \"_waveProduct(__activemask(), $0)\")\n")
SLANG_RAW("T WaveActiveProduct(T expr);\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int> vector<T,N> WaveActiveProduct(vector<T,N> expr);\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int, let M : int> matrix<T,N,M> WaveActiveProduct(matrix<T,N,M> expr);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType>\n")
SLANG_RAW("__target_intrinsic(cuda, \"_waveSum(__activemask(), $0)\")\n")
SLANG_RAW("T WaveActiveSum(T expr);\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int> vector<T,N> WaveActiveSum(vector<T,N> expr);\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int, let M : int> matrix<T,N,M> WaveActiveSum(matrix<T,N,M> expr);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType>\n")
SLANG_RAW("__target_intrinsic(cuda, \"_waveAllEqual(__activemask(), $0)\")\n")
SLANG_RAW("bool WaveActiveAllEqual(T value);\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int> vector<bool,N> WaveActiveAllEqual(vector<T,N> value);\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int, let M : int> matrix<bool,N,M> WaveActiveAllEqual(matrix<T,N,M> value);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType> uint4 WaveMatch(T value);\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int> uint4 WaveMatch(vector<T,N> value);\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int, let M : int> uint4 WaveMatch(matrix<T,N,M> value);\n")
SLANG_RAW("\n")
SLANG_RAW("// TODO(JS): For CUDA the article claims mask has to be used carefully\n")
SLANG_RAW("// https://devblogs.nvidia.com/using-cuda-warp-level-primitives/\n")
SLANG_RAW("// With the Warp intrinsics there is no mask, and it's just the 'active lanes'. So __activemask()\n")
SLANG_RAW("// seems to be appropriate.\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(cuda, \"(__all_sync(__activemask(), $0) != 0)\") \n")
SLANG_RAW("bool WaveActiveAllTrue(bool condition);\n")
SLANG_RAW("__target_intrinsic(cuda, \"(__any_sync(__activemask(), $0) != 0)\")\n")
SLANG_RAW("bool WaveActiveAnyTrue(bool condition);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(cuda, \"make_uint4(__ballot_sync(__activemask(), $0), 0, 0, 0)\")\n")
SLANG_RAW("uint4 WaveActiveBallot(bool condition);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(cuda, \"__popc(__ballot_sync(__activemask(), $0))\")\n")
SLANG_RAW("uint WaveActiveCountBits(bool value);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(cuda, \"(warpSize)\")\n")
SLANG_RAW("uint WaveGetLaneCount();\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(cuda, \"_getLaneId()\")\n")
SLANG_RAW("uint WaveGetLaneIndex();\n")
SLANG_RAW("\n")
SLANG_RAW("// If there are no *active* lanes less than this one, we must be the lowest lane\n")
SLANG_RAW("__target_intrinsic(cuda, \"_waveIsFirstLane()\")\n")
SLANG_RAW("bool WaveIsFirstLane();\n")
SLANG_RAW("\n")
SLANG_RAW("// TODO(JS): We cannot calculate prefix sums using a mask of __activemask() & __lanemask_lt(), because (amongst other reasons)\n")
SLANG_RAW("// that would mean different lanes having a different mask, and they all have to have the same mask.\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType>\n")
SLANG_RAW("T WavePrefixProduct(T expr);\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int> vector<T,N> WavePrefixProduct(vector<T,N> expr);\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int, let M : int> matrix<T,N,M> WavePrefixProduct(matrix<T,N,M> expr);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType>\n")
SLANG_RAW("T WavePrefixSum(T expr);\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int> vector<T,N> WavePrefixSum(vector<T,N> expr);\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int, let M : int> matrix<T,N,M> WavePrefixSum(matrix<T,N,M> expr);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType> T WaveMultiPrefixBitAnd(T expr);\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int> vector<T,N> WaveMultiPrefixBitAnd(vector<T,N> expr);\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int, let M : int> matrix<T,N,M> WaveMultiPrefixBitAnd(matrix<T,N,M> expr);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType> T WaveMultiPrefixBitOr(T expr);\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int> vector<T,N> WaveMultiPrefixBitOr(vector<T,N> expr);\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int, let M : int> matrix<T,N,M> WaveMultiPrefixBitOr(matrix<T,N,M> expr);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType>\n")
SLANG_RAW("T WaveMultiPrefixBitXor(T expr);\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int> vector<T,N> WaveMultiPrefixBitXor(vector<T,N> expr);\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int, let M : int> matrix<T,N,M> WaveMultiPrefixBitXor(matrix<T,N,M> expr);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(cuda, \"__popc(__ballot_sync(__activemask(), $0)  & __lanemask_lt())\")\n")
SLANG_RAW("uint WavePrefixCountBits(bool value);\n")
SLANG_RAW("\n")
SLANG_RAW("uint WaveMultiPrefixCountBits(bool value, uint4 mask);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType> T WaveMultiPrefixProduct(T value, uint4 mask);\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int> vector<T,N> WaveMultiPrefixProduct(vector<T,N> value, uint4 mask);\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int, let M : int> matrix<T,N,M> WaveMultiPrefixProduct(matrix<T,N,M> value, uint4 mask);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType> T WaveMultiPrefixSum(T value, uint4 mask);\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int> vector<T,N> WaveMultiPrefixSum(vector<T,N> value, uint4 mask);\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int, let M : int> matrix<T,N,M> WaveMultiPrefixSum(matrix<T,N,M> value, uint4 mask);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType>\n")
SLANG_RAW("__target_intrinsic(cuda, \"_waveReadFirst($0)\")\n")
SLANG_RAW("T WaveReadLaneFirst(T expr);\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int> vector<T,N> WaveReadLaneFirst(vector<T,N> expr);\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int, let M : int> matrix<T,N,M> WaveReadLaneFirst(matrix<T,N,M> expr);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType>\n")
SLANG_RAW("__target_intrinsic(cuda, \"__shfl_sync(SLANG_CUDA_WARP_MASK, $0, $1)\")\n")
SLANG_RAW("T WaveReadLaneAt(T value, int lane);\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int> vector<T,N> WaveReadLaneAt(vector<T,N> value, int lane);\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int, let M : int> matrix<T,N,M> WaveReadLaneAt(matrix<T,N,M> value, int lane);\n")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("// `typedef`s to help with the fact that HLSL has been sorta-kinda case insensitive at various points\n")
SLANG_RAW("typedef Texture2D texture2D;\n")
SLANG_RAW("\n")

// Component-wise multiplication ops
for(auto op : binaryOps)
{
    switch (op.opCode)
    {
    default:
        continue;

    case kIROp_Mul:
    case kCompoundIntrinsicOp_MulAssign:
        break;
    }

    for (auto type : kBaseTypes)
    {
        if ((type.flags & op.flags) == 0)
            continue;

        char const* leftType = type.name;
        char const* rightType = leftType;
        char const* resultType = leftType;

        char const* leftQual = "";
        if(op.flags & ASSIGNMENT) leftQual = "in out ";

        sb << "__generic<let N : int, let M : int> ";
        sb << "__intrinsic_op(" << int(op.opCode) << ") matrix<" << resultType << ",N,M> operator" << op.opName << "(" << leftQual << "matrix<" << leftType << ",N,M> left, matrix<" << rightType << ",N,M> right);\n";
    }
}

//

// Buffer types

static const struct {
    char const*         name;
    SlangResourceAccess access;
} kBaseBufferAccessLevels[] = {
    { "",                   SLANG_RESOURCE_ACCESS_READ },
    { "RW",                 SLANG_RESOURCE_ACCESS_READ_WRITE },
    { "RasterizerOrdered",  SLANG_RESOURCE_ACCESS_RASTER_ORDERED },
};
static const int kBaseBufferAccessLevelCount = sizeof(kBaseBufferAccessLevels) / sizeof(kBaseBufferAccessLevels[0]);

for (int aa = 0; aa < kBaseBufferAccessLevelCount; ++aa)
{
    auto access = kBaseBufferAccessLevels[aa].access;
    auto flavor = TextureFlavor::create(TextureFlavor::Shape::ShapeBuffer, access).flavor;
    sb << "__generic<T>\n";
    sb << "__magic_type(Texture," << int(flavor) << ")\n";
    sb << "__intrinsic_type(" << (kIROp_TextureType + (int(flavor) << kIROpMeta_OtherShift)) << ")\n";
    sb << "struct ";
    sb << kBaseBufferAccessLevels[aa].name;
    sb << "Buffer {\n";

    sb << "void GetDimensions(out uint dim);\n";

    char const* glslLoadFuncName = (access == SLANG_RESOURCE_ACCESS_READ) ? "texelFetch" : "imageLoad";

    sb << "__glsl_extension(GL_EXT_samplerless_texture_functions)";
    sb << "__target_intrinsic(glsl, \"" << glslLoadFuncName << "($0, $1)$z\")\n";
    sb << "T Load(int location);\n";

    sb << "T Load(int location, out uint status);\n";

    sb << "__subscript(uint index) -> T {\n";

    sb << "__glsl_extension(GL_EXT_samplerless_texture_functions)";
    sb << "__target_intrinsic(glsl, \"" << glslLoadFuncName << "($0, int($1))$z\") get;\n";

    if (access != SLANG_RESOURCE_ACCESS_READ)
    {
        sb << "__target_intrinsic(glsl, \"imageStore($0, int($1), $V2)\") set;\n";

        sb << "__intrinsic_op(" << int(kIROp_ImageSubscript) << ") ref;\n";
    }

    sb << "}\n";

    sb << "};\n";
}
SLANG_RAW("#line 1613 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("// DirectX Raytracing (DXR) Support\n")
SLANG_RAW("//\n")
SLANG_RAW("// The following is based on the experimental DXR SDK v0.09.01.\n")
SLANG_RAW("//\n")
SLANG_RAW("// Numbering follows the sections in the \"D3D12 Raytracing Functional Spec\" v0.09 (2018-03-12)\n")
SLANG_RAW("//\n")
SLANG_RAW("\n")
SLANG_RAW("// 10.1.1 - Ray Flags\n")
SLANG_RAW("\n")
SLANG_RAW("typedef uint RAY_FLAG;\n")
SLANG_RAW("\n")
SLANG_RAW("static const RAY_FLAG RAY_FLAG_NONE                             = 0x00;\n")
SLANG_RAW("static const RAY_FLAG RAY_FLAG_FORCE_OPAQUE                     = 0x01;\n")
SLANG_RAW("static const RAY_FLAG RAY_FLAG_FORCE_NON_OPAQUE                 = 0x02;\n")
SLANG_RAW("static const RAY_FLAG RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH  = 0x04;\n")
SLANG_RAW("static const RAY_FLAG RAY_FLAG_SKIP_CLOSEST_HIT_SHADER          = 0x08;\n")
SLANG_RAW("static const RAY_FLAG RAY_FLAG_CULL_BACK_FACING_TRIANGLES       = 0x10;\n")
SLANG_RAW("static const RAY_FLAG RAY_FLAG_CULL_FRONT_FACING_TRIANGLES      = 0x20;\n")
SLANG_RAW("static const RAY_FLAG RAY_FLAG_CULL_OPAQUE                      = 0x40;\n")
SLANG_RAW("static const RAY_FLAG RAY_FLAG_CULL_NON_OPAQUE                  = 0x80;\n")
SLANG_RAW("static const RAY_FLAG RAY_FLAG_SKIP_TRIANGLES                   = 0x100;\n")
SLANG_RAW("static const RAY_FLAG RAY_FLAG_SKIP_PROCEDURAL_PRIMITIVES       = 0x200;\n")
SLANG_RAW("\n")
SLANG_RAW("// 10.1.2 - Ray Description Structure\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(hlsl, RayDesc)\n")
SLANG_RAW("struct RayDesc\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_intrinsic(hlsl, Origin)\n")
SLANG_RAW("    float3 Origin;\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(hlsl, TMin)\n")
SLANG_RAW("    float  TMin;\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(hlsl, Direction)\n")
SLANG_RAW("    float3 Direction;\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(hlsl, TMax)\n")
SLANG_RAW("    float  TMax;\n")
SLANG_RAW("};\n")
SLANG_RAW("\n")
SLANG_RAW("// 10.1.3 - Ray Acceleration Structure\n")
SLANG_RAW("\n")
SLANG_RAW("__builtin\n")
SLANG_RAW("__magic_type(RaytracingAccelerationStructureType)\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_RaytracingAccelerationStructureType
)
SLANG_RAW(")\n")
SLANG_RAW("struct RaytracingAccelerationStructure {};\n")
SLANG_RAW("\n")
SLANG_RAW("// 10.1.4 - Subobject Definitions\n")
SLANG_RAW("\n")
SLANG_RAW("// TODO: We may decide to support these, but their reliance on C++ implicit\n")
SLANG_RAW("// constructor call syntax (`SomeType someVar(arg0, arg1);`) makes them\n")
SLANG_RAW("// annoying for the current Slang parsing strategy, and using global variables\n")
SLANG_RAW("// for this stuff comes across as a kludge rather than the best possible design.\n")
SLANG_RAW("\n")
SLANG_RAW("// 10.1.5 - Intersection Attributes Structure\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(hlsl, BuiltInTriangleIntersectionAttributes)\n")
SLANG_RAW("struct BuiltInTriangleIntersectionAttributes\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_intrinsic(hlsl, barycentrics)\n")
SLANG_RAW("    float2 barycentrics;\n")
SLANG_RAW("};\n")
SLANG_RAW("\n")
SLANG_RAW("// 10.2 Shaders\n")
SLANG_RAW("\n")
SLANG_RAW("// Right now new shader stages need to be added directly to the compiler\n")
SLANG_RAW("// implementation, rather than being something that can be declared in the stdlib.\n")
SLANG_RAW("\n")
SLANG_RAW("// 10.3 - Intrinsics\n")
SLANG_RAW("\n")
SLANG_RAW("// 10.3.1\n")
SLANG_RAW("\n")
SLANG_RAW("void CallShader<Payload>(uint shaderIndex, inout Payload payload);\n")
SLANG_RAW("\n")
SLANG_RAW("// `executeCallableNV` is the GLSL intrinsic that will be used to implement\n")
SLANG_RAW("// `CallShader()` for GLSL-based targets.\n")
SLANG_RAW("//\n")
SLANG_RAW("__target_intrinsic(glsl, \"executeCallableNV\")\n")
SLANG_RAW("void __executeCallableNV(uint shaderIndex, int payloadLocation);\n")
SLANG_RAW("\n")
SLANG_RAW("// Next is the custom intrinsic that will compute the payload location\n")
SLANG_RAW("// for a type being used in a `CallShader()` call for GLSL-based targets.\n")
SLANG_RAW("//\n")
SLANG_RAW("__generic<Payload>\n")
SLANG_RAW("__target_intrinsic(glsl, \"$XC\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("int __callablePayloadLocation(Payload payload);\n")
SLANG_RAW("\n")
SLANG_RAW("// Now we provide a hard-coded definition of `CallShader()` for GLSL-based\n")
SLANG_RAW("// targets, which maps the generic HLSL operation into the non-generic\n")
SLANG_RAW("// GLSL equivalent.\n")
SLANG_RAW("//\n")
SLANG_RAW("__generic<Payload>\n")
SLANG_RAW("__specialized_for_target(glsl)\n")
SLANG_RAW("void CallShader(uint shaderIndex, inout Payload payload)\n")
SLANG_RAW("{\n")
SLANG_RAW("    [__vulkanRayPayload]\n")
SLANG_RAW("    static Payload p;\n")
SLANG_RAW("\n")
SLANG_RAW("    p = payload;\n")
SLANG_RAW("    __executeCallableNV(shaderIndex, __callablePayloadLocation(p));\n")
SLANG_RAW("    payload = p;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// 10.3.2\n")
SLANG_RAW("void TraceRay<payload_t>(\n")
SLANG_RAW("    RaytracingAccelerationStructure AccelerationStructure,\n")
SLANG_RAW("    uint                            RayFlags,\n")
SLANG_RAW("    uint                            InstanceInclusionMask,\n")
SLANG_RAW("    uint                            RayContributionToHitGroupIndex,\n")
SLANG_RAW("    uint                            MultiplierForGeometryContributionToHitGroupIndex,\n")
SLANG_RAW("    uint                            MissShaderIndex,\n")
SLANG_RAW("    RayDesc                         Ray,\n")
SLANG_RAW("    inout payload_t                 Payload);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"traceNV\")\n")
SLANG_RAW("void __traceNV(\n")
SLANG_RAW("    RaytracingAccelerationStructure AccelerationStructure,\n")
SLANG_RAW("    uint                            RayFlags,\n")
SLANG_RAW("    uint                            InstanceInclusionMask,\n")
SLANG_RAW("    uint                            RayContributionToHitGroupIndex,\n")
SLANG_RAW("    uint                            MultiplierForGeometryContributionToHitGroupIndex,\n")
SLANG_RAW("    uint                            MissShaderIndex,\n")
SLANG_RAW("    float3                          Origin,\n")
SLANG_RAW("    float                           TMin,\n")
SLANG_RAW("    float3                          Direction,\n")
SLANG_RAW("    float                           TMax,\n")
SLANG_RAW("    int                             PayloadLocation);\n")
SLANG_RAW("\n")
SLANG_RAW("// TODO: Slang's parsing logic currently puts modifiers on\n")
SLANG_RAW("// the `GenericDecl` rather than the inner decl when\n")
SLANG_RAW("// using our default syntax, which seems wrong. We need\n")
SLANG_RAW("// to fix this, but for now using the expanded `__generic`\n")
SLANG_RAW("// syntax works in a pinch.\n")
SLANG_RAW("//\n")
SLANG_RAW("__generic<Payload>\n")
SLANG_RAW("__target_intrinsic(glsl, \"$XP\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("int __rayPayloadLocation(Payload payload);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<payload_t>\n")
SLANG_RAW("__specialized_for_target(glsl)\n")
SLANG_RAW("void TraceRay(\n")
SLANG_RAW("    RaytracingAccelerationStructure AccelerationStructure,\n")
SLANG_RAW("    uint                            RayFlags,\n")
SLANG_RAW("    uint                            InstanceInclusionMask,\n")
SLANG_RAW("    uint                            RayContributionToHitGroupIndex,\n")
SLANG_RAW("    uint                            MultiplierForGeometryContributionToHitGroupIndex,\n")
SLANG_RAW("    uint                            MissShaderIndex,\n")
SLANG_RAW("    RayDesc                         Ray,\n")
SLANG_RAW("    inout payload_t                 Payload)\n")
SLANG_RAW("{\n")
SLANG_RAW("    [__vulkanRayPayload]\n")
SLANG_RAW("    static payload_t p;\n")
SLANG_RAW("\n")
SLANG_RAW("    p = Payload;\n")
SLANG_RAW("    __traceNV(\n")
SLANG_RAW("        AccelerationStructure,\n")
SLANG_RAW("        RayFlags,\n")
SLANG_RAW("        InstanceInclusionMask,\n")
SLANG_RAW("        RayContributionToHitGroupIndex,\n")
SLANG_RAW("        MultiplierForGeometryContributionToHitGroupIndex,\n")
SLANG_RAW("        MissShaderIndex,\n")
SLANG_RAW("        Ray.Origin,\n")
SLANG_RAW("        Ray.TMin,\n")
SLANG_RAW("        Ray.Direction,\n")
SLANG_RAW("        Ray.TMax,\n")
SLANG_RAW("        __rayPayloadLocation(p));\n")
SLANG_RAW("    Payload = p;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// 10.3.3\n")
SLANG_RAW("bool ReportHit<A>(float tHit, uint hitKind, A attributes);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"reportIntersectionNV\")\n")
SLANG_RAW("bool __reportIntersectionNV(float tHit, uint hitKind);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<A>\n")
SLANG_RAW("__specialized_for_target(glsl)\n")
SLANG_RAW("bool ReportHit(float tHit, uint hitKind, A attributes)\n")
SLANG_RAW("{\n")
SLANG_RAW("    [__vulkanHitAttributes]\n")
SLANG_RAW("    static A a;\n")
SLANG_RAW("\n")
SLANG_RAW("    a = attributes;\n")
SLANG_RAW("    return __reportIntersectionNV(tHit, hitKind);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// 10.3.4\n")
SLANG_RAW("__target_intrinsic(glsl, ignoreIntersectionNV)\n")
SLANG_RAW("void IgnoreHit();\n")
SLANG_RAW("\n")
SLANG_RAW("// 10.3.5\n")
SLANG_RAW("__target_intrinsic(glsl, terminateRayNV)\n")
SLANG_RAW("void AcceptHitAndEndSearch();\n")
SLANG_RAW("\n")
SLANG_RAW("// 10.4 - System Values and Special Semantics\n")
SLANG_RAW("\n")
SLANG_RAW("// TODO: Many of these functions need to be restricted so that\n")
SLANG_RAW("// they can only be accessed from specific stages.\n")
SLANG_RAW("\n")
SLANG_RAW("// 10.4.1 - Ray Dispatch System Values\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"(gl_LaunchIDNV)\")\n")
SLANG_RAW("uint3 DispatchRaysIndex();\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"(gl_LaunchSizeNV)\")\n")
SLANG_RAW("uint3 DispatchRaysDimensions();\n")
SLANG_RAW("\n")
SLANG_RAW("// 10.4.2 - Ray System Values\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"(gl_WorldRayOriginNV)\")\n")
SLANG_RAW("float3 WorldRayOrigin();\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"(gl_WorldRayDirectionNV)\")\n")
SLANG_RAW("float3 WorldRayDirection();\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"(gl_RayTminNV)\")\n")
SLANG_RAW("float RayTMin();\n")
SLANG_RAW("\n")
SLANG_RAW("// Note: The `RayTCurrent()` intrinsic should translate to\n")
SLANG_RAW("// either `gl_HitTNV` (for hit shaders) or `gl_RayTmaxNV`\n")
SLANG_RAW("// (for intersection shaders). Right now we are handling this\n")
SLANG_RAW("// during code emission, for simplicity.\n")
SLANG_RAW("//\n")
SLANG_RAW("// TODO: Once the compiler supports a more refined concept\n")
SLANG_RAW("// of profiles/capabilities and overloading based on them,\n")
SLANG_RAW("// we should simply provide two overloads here, specialized\n")
SLANG_RAW("// to the appropriate Vulkan stages.\n")
SLANG_RAW("//\n")
SLANG_RAW("__target_intrinsic(glsl, \"$XT\")\n")
SLANG_RAW("float RayTCurrent();\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"(gl_IncomingRayFlagsNV)\")\n")
SLANG_RAW("uint RayFlags();\n")
SLANG_RAW("\n")
SLANG_RAW("// 10.4.3 - Primitive/Object Space System Values\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"(gl_InstanceCustomIndexNV)\")\n")
SLANG_RAW("uint InstanceIndex();\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"(gl_InstanceID)\")\n")
SLANG_RAW("uint InstanceID();\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"(gl_PrimitiveID)\")\n")
SLANG_RAW("uint PrimitiveIndex();\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"(gl_ObjectRayOriginNV)\")\n")
SLANG_RAW("float3 ObjectRayOrigin();\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"(gl_ObjectRayDirectionNV)\")\n")
SLANG_RAW("float3 ObjectRayDirection();\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"transpose(gl_ObjectToWorldNV)\")\n")
SLANG_RAW("float3x4 ObjectToWorld3x4();\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"transpose(gl_WorldToObjectNV)\")\n")
SLANG_RAW("float3x4 WorldToObject3x4();\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"(gl_ObjectToWorldNV)\")\n")
SLANG_RAW("float4x3 ObjectToWorld4x3();\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"(gl_WorldToObjectNV)\")\n")
SLANG_RAW("float4x3 WorldToObject4x3();\n")
SLANG_RAW("\n")
SLANG_RAW("// Note: The provisional DXR spec included these unadorned\n")
SLANG_RAW("// `ObjectToWorld()` and `WorldToObject()` functions, so\n")
SLANG_RAW("// we will forward them to the new names as a convience\n")
SLANG_RAW("// for users who are porting their code.\n")
SLANG_RAW("//\n")
SLANG_RAW("// TODO: Should we provide a deprecation warning on these\n")
SLANG_RAW("// declarations, so that users can know they aren't coding\n")
SLANG_RAW("// against the final spec?\n")
SLANG_RAW("//\n")
SLANG_RAW("float3x4 ObjectToWorld() { return ObjectToWorld3x4(); }\n")
SLANG_RAW("float3x4 WorldToObject() { return WorldToObject3x4(); }\n")
SLANG_RAW("\n")
SLANG_RAW("// 10.4.4 - Hit Specific System values\n")
SLANG_RAW("__target_intrinsic(glsl, \"(gl_HitKindNV)\")\n")
SLANG_RAW("uint HitKind();\n")
SLANG_RAW("\n")
SLANG_RAW("// Pre-defined hit kinds (not documented explicitly)\n")
SLANG_RAW("static const uint HIT_KIND_TRIANGLE_FRONT_FACE  = 254;\n")
SLANG_RAW("static const uint HIT_KIND_TRIANGLE_BACK_FACE   = 255;\n")
SLANG_RAW("\n")
SLANG_RAW("//\n")
SLANG_RAW("// Shader Model 6.4\n")
SLANG_RAW("//\n")
SLANG_RAW("\n")
SLANG_RAW("// Treats `left` and `right` as 4-component vectors of `UInt8` and computes `dot(left, right) + acc`\n")
SLANG_RAW("uint dot4add_u8packed(uint left, uint right, uint acc);\n")
SLANG_RAW("\n")
SLANG_RAW("// Treats `left` and `right` as 4-component vectors of `Int8` and computes `dot(left, right) + acc`\n")
SLANG_RAW("int dot4add_i8packed(uint left, uint right, int acc);\n")
SLANG_RAW("\n")
SLANG_RAW("// Computes `dot(left, right) + acc`.\n")
SLANG_RAW("//\n")
SLANG_RAW("// May not produce infinities or NaNs for intermediate results that overflow the range of `half`\n")
SLANG_RAW("float dot2add(float2 left, float2 right, float acc);\n")
SLANG_RAW("\n")
SLANG_RAW("//\n")
SLANG_RAW("// Shader Model 6.5\n")
SLANG_RAW("//\n")
SLANG_RAW("\n")
SLANG_RAW("//\n")
SLANG_RAW("// Mesh Shaders\n")
SLANG_RAW("//\n")
SLANG_RAW("\n")
SLANG_RAW("// Set the number of output vertices and primitives for a mesh shader invocation.\n")
SLANG_RAW("void SetMeshOutputCounts(uint vertexCount, uint primitiveCount);\n")
SLANG_RAW("\n")
SLANG_RAW("// Specify the number of downstream mesh shader thread groups to invoke from an amplification shader,\n")
SLANG_RAW("// and provide the values for per-mesh payload parameters.\n")
SLANG_RAW("//\n")
SLANG_RAW("void DispatchMesh<P>(uint threadGroupCountX, uint threadGroupCountY, uint threadGroupCountZ, P meshPayload);\n")
SLANG_RAW("\n")
SLANG_RAW("//\n")
SLANG_RAW("// TODO: \"Sampler feedback\" types `FeedbackTexture2D` and `FeedbackTexture2DArray`.\n")
SLANG_RAW("//\n")
SLANG_RAW("\n")
SLANG_RAW("//\n")
SLANG_RAW("// DXR 1.1 and `TraceRayInline` support\n")
SLANG_RAW("//\n")
SLANG_RAW("\n")
SLANG_RAW("// Get the index of the geometry that was hit in an intersection, any-hit, or closest-hit shader\n")
SLANG_RAW("uint GeometryIndex();\n")
SLANG_RAW("\n")
SLANG_RAW("// Status of whether a (closest) hit has been committed in a `RayQuery`.\n")
SLANG_RAW("typedef uint COMMITTED_STATUS;\n")
SLANG_RAW("\n")
SLANG_RAW("// No hit committed.\n")
SLANG_RAW("static const COMMITTED_STATUS COMMITTED_NOTHING = 0;\n")
SLANG_RAW("\n")
SLANG_RAW("// Closest hit is a triangle.\n")
SLANG_RAW("//\n")
SLANG_RAW("// This could be an opaque triangle hit found by the fixed-function\n")
SLANG_RAW("// traversal and intersection implementation, or a non-opaque\n")
SLANG_RAW("// triangle hit committed by user code with `RayQuery.CommitNonOpaqueTriangleHit`\n")
SLANG_RAW("//\n")
SLANG_RAW("static const COMMITTED_STATUS COMMITTED_TRIANGLE_HIT = 1;\n")
SLANG_RAW("\n")
SLANG_RAW("// Closest hit is a procedural primitive.\n")
SLANG_RAW("//\n")
SLANG_RAW("// A procedural hit primitive is committed using `RayQuery.CommitProceduralPrimitiveHit`.\n")
SLANG_RAW("static const COMMITTED_STATUS COMMITTED_PROCEDURAL_PRIMITIVE_HIT = 2;\n")
SLANG_RAW("\n")
SLANG_RAW("// Type of candidate hit that a `RayQuery` is pausing at.\n")
SLANG_RAW("//\n")
SLANG_RAW("// A `RayQuery` can automatically commit hits with opaque triangles,\n")
SLANG_RAW("// but yields to user code for other hits to allow them to be\n")
SLANG_RAW("// dismissed or committed.\n")
SLANG_RAW("//\n")
SLANG_RAW("typedef uint CANDIDATE_TYPE;\n")
SLANG_RAW("\n")
SLANG_RAW("// Candidate hit is a non-opaque triangle.\n")
SLANG_RAW("static const CANDIDATE_TYPE CANDIDATE_NON_OPAQUE_TRIANGLE = 0;\n")
SLANG_RAW("\n")
SLANG_RAW("// Candidate hit is a procedural primitive.\n")
SLANG_RAW("static const CANDIDATE_TYPE CANDIDATE_PROCEDURAL_PRIMITIVE = 1;\n")
SLANG_RAW("\n")
SLANG_RAW("// Handle to state of an in-progress ray-tracing query.\n")
SLANG_RAW("//\n")
SLANG_RAW("// The ray query is effectively a coroutine that user shader\n")
SLANG_RAW("// code can resume to continue tracing the ray, and which yields\n")
SLANG_RAW("// back to the user code at interesting events along the ray.\n")
SLANG_RAW("//\n")
SLANG_RAW("__target_intrinsic(hlsl, RayQuery)\n")
SLANG_RAW("struct RayQuery <let rayFlags : RAY_FLAG = RAY_FLAG_NONE>\n")
SLANG_RAW("{\n")
SLANG_RAW("    // Initialize a ray-tracing query.\n")
SLANG_RAW("    //\n")
SLANG_RAW("    // This method may be called on a \"fresh\" ray query, or\n")
SLANG_RAW("    // on one that is already tracing a ray. In the latter\n")
SLANG_RAW("    // case any state related to the ray previously being\n")
SLANG_RAW("    // traced is overwritten.\n")
SLANG_RAW("    //\n")
SLANG_RAW("    // The `rayFlags` here will be bitwise ORed with\n")
SLANG_RAW("    // the `rayFlags` passed as a generic argument to\n")
SLANG_RAW("    // `RayQuery` to get the effective ray flags, which\n")
SLANG_RAW("    // must obey any API-imposed restrictions.\n")
SLANG_RAW("    //\n")
SLANG_RAW("    void TraceRayInline(RaytracingAccelerationStructure accelerationStructure, RAY_FLAG rayFlags, uint instanceInclusionMask, RayDesc ray);\n")
SLANG_RAW("\n")
SLANG_RAW("    // Resume the ray query coroutine.\n")
SLANG_RAW("    //\n")
SLANG_RAW("    // If the coroutine suspends because of encountering\n")
SLANG_RAW("    // a candidate hit that cannot be resolved with fixed-funciton\n")
SLANG_RAW("    // logic, this function returns `true`, and the `Candidate*()`\n")
SLANG_RAW("    // functions should be used by application code to resolve\n")
SLANG_RAW("    // the candidate hit (by either committing or ignoring it).\n")
SLANG_RAW("    //\n")
SLANG_RAW("    // If the coroutine terminates because traversal is\n")
SLANG_RAW("    // complete (or has been aborted), this function returns\n")
SLANG_RAW("    // `false`, and application code should use the `Committed*()`\n")
SLANG_RAW("    // functions to appropriately handle the closest hit (it any)\n")
SLANG_RAW("    // that was found.\n")
SLANG_RAW("    //\n")
SLANG_RAW("    bool Proceed();\n")
SLANG_RAW("\n")
SLANG_RAW("    // Causes the ray query to terminate.\n")
SLANG_RAW("    //\n")
SLANG_RAW("    // This function cases the ray query to act as if\n")
SLANG_RAW("    // traversal has terminated, so that subsequent\n")
SLANG_RAW("    // `Proceed()` calls will return `false`.\n")
SLANG_RAW("    //\n")
SLANG_RAW("    void Abort();\n")
SLANG_RAW("\n")
SLANG_RAW("    // Get the type of candidate hit being considered.\n")
SLANG_RAW("    //\n")
SLANG_RAW("    // The ray query coroutine will suspend when it encounters\n")
SLANG_RAW("    // a hit that cannot be resolved with fixed-function logic\n")
SLANG_RAW("    // (either a non-opaque triangle or a procedural primitive).\n")
SLANG_RAW("    // In either of those cases, `CandidateType()` will return\n")
SLANG_RAW("    // the kind of candidate hit that must be resolved by\n")
SLANG_RAW("    // user code.\n")
SLANG_RAW("    //\n")
SLANG_RAW("    CANDIDATE_TYPE CandidateType();\n")
SLANG_RAW("\n")
SLANG_RAW("    // Access properties of a candidate hit.\n")
SLANG_RAW("    //\n")
SLANG_RAW("    float3x4 CandidateObjectToWorld3x4();\n")
SLANG_RAW("    float4x3 CandidateObjectToWorld4x3();\n")
SLANG_RAW("    float3x4 CandidateWorldToObject3x4();\n")
SLANG_RAW("    float4x3 CandidateWorldToObject4x3();\n")
SLANG_RAW("    uint CandidateInstanceIndex();\n")
SLANG_RAW("    uint CandidateInstanceID();\n")
SLANG_RAW("    uint CandidateGeometryIndex();\n")
SLANG_RAW("    uint CandidatePrimitiveIndex();\n")
SLANG_RAW("    uint CandidateInstanceContributionToHitGroupIndex();\n")
SLANG_RAW("\n")
SLANG_RAW("    // Access properties of the ray being traced\n")
SLANG_RAW("    // in the object space of a candidate hit.\n")
SLANG_RAW("    //\n")
SLANG_RAW("    float3 CandidateObjectRayOrigin();\n")
SLANG_RAW("    float3 CandidateObjectRayDirection();\n")
SLANG_RAW("\n")
SLANG_RAW("    // Access properties of a candidate procedural primitive hit.\n")
SLANG_RAW("    //\n")
SLANG_RAW("    bool CandidateProceduralPrimitiveNonOpaque();\n")
SLANG_RAW("\n")
SLANG_RAW("    // Access properties of a candidate no-opaque triangle hit.\n")
SLANG_RAW("    //\n")
SLANG_RAW("    bool CandidateTriangleFrontFace();\n")
SLANG_RAW("    float2 CandidateTriangleBarycentrics();\n")
SLANG_RAW("    float CandidateTriangleRayT();\n")
SLANG_RAW("\n")
SLANG_RAW("    // Commit the current non-opaque triangle hit.\n")
SLANG_RAW("    void CommitNonOpaqueTriangleHit();\n")
SLANG_RAW("\n")
SLANG_RAW("    // Commit the current procedural primitive hit, with hit time `t`.\n")
SLANG_RAW("    void CommitProceduralPrimitiveHit(float t);\n")
SLANG_RAW("\n")
SLANG_RAW("    // Get the status of the committed (closest) hit, if any.\n")
SLANG_RAW("    COMMITTED_STATUS CommittedStatus();\n")
SLANG_RAW("\n")
SLANG_RAW("    // Access properties of the committed hit.\n")
SLANG_RAW("    //\n")
SLANG_RAW("    float3x4 CommittedObjectToWorld3x4();\n")
SLANG_RAW("    float4x3 CommittedObjectToWorld4x3();\n")
SLANG_RAW("    float3x4 CommittedWorldToObject3x4();\n")
SLANG_RAW("    float4x3 CommittedWorldToObject4x3();\n")
SLANG_RAW("    float CommittedRayT();\n")
SLANG_RAW("    uint CommittedInstanceIndex();\n")
SLANG_RAW("    uint CommittedInstanceID();\n")
SLANG_RAW("    uint CommittedGeometryIndex();\n")
SLANG_RAW("    uint CommittedPrimitiveIndex();\n")
SLANG_RAW("    uint CommittedInstanceContributionToHitGroupIndex();\n")
SLANG_RAW("\n")
SLANG_RAW("    // Access properties of the ray being traced\n")
SLANG_RAW("    // in the object space of a committed hit.\n")
SLANG_RAW("    //\n")
SLANG_RAW("    float3 CommittedObjectRayOrigin();\n")
SLANG_RAW("    float3 CommittedObjectRayDirection();\n")
SLANG_RAW("\n")
SLANG_RAW("    // Access properties of a committed triangle hit.\n")
SLANG_RAW("    //\n")
SLANG_RAW("    bool CommittedTriangleFrontFace();\n")
SLANG_RAW("    float2 CommittedTriangleBarycentrics();\n")
SLANG_RAW("\n")
SLANG_RAW("    // Access properties of the ray being traced.\n")
SLANG_RAW("    uint RayFlags();\n")
SLANG_RAW("    float3 WorldRayOrigin();\n")
SLANG_RAW("    float3 WorldRayDirection();\n")
SLANG_RAW("    float RayTMin();\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("//\n")
SLANG_RAW("// Vulkan/SPIR-V specific features\n")
SLANG_RAW("//\n")
SLANG_RAW("\n")
SLANG_RAW("struct VkSubpassInput<T>\n")
SLANG_RAW("{\n")
SLANG_RAW("    T SubpassLoad();\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("struct VkSubpassInputMS<T>\n")
SLANG_RAW("{\n")
SLANG_RAW("    T SubpassLoad(int sampleIndex);\n")
SLANG_RAW("}\n")
