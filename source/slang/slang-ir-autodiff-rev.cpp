#include "slang-ir-autodiff-rev.h"

#include "slang-ir-clone.h"
#include "slang-ir-dce.h"
#include "slang-ir-eliminate-phis.h"
#include "slang-ir-autodiff-cfg-norm.h"
#include "slang-ir-util.h"
#include "slang-ir-inst-pass-base.h"
#include "slang-ir-ssa-simplification.h"
#include "slang-ir-autodiff-fwd.h"
#include "slang-ir-single-return.h"
#include "slang-ir-addr-inst-elimination.h"
#include "slang-ir-eliminate-multilevel-break.h"
#include "slang-ir-init-local-var.h"

namespace Slang
{
    IRFuncType* BackwardDiffTranscriberBase::differentiateFunctionTypeImpl(IRBuilder* builder, IRFuncType* funcType, IRInst* intermeidateType)
    {
        List<IRType*> newParameterTypes;
        IRType* diffReturnType; 

        for (UIndex i = 0; i < funcType->getParamCount(); i++)
        {
            auto origType = funcType->getParamType(i);
            auto paramType = transcribeParamTypeForPropagateFunc(builder, origType);
            if (paramType)
                newParameterTypes.add(paramType);
        }

        if (auto diffResultType = differentiateType(builder, funcType->getResultType()))
            newParameterTypes.add(diffResultType);

        if (intermeidateType)
        {
            newParameterTypes.add((IRType*)intermeidateType);
        }

        diffReturnType = builder->getVoidType();

        return builder->getFuncType(newParameterTypes, diffReturnType);
    }

    IRFuncType* BackwardDiffPrimalTranscriber::differentiateFunctionType(IRBuilder* builder, IRInst* func, IRFuncType* funcType)
    {
        IRType* intermediateType = builder->getBackwardDiffIntermediateContextType(maybeFindOuterGeneric(func));
        if (auto outerGeneric = findOuterGeneric(builder->getInsertLoc().getParent()))
        {
            intermediateType = (IRType*)specializeWithGeneric(*builder, intermediateType, as<IRGeneric>(outerGeneric));
        }

        auto outType = builder->getOutType(intermediateType);
        List<IRType*> paramTypes;
        for (UInt i = 0; i < funcType->getParamCount(); i++)
        {
            auto origType = funcType->getParamType(i);
            auto primalType = transcribeParamTypeForPrimalFunc(builder, origType);
            paramTypes.add(primalType);
        }
        paramTypes.add(outType);
        IRFuncType* primalFuncType = builder->getFuncType(
            paramTypes, (IRType*)findOrTranscribePrimalInst(builder, funcType->getResultType()));
        return primalFuncType;
    }

    InstPair BackwardDiffPrimalTranscriber::transcribeFunc(IRBuilder* builder, IRFunc* primalFunc, IRFunc* diffFunc)
    {
        // Don't need to do anything other than add a decoration in the original func to point to the primal func.
        // The body of the primal func will be generated by propagateTranscriber together with propagate func.
        addTranscribedFuncDecoration(*builder, primalFunc, diffFunc);
        return InstPair(primalFunc, diffFunc);
    }

    static List<IRInst*> _defineFuncParams(IRBuilder* builder, IRFunc* func)
    {
        auto propFuncType = cast<IRFuncType>(func->getFullType());
        List<IRInst*> params;
        for (UInt i = 0; i < propFuncType->getParamCount(); i++)
        {
            auto paramType = propFuncType->getParamType(i);
            auto param = builder->emitParam(paramType);
            params.add(param);
        }
        return params;
    }

    void BackwardDiffPropagateTranscriber::generateTrivialDiffFuncFromUserDefinedDerivative(
        IRBuilder* builder,
        IRFunc* originalFunc,
        IRFunc* diffPropFunc,
        IRUserDefinedBackwardDerivativeDecoration* udfDecor)
    {
        // Create an empty struct type to use as the intermediate context type.
        auto originalGeneric = findOuterGeneric(originalFunc);
        builder->setInsertBefore(originalFunc);
        IRInst* emptyStruct = builder->createStructType();
        IRInst* emptyStructType = nullptr;
        auto emptyStructGeneric = hoistValueFromGeneric(*builder, emptyStruct, emptyStructType, false);
        builder->addBackwardDerivativeIntermediateTypeDecoration(originalFunc, emptyStructGeneric);

        IRInst* udf = udfDecor->getBackwardDerivativeFunc();
        builder->setInsertInto(diffPropFunc);
        builder->emitBlock();
        List<IRInst*> params = _defineFuncParams(builder, diffPropFunc);
        params.removeLast();
        IRInst* udfRefFromPropFunc = udf;
        if (auto specialize = as<IRSpecialize>(udf))
        {
            udf = specialize->getBase();
            auto propGeneric = findOuterGeneric(diffPropFunc);
            SLANG_RELEASE_ASSERT(propGeneric);
            udfRefFromPropFunc = maybeSpecializeWithGeneric(*builder, udf, propGeneric);
        }
        builder->emitCallInst(builder->getVoidType(), udfRefFromPropFunc, params);
        builder->emitReturn();

        // Now create the trivial primal function.
        auto existingDecor = originalFunc->findDecoration<IRBackwardDerivativePrimalDecoration>();
        if (!existingDecor)
        {
            // We haven't created a header for primal func yet, create it now.
            if (originalGeneric)
                builder->setInsertBefore(originalGeneric);
            else
                builder->setInsertBefore(originalFunc);

            autoDiffSharedContext->transcriberSet.primalTranscriber->transcribe(builder, originalGeneric ? originalGeneric : originalFunc);
            existingDecor = originalFunc->findDecoration<IRBackwardDerivativePrimalDecoration>();
        }
        SLANG_RELEASE_ASSERT(existingDecor);

        // Fill the primal func header with trivial call to original func.
        IRInst* existingPrimalFunc = existingDecor->getBackwardDerivativePrimalFunc();
        IRGeneric* existingPriamlFuncGeneric = nullptr;
        if (auto specialize = as<IRSpecialize>(existingPrimalFunc))
        {
            existingPriamlFuncGeneric = as<IRGeneric>(specialize->getBase());
            existingPrimalFunc = findGenericReturnVal(existingPriamlFuncGeneric);
        }
        builder->setInsertBefore(existingPrimalFunc);

        builder->setInsertInto(existingPrimalFunc);
        builder->emitBlock();
        params = _defineFuncParams(builder, as<IRFunc>(existingPrimalFunc));
        params.removeLast();
        IRInst* originalFuncRefFromPrimalFunc = originalFunc;
        if (originalGeneric)
            originalFuncRefFromPrimalFunc = maybeSpecializeWithGeneric(*builder, originalGeneric, existingPriamlFuncGeneric);
        auto result = builder->emitCallInst(
            cast<IRFuncType>(existingPrimalFunc->getFullType())->getResultType(),
            originalFuncRefFromPrimalFunc,
            params);
        builder->emitReturn(result);
    }

    IRFuncType* BackwardDiffPropagateTranscriber::differentiateFunctionType(IRBuilder* builder, IRInst* func, IRFuncType* funcType)
    {
        IRType* intermediateType = builder->getBackwardDiffIntermediateContextType(maybeFindOuterGeneric(func));
        if (auto outerGeneric = findOuterGeneric(builder->getInsertLoc().getParent()))
        {
            intermediateType = (IRType*)specializeWithGeneric(*builder, intermediateType, as<IRGeneric>(outerGeneric));
        }
        return differentiateFunctionTypeImpl(builder, funcType, intermediateType);
    }

    IRFuncType* BackwardDiffTranscriber::differentiateFunctionType(IRBuilder* builder, IRInst* func, IRFuncType* funcType)
    {
        SLANG_UNUSED(func);
        return differentiateFunctionTypeImpl(builder, funcType, nullptr);
    }

    InstPair BackwardDiffPropagateTranscriber::transcribeFunc(IRBuilder* builder, IRFunc* primalFunc, IRFunc* diffFunc)
    {
        addTranscribedFuncDecoration(*builder, primalFunc, diffFunc);
        if (auto udf = primalFunc->findDecoration<IRUserDefinedBackwardDerivativeDecoration>())
        {
             generateTrivialDiffFuncFromUserDefinedDerivative(builder, primalFunc, diffFunc, udf);
        }
        else
        {
            transcribeFuncImpl(builder, primalFunc, diffFunc);
        }
        return InstPair(primalFunc, diffFunc);
    }

    InstPair BackwardDiffTranscriberBase::transcribeInstImpl(IRBuilder* builder, IRInst* origInst)
    {
        switch (origInst->getOp())
        {
        case kIROp_Param:
            return transcribeParam(builder, as<IRParam>(origInst));

        case kIROp_Return:
            return transcribeReturn(builder, as<IRReturn>(origInst));

        case kIROp_LookupWitness:
            return transcribeLookupInterfaceMethod(builder, as<IRLookupWitnessMethod>(origInst));

        case kIROp_Specialize:
            return transcribeSpecialize(builder, as<IRSpecialize>(origInst));

        case kIROp_MakeTuple:
        case kIROp_FloatLit:
        case kIROp_IntLit:
        case kIROp_VoidLit:
        case kIROp_ExtractExistentialWitnessTable:
        case kIROp_ExtractExistentialType:
        case kIROp_ExtractExistentialValue:
        case kIROp_WrapExistential:
        case kIROp_MakeExistential:
        case kIROp_MakeExistentialWithRTTI:
            return trascribeNonDiffInst(builder, origInst);

        case kIROp_StructKey:
            return InstPair(origInst, nullptr);
        }

        return InstPair(nullptr, nullptr);
    }

    // Returns "dp<var-name>" to use as a name hint for parameters.
    // If no primal name is available, returns a blank string.
    // 
    String BackwardDiffTranscriberBase::makeDiffPairName(IRInst* origVar)
    {
        if (auto namehintDecoration = origVar->findDecoration<IRNameHintDecoration>())
        {
            return ("dp" + String(namehintDecoration->getName()));
        }

        return String("");
    }

    static IRType* _getPrimalTypeFromNoDiffType(BackwardDiffTranscriberBase* transcriber, IRBuilder* builder, IRType* origType)
    {
        IRType* valueType = origType;
        auto ptrType = as<IROutTypeBase>(valueType);
        if (ptrType)
            valueType = ptrType->getValueType();

        if (auto attrType = as<IRAttributedType>(valueType))
        {
            if (attrType->findAttr<IRNoDiffAttr>())
            {
                auto primalValueType = (IRType*)transcriber->findOrTranscribePrimalInst(builder, valueType);
                if (ptrType)
                    return builder->getPtrType(ptrType->getOp(), primalValueType);
                return primalValueType;
            }
        }
        return nullptr;
    }

    IRType* BackwardDiffTranscriberBase::transcribeParamTypeForPrimalFunc(IRBuilder* builder, IRType* paramType)
    {
        // If the param is marked as no_diff, return the primal type.
        if (auto primalNoDiffType = _getPrimalTypeFromNoDiffType(this, builder, paramType))
            return primalNoDiffType;

        return (IRType*)findOrTranscribePrimalInst(builder, paramType);
    }

    IRType* BackwardDiffTranscriberBase::transcribeParamTypeForPropagateFunc(IRBuilder* builder, IRType* paramType)
    {
        if (auto outType = as<IROutType>(paramType))
        {
            auto valueType = outType->getValueType();
            auto diffValueType = differentiateType(builder, valueType);
            return diffValueType;
        }
        
        // If the param is marked as no_diff, return the primal type.
        if (auto primalNoDiffType = _getPrimalTypeFromNoDiffType(this, builder, paramType))
            return primalNoDiffType;
        
        auto diffPairType = tryGetDiffPairType(builder, paramType);
        if (diffPairType)
        {
            if (!as<IRPtrTypeBase>(diffPairType))
                return builder->getInOutType(diffPairType);
            return diffPairType;
        }
        auto primalType = (IRType*)findOrTranscribePrimalInst(builder, paramType);
        return primalType;
    }

    // Create an empty func to represent the transcribed func of `origFunc`.
    InstPair BackwardDiffTranscriberBase::transcribeFuncHeaderImpl(IRBuilder* inBuilder, IRFunc* origFunc)
    {
        if (auto bwdDiffFunc = findExistingDiffFunc(origFunc))
            return InstPair(origFunc, bwdDiffFunc);

        if (!isBackwardDifferentiableFunc(origFunc))
            return InstPair(nullptr, nullptr);

        IRBuilder builder = *inBuilder;

        IRFunc* primalFunc = origFunc;

        maybeMigrateDifferentiableDictionaryFromDerivativeFunc(inBuilder, origFunc);
        differentiableTypeConformanceContext.setFunc(origFunc);

        auto diffFunc = builder.createFunc();

        SLANG_ASSERT(as<IRFuncType>(origFunc->getFullType()));
        builder.setInsertBefore(diffFunc);

        IRType* diffFuncType = this->differentiateFunctionType(
            &builder,
            origFunc,
            as<IRFuncType>(origFunc->getFullType()));
        diffFunc->setFullType(diffFuncType);

        if (auto nameHint = origFunc->findDecoration<IRNameHintDecoration>())
        {
            auto originalName = nameHint->getName();
            StringBuilder newNameSb;
            newNameSb << "s_bwd_" << originalName;
            builder.addNameHintDecoration(diffFunc, newNameSb.getUnownedSlice());
        }

        // Mark the generated derivative function itself as differentiable.
        builder.addBackwardDifferentiableDecoration(diffFunc);
        // Find and clone `DifferentiableTypeDictionaryDecoration` to the new diffFunc.
        if (auto dictDecor = origFunc->findDecoration<IRDifferentiableTypeDictionaryDecoration>())
        {
            builder.setInsertBefore(diffFunc->getFirstDecorationOrChild());
            cloneInst(&cloneEnv, &builder, dictDecor);
        }

        return InstPair(primalFunc, diffFunc);
    }

    void BackwardDiffTranscriberBase::addTranscribedFuncDecoration(IRBuilder& builder, IRFunc* origFunc, IRFunc* transcribedFunc)
    {
        IRBuilder subBuilder = builder;
        if (auto outerGen = findOuterGeneric(transcribedFunc))
        {
            subBuilder.setInsertBefore(origFunc);
            auto specialized =
                specializeWithGeneric(subBuilder, outerGen, as<IRGeneric>(findOuterGeneric(origFunc)));
            addExistingDiffFuncDecor(&subBuilder, origFunc, specialized);
        }
        else
        {
            addExistingDiffFuncDecor(&subBuilder, origFunc, transcribedFunc);
        }
    }

    InstPair BackwardDiffTranscriberBase::transcribeFuncHeader(IRBuilder* inBuilder, IRFunc* origFunc)
    {
        auto result = transcribeFuncHeaderImpl(inBuilder, origFunc);

        FuncBodyTranscriptionTask task;
        task.originalFunc = as<IRFunc>(result.primal);
        task.resultFunc = as<IRFunc>(result.differential);
        task.type = diffTaskType;
        if (task.resultFunc)
        {
            autoDiffSharedContext->followUpFunctionsToTranscribe.add(task);
        }
        return result;
    }

    InstPair BackwardDiffTranscriber::transcribeFuncHeader(IRBuilder* inBuilder, IRFunc* origFunc)
    {
        auto header = transcribeFuncHeaderImpl(inBuilder, origFunc);
        if (!header.differential)
            return header;

        IRBuilder builder(inBuilder->getSharedBuilder());
        builder.setInsertInto(header.differential);
        builder.emitBlock();
        auto origFuncType = as<IRFuncType>(origFunc->getFullType());
        List<IRInst*> primalArgs, propagateArgs;
        List<IRType*> primalTypes, propagateTypes;
        for (UInt i = 0; i < origFuncType->getParamCount(); i++)
        {
            auto primalParamType = transcribeParamTypeForPrimalFunc(&builder, origFuncType->getParamType(i));
            auto propagateParamType = transcribeParamTypeForPropagateFunc(&builder, origFuncType->getParamType(i));
            if (propagateParamType)
            {
                auto param = builder.emitParam(propagateParamType);
                propagateTypes.add(propagateParamType);
                propagateArgs.add(param);

                // Fetch primal values to use as arguments in primal func call.
                IRInst* primalArg = param;
                if (!as<IROutType>(primalParamType))
                {
                    // As long as the primal parameter is not an out type,
                    // we need to fetch the primal value from the parameter.
                    if (as<IRPtrTypeBase>(propagateParamType))
                    {
                        primalArg = builder.emitLoad(param);
                    }
                    if (auto diffPairType = as<IRDifferentialPairType>(primalArg->getDataType()))
                    {
                        primalArg = builder.emitDifferentialPairGetPrimal(primalArg);
                    }
                }
                if (auto primalParamPtrType = as<IRPtrTypeBase>(primalParamType))
                {
                    // If primal parameter is mutable, we need to pass in a temp var.
                    auto tempVar = builder.emitVar(primalParamPtrType->getValueType());
                    if (primalParamPtrType->getOp() == kIROp_InOutType)
                    {
                        // If the primal parameter is inout, we need to set the initial value.
                        builder.emitStore(tempVar, primalArg);
                    }
                    primalArgs.add(tempVar);
                }
                else
                {
                    primalArgs.add(primalArg);
                }
            }
            else
            {
                auto var = builder.emitVar(primalParamType);
                primalArgs.add(var);
            }
            primalTypes.add(primalParamType);
        }

        // Add dOut argument to propagateArgs.
        auto diffResultType = differentiateType(&builder, origFunc->getResultType());
        if (diffResultType)
        {
            auto param = builder.emitParam(diffResultType);
            propagateArgs.add(param);
            propagateTypes.add(param->getFullType());
        }

        auto outerGeneric = findOuterGeneric(origFunc);
        IRType* intermediateType = builder.getBackwardDiffIntermediateContextType(maybeFindOuterGeneric(origFunc));
        IRInst* specializedOriginalFunc = origFunc;
        if (outerGeneric)
        {
            specializedOriginalFunc = maybeSpecializeWithGeneric(builder, outerGeneric, findOuterGeneric(header.differential));
            intermediateType = (IRType*)specializeWithGeneric(builder, intermediateType, as<IRGeneric>(findOuterGeneric(header.differential)));
        }

        auto intermediateVar = builder.emitVar(intermediateType);

        auto primalFuncType = builder.getFuncType(
            primalTypes,
            origFuncType->getResultType());
        primalArgs.add(intermediateVar);
        primalTypes.add(builder.getOutType(intermediateType));
        auto primalFunc = builder.emitBackwardDifferentiatePrimalInst(primalFuncType, specializedOriginalFunc);
        builder.emitCallInst(origFuncType->getResultType(), primalFunc, primalArgs);

        propagateTypes.add(intermediateType);
        propagateArgs.add(builder.emitLoad(intermediateVar));
        auto propagateFuncType = builder.getFuncType(propagateTypes, builder.getVoidType());
        auto propagateFunc = builder.emitBackwardDifferentiatePropagateInst(propagateFuncType, specializedOriginalFunc);
        builder.emitCallInst(builder.getVoidType(), propagateFunc, propagateArgs);

        builder.emitReturn();
        return header;
    }

    // Puts parameters into their own block.
    void BackwardDiffTranscriberBase::makeParameterBlock(IRBuilder* inBuilder, IRFunc* func)
    {
        IRBuilder builder(inBuilder->getSharedBuilder());

        auto firstBlock = func->getFirstBlock();
        IRParam* param = func->getFirstParam();

        builder.setInsertBefore(firstBlock);
        
        // Note: It looks like emitBlock() doesn't use the current 
        // builder position, so we're going to manually move the new block
        // to before the existing block.
        auto paramBlock = builder.emitBlock();
        paramBlock->insertBefore(firstBlock);
        builder.setInsertInto(paramBlock);

        while(param)
        {
            IRParam* nextParam = param->getNextParam();

            // Move inst into the new parameter block.
            param->insertAtEnd(paramBlock);

            param = nextParam;
        }
        
        // Replace this block as the first block.
        firstBlock->replaceUsesWith(paramBlock);

        // Add terminator inst.
        builder.emitBranch(firstBlock);
    }

    void insertTempVarForMutableParams(SharedIRBuilder* sharedBuilder, IRFunc* func)
    {
        IRBuilder builder(sharedBuilder);
        auto firstBlock = func->getFirstBlock();
        builder.setInsertBefore(firstBlock->getFirstOrdinaryInst());
        
        OrderedDictionary<IRParam*, IRVar*> mapParamToTempVar;
        List<IRParam*> params;
        for (auto param : firstBlock->getParams())
        {
            if (auto ptrType = as<IRPtrTypeBase>(param->getDataType()))
            {
                params.add(param);
            }
        }

        for (auto param : params)
        {
            auto ptrType = as<IRPtrTypeBase>(param->getDataType());
            auto tempVar = builder.emitVar(ptrType->getValueType());
            mapParamToTempVar[param] = tempVar;
            if (param->getOp() != kIROp_OutType)
            {
                builder.emitStore(tempVar, builder.emitLoad(param));
            }
            param->replaceUsesWith(tempVar);
        }

        for (auto block : func->getBlocks())
        {
            for (auto inst : block->getChildren())
            {
                if (inst->getOp() == kIROp_Return)
                {
                    builder.setInsertBefore(inst);
                    for (auto& kv : mapParamToTempVar)
                    {
                        builder.emitStore(kv.Key, builder.emitLoad(kv.Value));
                    }
                }
            }
        }
    }


    struct AutoDiffAddressConversionPolicy : public AddressConversionPolicy
    {
        DifferentiableTypeConformanceContext* diffTypeContext;

        virtual bool shouldConvertAddrInst(IRInst* addrInst) override
        {
            if (isDifferentiableType(*diffTypeContext, addrInst->getDataType()))
                return true;
            return false;
        }
    };

    SlangResult BackwardDiffTranscriberBase::prepareFuncForBackwardDiff(IRFunc* func)
    {
        DifferentiableTypeConformanceContext diffTypeContext(autoDiffSharedContext);
        diffTypeContext.setFunc(func);

        if (!isSingleReturnFunc(func))
        {
            convertFuncToSingleReturnForm(func->getModule(), func);
        }
        eliminateMultiLevelBreakForFunc(func->getModule(), func);

        IRCFGNormalizationPass cfgPass = {this->getSink()};
        normalizeCFG(autoDiffSharedContext->sharedBuilder, func);

        insertTempVarForMutableParams(sharedBuilder, func);

        AutoDiffAddressConversionPolicy cvtPolicty;
        cvtPolicty.diffTypeContext = &diffTypeContext;
        auto result = eliminateAddressInsts(sharedBuilder, &cvtPolicty, func, sink);
        if (SLANG_SUCCEEDED(result))
        {
            simplifyFunc(func);
        }
        return result;
    }

    // Create a copy of originalFunc's forward derivative in the same generic context (if any) of
    // `diffPropagateFunc`.
    IRFunc* BackwardDiffTranscriberBase::generateNewForwardDerivativeForFunc(
        IRBuilder* builder, IRFunc* originalFunc, IRFunc* diffPropagateFunc)
    {
        auto primalOuterParent = findOuterGeneric(originalFunc);
        if (!primalOuterParent)
            primalOuterParent = originalFunc;

        // Make a clone of original func so we won't modify the original.
        IRCloneEnv originalCloneEnv;
        primalOuterParent = cloneInst(&originalCloneEnv, builder, primalOuterParent);
        auto primalFunc = as<IRFunc>(getGenericReturnVal(primalOuterParent));

        // Strip any existing derivative decorations off the clone.
        stripDerivativeDecorations(primalFunc);
        eliminateDeadCode(primalOuterParent);

        // Perform required transformations and simplifications on the original func to make it
        // reversible.
        if (SLANG_FAILED(prepareFuncForBackwardDiff(primalFunc)))
            return diffPropagateFunc;
        
        autoDiffSharedContext->sharedBuilder->deduplicateAndRebuildGlobalNumberingMap();

        // Forward transcribe the clone of the original func.
        ForwardDiffTranscriber& fwdTranscriber = *static_cast<ForwardDiffTranscriber*>(
            autoDiffSharedContext->transcriberSet.forwardTranscriber);
        auto oldCount = autoDiffSharedContext->followUpFunctionsToTranscribe.getCount();
        IRFunc* fwdDiffFunc = as<IRFunc>(getGenericReturnVal(fwdTranscriber.transcribe(builder, primalOuterParent)));
        SLANG_ASSERT(fwdDiffFunc);
        auto newCount = autoDiffSharedContext->followUpFunctionsToTranscribe.getCount();
        for (auto i = oldCount; i < newCount; i++)
        {
            auto pendingTask = autoDiffSharedContext->followUpFunctionsToTranscribe.getLast();
            autoDiffSharedContext->followUpFunctionsToTranscribe.removeLast();
            SLANG_RELEASE_ASSERT(pendingTask.type == FuncBodyTranscriptionTaskType::Forward);
            fwdTranscriber.transcribeFunc(builder, pendingTask.originalFunc, pendingTask.resultFunc);
        }

        // Remove the clone of original func.
        primalOuterParent->removeAndDeallocate();

        // Migrate the new forward derivative function into the generic parent of `diffPropagateFunc`.
        if (auto fwdParentGeneric = as<IRGeneric>(findOuterGeneric(fwdDiffFunc)))
        {
            // Clone forward derivative func from its own generic into current generic parent.
            GenericChildrenMigrationContext migrationContext;
            auto diffOuterGeneric = as<IRGeneric>(findOuterGeneric(diffPropagateFunc));
            SLANG_RELEASE_ASSERT(diffOuterGeneric);

            migrationContext.init(fwdParentGeneric, diffOuterGeneric, diffPropagateFunc);
            auto inst = fwdParentGeneric->getFirstBlock()->getFirstOrdinaryInst();
            builder->setInsertBefore(diffPropagateFunc);
            while (inst)
            {
                auto next = inst->getNextInst();
                auto cloned = migrationContext.cloneInst(builder, inst);
                if (inst == fwdDiffFunc)
                {
                    fwdDiffFunc = as<IRFunc>(cloned);
                    break;
                }
                inst = next;
            }
            fwdParentGeneric->removeAndDeallocate();
        }
        return fwdDiffFunc;
    }

    InstPair BackwardDiffTranscriberBase::transcribeFuncParam(IRBuilder* builder, IRParam* origParam, IRInst* primalType)
    {
        SLANG_UNUSED(primalType);

        SLANG_RELEASE_ASSERT(origParam->getParent() && origParam->getParent()->getParent()
            && origParam->getParent()->getParent()->getOp() == kIROp_Generic);

        auto primalInst = maybeCloneForPrimalInst(builder, origParam);
        if (auto primalParam = as<IRParam>(primalInst))
        {
            SLANG_RELEASE_ASSERT(builder->getInsertLoc().getBlock());
            primalParam->removeFromParent();
            builder->getInsertLoc().getBlock()->addParam(primalParam);
        }
        return InstPair(primalInst, nullptr);
    }

    // Transcribe a function definition.
    void BackwardDiffTranscriberBase::transcribeFuncImpl(IRBuilder* builder, IRFunc* primalFunc, IRFunc* diffPropagateFunc)
    {
        SLANG_ASSERT(primalFunc);
        SLANG_ASSERT(diffPropagateFunc);
        // Reverse-mode transcription uses 4 separate steps:
        // TODO(sai): Fill in documentation.

        // Generate a temporary forward derivative function as an intermediate step.
        IRBuilder tempBuilder = *builder;
        if (auto outerGeneric = findOuterGeneric(diffPropagateFunc))
        {
            tempBuilder.setInsertBefore(outerGeneric);
        }
        else
        {
            tempBuilder.setInsertBefore(diffPropagateFunc);
        }

        auto fwdDiffFunc = generateNewForwardDerivativeForFunc(&tempBuilder, primalFunc, diffPropagateFunc);
        if (!fwdDiffFunc)
            return;

        bool isResultDifferentiable = as<IRDifferentialPairType>(fwdDiffFunc->getResultType());

        // Split first block into a paramter block.
        this->makeParameterBlock(&tempBuilder, as<IRFunc>(fwdDiffFunc));
        
        // This steps adds a decoration to instructions that are computing the differential.
        // TODO: This is disabled for now because fwd-mode already adds differential decorations
        // wherever need. We need to run this pass only for user-writted forward derivativecode.
        // 
        // diffPropagationPass->propagateDiffInstDecoration(builder, fwdDiffFunc);

        // Copy primal insts to the first block of the unzipped function, copy diff insts to the
        // second block of the unzipped function.
        // 
        IRFunc* unzippedFwdDiffFunc = diffUnzipPass->unzipDiffInsts(fwdDiffFunc);

       
        // Move blocks from `unzippedFwdDiffFunc` to the `diffPropagateFunc` shell.
        builder->setInsertInto(diffPropagateFunc->getParent());
        {
            List<IRBlock*> workList;
            for (auto block = unzippedFwdDiffFunc->getFirstBlock(); block; block = block->getNextBlock())
                workList.add(block);
            
            for (auto block : workList)
                block->insertAtEnd(diffPropagateFunc);
        }

        // Transpose the first block (parameter block)
        List<IRInst*> primalFuncSpecificParams;
        auto dOutParameter = transposeParameterBlock(builder, diffPropagateFunc, primalFuncSpecificParams, isResultDifferentiable);

        builder->setInsertInto(diffPropagateFunc);

        // Transpose differential blocks from unzippedFwdDiffFunc into diffFunc (with dOutParameter) representing the 
        DiffTransposePass::FuncTranspositionInfo info = {dOutParameter, nullptr};
        diffTransposePass->transposeDiffBlocksInFunc(diffPropagateFunc, info);

        eliminateDeadCode(diffPropagateFunc);

        // Extracts the primal computations into its own func, and replace the primal insts
        // with the intermediate results computed from the extracted func.
        IRInst* intermediateType = nullptr;
        auto extractedPrimalFunc = diffUnzipPass->extractPrimalFunc(
            diffPropagateFunc, primalFunc, isResultDifferentiable, intermediateType);

        // Clean up by deallocating the tempoarary forward derivative func.
        fwdDiffFunc->removeAndDeallocate();
        
        // Remove primalFuncSpecificParams.
        for (auto specificParam : primalFuncSpecificParams)
        {
            while (auto use = specificParam->firstUse)
            {
                if (use->getUser()->getOp() == kIROp_Store && use == use->getUser()->getOperands())
                {
                    use->getUser()->removeAndDeallocate();
                }
                else if (auto decor = as<IRDecoration>(use->getUser()))
                {
                    decor->removeAndDeallocate();
                }
                else
                {
                    SLANG_UNEXPECTED("unexpected use of transcribed param.");
                }
            }
            specificParam->removeAndDeallocate();
        }

        // If primal function is nested in a generic, we want to create separate generics for all the associated things
        // we have just created.
        auto primalOuterGeneric = findOuterGeneric(primalFunc);
        IRInst* specializedFunc = nullptr;
        auto intermediateTypeGeneric = hoistValueFromGeneric(*builder, intermediateType, specializedFunc, true);
        builder->setInsertBefore(primalFunc);
        builder->addBackwardDerivativeIntermediateTypeDecoration(primalFunc, intermediateTypeGeneric);

        auto primalFuncGeneric = hoistValueFromGeneric(*builder, extractedPrimalFunc, specializedFunc, true);
        builder->setInsertBefore(primalFunc);

        if (auto existingDecor = primalFunc->findDecoration<IRBackwardDerivativePrimalDecoration>())
        {
            // If we already created a header for primal func, move the body into the existing primal func header.
            auto existingPrimalHeader = existingDecor->getBackwardDerivativePrimalFunc();
            if (auto spec = as<IRSpecialize>(existingPrimalHeader))
                existingPrimalHeader = spec->getBase();
            moveInstChildren(existingPrimalHeader, primalFuncGeneric);
            primalFuncGeneric->replaceUsesWith(existingPrimalHeader);
            primalFuncGeneric->removeAndDeallocate();
        }
        else
        {
            auto specializedBackwardPrimalFunc = maybeSpecializeWithGeneric(*builder, primalFuncGeneric, primalOuterGeneric);
            builder->addBackwardDerivativePrimalDecoration(primalFunc, specializedBackwardPrimalFunc);
        }

        initializeLocalVariables(builder->getSharedBuilder(), primalFunc);
        initializeLocalVariables(builder->getSharedBuilder(), diffPropagateFunc);
    }

    IRInst* BackwardDiffTranscriberBase::transposeParameterBlock(
        IRBuilder* builder,
        IRFunc* diffFunc,
        List<IRInst*>& primalFuncSpecificParams,
        bool isResultDifferentiable)
    {
        IRBlock* fwdDiffParameterBlock = diffFunc->getFirstBlock();

        // Find the 'next' block using the terminator inst of the parameter block.
        auto fwdParamBlockBranch = as<IRUnconditionalBranch>(fwdDiffParameterBlock->getTerminator());
        auto nextBlock = fwdParamBlockBranch->getTargetBlock();

        builder->setInsertBefore(fwdParamBlockBranch);

        List<IRParam*> fwdParams;
        for (auto child = fwdDiffParameterBlock->getFirstParam(); child; child = child->getNextParam())
        {
            fwdParams.add(child);
        }

        // 1. Turn fwd-diff versions of the parameters into reverse-diff versions by wrapping them as InOutType<>
        for (auto fwdParam : fwdParams)
        {   
            if (auto outType = as<IROutType>(fwdParam->getDataType()))
            {
                IRParam* newPropParam = nullptr;
                IRParam* newPrimalParam = nullptr;
                auto diffPairType = as<IRDifferentialPairType>(outType->getValueType());
                if (diffPairType)
                {
                    // Create dOut param. 
                    auto diffType = (IRType*)differentiableTypeConformanceContext.getDifferentialTypeFromDiffPairType(builder, diffPairType);
                    newPropParam = builder->emitParam(diffType);
                    newPrimalParam = builder->emitParam(builder->getOutType(diffPairType->getValueType()));
                }
                else
                {
                    newPrimalParam = builder->emitParam(outType);
                }

                // Create a temp var to represent the original `out` param.
                auto arg = builder->emitVar(outType->getValueType());
                builder->addAutoDiffOriginalValueDecoration(arg, newPrimalParam);
                if (newPropParam)
                {
                    builder->addDecoration(arg, kIROp_OutParamReverseGradientDecoration, newPropParam);
                }
                
                fwdParam->replaceUsesWith(arg);
                fwdParam->removeAndDeallocate();

                primalFuncSpecificParams.add(newPrimalParam);
            }
            else if (auto diffPairType = as<IRDifferentialPairType>(fwdParam->getDataType()))
            {
                // Create inout version. 
                auto inoutDiffPairType = builder->getInOutType(diffPairType);
                auto newParam = builder->emitParam(inoutDiffPairType); 

                // Map the _load_ of the new parameter as the clone of the old one.
                auto newParamLoad = builder->emitLoad(newParam);
                newParamLoad->insertAtStart(nextBlock); // Move to first block _after_ the parameter block.
                fwdParam->replaceUsesWith(newParamLoad);
                fwdParam->removeAndDeallocate();
            }
            else
            {
                // Default case (parameter is inout type or has nothing to do with differentiation)
                // Simply move the parameter to the end.
                //
                fwdParam->removeFromParent();
                fwdDiffParameterBlock->addParam(fwdParam);
            }
        }

        auto paramCount = as<IRFuncType>(diffFunc->getDataType())->getParamCount();

        // 2. If the return type of the original function is differentiable,
        // add a parameter for 'derivative of the output' (d_out). 
        // The type is the second last parameter type of the function.
        // 
        IRParam* dOutParam = nullptr;
        if (isResultDifferentiable)
        {
            auto dOutParamType = as<IRFuncType>(diffFunc->getDataType())->getParamType(paramCount - 2);

            SLANG_ASSERT(dOutParamType);

            dOutParam = builder->emitParam(dOutParamType);
        }

        // Add a parameter for intermediate val.
        builder->emitParam(as<IRFuncType>(diffFunc->getDataType())->getParamType(paramCount - 1));

        return dOutParam;
    }

    InstPair BackwardDiffTranscriberBase::transcribeSpecialize(IRBuilder* builder, IRSpecialize* origSpecialize)
    {
        auto primalBase = findOrTranscribePrimalInst(builder, origSpecialize->getBase());
        List<IRInst*> primalArgs;
        for (UInt i = 0; i < origSpecialize->getArgCount(); i++)
        {
            primalArgs.add(findOrTranscribePrimalInst(builder, origSpecialize->getArg(i)));
        }
        auto primalType = findOrTranscribePrimalInst(builder, origSpecialize->getFullType());
        auto primalSpecialize = (IRSpecialize*)builder->emitSpecializeInst(
            (IRType*)primalType, primalBase, primalArgs.getCount(), primalArgs.getBuffer());

        if (auto diffBase = instMapD.TryGetValue(origSpecialize->getBase()))
        {
            List<IRInst*> args;
            for (UInt i = 0; i < primalSpecialize->getArgCount(); i++)
            {
                args.add(primalSpecialize->getArg(i));
            }
            auto diffSpecialize = builder->emitSpecializeInst(
                builder->getTypeKind(), *diffBase, args.getCount(), args.getBuffer());
            return InstPair(primalSpecialize, diffSpecialize);
        }

        auto genericInnerVal = findInnerMostGenericReturnVal(as<IRGeneric>(origSpecialize->getBase()));
        // Look for an IRBackwardDerivativeDecoration on the specialize inst.
        // (Normally, this would be on the inner IRFunc, but in this case only the JVP func
        // can be specialized, so we put a decoration on the IRSpecialize)
        //
        if (auto derivativeFunc = findExistingDiffFunc(origSpecialize))
        {
            // Make sure this isn't itself a specialize .
            SLANG_RELEASE_ASSERT(!as<IRSpecialize>(derivativeFunc));

            return InstPair(primalSpecialize, derivativeFunc);
        }
        else if (auto diffBase = findExistingDiffFunc(genericInnerVal))
        {
            List<IRInst*> args;
            for (UInt i = 0; i < primalSpecialize->getArgCount(); i++)
            {
                args.add(primalSpecialize->getArg(i));
            }

            // A `BackwardDerivative` decoration on an inner func of a generic should always be a `specialize`.
            auto diffBaseSpecialize = as<IRSpecialize>(diffBase);
            SLANG_RELEASE_ASSERT(diffBaseSpecialize);

            // Note: this assumes that the generic arguments to specialize the derivative is the same as the
            // generic args to specialize the primal function. This is true for all of our stdlib functions,
            // but we may need to rely on more general substitution logic here.
            auto diffSpecialize = builder->emitSpecializeInst(
                builder->getTypeKind(), diffBaseSpecialize->getBase(), args.getCount(), args.getBuffer());

            return InstPair(primalSpecialize, diffSpecialize);
        }
        else if (isBackwardDifferentiableFunc(genericInnerVal))
        {
            List<IRInst*> args;
            for (UInt i = 0; i < primalSpecialize->getArgCount(); i++)
            {
                args.add(primalSpecialize->getArg(i));
            }
            auto diffCallee = findOrTranscribeDiffInst(builder, origSpecialize->getBase());
            auto diffSpecialize = builder->emitSpecializeInst(
                builder->getTypeKind(), diffCallee, args.getCount(), args.getBuffer());
            return InstPair(primalSpecialize, diffSpecialize);
        }
        else
        {
            return InstPair(primalSpecialize, nullptr);
        }
    }
}
