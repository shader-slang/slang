#include "slang-ir-autodiff-rev.h"

#include "slang-ir-autodiff-cfg-norm.h"
#include "slang-ir-autodiff-fwd.h"
#include "slang-ir-clone.h"
#include "slang-ir-dce.h"
#include "slang-ir-dominators.h"
#include "slang-ir-eliminate-multilevel-break.h"
#include "slang-ir-init-local-var.h"
#include "slang-ir-inline.h"
#include "slang-ir-inst-pass-base.h"
#include "slang-ir-loop-unroll.h"
#include "slang-ir-redundancy-removal.h"
#include "slang-ir-single-return.h"
#include "slang-ir-ssa-simplification.h"
#include "slang-ir-util.h"

namespace Slang
{
IRFuncType* BackwardDiffTranscriberBase::differentiateFunctionTypeImpl(
    IRBuilder* builder,
    IRFuncType* funcType,
    IRInst* intermeidateType)
{
    List<IRType*> newParameterTypes;
    IRType* diffReturnType;

    for (UIndex i = 0; i < funcType->getParamCount(); i++)
    {
        auto origType = funcType->getParamType(i);
        auto paramType = transcribeParamTypeForPropagateFunc(builder, origType);
        if (paramType)
            newParameterTypes.add(paramType);
    }

    if (auto diffResultType = differentiateType(builder, funcType->getResultType()))
        newParameterTypes.add(diffResultType);

    if (intermeidateType)
    {
        newParameterTypes.add((IRType*)intermeidateType);
    }

    diffReturnType = builder->getVoidType();

    return builder->getFuncType(newParameterTypes, diffReturnType);
}

IRFuncType* BackwardDiffPrimalTranscriber::differentiateFunctionType(
    IRBuilder* builder,
    IRInst* func,
    IRFuncType* funcType)
{
    IRType* intermediateType =
        builder->getBackwardDiffIntermediateContextType(maybeFindOuterGeneric(func));
    if (auto outerGeneric = findOuterGeneric(builder->getInsertLoc().getParent()))
    {
        intermediateType =
            (IRType*)specializeWithGeneric(*builder, intermediateType, as<IRGeneric>(outerGeneric));
    }

    auto outType = builder->getOutParamType(intermediateType);
    List<IRType*> paramTypes;
    for (UInt i = 0; i < funcType->getParamCount(); i++)
    {
        auto origType = funcType->getParamType(i);
        auto primalType = transcribeParamTypeForPrimalFunc(builder, origType);
        paramTypes.add(primalType);
    }
    paramTypes.add(outType);
    IRFuncType* primalFuncType = builder->getFuncType(
        paramTypes,
        (IRType*)findOrTranscribePrimalInst(builder, funcType->getResultType()));
    return primalFuncType;
}

InstPair BackwardDiffPrimalTranscriber::transcribeFunc(
    IRBuilder* builder,
    IRFunc* primalFunc,
    IRFunc* diffFunc)
{
    // Don't need to do anything other than add a decoration in the original func to point to the
    // primal func. The body of the primal func will be generated by propagateTranscriber together
    // with propagate func.
    addTranscribedFuncDecoration(*builder, primalFunc, diffFunc);
    builder->addDecoration(diffFunc, kIROp_IgnoreSideEffectsDecoration);
    return InstPair(primalFunc, diffFunc);
}

static List<IRInst*> _defineFuncParams(IRBuilder* builder, IRFunc* func)
{
    auto propFuncType = cast<IRFuncType>(func->getFullType());
    List<IRInst*> params;
    for (UInt i = 0; i < propFuncType->getParamCount(); i++)
    {
        auto paramType = propFuncType->getParamType(i);
        auto param = builder->emitParam(paramType);
        params.add(param);
    }
    return params;
}

void BackwardDiffPropagateTranscriber::generateTrivialDiffFuncFromUserDefinedDerivative(
    IRBuilder* builder,
    IRFunc* originalFunc,
    IRFunc* diffPropFunc,
    IRUserDefinedBackwardDerivativeDecoration* udfDecor)
{
    // Create an empty struct type to use as the intermediate context type.
    auto originalGeneric = findOuterGeneric(originalFunc);
    builder->setInsertBefore(originalFunc);
    IRInst* emptyStruct = builder->createStructType();
    IRInst* emptyStructType = nullptr;
    auto emptyStructGeneric = hoistValueFromGeneric(*builder, emptyStruct, emptyStructType, false);
    builder->addBackwardDerivativeIntermediateTypeDecoration(originalFunc, emptyStructGeneric);

    IRInst* udf = udfDecor->getBackwardDerivativeFunc();
    builder->setInsertInto(diffPropFunc);
    builder->emitBlock();
    List<IRInst*> params = _defineFuncParams(builder, diffPropFunc);
    params.removeLast();
    IRInst* udfRefFromPropFunc = udf;
    if (auto specialize = as<IRSpecialize>(udf))
    {
        udf = specialize->getBase();
        auto propGeneric = findOuterGeneric(diffPropFunc);
        SLANG_RELEASE_ASSERT(propGeneric);
        udfRefFromPropFunc = maybeSpecializeWithGeneric(*builder, udf, propGeneric);
    }
    builder->emitCallInst(builder->getVoidType(), udfRefFromPropFunc, params);
    builder->emitReturn();

    // Copy other decorations from the original func to the generated primal func wrapper.
    copyOriginalDecorations(udf, diffPropFunc);

    // Now create the trivial primal function.
    auto existingDecor = originalFunc->findDecoration<IRBackwardDerivativePrimalDecoration>();
    if (!existingDecor)
    {
        // We haven't created a header for primal func yet, create it now.
        if (originalGeneric)
            builder->setInsertBefore(originalGeneric);
        else
            builder->setInsertBefore(originalFunc);

        autoDiffSharedContext->transcriberSet.primalTranscriber->transcribe(
            builder,
            originalGeneric ? originalGeneric : originalFunc);
        existingDecor = originalFunc->findDecoration<IRBackwardDerivativePrimalDecoration>();
    }
    SLANG_RELEASE_ASSERT(existingDecor);

    // Fill the primal func header with trivial call to original func.
    IRInst* existingPrimalFunc = existingDecor->getBackwardDerivativePrimalFunc();
    IRGeneric* existingPriamlFuncGeneric = nullptr;
    if (auto specialize = as<IRSpecialize>(existingPrimalFunc))
    {
        existingPriamlFuncGeneric = as<IRGeneric>(specialize->getBase());
        existingPrimalFunc = findGenericReturnVal(existingPriamlFuncGeneric);
    }
    builder->setInsertBefore(existingPrimalFunc);

    builder->setInsertInto(existingPrimalFunc);

    auto checkpointHint = udf->findDecoration<IRCheckpointHintDecoration>();
    if (!checkpointHint)
        checkpointHint = originalFunc->findDecoration<IRCheckpointHintDecoration>();
    if (checkpointHint)
        cloneCheckpointHint(
            builder,
            checkpointHint,
            cast<IRGlobalValueWithCode>(existingPrimalFunc));

    // Copy other decorations from the original func to the generated primal func wrapper.
    copyOriginalDecorations(udf, existingPrimalFunc);

    builder->emitBlock();
    params = _defineFuncParams(builder, as<IRFunc>(existingPrimalFunc));
    params.removeLast();

    // Unwrap any ref pairs. We need this special case for trivial funcs.
    for (Int i = 0; i < params.getCount(); i++)
    {
        if (as<IRDifferentialPtrPairType>(params[i]->getDataType()))
        {
            params[i] = builder->emitDifferentialPtrPairGetPrimal(params[i]);
        }
    }

    IRInst* originalFuncRefFromPrimalFunc = originalFunc;
    if (originalGeneric)
        originalFuncRefFromPrimalFunc =
            maybeSpecializeWithGeneric(*builder, originalGeneric, existingPriamlFuncGeneric);
    auto result = builder->emitCallInst(
        cast<IRFuncType>(existingPrimalFunc->getFullType())->getResultType(),
        originalFuncRefFromPrimalFunc,
        params);
    builder->emitReturn(result);
}

IRFuncType* BackwardDiffPropagateTranscriber::differentiateFunctionType(
    IRBuilder* builder,
    IRInst* func,
    IRFuncType* funcType)
{
    IRType* intermediateType = nullptr;
    if (auto outerGeneric = findOuterGeneric(builder->getInsertLoc().getParent()))
    {
        intermediateType =
            builder->getBackwardDiffIntermediateContextType(maybeFindOuterGeneric(func));
        intermediateType =
            (IRType*)specializeWithGeneric(*builder, intermediateType, as<IRGeneric>(outerGeneric));
    }
    else if (as<IRLookupWitnessMethod>(func))
    {
        intermediateType = nullptr;
    }
    else
    {
        intermediateType =
            builder->getBackwardDiffIntermediateContextType(maybeFindOuterGeneric(func));
    }
    return differentiateFunctionTypeImpl(builder, funcType, intermediateType);
}

IRFuncType* BackwardDiffTranscriber::differentiateFunctionType(
    IRBuilder* builder,
    IRInst* func,
    IRFuncType* funcType)
{
    SLANG_UNUSED(func);
    return differentiateFunctionTypeImpl(builder, funcType, nullptr);
}

InstPair BackwardDiffPropagateTranscriber::transcribeFunc(
    IRBuilder* builder,
    IRFunc* primalFunc,
    IRFunc* diffFunc)
{
    addTranscribedFuncDecoration(*builder, primalFunc, diffFunc);
    if (auto udf = primalFunc->findDecoration<IRUserDefinedBackwardDerivativeDecoration>())
    {
        generateTrivialDiffFuncFromUserDefinedDerivative(builder, primalFunc, diffFunc, udf);
    }
    else
    {
        transcribeFuncImpl(builder, primalFunc, diffFunc);
    }
    return InstPair(primalFunc, diffFunc);
}

InstPair BackwardDiffTranscriberBase::transcribeInstImpl(IRBuilder* builder, IRInst* origInst)
{
    switch (origInst->getOp())
    {
    case kIROp_Param:
        return transcribeParam(builder, as<IRParam>(origInst));

    case kIROp_Return:
        return transcribeReturn(builder, as<IRReturn>(origInst));

    case kIROp_LookupWitnessMethod:
        return transcribeLookupInterfaceMethod(builder, as<IRLookupWitnessMethod>(origInst));

    case kIROp_Specialize:
        return transcribeSpecialize(builder, as<IRSpecialize>(origInst));

    case kIROp_MakeTuple:
    case kIROp_FloatLit:
    case kIROp_IntLit:
    case kIROp_VoidLit:
    case kIROp_ExtractExistentialWitnessTable:
    case kIROp_ExtractExistentialType:
    case kIROp_ExtractExistentialValue:
    case kIROp_WrapExistential:
    case kIROp_MakeExistential:
    case kIROp_MakeExistentialWithRTTI:
    case kIROp_DebugInlinedAt:
    case kIROp_DebugScope:
    case kIROp_DebugNoScope:
    case kIROp_DebugInlinedVariable:
    case kIROp_DebugFunction:
        return transcribeNonDiffInst(builder, origInst);

    case kIROp_StructKey:
        return InstPair(origInst, nullptr);
    }

    return InstPair(nullptr, nullptr);
}

// Returns "dp<var-name>" to use as a name hint for parameters.
// If no primal name is available, returns a blank string.
//
String BackwardDiffTranscriberBase::makeDiffPairName(IRInst* origVar)
{
    if (auto namehintDecoration = origVar->findDecoration<IRNameHintDecoration>())
    {
        return ("dp" + String(namehintDecoration->getName()));
    }

    return String("");
}

static IRType* _getPrimalTypeFromNoDiffType(
    BackwardDiffTranscriberBase* transcriber,
    IRBuilder* builder,
    IRType* origType)
{
    IRType* valueType = origType;
    auto ptrType = as<IROutParamTypeBase>(valueType);
    if (ptrType)
        valueType = ptrType->getValueType();

    if (auto attrType = as<IRAttributedType>(valueType))
    {
        if (attrType->findAttr<IRNoDiffAttr>())
        {
            auto primalValueType =
                (IRType*)transcriber->findOrTranscribePrimalInst(builder, valueType);
            if (ptrType)
                return builder->getPtrType(ptrType->getOp(), primalValueType);
            return primalValueType;
        }
    }
    return nullptr;
}

IRType* BackwardDiffTranscriberBase::transcribeParamTypeForPrimalFunc(
    IRBuilder* builder,
    IRType* paramType)
{
    // If the param is marked as no_diff, return the primal type.
    if (auto primalNoDiffType = _getPrimalTypeFromNoDiffType(this, builder, paramType))
        return primalNoDiffType;

    auto primalType = (IRType*)findOrTranscribePrimalInst(builder, paramType);

    // Differentiable pointer types are treated as primal pairs, since they aren't involved in the
    // transposition process.
    //
    if (differentiableTypeConformanceContext.isDifferentiablePtrType(primalType))
    {
        auto diffPairType = tryGetDiffPairType(builder, primalType);
        SLANG_ASSERT(diffPairType);

        return diffPairType;
    }

    return primalType;
}

IRType* BackwardDiffTranscriberBase::transcribeParamTypeForPropagateFunc(
    IRBuilder* builder,
    IRType* paramType)
{
    if (auto outType = as<IROutParamType>(paramType))
    {
        auto valueType = outType->getValueType();
        auto diffValueType = differentiateType(builder, valueType);
        return diffValueType;
    }

    auto maybeConvertBorrowInOutParamTypeToValueType = [](IRType* type)
    {
        if (auto inoutType = as<IRBorrowInOutParamType>(type))
            return inoutType->getValueType();
        return type;
    };

    // If the param is marked as no_diff, return the primal type.
    if (auto primalNoDiffType = _getPrimalTypeFromNoDiffType(this, builder, paramType))
        return maybeConvertBorrowInOutParamTypeToValueType(primalNoDiffType);

    auto diffPairType = tryGetDiffPairType(builder, paramType);
    if (diffPairType)
    {
        if (!asRelevantPtrType(diffPairType) && !as<IRDifferentialPtrPairType>(diffPairType))
            return builder->getBorrowInOutParamType(diffPairType);
        return diffPairType;
    }
    auto primalType = (IRType*)findOrTranscribePrimalInst(builder, paramType);
    return maybeConvertBorrowInOutParamTypeToValueType(primalType);
}

// Create an empty func to represent the transcribed func of `origFunc`.
InstPair BackwardDiffTranscriberBase::transcribeFuncHeaderImpl(
    IRBuilder* inBuilder,
    IRFunc* origFunc)
{
    if (!isBackwardDifferentiableFunc(origFunc) &&
        !origFunc->findDecoration<IRTreatAsDifferentiableDecoration>())
        return InstPair(nullptr, nullptr);

    IRBuilder builder = *inBuilder;

    IRFunc* primalFunc = origFunc;

    maybeMigrateDifferentiableDictionaryFromDerivativeFunc(inBuilder, origFunc);
    differentiableTypeConformanceContext.setFunc(origFunc);

    auto diffFunc = builder.createFunc();

    SLANG_ASSERT(as<IRFuncType>(origFunc->getFullType()));
    builder.setInsertBefore(diffFunc);

    IRType* diffFuncType = this->differentiateFunctionType(
        &builder,
        origFunc,
        as<IRFuncType>(origFunc->getFullType()));
    diffFunc->setFullType(diffFuncType);

    if (origFunc->findDecoration<IRNameHintDecoration>())
    {
        auto newName = this->getTranscribedFuncName(&builder, origFunc);
        builder.addNameHintDecoration(diffFunc, newName);
    }
    addTranscribedFuncDecoration(builder, primalFunc, diffFunc);

    // Transfer checkpoint hint decorations
    copyCheckpointHints(&builder, origFunc, diffFunc);

    // Mark the generated derivative function itself as differentiable.
    builder.addBackwardDifferentiableDecoration(diffFunc);

    copyOriginalDecorations(origFunc, diffFunc);
    builder.addFloatingModeOverrideDecoration(diffFunc, FloatingPointMode::Fast);
    return InstPair(primalFunc, diffFunc);
}

void BackwardDiffTranscriberBase::addTranscribedFuncDecoration(
    IRBuilder& builder,
    IRFunc* origFunc,
    IRFunc* transcribedFunc)
{
    IRBuilder subBuilder = builder;
    if (auto outerGen = findOuterGeneric(transcribedFunc))
    {
        subBuilder.setInsertBefore(origFunc);
        auto specialized =
            specializeWithGeneric(subBuilder, outerGen, as<IRGeneric>(findOuterGeneric(origFunc)));
        addExistingDiffFuncDecor(&subBuilder, origFunc, specialized);
    }
    else
    {
        addExistingDiffFuncDecor(&subBuilder, origFunc, transcribedFunc);
    }
}

InstPair BackwardDiffTranscriberBase::transcribeFuncHeader(IRBuilder* inBuilder, IRFunc* origFunc)
{
    InstPair result;

    // If we're transcribing a function as a 'value' (i.e. maybe embedded in a generic, keep the
    // insert location unchanges). If we're transcribing it as a declaration, we should
    // insert into the module.
    //
    auto origOuterGen = as<IRGeneric>(findOuterGeneric(origFunc));
    if (!origOuterGen || !(findInnerMostGenericReturnVal(origOuterGen) == origFunc))
    {
        // Dealing with a declaration.. insert into module scope.
        IRBuilder subBuilder = *inBuilder;
        subBuilder.setInsertInto(inBuilder->getModule());
        result = transcribeFuncHeaderImpl(&subBuilder, origFunc);
    }
    else
    {
        result = transcribeFuncHeaderImpl(inBuilder, origFunc);
    }

    FuncBodyTranscriptionTask task;
    task.originalFunc = as<IRFunc>(result.primal);
    task.resultFunc = as<IRFunc>(result.differential);
    task.type = diffTaskType;
    if (task.resultFunc)
    {
        autoDiffSharedContext->followUpFunctionsToTranscribe.add(task);
    }
    return result;
}

InstPair BackwardDiffTranscriber::transcribeFuncHeader(IRBuilder* inBuilder, IRFunc* origFunc)
{
    if (auto bwdDiffFunc = findExistingDiffFunc(origFunc))
        return InstPair(origFunc, bwdDiffFunc);

    auto header = transcribeFuncHeaderImpl(inBuilder, origFunc);
    if (!header.differential)
        return header;

    IRBuilder builder = *inBuilder;

    builder.setInsertInto(header.differential);
    builder.emitBlock();
    auto origFuncType = as<IRFuncType>(origFunc->getFullType());
    List<IRInst*> primalArgs, propagateArgs;
    List<IRType*> primalTypes, propagateTypes;
    IRType* primalResultType =
        transcribeParamTypeForPrimalFunc(&builder, origFuncType->getResultType());

    IRParam* currentParam = origFunc->getFirstParam();
    for (UInt i = 0; i < origFuncType->getParamCount(); i++)
    {
        IRBuilderSourceLocRAII sourceLocationScope(&builder, currentParam->sourceLoc);

        auto primalParamType =
            transcribeParamTypeForPrimalFunc(&builder, origFuncType->getParamType(i));
        auto propagateParamType =
            transcribeParamTypeForPropagateFunc(&builder, origFuncType->getParamType(i));
        if (propagateParamType)
        {
            auto param = builder.emitParam(propagateParamType);
            propagateTypes.add(propagateParamType);
            propagateArgs.add(param);

            // Fetch primal values to use as arguments in primal func call.
            IRInst* primalArg = param;
            if (!as<IROutParamType>(primalParamType) && !as<IRBorrowInParamType>(primalParamType))
            {
                // As long as the primal parameter is not an out or constref type,
                // we need to fetch the primal value from the parameter.
                if (asRelevantPtrType(propagateParamType))
                {
                    primalArg = builder.emitLoad(param);
                }
                if (const auto diffPairType = as<IRDifferentialPairType>(primalArg->getDataType()))
                {
                    primalArg = builder.emitDifferentialPairGetPrimal(primalArg);
                }
            }
            if (auto primalParamPtrType = isMutablePointerType(primalParamType))
            {
                // If primal parameter is mutable, we need to pass in a temp var.
                auto tempVar = builder.emitVar(primalParamPtrType->getValueType());

                // If the parameter is not a pure 'out' param, we also need to setup the initial
                // value of the temp var, otherwise the temp var will be uninitialized which could
                // cause undefined behavior in the primal function.
                //
                if (!as<IROutParamType>(primalParamType))
                    builder.emitStore(tempVar, primalArg);

                primalArgs.add(tempVar);
            }
            else
            {
                primalArgs.add(primalArg);
            }
        }
        else
        {
            auto primalPtrType = asRelevantPtrType(primalParamType);
            SLANG_RELEASE_ASSERT(primalPtrType);
            auto primalValueType = primalPtrType->getValueType();
            auto var = builder.emitVar(primalValueType);
            primalArgs.add(var);
        }
        primalTypes.add(primalParamType);
        currentParam = currentParam->getNextParam();
    }

    // Add dOut argument to propagateArgs.
    auto diffResultType = differentiateType(&builder, origFunc->getResultType());
    if (diffResultType)
    {
        auto param = builder.emitParam(diffResultType);
        propagateArgs.add(param);
        propagateTypes.add(param->getFullType());
    }

    auto outerGeneric = findOuterGeneric(origFunc);
    IRType* intermediateType =
        builder.getBackwardDiffIntermediateContextType(maybeFindOuterGeneric(origFunc));
    IRInst* specializedOriginalFunc = origFunc;
    if (outerGeneric)
    {
        specializedOriginalFunc = maybeSpecializeWithGeneric(
            builder,
            outerGeneric,
            findOuterGeneric(header.differential));
        intermediateType = (IRType*)specializeWithGeneric(
            builder,
            intermediateType,
            as<IRGeneric>(findOuterGeneric(header.differential)));
    }

    auto intermediateVar = builder.emitVar(intermediateType);

    auto primalFuncType = builder.getFuncType(primalTypes, primalResultType);
    primalArgs.add(intermediateVar);
    primalTypes.add(builder.getOutParamType(intermediateType));
    auto primalFunc =
        builder.emitBackwardDifferentiatePrimalInst(primalFuncType, specializedOriginalFunc);
    builder.emitCallInst(primalResultType, primalFunc, primalArgs);

    propagateTypes.add(intermediateType);
    propagateArgs.add(builder.emitLoad(intermediateVar));
    auto propagateFuncType = builder.getFuncType(propagateTypes, builder.getVoidType());
    auto propagateFunc =
        builder.emitBackwardDifferentiatePropagateInst(propagateFuncType, specializedOriginalFunc);
    builder.emitCallInst(builder.getVoidType(), propagateFunc, propagateArgs);

    builder.emitReturn();

    addTranscribedFuncDecoration(builder, origFunc, cast<IRFunc>(header.differential));
    return header;
}

// Puts parameters into their own block.
void BackwardDiffTranscriberBase::makeParameterBlock(IRBuilder* inBuilder, IRFunc* func)
{
    IRBuilder builder = *inBuilder;

    auto firstBlock = func->getFirstBlock();
    IRParam* param = func->getFirstParam();

    builder.setInsertBefore(firstBlock);

    // Note: It looks like emitBlock() doesn't use the current
    // builder position, so we're going to manually move the new block
    // to before the existing block.
    auto paramBlock = builder.emitBlock();
    builder.markInstAsMixedDifferential(paramBlock);
    paramBlock->insertBefore(firstBlock);
    builder.setInsertInto(paramBlock);

    while (param)
    {
        IRParam* nextParam = param->getNextParam();

        // Move inst into the new parameter block.
        param->insertAtEnd(paramBlock);

        param = nextParam;
    }

    // Replace this block as the first block.
    firstBlock->replaceUsesWith(paramBlock);

    // Add terminator inst.
    builder.emitBranch(firstBlock);
}

SlangResult BackwardDiffTranscriberBase::prepareFuncForBackwardDiff(IRFunc* func)
{
    removeLinkageDecorations(func);

    performPreAutoDiffForceInlining(func);

    DifferentiableTypeConformanceContext diffTypeContext(autoDiffSharedContext);
    diffTypeContext.setFunc(func);

    auto returnCount = getReturnCount(func);
    if (returnCount > 1)
    {
        convertFuncToSingleReturnForm(func->getModule(), func);
    }
    else if (returnCount == 0)
    {
        // The function is ill-formed and never returns (such as having an infinite loop),
        // we can't possibly reverse-differentiate such functions, so we will diagnose it here.
        getSink()->diagnose(func->sourceLoc, Diagnostics::functionNeverReturnsFatal, func);
    }

    eliminateContinueBlocksInFunc(func->getModule(), func);

    eliminateMultiLevelBreakForFunc(func->getModule(), func);

    IRCFGNormalizationPass cfgPass = {this->getSink()};
    normalizeCFG(autoDiffSharedContext->moduleInst->getModule(), func, cfgPass);

    return SLANG_OK;
}

// Create a copy of originalFunc's forward derivative in the same generic context (if any) of
// `diffPropagateFunc`.
IRFunc* BackwardDiffTranscriberBase::generateNewForwardDerivativeForFunc(
    IRBuilder* builder,
    IRFunc* originalFunc,
    IRFunc* diffPropagateFunc)
{
    // auto primalOuterParent = findOuterGeneric(originalFunc);
    // if (!primalOuterParent)
    //     primalOuterParent = originalFunc;

    // Make a clone of original func so we won't modify the original.
    IRCloneEnv originalCloneEnv;
    auto clonedFunc = cloneInst(&originalCloneEnv, builder, originalFunc);
    auto primalFunc = as<IRFunc>(clonedFunc);

    // Strip any existing derivative decorations off the clone.
    stripDerivativeDecorations(primalFunc);
    eliminateDeadCode(primalFunc);

    // Perform required transformations and simplifications on the original func to make it
    // reversible.
    if (SLANG_FAILED(prepareFuncForBackwardDiff(primalFunc)))
        return diffPropagateFunc;

    // Forward transcribe the clone of the original func.
    /*ForwardDiffTranscriber& fwdTranscriber = *static_cast<ForwardDiffTranscriber*>(
        autoDiffSharedContext->transcriberSet.forwardTranscriber);*/

    ForwardDiffTranscriber fwdTranscriber(autoDiffSharedContext, sink);
    fwdTranscriber.enableReverseModeCompatibility();
    IRFunc* fwdDiffFunc = as<IRFunc>(fwdTranscriber.transcribe(builder, primalFunc));
    SLANG_ASSERT(fwdDiffFunc);

    fwdTranscriber.transcribeFunc(builder, primalFunc, fwdDiffFunc);
    fwdDiffFunc->sourceLoc = primalFunc->sourceLoc;

    // Remove the clone of original func.
    SLANG_ASSERT(primalFunc->hasUses() == false);
    primalFunc->removeAndDeallocate();

    // Remove redundant loads since they interfere with transposition logic.
    eliminateRedundantLoadStore(fwdDiffFunc);

    // Migrate the new forward derivative function into the generic parent of `diffPropagateFunc`.
    /*
    if (auto fwdParentGeneric = as<IRGeneric>(findOuterGeneric(fwdDiffFunc)))
    {
        // Clone forward derivative func from its own generic into current generic parent.
        GenericChildrenMigrationContext migrationContext;
        auto diffOuterGeneric = as<IRGeneric>(findOuterGeneric(diffPropagateFunc));
        SLANG_RELEASE_ASSERT(diffOuterGeneric);

        migrationContext.init(fwdParentGeneric, diffOuterGeneric, diffPropagateFunc);
        auto inst = fwdParentGeneric->getFirstBlock()->getFirstOrdinaryInst();
        builder->setInsertBefore(diffPropagateFunc);
        while (inst)
        {
            auto next = inst->getNextInst();
            auto cloned = migrationContext.cloneInst(builder, inst);
            if (inst == fwdDiffFunc)
            {
                fwdDiffFunc = as<IRFunc>(cloned);
                break;
            }
            inst = next;
        }
        fwdParentGeneric->removeAndDeallocate();
    }
    */

    return fwdDiffFunc;
}

IRFunc* BackwardDiffTranscriberBase::generateTrivialForwardDerivativeForFunc(
    IRBuilder* builder,
    IRFunc* originalFunc,
    IRFunc* diffPropagateFunc)
{
    IRInst* operand = originalFunc;
    // Generate a `OpTrivialForwardDifferentiate' inst and translate it.
    IRInst* trivialFwdDiffInst = builder->emitIntrinsicInst(
        diffPropagateFunc->getDataType(),
        kIROp_TrivialForwardDifferentiate,
        1,
        &operand);

    TrivialForwardDiffTranslator translator;
    return cast<IRFunc>(
        translator.processTranslationRequest(trivialFwdDiffInst, autoDiffSharedContext, sink));
}

InstPair BackwardDiffTranscriberBase::transcribeFuncParam(
    IRBuilder* builder,
    IRParam* origParam,
    IRInst* primalType)
{
    SLANG_UNUSED(primalType);

    SLANG_RELEASE_ASSERT(
        origParam->getParent() && origParam->getParent()->getParent() &&
        origParam->getParent()->getParent()->getOp() == kIROp_Generic);

    auto primalInst = maybeCloneForPrimalInst(builder, origParam);
    if (auto primalParam = as<IRParam>(primalInst))
    {
        SLANG_RELEASE_ASSERT(builder->getInsertLoc().getBlock());
        primalParam->removeFromParent();
        builder->getInsertLoc().getBlock()->addParam(primalParam);
    }
    return InstPair(primalInst, nullptr);
}

// Keep primal param replacement insts alive during DCE.
static void _lockPrimalParamReplacementInsts(
    IRBuilder* builder,
    ParameterBlockTransposeInfo& paramInfo)
{
    for (auto& kv : paramInfo.mapPrimalSpecificParamToReplacementInPropFunc)
        builder->addKeepAliveDecoration(kv.value);
}

// Remove [KeepAlive] decorations for primal param replacement insts.
static void _unlockPrimalParamReplacementInsts(ParameterBlockTransposeInfo& paramInfo)
{
    for (const auto& [_, value] : paramInfo.mapPrimalSpecificParamToReplacementInPropFunc)
        value->findDecoration<IRKeepAliveDecoration>()->removeAndDeallocate();
}

static void generateName(IRBuilder* builder, IRInst* srcInst, IRInst* dstInst, const char* prefix)
{
    if (auto nameHint = srcInst->findDecoration<IRNameHintDecoration>())
    {
        String name = nameHint->getName();
        name = prefix + name;
        builder->addNameHintDecoration(dstInst, name.getUnownedSlice());
    }
}

static IRInst* maybeHoist(IRBuilder& builder, IRInst* inst)
{
    IRInst* specializedVal = nullptr;
    auto hoistResult = hoistValueFromGeneric(builder, inst, specializedVal, true);
    return hoistResult; //(as<IRGeneric>(hoistResult)) ? getGenericReturnVal(hoistResult) :
                        // hoistResult;
}

static IRInst* maybeHoistAndSpecialize(IRBuilder& builder, IRInst* inst)
{
    IRInst* specializedVal = nullptr;
    auto hoistResult = hoistValueFromGeneric(builder, inst, specializedVal, true);
    return (specializedVal) ? specializedVal : hoistResult;
}

// Transcribe a function definition (AD 2.0)
void BackwardDiffTranscriberBase::_transcribeFuncImpl(
    IRBuilder* builder,
    IRFunc* targetFunc,
    IRInst*& applyFuncInst,
    IRInst*& propagateFuncInst,
    IRInst*& contextGetValFuncInst,
    IRInst*& contextTypeInst,
    bool isTrivial)
{
    differentiableTypeConformanceContext.setFunc(targetFunc);

    // --------------------------------------------------------------------------
    // Create IRFunc* for propagate function &
    // create the IRFuncType for it.
    //
    builder->setInsertAfter(targetFunc);
    auto propagateFunc = builder->createFunc();


    IRBuilder tempBuilder = *builder;
    tempBuilder.setInsertBefore(propagateFunc);

    auto fwdDiffFunc =
        (!isTrivial)
            ? generateNewForwardDerivativeForFunc(&tempBuilder, targetFunc, propagateFunc)
            : generateTrivialForwardDerivativeForFunc(&tempBuilder, targetFunc, propagateFunc);
    if (!fwdDiffFunc)
        return;

    // Split first block into a paramter block.
    this->makeParameterBlock(&tempBuilder, as<IRFunc>(fwdDiffFunc));

    diffUnzipPass->unzipDiffInsts(fwdDiffFunc);
    IRFunc* unzippedFwdDiffFunc = fwdDiffFunc;

    // Move blocks from `unzippedFwdDiffFunc` to the `diffPropagateFunc` shell.
    builder->setInsertInto(propagateFunc->getParent());
    {
        List<IRBlock*> workList;
        for (auto block = unzippedFwdDiffFunc->getFirstBlock(); block;
             block = block->getNextBlock())
            workList.add(block);

        for (auto block : workList)
            block->insertAtEnd(propagateFunc);
    }

    builder->setInsertInto(propagateFunc);

    // Transpose differential blocks from unzippedFwdDiffFunc into diffFunc (with dOutParameter)
    // representing the derivative of the return value.
    diffTransposePass->transposeDiffBlocksInFunc(propagateFunc, {});

    // Apply checkpointing policy to legalize cross-scope uses of primal values
    // using either recompute or store strategies.
    auto primalsInfo = applyCheckpointPolicy(propagateFunc);

    // Extracts the primal computations into its own func, turn all accesses to stored primal insts
    // into explicit intermediate data structure reads and writes.
    IRInst* intermediateType = nullptr;
    IRFunc* getValFunc = nullptr;
    auto applyFunc = diffUnzipPass->extractPrimalFunc(
        propagateFunc,
        targetFunc,
        primalsInfo,
        intermediateType,
        getValFunc);

    // At this point the unzipped func is just an empty shell
    // and we can simply remove it.
    unzippedFwdDiffFunc->removeAndDeallocate();

    // Copy over checkpoint preference hints.
    {
        auto diffPrimalFunc = getResolvedInstForDecorations(applyFunc, true);
        auto checkpointHint = targetFunc->findDecoration<IRCheckpointHintDecoration>();
        if (checkpointHint)
            builder->addDecoration(diffPrimalFunc, checkpointHint->getOp());
    }

    // ------------------------------------------------------------
    // Fill in the propagate function's type.
    List<IRType*> propagateParamTypes;
    IRType* propagateResultType;

    propagateParamTypes.add((IRType*)intermediateType);

    for (UInt i = 0; i < targetFunc->getParamCount(); i++)
    {
        const auto& [direction, paramType] =
            splitParameterDirectionAndType(targetFunc->getParamType(i));
        auto diffParamType = (IRType*)differentiableTypeConformanceContext.getDifferentialForType(
            builder,
            paramType);

        if (diffParamType)
            propagateParamTypes.add(
                fromDirectionAndType(builder, transposeDirection(direction), diffParamType));
        else
            propagateParamTypes.add(builder->getVoidType());
    }

    auto resultType = targetFunc->getResultType();
    auto diffResultType =
        (IRType*)differentiableTypeConformanceContext.getDifferentialForType(builder, resultType);
    if (diffResultType)
    {
        propagateResultType =
            fromDirectionAndType(builder, ParameterDirectionInfo::Kind::In, diffResultType);
    }
    else
    {
        propagateResultType = builder->getVoidType();
    }

    if (propagateResultType->getOp() != kIROp_VoidType)
    {
        // If the result type is not void, we need to add it as the last parameter.
        propagateParamTypes.add(propagateResultType);
    }

    auto propagateFuncType = builder->getFuncType(propagateParamTypes, builder->getVoidType());
    propagateFunc->setFullType(propagateFuncType);

    // --------------------------------------------------------------------------

    initializeLocalVariables(builder->getModule(), applyFunc);
    initializeLocalVariables(builder->getModule(), propagateFunc);

    // Clean up block labels & other temp decorations.
    stripTempDecorations(propagateFunc);
    stripTempDecorations(applyFunc);
    stripTempDecorations(getValFunc);

    // Make sure blocks are in control-flow order.
    sortBlocksInFunc(propagateFunc);
    sortBlocksInFunc(targetFunc);

    generateName(builder, targetFunc, applyFunc, "s_apply_");
    generateName(builder, targetFunc, propagateFunc, "s_bwdProp_");
    generateName(builder, targetFunc, getValFunc, "s_getVal_");
    generateName(builder, targetFunc, intermediateType, "s_bwdCallableCtx_");

    copyDebugInfo(targetFunc, applyFunc);
    copyDebugInfo(targetFunc, propagateFunc);
    copyDebugInfo(targetFunc, getValFunc);

    IRBuilder subBuilder = *builder;

    //
    // Output the 4-tuple result of the translation (and hoist values out of any generic contexts).
    //

    // It's important to hoist the context type out *first* because the other funcs may depend on
    // it.
    //
    contextTypeInst = maybeHoist(subBuilder, intermediateType);

    propagateFuncInst = maybeHoist(subBuilder, propagateFunc);
    applyFuncInst = maybeHoist(subBuilder, applyFunc);
    contextGetValFuncInst = maybeHoist(subBuilder, getValFunc);
}

// Transcribe a function definition. (Old code)
void BackwardDiffTranscriberBase::transcribeFuncImpl(
    IRBuilder* builder,
    IRFunc* primalFunc,
    IRFunc* diffPropagateFunc)
{
    SLANG_ASSERT(primalFunc);
    SLANG_ASSERT(diffPropagateFunc);
    // Reverse-mode transcription uses 4 separate steps:
    // TODO(sai): Fill in documentation.

    // Generate a temporary forward derivative function as an intermediate step.
    IRBuilder tempBuilder = *builder;
    if (auto outerGeneric = findOuterGeneric(diffPropagateFunc))
    {
        tempBuilder.setInsertBefore(outerGeneric);
    }
    else
    {
        tempBuilder.setInsertBefore(diffPropagateFunc);
    }

    auto fwdDiffFunc =
        generateNewForwardDerivativeForFunc(&tempBuilder, primalFunc, diffPropagateFunc);
    if (!fwdDiffFunc)
        return;

    bool isResultDifferentiable = as<IRDifferentialPairType>(fwdDiffFunc->getResultType());

    // Split first block into a paramter block.
    this->makeParameterBlock(&tempBuilder, as<IRFunc>(fwdDiffFunc));

    // This steps adds a decoration to instructions that are computing the differential.
    // TODO: This is disabled for now because fwd-mode already adds differential decorations
    // wherever need. We need to run this pass only for user-writted forward derivativecode.
    //
    // diffPropagationPass->propagateDiffInstDecoration(builder, fwdDiffFunc);

    diffUnzipPass->unzipDiffInsts(fwdDiffFunc);
    IRFunc* unzippedFwdDiffFunc = fwdDiffFunc;

    // Move blocks from `unzippedFwdDiffFunc` to the `diffPropagateFunc` shell.
    builder->setInsertInto(diffPropagateFunc->getParent());
    {
        List<IRBlock*> workList;
        for (auto block = unzippedFwdDiffFunc->getFirstBlock(); block;
             block = block->getNextBlock())
            workList.add(block);

        for (auto block : workList)
            block->insertAtEnd(diffPropagateFunc);
    }

    // Transpose the first block (parameter block)
    auto paramTransposeInfo = splitAndTransposeParameterBlock(
        builder,
        diffPropagateFunc,
        primalFunc->sourceLoc,
        isResultDifferentiable);

    // The insts we inserted in paramTransposeInfo.mapPrimalSpecificParamToReplacementInPropFunc
    // may be used by write back logic that we are going to insert later.
    // Before then we want to keep them alive.
    _lockPrimalParamReplacementInsts(builder, paramTransposeInfo);

    builder->setInsertInto(diffPropagateFunc);

    // Transpose differential blocks from unzippedFwdDiffFunc into diffFunc (with dOutParameter)
    // representing the derivative of the return value.
    DiffTransposePass::FuncTranspositionInfo transposeInfo = {};
    diffTransposePass->transposeDiffBlocksInFunc(diffPropagateFunc, {});

    // Apply checkpointing policy to legalize cross-scope uses of primal values
    // using either recompute or store strategies.
    auto primalsInfo = applyCheckpointPolicy(diffPropagateFunc);

    eliminateDeadCode(diffPropagateFunc);

    // Extracts the primal computations into its own func, turn all accesses to stored primal insts
    // into explicit intermediate data structure reads and writes.
    IRInst* intermediateType = nullptr;
    IRFunc* getValFunc = nullptr;
    auto extractedPrimalFunc = diffUnzipPass->extractPrimalFunc(
        diffPropagateFunc,
        primalFunc,
        primalsInfo,
        intermediateType,
        getValFunc);

    // At this point the unzipped func is just an empty shell
    // and we can simply remove it.
    unzippedFwdDiffFunc->removeAndDeallocate();

    // Write back derivatives to inout parameters.
    writeBackDerivativeToInOutParams(paramTransposeInfo, diffPropagateFunc);

    // Remove primalFunc specific params.
    List<IRInst*> paramsToRemove;
    for (auto param : diffPropagateFunc->getParams())
    {
        if (!paramTransposeInfo.propagateFuncParams.contains(param))
            paramsToRemove.add(param);
    }
    for (auto param : paramsToRemove)
    {
        if (param->hasUses())
        {
            IRInst* replacement = nullptr;
            paramTransposeInfo.mapPrimalSpecificParamToReplacementInPropFunc.tryGetValue(
                param,
                replacement);
            SLANG_RELEASE_ASSERT(replacement);
            param->replaceUsesWith(replacement);
        }
        param->removeAndDeallocate();
    }

    _unlockPrimalParamReplacementInsts(paramTransposeInfo);

    // If primal function is nested in a generic, we want to create separate generics for all the
    // associated things we have just created.
    auto primalOuterGeneric = findOuterGeneric(primalFunc);
    IRInst* specializedFunc = nullptr;
    auto intermediateTypeGeneric =
        hoistValueFromGeneric(*builder, intermediateType, specializedFunc, true);
    builder->setInsertBefore(primalFunc);
    builder->addBackwardDerivativeIntermediateTypeDecoration(primalFunc, intermediateTypeGeneric);

    auto primalFuncGeneric =
        hoistValueFromGeneric(*builder, extractedPrimalFunc, specializedFunc, true);
    builder->setInsertBefore(primalFunc);

    // Copy over checkpoint preference hints.
    {
        auto diffPrimalFunc = getResolvedInstForDecorations(primalFuncGeneric, true);
        auto checkpointHint = primalFunc->findDecoration<IRCheckpointHintDecoration>();
        if (checkpointHint)
            builder->addDecoration(diffPrimalFunc, checkpointHint->getOp());
    }

    if (auto existingDecor = primalFunc->findDecoration<IRBackwardDerivativePrimalDecoration>())
    {
        // If we already created a header for primal func, move the body into the existing primal
        // func header.
        auto existingPrimalHeader = existingDecor->getBackwardDerivativePrimalFunc();
        if (auto spec = as<IRSpecialize>(existingPrimalHeader))
            existingPrimalHeader = spec->getBase();
        moveInstChildren(existingPrimalHeader, primalFuncGeneric);
        primalFuncGeneric->replaceUsesWith(existingPrimalHeader);
        primalFuncGeneric->removeAndDeallocate();
        primalFuncGeneric = existingPrimalHeader;
    }
    else
    {
        auto specializedBackwardPrimalFunc =
            maybeSpecializeWithGeneric(*builder, primalFuncGeneric, primalOuterGeneric);
        builder->addBackwardDerivativePrimalDecoration(primalFunc, specializedBackwardPrimalFunc);
    }

    initializeLocalVariables(
        builder->getModule(),
        as<IRGlobalValueWithCode>(getGenericReturnVal(primalFuncGeneric)));
    initializeLocalVariables(builder->getModule(), diffPropagateFunc);

    stripTempDecorations(diffPropagateFunc);

    sortBlocksInFunc(diffPropagateFunc);
    sortBlocksInFunc(primalFunc);
}

ParameterBlockTransposeInfo BackwardDiffTranscriberBase::splitAndTransposeParameterBlock(
    IRBuilder* builder,
    IRFunc* diffFunc,
    SourceLoc primalLoc,
    bool isResultDifferentiable)
{
    differentiableTypeConformanceContext.setFunc(diffFunc);
    // This method splits transposes the all the parameters for both the primal and propagate
    // computation. At the end of this method, the parameter block will contain a combination of
    // parameters for both the to-be-primal function and to-be-propagate function. We use
    // ParameterBlockTransposeInfo::primalFuncParams and
    // ParameterBlockTransposeInfo::propagateFuncParams to track which parameters are dedicated to
    // the future primal or propagate func. A later step will then split the parameters out to each
    // new function.

    ParameterBlockTransposeInfo result;

    // First, we initialize the IR builders and locate the import code insertion points that will
    // be used for the rest of this method.

    IRBlock* fwdDiffParameterBlock = diffFunc->getFirstBlock();

    // Find the 'next' block using the terminator inst of the parameter block.
    auto fwdParamBlockBranch = as<IRUnconditionalBranch>(fwdDiffParameterBlock->getTerminator());
    // We create a new block after parameter block to hold insts that translates from transposed
    // parameters into something that the rest of the function can use.
    IRBuilder::insertBlockAlongEdge(diffFunc->getModule(), IREdge(&fwdParamBlockBranch->block));
    auto paramPreludeBlock = fwdParamBlockBranch->getTargetBlock();

    auto nextBlockBuilder = *builder;
    nextBlockBuilder.setInsertBefore(paramPreludeBlock->getFirstOrdinaryInst());

    SourceLoc returnLoc;
    IRBlock* firstDiffBlock = nullptr;
    for (auto block : diffFunc->getBlocks())
    {
        if (isDifferentialInst(block))
        {
            firstDiffBlock = block;
            break;
        }

        auto terminator = block->getTerminator();
        if (as<IRReturn>(terminator))
        {
            returnLoc = terminator->sourceLoc;
            break;
        }
    }

    SLANG_RELEASE_ASSERT(firstDiffBlock);

    auto diffBuilder = *builder;
    diffBuilder.setInsertBefore(firstDiffBlock->getFirstOrdinaryInst());

    builder->setInsertBefore(fwdParamBlockBranch);

    // Collect all the original parameters.
    List<IRParam*> fwdParams;
    for (auto param : diffFunc->getParams())
        fwdParams.add(param);

    // Maintain a set for insts pending removal.
    OrderedHashSet<IRInst*> instsToRemove;

    // Now we begin the actual processing.
    // The first step is to transcribe all the existing parameters from the original function.
    // There are many cases to handle, including different combinations of parameter directions and
    // whether or not the parameter is differentiable.
    // To normalize the process for all these cases, we determine the following actions for each
    // parameter:
    // 1. Should this original parameter be translated to a parameter in the primal func and the
    // propagate func?
    //    if so, we emit a param inst representing the final parameter for that func. If the
    //    parameter should be mapped to both the primal func and the propagate func, we will emit
    //    two separate params with their final type.
    // 2. If this parameter has a corresponding primal func parameter, we replace all uses of the
    // original
    //    parameter in the primal computation code to the new primal parameter. If any
    //    initialization logic is needed to convert the type of the new primal parameter to what the
    //    code was expecting, we insert that code in the first block.
    // 3. If this parameter has a correponding propagate func parameter, we replace all uses of the
    // original parameter
    //    in the diff computation code to the new propagate parameter. We insert necessary
    //    initialization diff block or the first block depending on whether we want that logic go
    //    through the transposition pass. We may need to replace the uses to different
    //    values/variables depending on whether that use is a read or write.
    // 4. If the parameter has both corresponding primal and propagate parameters, we also need to
    // consider
    //    how the future propagate function access the primal parameter. We will insert necessary
    //    preparation code that constructs temp vars or values to replace the primal parameter after
    //    we remove it from the propagate func.
    // Base on above discussion, we need to compute the following values for each parameter:
    // - diffRefReplacement. What should all read(load) references to this parameter from
    // differential code be replaced to.
    // - diffRefWriteReplacement. What should all write references to this parameter from
    // differential code be replaced to.
    // - primalRefReplacement. What should all references to this parameter from primal code be
    // replaced to.
    // - mapPrimalSpecificParamToReplacementInPropFunc[param]. What should all references to this
    // parameter
    //      from the primal compuation logic in the future propagate function be replaced to.

    auto ctxParam = builder->emitParam(as<IRFuncType>(diffFunc->getDataType())->getParamType(0));
    builder->addNameHintDecoration(ctxParam, UnownedStringSlice("_s_diff_ctx"));
    builder->addDecoration(ctxParam, kIROp_PrimalContextDecoration);
    result.propagateFuncParams.add(ctxParam);

    diffFunc->sourceLoc = primalLoc;
    ctxParam->sourceLoc = primalLoc;

    for (auto fwdParam : fwdParams)
    {
        IRBuilderSourceLocRAII sourceLocationScope(builder, fwdParam->sourceLoc);

        // Define the replacement insts that we are going to fill in for each case.
        IRInst* diffRefReplacement = nullptr;
        IRInst* primalRefReplacement = nullptr;
        IRInst* diffWriteRefReplacement = nullptr;

        // Common logic that computes all the important types we care about.
        IRDifferentialPairType* diffPairType = as<IRDifferentialPairType>(fwdParam->getDataType());
        auto inoutType = as<IRBorrowInOutParamType>(fwdParam->getDataType());
        auto outType = as<IROutParamType>(fwdParam->getDataType());
        if (inoutType)
            diffPairType = as<IRDifferentialPairType>(inoutType->getValueType());
        else if (outType)
            diffPairType = as<IRDifferentialPairType>(outType->getValueType());
        IRType* primalType = nullptr;
        IRType* diffType = nullptr;
        if (diffPairType)
        {
            primalType = diffPairType->getValueType();
            diffType = (IRType*)differentiableTypeConformanceContext.getDiffTypeFromPairType(
                builder,
                diffPairType);
        }
        else
        {
            primalType = fwdParam->getDataType();

            if (auto outType = as<IROutParamType>(primalType))
                primalType = outType->getValueType();
            else if (auto inoutType = as<IRBorrowInOutParamType>(primalType))
                primalType = inoutType->getValueType();
        }

        // AD 2.0 logic (significantly simplified)
        // If the parameter is a relevant differential pair, we
        // put the primal component in the primal function and the diff component
        // in the propagate function.
        // If it's not relevant, then we replace it with a none-type parameter.
        //
        switch (fwdParam->getDataType()->getOp())
        {
        case kIROp_OutParamType:
            // Out.
            if (diffType)
            {
                diffWriteRefReplacement = builder->emitParam(diffType); // In diff.
                markDiffTypeInst(builder, diffWriteRefReplacement, primalType);

                result.propagateFuncParams.add(diffWriteRefReplacement);
                copyNameHintAndDebugDecorations(diffWriteRefReplacement, fwdParam);
                diffRefReplacement = nullptr;
            }
            else
            {
                // NoneType parameter.
                result.propagateFuncParams.add(builder->emitParam(builder->getVoidType()));
            }

            primalRefReplacement = builder->emitParam( // Out primal.
                builder->getOutParamType(primalType));
            result.primalFuncParams.add(primalRefReplacement);
            copyNameHintAndDebugDecorations(primalRefReplacement, fwdParam);

            break;

        case kIROp_BorrowInOutParamType:
            // In Out.
            if (diffType)
            {
                auto diffParam =
                    builder->emitParam(builder->getBorrowInOutParamType(diffType)); // InOut diff.
                markDiffTypeInst(builder, diffParam, primalType);

                result.propagateFuncParams.add(diffParam);
                copyNameHintAndDebugDecorations(diffParam, fwdParam);

                diffRefReplacement = diffParam;
                diffWriteRefReplacement = diffParam;
            }
            else
            {
                // NoneType parameter.
                result.propagateFuncParams.add(builder->emitParam(builder->getVoidType()));
            }

            primalRefReplacement =
                builder->emitParam(builder->getBorrowInOutParamType(primalType)); // InOut primal.
            result.primalFuncParams.add(primalRefReplacement);
            break;

        case kIROp_RefParamType:
        case kIROp_BorrowInParamType:
            SLANG_UNEXPECTED("Unexpected ref/constref type in backward diff transcriber");
            break;

        default:
            // In.
            if (diffPairType)
            {
                auto diffParam =
                    builder->emitParam(builder->getOutParamType(diffType)); // Out diff.
                markDiffTypeInst(builder, diffParam, primalType);

                result.propagateFuncParams.add(diffParam);

                diffWriteRefReplacement = nullptr;
                diffRefReplacement = diffParam;
            }
            else
            {
                // NoneType parameter.
                result.propagateFuncParams.add(builder->emitParam(builder->getVoidType()));
            }

            primalRefReplacement = builder->emitParam(primalType); // Out primal.
            result.primalFuncParams.add(primalRefReplacement);
            break;
        }

        // Now we handle each combination of parameter direction x differentiability.
        // TODO: Temporarily disabled.
        // Remove after AD 2.0 (above) is working
        if (false)
        {
            if (outType)
            {
                // Case 1: out parameters.
                // Out parameters need to be handled differently whether or not it is
                // differentiable, since the propagate function will not have a corresponding
                // output.
                if (diffPairType)
                {
                    // Create dOut param.
                    auto diffParam = builder->emitParam(diffType);
                    copyNameHintAndDebugDecorations(diffParam, fwdParam);
                    result.propagateFuncParams.add(diffParam);
                    primalRefReplacement = builder->emitParam(builder->getOutParamType(primalType));
                    copyNameHintAndDebugDecorations(primalRefReplacement, fwdParam);

                    // Create a local var for read access in pre-transpose code.
                    // This will the var from which we will fetch the final resulting derivative
                    // after transposition.
                    auto tempVar = nextBlockBuilder.emitVar(diffType);
                    copyNameHintAndDebugDecorations(tempVar, fwdParam);
                    result.propagateFuncSpecificPrimalInsts.add(tempVar);

                    // Initialize the var with input diff param at start.
                    // Note that we insert the store in the primal block so it won't get transposed.
                    auto storeInst = nextBlockBuilder.emitStore(tempVar, diffParam);
                    nextBlockBuilder.markInstAsDifferential(storeInst, primalType);
                    // Since this store inst is specific to propagate function, we track it in a
                    // set so we can remove it when we generate the primal func.
                    result.propagateFuncSpecificPrimalInsts.add(storeInst);

                    diffWriteRefReplacement = tempVar;
                    diffRefReplacement = tempVar;
                }
                else
                {
                    primalRefReplacement = builder->emitParam(outType);
                    copyNameHintAndDebugDecorations(primalRefReplacement, fwdParam);
                }
                result.primalFuncParams.add(primalRefReplacement);

                // Create a local var for the out param for the primal part of the prop func.
                auto tempPrimalVar = nextBlockBuilder.emitVar(outType->getValueType());
                copyNameHintAndDebugDecorations(tempPrimalVar, fwdParam);
                result.mapPrimalSpecificParamToReplacementInPropFunc[primalRefReplacement] =
                    tempPrimalVar;

                instsToRemove.add(fwdParam);
            }
            else if (!isRelevantDifferentialPair(fwdParam->getDataType()))
            {
                if (inoutType)
                {
                    // Case 2: non differentiable inout parameter.
                    // They should become an inout parameter in primal func, but an in parameter in
                    // bwd func.
                    fwdParam->removeFromParent();
                    fwdDiffParameterBlock->addParam(fwdParam);
                    result.primalFuncParams.add(fwdParam);

                    primalRefReplacement = fwdParam;

                    // Create an in param for the prop func.
                    auto propParam = builder->emitParam(inoutType->getValueType());
                    copyNameHintAndDebugDecorations(propParam, fwdParam);
                    result.propagateFuncParams.add(propParam);

                    // Create a local var for the out param for the primal part of the prop func.
                    auto tempPrimalVar = nextBlockBuilder.emitVar(inoutType->getValueType());
                    copyNameHintAndDebugDecorations(tempPrimalVar, fwdParam);

                    result.propagateFuncSpecificPrimalInsts.add(tempPrimalVar);
                    auto storeInst = nextBlockBuilder.emitStore(tempPrimalVar, propParam);
                    result.propagateFuncSpecificPrimalInsts.add(storeInst);
                    result.mapPrimalSpecificParamToReplacementInPropFunc[primalRefReplacement] =
                        tempPrimalVar;
                }
                else
                {
                    // Case 3: non differentiable, non output parameters.
                    // If parameter is not an out param and has nothing to do with differentiation,
                    // simply move the parameter to the end.
                    //
                    fwdParam->removeFromParent();
                    fwdDiffParameterBlock->addParam(fwdParam);
                    result.primalFuncParams.add(fwdParam);
                    result.propagateFuncParams.add(fwdParam);
                    continue;
                }
            }
            else if (!inoutType)
            {
                // Case 4: `in` differentiable parameters.

                SLANG_RELEASE_ASSERT(diffPairType);

                // Create inout version.
                auto inoutDiffPairType = builder->getBorrowInOutParamType(diffPairType);
                primalRefReplacement = builder->emitParam(primalType);
                copyNameHintAndDebugDecorations(primalRefReplacement, fwdParam);

                result.primalFuncParams.add(primalRefReplacement);
                auto propParam = builder->emitParam(inoutDiffPairType);
                copyNameHintAndDebugDecorations(propParam, fwdParam);
                result.propagateFuncParams.add(propParam);

                // A reference to this parameter from the diff blocks should be replaced with a load
                // of the differential component of the pair.
                auto newParamLoad = diffBuilder.emitLoad(propParam);
                diffBuilder.markInstAsDifferential(newParamLoad, primalType);
                result.propagateFuncSpecificPrimalInsts.add(newParamLoad);

                diffRefReplacement =
                    diffBuilder.emitDifferentialPairGetDifferential(diffType, newParamLoad);
                diffBuilder.markInstAsDifferential(diffRefReplacement, primalType);
                result.propagateFuncSpecificPrimalInsts.add(diffRefReplacement);

                // Load the primal component from the prop param and use it as replacement for the
                // primal param in the primal part of the prop func.
                // Since these are logic specific to propagate function, we will add them to the
                // `propagateFuncSpecificPrimalInsts` set so we can remove them when we generate the
                // primal func.
                auto primalReplacementLoad = nextBlockBuilder.emitLoad(propParam);
                result.propagateFuncSpecificPrimalInsts.add(primalReplacementLoad);
                auto primalVal =
                    nextBlockBuilder.emitDifferentialPairGetPrimal(primalReplacementLoad);
                result.propagateFuncSpecificPrimalInsts.add(primalVal);
                result.mapPrimalSpecificParamToReplacementInPropFunc[primalRefReplacement] =
                    primalVal;

                instsToRemove.add(fwdParam);
            }
            else
            {
                // Case 5: `inout` differentiable parameters.
                SLANG_ASSERT(inoutType && diffPairType);

                // Process differentiable inout parameters.
                auto primalParam = builder->emitParam(builder->getBorrowInOutParamType(primalType));
                copyNameHintAndDebugDecorations(primalParam, fwdParam);
                result.primalFuncParams.add(primalParam);

                auto diffParam = builder->emitParam(inoutType);
                copyNameHintAndDebugDecorations(diffParam, fwdParam);
                result.propagateFuncParams.add(diffParam);

                // Primal references to this param is the new primal param.
                primalRefReplacement = primalParam;

                // Diff references to this param should be replaced with one local temp var
                // for read and one separate temp var for write.

                // Load the inital diff value.
                auto loadedParam = nextBlockBuilder.emitLoad(diffParam);
                result.propagateFuncSpecificPrimalInsts.add(loadedParam);

                auto initDiff =
                    nextBlockBuilder.emitDifferentialPairGetDifferential(diffType, loadedParam);
                result.propagateFuncSpecificPrimalInsts.add(initDiff);

                // Create a local var for diff read access.
                auto diffVar = nextBlockBuilder.emitVar(diffType);
                copyNameHintAndDebugDecorations(diffVar, fwdParam);
                result.propagateFuncSpecificPrimalInsts.add(diffVar);
                diffRefReplacement = diffVar;

                // Clear the diff read var to zero at start of the function.
                auto dzero = getDifferentialZeroOfType(&nextBlockBuilder, primalType);
                result.propagateFuncSpecificPrimalInsts.add(dzero);
                auto initDiffStore = nextBlockBuilder.emitStore(diffVar, dzero);
                result.propagateFuncSpecificPrimalInsts.add(initDiffStore);

                // Create a local var for diff write access.
                auto diffWriteVar = nextBlockBuilder.emitVar(diffType);
                result.propagateFuncSpecificPrimalInsts.add(diffWriteVar);
                copyNameHintAndDebugDecorations(diffWriteVar, fwdParam);

                // Initialize write var to 0.
                auto writeStore = nextBlockBuilder.emitStore(diffWriteVar, initDiff);
                result.propagateFuncSpecificPrimalInsts.add(writeStore);

                diffWriteRefReplacement = diffWriteVar;

                // Create a local var for the primal logic in the propagate func.
                auto primalVar = nextBlockBuilder.emitVar(primalType);
                copyNameHintAndDebugDecorations(primalVar, fwdParam);

                result.propagateFuncSpecificPrimalInsts.add(primalVar);
                auto initPrimalVal = nextBlockBuilder.emitDifferentialPairGetPrimal(loadedParam);
                result.propagateFuncSpecificPrimalInsts.add(initPrimalVal);
                auto storeInst = nextBlockBuilder.emitStore(primalVar, initPrimalVal);
                result.propagateFuncSpecificPrimalInsts.add(storeInst);
                result.mapPrimalSpecificParamToReplacementInPropFunc[primalParam] = primalVar;
                result.outDiffWritebacks[diffParam] = InstPair(initPrimalVal, diffVar);

                instsToRemove.add(fwdParam);
            }
        }

        // We have emitted all the new parameters and computed the replacements for the original
        // parameter. Now we perform that replacement.
        List<IRUse*> uses;
        for (auto use = fwdParam->firstUse; use; use = use->nextUse)
            uses.add(use);

        for (auto use : uses)
        {
            if (auto primalRef = as<IRPrimalParamRef>(use->getUser()))
            {
                SLANG_RELEASE_ASSERT(primalRefReplacement);
                primalRef->replaceUsesWith(primalRefReplacement);
                instsToRemove.add(primalRef);
            }
            else if (auto getPrimal = as<IRDifferentialPairGetPrimal>(use->getUser()))
            {
                SLANG_RELEASE_ASSERT(primalRefReplacement);
                getPrimal->replaceUsesWith(primalRefReplacement);
                instsToRemove.add(getPrimal);
            }
            else if (auto propagateRef = as<IRDiffParamRef>(use->getUser()))
            {
                /*
                // old code...
                auto refUse = propagateRef->firstUse;
                while (refUse)
                {
                    auto nextUse = refUse->nextUse;
                    // Is this use the dest operand of a store inst?
                    // If so, replace it with writeRefReplacement, otherwise, refReplacement.
                    if (refUse->getUser()->getOp() == kIROp_Store &&
                        refUse == refUse->getUser()->getOperands())
                    {
                        SLANG_RELEASE_ASSERT(diffWriteRefReplacement);
                        refUse->set(diffWriteRefReplacement);
                    }
                    else
                    {
                        SLANG_RELEASE_ASSERT(diffRefReplacement);
                        refUse->set(diffRefReplacement);
                    }
                    refUse = nextUse;
                }
                instsToRemove.add(propagateRef);
                */
                result.transposedInstMap[propagateRef] = diffRefReplacement;
            }
            else if (auto getDiff = as<IRDifferentialPairGetDifferential>(use->getUser()))
            {
                SLANG_RELEASE_ASSERT(diffRefReplacement);
                // getDiff->replaceUsesWith(diffRefReplacement);
                // instsToRemove.add(getDiff);

                result.transposedInstMap[getDiff] = diffRefReplacement;
            }
            else
            {
                // If the user is something else, it'd better be a non relevant parameter.
                if (diffRefReplacement || diffWriteRefReplacement)
                    SLANG_UNEXPECTED("unknown use of parameter.");
                use->set(primalRefReplacement);
            }
        }
    }

    // Actually remove all the insts that we decided to remove in the process.
    for (auto inst : instsToRemove)
    {
        inst->removeAndDeallocate();
    }


    // The next step is to insert new parameters that is not related to any existing parameters.
    //
    // If the return type of the original function is differentiable,
    // add a parameter for 'derivative of the output' (d_out).
    // The type is the second last parameter type of the function.
    //
    auto paramCount = as<IRFuncType>(diffFunc->getDataType())->getParamCount();
    IRParam* dOutParam = nullptr;
    if (isResultDifferentiable)
    {
        auto dOutParamType = as<IRFuncType>(diffFunc->getDataType())->getParamType(paramCount - 1);

        SLANG_ASSERT(dOutParamType);

        dOutParam = builder->emitParam(dOutParamType);
        dOutParam->sourceLoc = returnLoc;
        builder->addNameHintDecoration(dOutParam, UnownedStringSlice("_s_dOut"));
        result.propagateFuncParams.add(dOutParam);
    }

    result.dOutParam = dOutParam;

    // Add a parameter for intermediate val.
    /*
    auto ctxParam =
        builder->emitParam(as<IRFuncType>(diffFunc->getDataType())->getParamType(paramCount - 1));
    */

    return result;
}

void BackwardDiffTranscriberBase::writeBackDerivativeToInOutParams(
    ParameterBlockTransposeInfo& info,
    IRFunc* diffFunc)
{
    IRInst* returnInst = nullptr;
    for (auto block : diffFunc->getBlocks())
    {
        for (auto inst : block->getChildren())
        {
            if (inst->getOp() == kIROp_Return)
            {
                returnInst = inst;
                break;
            }
        }
    }
    SLANG_RELEASE_ASSERT(returnInst);

    IRBuilder builder(autoDiffSharedContext->moduleInst);
    builder.setInsertBefore(returnInst);
    for (auto& wb : info.outDiffWritebacks)
    {
        auto dest = wb.key;
        auto srcPrimalVal = wb.value.primal;
        auto srcDiffAddr = wb.value.differential;
        auto srcDiffVal = builder.emitLoad(srcDiffAddr);
        auto destVal = builder.emitMakeDifferentialPair(
            as<IRPtrTypeBase>(dest->getFullType())->getValueType(),
            srcPrimalVal,
            srcDiffVal);
        builder.emitStore(dest, destVal);
    }
}

InstPair BackwardDiffTranscriberBase::transcribeSpecialize(
    IRBuilder* builder,
    IRSpecialize* origSpecialize)
{
    auto primalBase = findOrTranscribePrimalInst(builder, origSpecialize->getBase());
    List<IRInst*> primalArgs;
    for (UInt i = 0; i < origSpecialize->getArgCount(); i++)
    {
        primalArgs.add(findOrTranscribePrimalInst(builder, origSpecialize->getArg(i)));
    }
    auto primalType = findOrTranscribePrimalInst(builder, origSpecialize->getFullType());
    auto primalSpecialize = (IRSpecialize*)builder->emitSpecializeInst(
        (IRType*)primalType,
        primalBase,
        primalArgs.getCount(),
        primalArgs.getBuffer());

    if (auto diffBase = instMapD.tryGetValue(origSpecialize->getBase()))
    {
        List<IRInst*> args;
        for (UInt i = 0; i < primalSpecialize->getArgCount(); i++)
        {
            args.add(primalSpecialize->getArg(i));
        }

        IRType* typeForSpecialization = nullptr;
        switch ((*diffBase)->getDataType()->getOp())
        {
        case kIROp_TypeKind:
        case kIROp_GenericKind:
            typeForSpecialization = (*diffBase)->getDataType();
            break;
        case kIROp_Generic:
            typeForSpecialization = (IRType*)builder->emitSpecializeInst(
                builder->getTypeKind(),
                (*diffBase)->getDataType(),
                args.getCount(),
                args.getBuffer());
            break;
        default:
            typeForSpecialization = builder->getTypeKind();
            break;
        }

        auto diffSpecialize = builder->emitSpecializeInst(
            typeForSpecialization,
            *diffBase,
            args.getCount(),
            args.getBuffer());
        return InstPair(primalSpecialize, diffSpecialize);
    }

    auto genericInnerVal = findInnerMostGenericReturnVal(as<IRGeneric>(origSpecialize->getBase()));
    // Look for an IRBackwardDerivativeDecoration on the specialize inst.
    // (Normally, this would be on the inner IRFunc, but in this case only the JVP func
    // can be specialized, so we put a decoration on the IRSpecialize)
    //
    if (auto derivativeFunc = findExistingDiffFunc(origSpecialize))
    {
        // Make sure this isn't itself a specialize .
        SLANG_RELEASE_ASSERT(!as<IRSpecialize>(derivativeFunc));

        return InstPair(primalSpecialize, derivativeFunc);
    }
    else if (auto diffBase = findExistingDiffFunc(genericInnerVal))
    {
        List<IRInst*> args;
        for (UInt i = 0; i < primalSpecialize->getArgCount(); i++)
        {
            args.add(primalSpecialize->getArg(i));
        }

        // A `BackwardDerivative` decoration on an inner func of a generic should always be a
        // `specialize`.
        auto diffBaseSpecialize = as<IRSpecialize>(diffBase);
        SLANG_RELEASE_ASSERT(diffBaseSpecialize);

        // Note: this assumes that the generic arguments to specialize the derivative is the same as
        // the generic args to specialize the primal function. This is true for all of our core
        // module functions, but we may need to rely on more general substitution logic here.
        auto diffSpecialize = builder->emitSpecializeInst(
            (IRType*)builder->emitSpecializeInst(
                builder->getTypeKind(),
                diffBaseSpecialize->getBase()->getDataType(),
                args.getCount(),
                args.getBuffer()),
            diffBaseSpecialize->getBase(),
            args.getCount(),
            args.getBuffer());

        return InstPair(primalSpecialize, diffSpecialize);
    }
    else if (isBackwardDifferentiableFunc(genericInnerVal) || as<IRFuncType>(genericInnerVal))
    {
        List<IRInst*> args;
        for (UInt i = 0; i < primalSpecialize->getArgCount(); i++)
        {
            args.add(primalSpecialize->getArg(i));
        }
        auto diffCallee = findOrTranscribeDiffInst(builder, origSpecialize->getBase());
        auto diffSpecialize = builder->emitSpecializeInst(
            (IRType*)builder->emitSpecializeInst(
                builder->getTypeKind(),
                diffCallee->getDataType(),
                args.getCount(),
                args.getBuffer()),
            diffCallee,
            args.getCount(),
            args.getBuffer());
        return InstPair(primalSpecialize, diffSpecialize);
    }
    else
    {
        return InstPair(primalSpecialize, nullptr);
    }
}

LegacyBackwardDiffTranslationFuncContext::Result LegacyBackwardDiffTranslationFuncContext::
    translate(IRBuilder* builder)
{
    // We just need to call the applyBwdFunc() with all the primal parts of the parameters
    // then call the bwdPropFunc() with the differential parts of the parameters &
    // write back any output derivatives.
    //
    auto bwdDiffFunc = builder->createFunc();
    bwdDiffFunc->setFullType(this->bwdDiffFuncType);

    // TODO: do all the decorator and naming stuff here.

    builder->setInsertInto(bwdDiffFunc);
    builder->emitBlock();
    List<IRInst*> bwdDiffFuncParams;
    // Emit parameters for the backward derivative function.
    for (auto paramType : this->bwdDiffFuncType->getParamTypes())
    {
        // TODO: figure out how to put the right names for the parameters.
        auto param = builder->emitParam(paramType);
        bwdDiffFuncParams.add(param);
    }

    auto applyBwdFuncType = cast<IRFuncType>(this->applyBwdFunc->getDataType());
    auto bwdPropFuncType = cast<IRFuncType>(this->bwdPropFunc->getDataType());
    List<IRInst*> applyBwdFuncArgs;
    List<IRInst*> bwdPropFuncParams;

    // TODO: This logic is annoyingly confusing.. rewrite as a switch-case.
    UIndex bwdDiffParamIdx = 0;
    for (UIndex i = 0; i < applyBwdFuncType->getParamCount(); i++)
    {
        // auto applyParamType = this->applyBwdFunc->getParamType(i);
        /*auto bwdPropParamType =
            this->bwdPropFunc->getParamType(i + 1); // +1 to skip the context param*/
        auto applyParamType = applyBwdFuncType->getParamType(i);
        auto bwdPropParamType =
            bwdPropFuncType->getParamType(i + 1); // +1 to skip the context param

        if (as<IRVoidType>(bwdPropParamType))
        {
            bwdPropFuncParams.add(builder->getVoidValue());
        }

        if (as<IROutParamType>(applyParamType))
        {
            // There won't be any parameter in the legacy bwd_diff function for this parameter.
            applyBwdFuncArgs.add(
                builder->emitVar(as<IRPtrTypeBase>(applyParamType)->getValueType()));

            if (!as<IRVoidType>(bwdPropParamType))
            {
                bwdPropFuncParams.add(
                    bwdDiffFuncParams[bwdDiffParamIdx]); // Use the original parameter as-is.
                bwdDiffParamIdx++;
            }
            continue;
        }
        else if (as<IRBorrowInOutParamType>(applyParamType) && as<IRVoidType>(bwdPropParamType))
        {
            auto var = builder->emitVar(as<IRPtrTypeBase>(applyParamType)->getValueType());
            applyBwdFuncArgs.add(var);
            builder->emitStore(var, bwdDiffFuncParams[bwdDiffParamIdx]);
            bwdDiffParamIdx++;
            continue;
        }
        else if (!as<IRVoidType>(bwdPropParamType))
        {
            // TODO: STOPPED HERE: Handle inout no-diff parameters.

            // inout diff-pair or in diff-ptr-pair
            if (auto bwdDiffParamPtrType =
                    as<IRPtrTypeBase>(this->bwdDiffFuncType->getParamType(bwdDiffParamIdx)))
            {
                // as<IRDifferentialPairType>(bwdParamPtrType);
                if (auto applyParamPtrType = as<IRPtrTypeBase>(applyParamType))
                {
                    /*applyBwdFuncArgs.add(builder->emitIntrinsicInst(
                        builder->getPtrType(applyParamPtrType->getValueType()),
                        kIROp_DifferentialPairGetPrimalUserCode,
                        1,
                        &bwdDiffFuncParams[bwdDiffParamIdx]));*/

                    // The legacy bwd_diff function should not modify the primal values,
                    // so we'll create a local var and load the primal into it.
                    //
                    auto var = builder->emitVar(as<IRPtrTypeBase>(applyParamType)->getValueType());
                    applyBwdFuncArgs.add(var);
                    builder->emitStore(
                        var,
                        builder->emitLoad(builder->emitIntrinsicInst(
                            builder->getPtrType(applyParamPtrType->getValueType()),
                            kIROp_DifferentialPairGetPrimalUserCode,
                            1,
                            &bwdDiffFuncParams[bwdDiffParamIdx])));
                }
                else
                {
                    applyBwdFuncArgs.add(builder->emitLoad(builder->emitIntrinsicInst(
                        builder->getPtrType(applyParamType),
                        kIROp_DifferentialPairGetPrimalUserCode,
                        1,
                        &bwdDiffFuncParams[bwdDiffParamIdx])));
                }
                // applyBwdFuncArgs.add(builder->emitLoad(builder->emitDifferentialPairGetPrimal(
                //     bwdDiffFuncParams[bwdDiffParamIdx++]))); // get the primal part

                if (auto bwdPropParamPtrType = as<IRPtrTypeBase>(bwdPropParamType))
                {
                    bwdPropFuncParams.add(builder->emitIntrinsicInst(
                        builder->getPtrType(bwdPropParamPtrType->getValueType()),
                        kIROp_DifferentialPairGetDifferentialUserCode,
                        1,
                        &bwdDiffFuncParams[bwdDiffParamIdx]));
                }
                else
                {
                    bwdPropFuncParams.add(builder->emitLoad(builder->emitIntrinsicInst(
                        bwdPropParamType,
                        kIROp_DifferentialPairGetDifferentialUserCode,
                        1,
                        &bwdDiffFuncParams[bwdDiffParamIdx])));
                }
                bwdDiffParamIdx++;
            }
            else
            {
                SLANG_UNEXPECTED("Unexpected parameter type in backward diff transcriber");
            }
        }
        else
        {
            applyBwdFuncArgs.add(bwdDiffFuncParams[bwdDiffParamIdx]);
            bwdDiffParamIdx++;
        }
    }

    // Do we have a left over parameter? This should be the
    // d_Out parameter.
    //
    if (bwdDiffFuncParams.getCount() > bwdDiffParamIdx)
    {
        bwdPropFuncParams.add(bwdDiffFuncParams[bwdDiffParamIdx]);
    }

    auto contextVal = builder->emitCallInst(
        applyBwdFuncType->getResultType(),
        this->applyBwdFunc,
        applyBwdFuncArgs.getCount(),
        applyBwdFuncArgs.getBuffer());
    bwdPropFuncParams.insert(0, contextVal);

    builder->emitCallInst(
        bwdPropFuncType->getResultType(),
        this->bwdPropFunc,
        bwdPropFuncParams.getCount(),
        bwdPropFuncParams.getBuffer());

    builder->emitReturn();

    return {bwdDiffFunc};
}

LegacyToNewBackwardDiffTranslationFuncContext::Result LegacyToNewBackwardDiffTranslationFuncContext::
    translate(IRBuilder* builder)
{
    // We just need to call the applyBwdFunc() with all the primal parts of the parameters
    // then call the bwdPropFunc() with the differential parts of the parameters &
    // write back any output derivatives.
    //

    // Create the context type first (since the rest depend on it).
    auto contextType = builder->createStructType();

    auto applyFunc = builder->createFunc();
    auto bwdPropFunc = builder->createFunc();
    auto getValFunc = builder->createFunc();

    auto legacyBwdDiffFuncType = as<IRFuncType>(this->legacyBwdDiffFunc->getDataType());

    auto outerParent = as<IRGeneric>(findOuterGeneric(primalFunc));
    diffTypeContext.setFunc(outerParent ? outerParent : primalFunc);

    IRInst* primalFuncType = this->primalFunc->getDataType();

    /*
    auto applyForBwdFuncType = as<IRFuncType>(diffTypeContext.resolveType(
        builder,
        (IRType*)
            builder->emitIntrinsicInst(nullptr, kIROp_ApplyForBwdFuncType, 1, &primalFuncType)));
    auto bwdPropFuncType = as<IRFuncType>(diffTypeContext.resolveType(
        builder,
        (IRType*)
            builder->emitIntrinsicInst(nullptr, kIROp_BwdCallableFuncType, 2, &primalFuncType)));
    */

    List<IRInst*> applyForBwdFuncTypeParams;
    applyForBwdFuncTypeParams.add(primalFunc->getDataType());
    applyForBwdFuncTypeParams.add(contextType);
    auto applyForBwdFuncType = cast<IRFuncType>(diffTypeContext.resolveType(
        builder,
        builder->emitIntrinsicInst(
            builder->getTypeKind(),
            kIROp_ApplyForBwdFuncType,
            applyForBwdFuncTypeParams.getCount(),
            applyForBwdFuncTypeParams.getBuffer())));

    List<IRInst*> bwdPropFuncTypeParams;
    bwdPropFuncTypeParams.add(primalFunc->getDataType());
    bwdPropFuncTypeParams.add(contextType);
    auto bwdPropFuncType = cast<IRFuncType>(diffTypeContext.resolveType(
        builder,
        builder->emitIntrinsicInst(
            builder->getTypeKind(),
            kIROp_BwdCallableFuncType,
            bwdPropFuncTypeParams.getCount(),
            bwdPropFuncTypeParams.getBuffer())));

    applyFunc->setFullType(applyForBwdFuncType);
    bwdPropFunc->setFullType(bwdPropFuncType);

    // TODO: do all the decorator and naming stuff here.

    IRBuilder applyFuncBuilder(builder->getModule());
    applyFuncBuilder.setInsertInto(applyFunc);
    applyFuncBuilder.emitBlock();
    auto contextVar = applyFuncBuilder.emitVar(contextType);

    IRBuilder contextTypeBuilder(builder->getModule());
    contextTypeBuilder.setInsertInto(builder->getModule());

    IRBuilder bwdPropFuncBuilder(builder->getModule());
    bwdPropFuncBuilder.setInsertInto(bwdPropFunc);
    bwdPropFuncBuilder.emitBlock();
    auto contextInParam =
        bwdPropFuncBuilder.emitParam(contextType); // Context parameter for the bwd prop func.
    bwdPropFuncBuilder.addNameHintDecoration(contextInParam, UnownedStringSlice("ctx"));

    IRBuilder bwdPropPostCallBuilder(builder->getModule());
    bwdPropPostCallBuilder.setInsertAfter(contextInParam);
    auto placeholderCall = bwdPropPostCallBuilder.emitCallInst(
        legacyBwdDiffFuncType->getResultType(),
        legacyBwdDiffFunc,
        0,
        nullptr);

    bwdPropFuncBuilder.setInsertBefore(placeholderCall);

    // Pull up a list of primal params, so we can use them for naming &
    // location tagging.
    //
    ShortList<IRParam*, 8> primalFuncParams;
    auto funcForNames = as<IRFunc>(getResolvedInstForDecorations(primalFunc));
    for (auto param : funcForNames->getParams())
    {
        primalFuncParams.add(param);
    }

    // Jointly emit parameters for the apply and bwd prop functions, while
    // also building the context type.
    //
    List<IRInst*> bwdDiffFuncArgs;
    for (UIndex idx = 0; idx < applyForBwdFuncType->getParamCount(); idx++)
    {
        auto applyForBwdParam = applyFuncBuilder.emitParam(applyForBwdFuncType->getParamType(idx));
        generateName(builder, primalFuncParams[idx], applyForBwdParam, "");
        applyForBwdParam->sourceLoc = primalFuncParams[idx]->sourceLoc;

        auto bwdPropParam = bwdPropFuncBuilder.emitParam(
            bwdPropFuncType->getParamType(idx + 1)); // +1 to skip the context param
        generateName(builder, primalFuncParams[idx], bwdPropParam, "d_");
        bwdPropParam->sourceLoc = primalFuncParams[idx]->sourceLoc;

        if (!as<IROutParamType>(applyForBwdParam->getDataType()))
        {
            auto key = contextTypeBuilder.createStructKey();
            auto structFieldType = applyForBwdParam->getDataType();

            if (auto inoutParamType = as<IRBorrowInOutParamType>(applyForBwdParam->getDataType()))
            {
                structFieldType = inoutParamType->getValueType();
                contextTypeBuilder.createStructField(contextType, key, structFieldType);
            }
            else
            {
                // Has to be "in" type.
                contextTypeBuilder.createStructField(contextType, key, structFieldType);
            }

            applyFuncBuilder.emitStore(
                applyFuncBuilder
                    .emitFieldAddress(builder->getPtrType(structFieldType), contextVar, key),
                applyForBwdParam);

            if (as<IRVoidType>(bwdPropParam->getDataType()))
            {
                // Add just the primal part (there's no differential part since its void).
                bwdDiffFuncArgs.add(
                    bwdPropFuncBuilder.emitFieldExtract(structFieldType, contextInParam, key));
            }
            else
            {
                // If this is not a void type, we need to construct a differential pair
                // var.
                //
                auto inOutPairType = cast<IRBorrowInOutParamType>(
                    legacyBwdDiffFuncType->getParamType(bwdDiffFuncArgs.getCount()));
                IRInst* pairVar = bwdPropFuncBuilder.emitVar(inOutPairType->getValueType());

                // Load the primal value from the context param and store it in here.
                bwdPropFuncBuilder.emitStore(
                    bwdPropFuncBuilder.emitIntrinsicInst(
                        builder->getPtrType(structFieldType),
                        kIROp_DifferentialPairGetPrimalUserCode,
                        1,
                        &pairVar),
                    bwdPropFuncBuilder.emitFieldExtract(structFieldType, contextInParam, key));

                auto diffPtr = bwdPropFuncBuilder.emitIntrinsicInst(
                    bwdPropFuncBuilder.getPtrType(
                        as<IROutParamTypeBase>(bwdPropParam->getDataType())->getValueType()),
                    kIROp_DifferentialPairGetDifferentialUserCode,
                    1,
                    &pairVar);

                if (as<IRBorrowInOutParamType>(bwdPropParam->getDataType()))
                {
                    bwdPropFuncBuilder.emitStore(
                        diffPtr,
                        bwdPropFuncBuilder.emitLoad(bwdPropParam));
                }

                // After the bwdDiff call, load the differential value and put it in bwdPropParam.
                bwdPropPostCallBuilder.emitStore(
                    bwdPropParam,
                    bwdPropPostCallBuilder.emitLoad(diffPtr));

                bwdDiffFuncArgs.add(pairVar);
            }
        }
        else if (!as<IRVoidType>(bwdPropParam->getDataType()))
        {
            // Primal => Out param
            // Diff => In diff param.
            //
            // SLANG_ASSERT(!as<IROutParamTypeBase>(bwdPropParam->getDataType()));
            bwdDiffFuncArgs.add(bwdPropParam);
        }
        else
        {
            // Primal => Out param
            // Diff => Void.

            // Nothing to do.
        }
    }

    //
    // Build the getVal() function.
    //

    auto getValFuncType = builder->getFuncType(
        {contextType},
        as<IRFuncType>(primalFunc->getDataType())->getResultType());

    // Emit a call to the primal-func & store the result in a new key,
    // then load that key in the getValFunc and return it.
    //
    IRStructKey* resultKeyInst = contextTypeBuilder.createStructKey();
    auto resultFieldType = as<IRFuncType>(primalFunc->getDataType())->getResultType();
    contextTypeBuilder.createStructField(contextType, resultKeyInst, resultFieldType);

    getValFunc->setFullType(getValFuncType);
    IRBuilder getValFuncBuilder(builder->getModule());
    getValFuncBuilder.setInsertInto(getValFunc);
    getValFuncBuilder.emitBlock();
    auto getValContextParam = getValFuncBuilder.emitParam(contextType);
    getValFuncBuilder.addNameHintDecoration(getValContextParam, UnownedStringSlice("ctx"));

    if (!as<IRVoidType>(resultFieldType))
    {
        // Load the result value from the context and return it
        auto resultVal =
            getValFuncBuilder.emitFieldExtract(resultFieldType, getValContextParam, resultKeyInst);
        getValFuncBuilder.emitReturn(resultVal);
    }
    else
    {
        getValFuncBuilder.emitReturn();
    }

    // Now we need to emit the call to the primal function in the apply function
    List<IRInst*> primalFuncArgs;
    for (auto param : applyFunc->getParams())
    {
        primalFuncArgs.add(param);
    }

    // Call the primal function and store the result in the context
    auto primalResult = applyFuncBuilder.emitCallInst(
        as<IRFuncType>(primalFunc->getDataType())->getResultType(),
        primalFunc,
        primalFuncArgs.getCount(),
        primalFuncArgs.getBuffer());

    if (!as<IRVoidType>(resultFieldType))
    {
        applyFuncBuilder.emitStore(
            applyFuncBuilder.emitFieldAddress(
                applyFuncBuilder.getPtrType(resultFieldType),
                contextVar,
                resultKeyInst),
            primalResult);
    }

    //
    // Finish up applyFunc & bwdPropFunc.
    //

    applyFuncBuilder.emitReturn(applyFuncBuilder.emitLoad(contextVar));

    if (legacyBwdDiffFuncType->getParamCount() > bwdDiffFuncArgs.getCount())
    {
        // We have a d_out parameter.
        auto dOutParamType = legacyBwdDiffFuncType->getParamType(bwdDiffFuncArgs.getCount());
        auto dOutParam = bwdPropFuncBuilder.emitParam(dOutParamType);
        builder->addNameHintDecoration(dOutParam, UnownedStringSlice("d_out"));
        bwdDiffFuncArgs.add(dOutParam);
    }

    // Replace the placeholder call with the actual bwd diff func call.
    bwdPropFuncBuilder.setInsertBefore(placeholderCall);
    bwdPropFuncBuilder.emitCallInst(
        legacyBwdDiffFuncType->getResultType(),
        this->legacyBwdDiffFunc,
        bwdDiffFuncArgs.getCount(),
        bwdDiffFuncArgs.getBuffer());

    placeholderCall->removeAndDeallocate();

    bwdPropPostCallBuilder.emitReturn();

    generateName(builder, primalFunc, applyFunc, "s_apply_");
    generateName(builder, primalFunc, bwdPropFunc, "s_bwdProp_");
    generateName(builder, primalFunc, getValFunc, "s_getVal_");
    generateName(builder, primalFunc, contextType, "s_bwdCallableCtx_");

    // Hoist contextType first.
    auto contextTypeGlobalVal = maybeHoistAndSpecialize(*builder, contextType);

    auto applyFuncGlobalVal = maybeHoistAndSpecialize(*builder, applyFunc);
    auto bwdPropFuncGlobalVal = maybeHoistAndSpecialize(*builder, bwdPropFunc);
    auto getValFuncGlobalVal = maybeHoistAndSpecialize(*builder, getValFunc);
    return {applyFuncGlobalVal, contextTypeGlobalVal, getValFuncGlobalVal, bwdPropFuncGlobalVal};
}


IRInst* maybeTranslateLegacyToNewBackwardDerivative(
    AutoDiffSharedContext* sharedContext,
    DiagnosticSink* sink,
    IRBackwardFromLegacyBwdDiffFunc* translateInst)
{
    IRInst* primalFunc = translateInst->getOperand(0);
    IRInst* bwdDiffFunc = translateInst->getOperand(1);

    LegacyToNewBackwardDiffTranslationFuncContext context(
        primalFunc,
        bwdDiffFunc,
        sharedContext,
        sink);

    IRBuilder builder(sharedContext->moduleInst);
    builder.setInsertBefore(translateInst);

    LegacyToNewBackwardDiffTranslationFuncContext::Result translationResult =
        context.translate(&builder);
    return builder.emitMakeTuple(
        {translationResult.applyBwdFunc,
         translationResult.bwdPropFunc,
         translationResult.getValFunc,
         translationResult.contextType});
}

IRInst* maybeTranslateLegacyBackwardDerivative(
    AutoDiffSharedContext* sharedContext,
    DiagnosticSink* sink,
    IRLegacyBackwardDifferentiate* translateInst)
{
    IRInst* applyBwdFunc = translateInst->getOperand(0);
    IRInst* contextType = translateInst->getOperand(1);
    IRInst* bwdPropFunc = translateInst->getOperand(2);
    IRFuncType* bwdDiffFuncType = cast<IRFuncType>(translateInst->getDataType());

    LegacyBackwardDiffTranslationFuncContext
        context(applyBwdFunc, contextType, bwdPropFunc, bwdDiffFuncType, sharedContext, sink);

    IRBuilder builder(sharedContext->moduleInst);

    // This will nest the func at the right place (inside any generic contexts).
    builder.setInsertAfter(translateInst);

    LegacyBackwardDiffTranslationFuncContext::Result translationResult =
        context.translate(&builder);
    return translationResult.bwdDiffFunc;
}

IRInst* maybeTranslateBackwardDerivative(
    AutoDiffSharedContext* sharedContext,
    DiagnosticSink* sink,
    IRBackwardDifferentiate* translateInst)
{
    // TODO: This is a temporary redirect into the old solution.. once we
    // know things work, we can just move the logic into this class.

    // Do the reverse-mode translation & return the 4-tuple result.
    BackwardDiffPropagateTranscriber transcriber(sharedContext, sink);
    IRBuilder builder(sharedContext->moduleInst);

    auto baseFunc = translateInst->getOperand(0);
    if (as<IRGeneric>(translateInst->getOperand(0)))
    {
        baseFunc = getGenericReturnVal(translateInst->getOperand(0));
    }

    if (!as<IRFunc>(baseFunc))
        return translateInst;

    auto targetFunc = cast<IRFunc>(baseFunc);

    IRInst* bwdPrimalFunc;
    IRInst* bwdPropagateFunc;
    IRInst* bwdContextGetValFunc;
    IRInst* bwdContextType;
    transcriber._transcribeFuncImpl(
        &builder,
        targetFunc,
        bwdPrimalFunc,
        bwdPropagateFunc,
        bwdContextGetValFunc,
        bwdContextType,
        false);

    builder.setInsertAfter(translateInst);
    return builder.emitMakeTuple(
        {bwdPrimalFunc, bwdPropagateFunc, bwdContextGetValFunc, (IRType*)bwdContextType});
}


IRInst* maybeTranslateTrivialBackwardDerivative(
    AutoDiffSharedContext* sharedContext,
    DiagnosticSink* sink,
    IRTrivialBackwardDifferentiate* translateInst)
{
    // TODO: This is a temporary redirect into the old solution.. once we
    // know things work, we can just move the logic into this class.

    // Do the reverse-mode translation & return the 4-tuple result.
    BackwardDiffPropagateTranscriber transcriber(sharedContext, sink);
    IRBuilder builder(sharedContext->moduleInst);

    auto baseFunc = translateInst->getOperand(0);
    if (as<IRGeneric>(translateInst->getOperand(0)))
    {
        baseFunc = getGenericReturnVal(translateInst->getOperand(0));
    }

    if (!as<IRFunc>(baseFunc))
        return translateInst;

    auto targetFunc = cast<IRFunc>(baseFunc);

    IRInst* bwdPrimalFunc;
    IRInst* bwdPropagateFunc;
    IRInst* bwdContextGetValFunc;
    IRInst* bwdContextType;
    transcriber._transcribeFuncImpl(
        &builder,
        targetFunc,
        bwdPrimalFunc,
        bwdPropagateFunc,
        bwdContextGetValFunc,
        bwdContextType,
        true);

    builder.setInsertAfter(translateInst);
    return builder.emitMakeTuple(
        {bwdPrimalFunc, bwdPropagateFunc, bwdContextGetValFunc, (IRType*)bwdContextType});
}

IRInst* maybeTranslateBackwardDerivativeWitnessFromLegacyBwdDiffFunc(
    AutoDiffSharedContext* sharedContext,
    DiagnosticSink* sink,
    IRSynthesizedBackwardDerivativeWitnessTableFromLegacyBwdDiffFunc* translateInst)
{
    IRInst* primalFunc = translateInst->getOperand(0);
    IRInst* bwdDiffFunc = translateInst->getOperand(1);

    IRBuilder builder(sharedContext->moduleInst);
    builder.setInsertBefore(translateInst);

    LegacyToNewBackwardDiffTranslationFuncContext context(
        primalFunc,
        bwdDiffFunc,
        sharedContext,
        sink);

    LegacyToNewBackwardDiffTranslationFuncContext::Result translationResult =
        context.translate(&builder);

    auto bwdDiffTable = builder.createWitnessTable(
        (IRType*)builder.emitSpecializeInst(
            builder.getTypeKind(),
            sharedContext->backwardDifferentiableInterfaceType,
            1,
            &primalFunc),
        (IRType*)primalFunc);

    // ?
    auto bwdDiffInterface = cast<IRInterfaceType>(
        getGenericReturnVal(sharedContext->backwardDifferentiableInterfaceType));
    builder.createWitnessTableEntry(
        bwdDiffTable,
        cast<IRInterfaceRequirementEntry>(bwdDiffInterface->getOperand(0))->getRequirementKey(),
        translationResult.contextType);

    auto bwdCallableTable = builder.createWitnessTable(
        (IRType*)builder.emitSpecializeInst(
            builder.getTypeKind(),
            sharedContext->backwardCallableInterfaceType,
            1,
            &primalFunc),
        (IRType*)translationResult.contextType);

    auto bwdCallableInterface =
        cast<IRInterfaceType>(getGenericReturnVal(sharedContext->backwardCallableInterfaceType));

    builder.createWitnessTableEntry(
        bwdCallableTable,
        cast<IRInterfaceRequirementEntry>(bwdCallableInterface->getOperand(0))->getRequirementKey(),
        translationResult.bwdPropFunc);
    builder.createWitnessTableEntry(
        bwdCallableTable,
        cast<IRInterfaceRequirementEntry>(bwdCallableInterface->getOperand(1))->getRequirementKey(),
        translationResult.getValFunc);

    builder.createWitnessTableEntry(
        bwdDiffTable,
        cast<IRInterfaceRequirementEntry>(bwdDiffInterface->getOperand(1))->getRequirementKey(),
        bwdCallableTable);

    builder.createWitnessTableEntry(
        bwdDiffTable,
        cast<IRInterfaceRequirementEntry>(bwdDiffInterface->getOperand(2))->getRequirementKey(),
        translationResult.applyBwdFunc);

    builder.createWitnessTableEntry(
        bwdDiffTable,
        cast<IRInterfaceRequirementEntry>(bwdDiffInterface->getOperand(3))->getRequirementKey(),
        bwdDiffFunc);

    maybeHoist(builder, bwdCallableTable);
    return bwdDiffTable;
}

} // namespace Slang
