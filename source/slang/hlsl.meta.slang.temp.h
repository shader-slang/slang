SLANG_RAW("// Slang HLSL compatibility library\n")
SLANG_RAW("\n")
SLANG_RAW("typedef uint UINT;\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_StructuredBufferGetDimensions
)
SLANG_RAW(")\n")
SLANG_RAW("uint2 __structuredBufferGetDimensions(AppendStructuredBuffer<T> buffer);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_StructuredBufferGetDimensions
)
SLANG_RAW(")\n")
SLANG_RAW("uint2 __structuredBufferGetDimensions(ConsumeStructuredBuffer<T> buffer);\n")
SLANG_RAW("\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_StructuredBufferGetDimensions
)
SLANG_RAW(")\n")
SLANG_RAW("uint2 __structuredBufferGetDimensions<T>(StructuredBuffer<T> buffer);\n")
SLANG_RAW("\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_StructuredBufferGetDimensions
)
SLANG_RAW(")\n")
SLANG_RAW("uint2 __structuredBufferGetDimensions<T>(RWStructuredBuffer<T> buffer);\n")
SLANG_RAW("\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_StructuredBufferGetDimensions
)
SLANG_RAW(")\n")
SLANG_RAW("uint2 __structuredBufferGetDimensions<T>(RasterizerOrderedStructuredBuffer<T> buffer);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("__magic_type(HLSLAppendStructuredBufferType)\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_HLSLAppendStructuredBufferType
)
SLANG_RAW(")\n")
SLANG_RAW("struct AppendStructuredBuffer\n")
SLANG_RAW("{\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_StructuredBufferAppend
)
SLANG_RAW(")\n")
SLANG_RAW("    void Append(T value);\n")
SLANG_RAW("\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    void GetDimensions(\n")
SLANG_RAW("        out uint numStructs,\n")
SLANG_RAW("        out uint stride)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        let result = __structuredBufferGetDimensions(this);\n")
SLANG_RAW("        numStructs = result.x;\n")
SLANG_RAW("        stride = result.y;\n")
SLANG_RAW("    }\n")
SLANG_RAW("};\n")
SLANG_RAW("\n")
SLANG_RAW("__magic_type(HLSLByteAddressBufferType)\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_HLSLByteAddressBufferType
)
SLANG_RAW(")\n")
SLANG_RAW("struct ByteAddressBuffer\n")
SLANG_RAW("{\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    __target_intrinsic(hlsl)\n")
SLANG_RAW("    __target_intrinsic(cpp)\n")
SLANG_RAW("    __target_intrinsic(cuda)\n")
SLANG_RAW("    [__unsafeForceInlineEarly]\n")
SLANG_RAW("    void GetDimensions(out uint dim);\n")
SLANG_RAW("\n")
SLANG_RAW("    [__unsafeForceInlineEarly]\n")
SLANG_RAW("    __specialized_for_target(spirv)\n")
SLANG_RAW("    __specialized_for_target(glsl)\n")
SLANG_RAW("    void GetDimensions(out uint dim)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        dim = __structuredBufferGetDimensions(__getEquivalentStructuredBuffer<uint>(this)).x*4;\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    __target_intrinsic(hlsl)\n")
SLANG_RAW("    uint Load(int location)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        return __byteAddressBufferLoad<uint>(this, location);\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    uint Load(int location, out uint status);\n")
SLANG_RAW("\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    __target_intrinsic(hlsl)\n")
SLANG_RAW("    uint2 Load2(int location)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        return __byteAddressBufferLoad<uint2>(this, location);\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    uint2 Load2(int location, out uint status);\n")
SLANG_RAW("\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    __target_intrinsic(hlsl)\n")
SLANG_RAW("    uint3 Load3(int location)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        return __byteAddressBufferLoad<uint3>(this, location);\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    uint3 Load3(int location, out uint status);\n")
SLANG_RAW("\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    __target_intrinsic(hlsl)\n")
SLANG_RAW("    uint4 Load4(int location)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        return __byteAddressBufferLoad<uint4>(this, location);\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    uint4 Load4(int location, out uint status);\n")
SLANG_RAW("\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    T Load<T>(int location)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        return __byteAddressBufferLoad<T>(this, location);\n")
SLANG_RAW("    }\n")
SLANG_RAW("};\n")
SLANG_RAW("\n")
SLANG_RAW("// Texture\n")
SLANG_RAW("[sealed]\n")
SLANG_RAW("[builtin]\n")
SLANG_RAW("interface __ITextureShape\n")
SLANG_RAW("{\n")
SLANG_RAW("    static const int flavor;\n")
SLANG_RAW("    static const int dimensions;\n")
SLANG_RAW("    static const int planeDimensions;\n")
SLANG_RAW("}\n")
SLANG_RAW("__magic_type(TextureShape1DType)\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_TextureShape1DType
)
SLANG_RAW(")\n")
SLANG_RAW("struct __Shape1D : __ITextureShape\n")
SLANG_RAW("{\n")
SLANG_RAW("    static const int flavor = ")
SLANG_SPLICE(SLANG_TEXTURE_1D
)
SLANG_RAW(";\n")
SLANG_RAW("    static const int dimensions = 1;\n")
SLANG_RAW("    static const int planeDimensions = 1;\n")
SLANG_RAW("}\n")
SLANG_RAW("__magic_type(TextureShape2DType)\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_TextureShape2DType
)
SLANG_RAW(")\n")
SLANG_RAW("struct __Shape2D : __ITextureShape\n")
SLANG_RAW("{\n")
SLANG_RAW("    static const int flavor = ")
SLANG_SPLICE(SLANG_TEXTURE_2D
)
SLANG_RAW(";\n")
SLANG_RAW("    static const int dimensions = 2;\n")
SLANG_RAW("    static const int planeDimensions = 2;\n")
SLANG_RAW("}\n")
SLANG_RAW("__magic_type(TextureShape3DType)\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_TextureShape3DType
)
SLANG_RAW(")\n")
SLANG_RAW("struct __Shape3D : __ITextureShape\n")
SLANG_RAW("{\n")
SLANG_RAW("    static const int flavor = ")
SLANG_SPLICE(SLANG_TEXTURE_3D
)
SLANG_RAW(";\n")
SLANG_RAW("    static const int dimensions = 3;\n")
SLANG_RAW("    static const int planeDimensions = 3;\n")
SLANG_RAW("}\n")
SLANG_RAW("__magic_type(TextureShapeCubeType)\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_TextureShapeCubeType
)
SLANG_RAW(")\n")
SLANG_RAW("struct __ShapeCube : __ITextureShape\n")
SLANG_RAW("{\n")
SLANG_RAW("    static const int flavor = ")
SLANG_SPLICE(SLANG_TEXTURE_CUBE
)
SLANG_RAW(";\n")
SLANG_RAW("    static const int dimensions = 3;\n")
SLANG_RAW("    static const int planeDimensions = 2;\n")
SLANG_RAW("}\n")
SLANG_RAW("__magic_type(TextureShapeBufferType)\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_TextureShapeBufferType
)
SLANG_RAW(")\n")
SLANG_RAW("struct __ShapeBuffer : __ITextureShape\n")
SLANG_RAW("{\n")
SLANG_RAW("    static const int flavor = ")
SLANG_SPLICE(SLANG_TEXTURE_BUFFER
)
SLANG_RAW(";\n")
SLANG_RAW("    static const int dimensions = 1;\n")
SLANG_RAW("    static const int planeDimensions = 1;\n")
SLANG_RAW("}\n")
SLANG_RAW("__intrinsic_op(vectorReshape)\n")
SLANG_RAW("vector<T,N> __vectorReshape<let N : int, T, let M : int>(vector<T,M> vin);\n")
SLANG_RAW("\n")
SLANG_RAW("__intrinsic_op(makeVector)\n")
SLANG_RAW("__generic<T, let N:int>\n")
SLANG_RAW("vector<T,N+1> __makeVector(vector<T,N> vec, T scalar);\n")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("__magic_type(TextureType)\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_TextureType
)
SLANG_RAW(")\n")
SLANG_RAW("struct __TextureImpl<T, Shape: __ITextureShape, let isArray:int, let isMS:int, let sampleCount:int, let access:int, let isShadow:int, let isCombined:int, let format:int>\n")
SLANG_RAW("{\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Combined texture sampler specific functions\n")
SLANG_RAW("__generic<T, Shape: __ITextureShape, let isArray:int, let isMS:int, let sampleCount:int, let isShadow:int, let format:int>\n")
SLANG_RAW("extension __TextureImpl<T,Shape,isArray,isMS,sampleCount,0,isShadow,1,format>\n")
SLANG_RAW("{\n")
SLANG_RAW("    static const int access = 0;\n")
SLANG_RAW("\n")
SLANG_RAW("    typealias TextureCoord = vector<float, Shape.dimensions>;\n")
SLANG_RAW("\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    float CalculateLevelOfDetail(TextureCoord location)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case hlsl:\n")
SLANG_RAW("            __intrinsic_asm \"CalculateLevelOfDetail\";\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("            __intrinsic_asm \"textureQueryLod($0, $1).x\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            return (spirv_asm\n")
SLANG_RAW("            {\n")
SLANG_RAW("                result:$$float2 = OpImageQueryLod $this $location\n")
SLANG_RAW("            }).x;\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    float CalculateLevelOfDetailUnclamped(TextureCoord location)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case hlsl:\n")
SLANG_RAW("            __intrinsic_asm \"CalculateLevelOfDetailUnclamped\";\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("            __intrinsic_asm \"textureQueryLod($0, $1).y\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            return (spirv_asm\n")
SLANG_RAW("            {\n")
SLANG_RAW("                result:$$float2 = OpImageQueryLod $this $location\n")
SLANG_RAW("            }).y;\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    T Sample(vector<float, Shape.dimensions+isArray> location)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("            case cpp:\n")
SLANG_RAW("            case hlsl:\n")
SLANG_RAW("                __intrinsic_asm \".Sample\";\n")
SLANG_RAW("            case glsl:\n")
SLANG_RAW("                __intrinsic_asm \"$ctexture($0, $1)$z\";\n")
SLANG_RAW("            case cuda:\n")
SLANG_RAW("                if (isArray != 0)\n")
SLANG_RAW("                {\n")
SLANG_RAW("                    switch(Shape.flavor)\n")
SLANG_RAW("                    {\n")
SLANG_RAW("                    case ")
SLANG_SPLICE(SLANG_TEXTURE_1D
)
SLANG_RAW(":\n")
SLANG_RAW("                        __intrinsic_asm \"tex1DLayered<$T0>($0, ($1).x, int(($1).y))\";\n")
SLANG_RAW("                    case ")
SLANG_SPLICE(SLANG_TEXTURE_2D
)
SLANG_RAW(":\n")
SLANG_RAW("                        __intrinsic_asm \"tex2DLayered<$T0>($0, ($1).x, ($1).y, int(($1).z))\";\n")
SLANG_RAW("                    case ")
SLANG_SPLICE(SLANG_TEXTURE_CUBE
)
SLANG_RAW(":\n")
SLANG_RAW("                        __intrinsic_asm \"texCubemapLayered<$T0>($0, ($1).x, ($1).y, ($1).z, int(($1).w))\";\n")
SLANG_RAW("                    }\n")
SLANG_RAW("                }\n")
SLANG_RAW("                else\n")
SLANG_RAW("                {\n")
SLANG_RAW("                    switch(Shape.flavor)\n")
SLANG_RAW("                    {\n")
SLANG_RAW("                    case ")
SLANG_SPLICE(SLANG_TEXTURE_1D
)
SLANG_RAW(":\n")
SLANG_RAW("                        __intrinsic_asm \"tex1D<$T0>($0, ($1))\";\n")
SLANG_RAW("                    case ")
SLANG_SPLICE(SLANG_TEXTURE_2D
)
SLANG_RAW(":\n")
SLANG_RAW("                        __intrinsic_asm \"tex2D<$T0>($0, ($1).x, ($1).y)\";\n")
SLANG_RAW("                    case ")
SLANG_SPLICE(SLANG_TEXTURE_3D
)
SLANG_RAW(":\n")
SLANG_RAW("                        __intrinsic_asm \"tex3D<$T0>($0, ($1).x, ($1).y, ($1).z)\";\n")
SLANG_RAW("                    case ")
SLANG_SPLICE(SLANG_TEXTURE_CUBE
)
SLANG_RAW(":\n")
SLANG_RAW("                        __intrinsic_asm \"texCubemap<$T0>($0, ($1).x, ($1).y, ($1).z)\";\n")
SLANG_RAW("                    }\n")
SLANG_RAW("                }\n")
SLANG_RAW("            case spirv:\n")
SLANG_RAW("                return spirv_asm\n")
SLANG_RAW("                {\n")
SLANG_RAW("                    %sampled : __sampledType(T) = OpImageSampleImplicitLod $this $location None;\n")
SLANG_RAW("                    __truncate $$T result __sampledType(T) %sampled;\n")
SLANG_RAW("                };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    __glsl_extension(GL_ARB_sparse_texture_clamp)\n")
SLANG_RAW("    T Sample(vector<float, Shape.dimensions+isArray> location, vector<int, Shape.planeDimensions> offset, float clamp)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("            case cpp:\n")
SLANG_RAW("            case hlsl:\n")
SLANG_RAW("                __intrinsic_asm \".Sample\";\n")
SLANG_RAW("            case glsl:\n")
SLANG_RAW("                __intrinsic_asm \"$ctextureOffsetClampARB($0, $1, $2, $3)$z\";\n")
SLANG_RAW("            case spirv:\n")
SLANG_RAW("                return spirv_asm\n")
SLANG_RAW("                {\n")
SLANG_RAW("                    OpCapability MinLod;\n")
SLANG_RAW("                    %sampled : __sampledType(T) = OpImageSampleImplicitLod $this $location None|ConstOffset|MinLod $offset $clamp;\n")
SLANG_RAW("                    __truncate $$T result __sampledType(T) %sampled;\n")
SLANG_RAW("                };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    __target_intrinsic(hlsl)\n")
SLANG_RAW("    T Sample(vector<float, Shape.dimensions+isArray> location, vector<int, Shape.planeDimensions> offset, float clamp, out uint status)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        status = 0;\n")
SLANG_RAW("        return Sample(location, offset, clamp);\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    T SampleBias(vector<float, Shape.dimensions+isArray> location, float bias)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("            case cpp:\n")
SLANG_RAW("            case hlsl:\n")
SLANG_RAW("                __intrinsic_asm \".SampleBias\";\n")
SLANG_RAW("            case glsl:\n")
SLANG_RAW("                __intrinsic_asm \"$ctexture($0, $1, $2)$z\";\n")
SLANG_RAW("            case spirv:\n")
SLANG_RAW("                return spirv_asm\n")
SLANG_RAW("                {\n")
SLANG_RAW("                    %sampled : __sampledType(T) = OpImageSampleImplicitLod $this $location None|Bias $bias;\n")
SLANG_RAW("                    __truncate $$T result __sampledType(T) %sampled;\n")
SLANG_RAW("\n")
SLANG_RAW("                };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    T SampleBias(vector<float, Shape.dimensions+isArray> location, float bias, constexpr vector<int, Shape.planeDimensions> offset)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("            case cpp:\n")
SLANG_RAW("            case hlsl:\n")
SLANG_RAW("            __intrinsic_asm \".SampleBias\";\n")
SLANG_RAW("            case glsl:\n")
SLANG_RAW("            __intrinsic_asm \"$ctextureOffset($0, $1, $3, $2)$z\";\n")
SLANG_RAW("            case spirv:\n")
SLANG_RAW("            return spirv_asm\n")
SLANG_RAW("            {\n")
SLANG_RAW("                %sampled : __sampledType(T) = OpImageSampleImplicitLod $this $location None|Bias|ConstOffset $bias $offset;\n")
SLANG_RAW("                __truncate $$T result __sampledType(T) %sampled;\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(glsl, \"texture($0, $1)\")\n")
SLANG_RAW("    float __glsl_texture(vector<float, Shape.dimensions+isArray+1> value);\n")
SLANG_RAW("\n")
SLANG_RAW("    __glsl_extension(GL_EXT_texture_shadow_lod)\n")
SLANG_RAW("    __target_intrinsic(glsl, \"textureOffset($0, $1, $2)\")\n")
SLANG_RAW("    float __glsl_texture_offset(vector<float, Shape.dimensions+isArray+1> value, constexpr vector<int, Shape.planeDimensions> offset);\n")
SLANG_RAW("\n")
SLANG_RAW("    __glsl_extension(GL_EXT_texture_shadow_lod)\n")
SLANG_RAW("    __target_intrinsic(glsl, \"textureLod($0, $1, 0)\")\n")
SLANG_RAW("    float __glsl_texture_level_zero(vector<float, Shape.dimensions+isArray+1> value);\n")
SLANG_RAW("\n")
SLANG_RAW("    __glsl_extension(GL_EXT_texture_shadow_lod)\n")
SLANG_RAW("    __target_intrinsic(glsl, \"textureLodOffset($0, $1, 0, $2)\")\n")
SLANG_RAW("    float __glsl_texture_offset_level_zero(vector<float, Shape.dimensions+isArray+1> value, constexpr vector<int, Shape.planeDimensions> offset);\n")
SLANG_RAW("\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    float SampleCmp(vector<float, Shape.dimensions+isArray> location, float compareValue)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("            __glsl_texture(__makeVector(location, compareValue));\n")
SLANG_RAW("        case hlsl:\n")
SLANG_RAW("            __intrinsic_asm \".SampleCmp\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            return spirv_asm\n")
SLANG_RAW("            {\n")
SLANG_RAW("                result:$$float = OpImageSampleDrefImplicitLod $this $location $compareValue;\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    float SampleCmpLevelZero(vector<float, Shape.dimensions+isArray> location, float compareValue)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("            __glsl_texture_level_zero(__makeVector(location, compareValue));\n")
SLANG_RAW("        case hlsl:\n")
SLANG_RAW("            __intrinsic_asm \".SampleCmpLevelZero\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            const float zeroFloat = 0.0f;\n")
SLANG_RAW("            return spirv_asm\n")
SLANG_RAW("            {\n")
SLANG_RAW("                result:$$float = OpImageSampleDrefExplicitLod $this $location $compareValue Lod $zeroFloat;\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__readNone] \n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    float SampleCmp(vector<float, Shape.dimensions+isArray> location, float compareValue, constexpr vector<int, Shape.planeDimensions> offset)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("            __glsl_texture_offset(__makeVector(location, compareValue), offset);\n")
SLANG_RAW("        case hlsl:\n")
SLANG_RAW("            __intrinsic_asm \".SampleCmp\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            return spirv_asm\n")
SLANG_RAW("            {\n")
SLANG_RAW("                result:$$float = OpImageSampleDrefImplicitLod $this $location $compareValue ConstOffset $offset;\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    float SampleCmpLevelZero(vector<float, Shape.dimensions+isArray> location, float compareValue, constexpr vector<int, Shape.planeDimensions> offset)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("            __glsl_texture_offset_level_zero(__makeVector(location, compareValue), offset);\n")
SLANG_RAW("        case hlsl:\n")
SLANG_RAW("            __intrinsic_asm \".SampleCmpLevelZero\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            const float zeroFloat = 0.0f;\n")
SLANG_RAW("            return spirv_asm\n")
SLANG_RAW("            {\n")
SLANG_RAW("                result:$$float = OpImageSampleDrefExplicitLod $this $location $compareValue Lod|ConstOffset $zeroFloat $offset;\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    T SampleGrad(vector<float, Shape.dimensions+isArray> location, vector<float, Shape.planeDimensions> gradX, vector<float, Shape.planeDimensions> gradY)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("            case cpp:\n")
SLANG_RAW("            case hlsl:\n")
SLANG_RAW("            __intrinsic_asm \".SampleGrad\";\n")
SLANG_RAW("            case glsl:\n")
SLANG_RAW("            __intrinsic_asm \"$ctextureGrad($0, $1, $2, $3)$z\";\n")
SLANG_RAW("            case spirv:\n")
SLANG_RAW("                return spirv_asm\n")
SLANG_RAW("                {\n")
SLANG_RAW("                    %sampled : __sampledType(T) = OpImageSampleExplicitLod $this $location None|Grad $gradX $gradY;\n")
SLANG_RAW("                    __truncate $$T result __sampledType(T) %sampled;\n")
SLANG_RAW("                };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    T SampleGrad(vector<float, Shape.dimensions+isArray> location, vector<float, Shape.planeDimensions> gradX, vector<float, Shape.planeDimensions> gradY, constexpr vector<int, Shape.planeDimensions> offset)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("            case cpp:\n")
SLANG_RAW("            case hlsl:\n")
SLANG_RAW("            __intrinsic_asm \".SampleGrad\";\n")
SLANG_RAW("            case glsl:\n")
SLANG_RAW("            __intrinsic_asm \"$ctextureGradOffset($0, $1, $2, $3, $4)$z\";\n")
SLANG_RAW("            case spirv:\n")
SLANG_RAW("                return spirv_asm\n")
SLANG_RAW("                {\n")
SLANG_RAW("                    %sampled : __sampledType(T) = OpImageSampleExplicitLod $this $location None|Grad|ConstOffset $gradX $gradY $offset;\n")
SLANG_RAW("                    __truncate $$T result __sampledType(T) %sampled;\n")
SLANG_RAW("                };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    __glsl_extension(GL_ARB_sparse_texture_clamp)\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    T SampleGrad(vector<float, Shape.dimensions+isArray> location, vector<float, Shape.planeDimensions> gradX, vector<float, Shape.planeDimensions> gradY, constexpr vector<int, Shape.planeDimensions> offset, float lodClamp)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("            case cpp:\n")
SLANG_RAW("            case hlsl:\n")
SLANG_RAW("            __intrinsic_asm \".SampleGrad\";\n")
SLANG_RAW("            case glsl:\n")
SLANG_RAW("            __intrinsic_asm \"$ctextureGradOffsetClampARB($0, $1, $2, $3, $4, $5)$z\";\n")
SLANG_RAW("            case spirv:\n")
SLANG_RAW("                return spirv_asm\n")
SLANG_RAW("                {\n")
SLANG_RAW("                    OpCapability MinLod;\n")
SLANG_RAW("                    %sampled : __sampledType(T) = OpImageSampleExplicitLod $this $location None|Grad|ConstOffset|MinLod $gradX $gradY $offset $lodClamp;\n")
SLANG_RAW("                    __truncate $$T result __sampledType(T) %sampled;\n")
SLANG_RAW("                };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    T SampleLevel(vector<float, Shape.dimensions+isArray> location, float level)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("            case cpp:\n")
SLANG_RAW("            case hlsl:\n")
SLANG_RAW("                __intrinsic_asm \".SampleLevel\";\n")
SLANG_RAW("            case glsl:\n")
SLANG_RAW("                __intrinsic_asm \"$ctextureLod($0, $1, $2)$z\";\n")
SLANG_RAW("            case cuda:\n")
SLANG_RAW("                if (isArray != 0)\n")
SLANG_RAW("                {\n")
SLANG_RAW("                    switch(Shape.flavor)\n")
SLANG_RAW("                    {\n")
SLANG_RAW("                    case ")
SLANG_SPLICE(SLANG_TEXTURE_1D
)
SLANG_RAW(":\n")
SLANG_RAW("                        __intrinsic_asm \"tex1DLayeredLod<$T0>($0, ($1).x, int(($1).y), ($2))\";\n")
SLANG_RAW("                    case ")
SLANG_SPLICE(SLANG_TEXTURE_2D
)
SLANG_RAW(":\n")
SLANG_RAW("                        __intrinsic_asm \"tex2DLayeredLod<$T0>($0, ($1).x, ($1).y, int(($1).z), ($2))\";\n")
SLANG_RAW("                    case ")
SLANG_SPLICE(SLANG_TEXTURE_CUBE
)
SLANG_RAW(":\n")
SLANG_RAW("                        __intrinsic_asm \"texCubemapLayeredLod<$T0>($0, ($1).x, ($1).y, ($1).z, int(($1).w), ($2))\";\n")
SLANG_RAW("                    default:\n")
SLANG_RAW("                        __intrinsic_asm \"<invalid intrinsic>\";\n")
SLANG_RAW("                    }\n")
SLANG_RAW("                }\n")
SLANG_RAW("                else\n")
SLANG_RAW("                {\n")
SLANG_RAW("                    switch(Shape.flavor)\n")
SLANG_RAW("                    {\n")
SLANG_RAW("                    case ")
SLANG_SPLICE(SLANG_TEXTURE_1D
)
SLANG_RAW(":\n")
SLANG_RAW("                        __intrinsic_asm \"tex1DLod<$T0>($0, ($1), ($2))\";\n")
SLANG_RAW("                    case ")
SLANG_SPLICE(SLANG_TEXTURE_2D
)
SLANG_RAW(":\n")
SLANG_RAW("                        __intrinsic_asm \"tex2DLod<$T0>($0, ($1).x, ($1).y, ($2))\";\n")
SLANG_RAW("                    case ")
SLANG_SPLICE(SLANG_TEXTURE_3D
)
SLANG_RAW(":\n")
SLANG_RAW("                        __intrinsic_asm \"tex3DLod<$T0>($0, ($1).x, ($1).y, ($1).z, ($2))\";\n")
SLANG_RAW("                    case ")
SLANG_SPLICE(SLANG_TEXTURE_CUBE
)
SLANG_RAW(":\n")
SLANG_RAW("                        __intrinsic_asm \"texCubemapLod<$T0>($0, ($1).x, ($1).y, ($1).z, ($2))\";\n")
SLANG_RAW("                    }\n")
SLANG_RAW("                }\n")
SLANG_RAW("            case spirv:\n")
SLANG_RAW("                return spirv_asm\n")
SLANG_RAW("                {\n")
SLANG_RAW("                    %sampled : __sampledType(T) = OpImageSampleExplicitLod $this $location None|Lod $level;\n")
SLANG_RAW("                    __truncate $$T result __sampledType(T) %sampled;\n")
SLANG_RAW("                };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    T SampleLevel(vector<float, Shape.dimensions+isArray> location, float level, constexpr vector<int, Shape.planeDimensions> offset)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("            case cpp:\n")
SLANG_RAW("            case hlsl:\n")
SLANG_RAW("                __intrinsic_asm \".SampleLevel\";\n")
SLANG_RAW("            case glsl:\n")
SLANG_RAW("                __intrinsic_asm \"$ctextureLodOffset($0, $1, $2, $3)$z\";\n")
SLANG_RAW("            case spirv:\n")
SLANG_RAW("                return spirv_asm\n")
SLANG_RAW("                {\n")
SLANG_RAW("                    %sampled : __sampledType(T) = OpImageSampleExplicitLod $this $location None|Lod|ConstOffset $level $offset;\n")
SLANG_RAW("                    __truncate $$T result __sampledType(T) %sampled;\n")
SLANG_RAW("                };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Non-combined texture types specific functions\n")
SLANG_RAW("__generic<T, Shape: __ITextureShape, let isArray:int, let isMS:int, let sampleCount:int, let access:int, let isShadow:int, let format:int>\n")
SLANG_RAW("extension __TextureImpl<T,Shape,isArray,isMS,sampleCount,access,isShadow,0,format>\n")
SLANG_RAW("{\n")
SLANG_RAW("    typealias TextureCoord = vector<float, Shape.dimensions>;\n")
SLANG_RAW("\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    float CalculateLevelOfDetail(SamplerState s, TextureCoord location)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case hlsl:\n")
SLANG_RAW("            __intrinsic_asm \"CalculateLevelOfDetail\";\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("            __intrinsic_asm \"textureQueryLod($p, $2).x\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            return (spirv_asm {\n")
SLANG_RAW("                %sampledImage : __sampledImageType(this) = OpSampledImage $this $s;\n")
SLANG_RAW("                result:$$float2 = OpImageQueryLod %sampledImage $location;\n")
SLANG_RAW("            }).x;\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    float CalculateLevelOfDetailUnclamped(SamplerState s, TextureCoord location)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case hlsl:\n")
SLANG_RAW("            __intrinsic_asm \"CalculateLevelOfDetailUnclamped\";\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("            __intrinsic_asm \"textureQueryLod($p, $2).y\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            return (spirv_asm {\n")
SLANG_RAW("                %sampledImage : __sampledImageType(this) = OpSampledImage $this $s;\n")
SLANG_RAW("                result:$$float2 = OpImageQueryLod %sampledImage $location;\n")
SLANG_RAW("            }).y;\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    T Sample(SamplerState s, vector<float, Shape.dimensions+isArray> location)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("            case cpp:\n")
SLANG_RAW("            case hlsl:\n")
SLANG_RAW("                __intrinsic_asm \".Sample\";\n")
SLANG_RAW("            case glsl:\n")
SLANG_RAW("                __intrinsic_asm \"$ctexture($p, $2)$z\";\n")
SLANG_RAW("            case cuda:\n")
SLANG_RAW("                if (isArray != 0)\n")
SLANG_RAW("                {\n")
SLANG_RAW("                    switch(Shape.flavor)\n")
SLANG_RAW("                    {\n")
SLANG_RAW("                    case ")
SLANG_SPLICE(SLANG_TEXTURE_1D
)
SLANG_RAW(":\n")
SLANG_RAW("                        __intrinsic_asm \"tex1DLayered<$T0>($0, ($2).x, int(($2).y))\";\n")
SLANG_RAW("                    case ")
SLANG_SPLICE(SLANG_TEXTURE_2D
)
SLANG_RAW(":\n")
SLANG_RAW("                        __intrinsic_asm \"tex2DLayered<$T0>($0, ($2).x, ($2).y, int(($2).z))\";\n")
SLANG_RAW("                    case ")
SLANG_SPLICE(SLANG_TEXTURE_CUBE
)
SLANG_RAW(":\n")
SLANG_RAW("                        __intrinsic_asm \"texCubemapLayered<$T0>($0, ($2).x, ($2).y, ($2).z, int(($2).w))\";\n")
SLANG_RAW("                    default:\n")
SLANG_RAW("                        __intrinsic_asm \"<invalid intrinsic>\";\n")
SLANG_RAW("                    }\n")
SLANG_RAW("                }\n")
SLANG_RAW("                else\n")
SLANG_RAW("                {\n")
SLANG_RAW("                    switch(Shape.flavor)\n")
SLANG_RAW("                    {\n")
SLANG_RAW("                    case ")
SLANG_SPLICE(SLANG_TEXTURE_1D
)
SLANG_RAW(":\n")
SLANG_RAW("                        __intrinsic_asm \"tex1D<$T0>($0, ($2))\";\n")
SLANG_RAW("                    case ")
SLANG_SPLICE(SLANG_TEXTURE_2D
)
SLANG_RAW(":\n")
SLANG_RAW("                        __intrinsic_asm \"tex2D<$T0>($0, ($2).x, ($2).y)\";\n")
SLANG_RAW("                    case ")
SLANG_SPLICE(SLANG_TEXTURE_3D
)
SLANG_RAW(":\n")
SLANG_RAW("                        __intrinsic_asm \"tex3D<$T0>($0, ($2).x, ($2).y, ($2).z)\";\n")
SLANG_RAW("                    case ")
SLANG_SPLICE(SLANG_TEXTURE_CUBE
)
SLANG_RAW(":\n")
SLANG_RAW("                        __intrinsic_asm \"texCubemap<$T0>($0, ($2).x, ($2).y, ($2).z)\";\n")
SLANG_RAW("                    }\n")
SLANG_RAW("                }\n")
SLANG_RAW("            case spirv:\n")
SLANG_RAW("                return spirv_asm\n")
SLANG_RAW("                {\n")
SLANG_RAW("                    %sampledImage : __sampledImageType(this) = OpSampledImage $this $s;\n")
SLANG_RAW("                    %sampled : __sampledType(T) = OpImageSampleImplicitLod %sampledImage $location None;\n")
SLANG_RAW("                    __truncate $$T result __sampledType(T) %sampled;\n")
SLANG_RAW("                };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    T Sample(SamplerState s, vector<float, Shape.dimensions+isArray> location, constexpr vector<int, Shape.planeDimensions> offset)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("            case cpp:\n")
SLANG_RAW("            case hlsl:\n")
SLANG_RAW("                __intrinsic_asm \".Sample\";\n")
SLANG_RAW("            case glsl:\n")
SLANG_RAW("                __intrinsic_asm \"$ctextureOffset($p, $2, $3)$z\";\n")
SLANG_RAW("            case spirv:\n")
SLANG_RAW("            return spirv_asm\n")
SLANG_RAW("            {\n")
SLANG_RAW("                %sampledImage : __sampledImageType(this) = OpSampledImage $this $s;\n")
SLANG_RAW("                %sampled : __sampledType(T) = OpImageSampleImplicitLod %sampledImage $location None|ConstOffset $offset;\n")
SLANG_RAW("                __truncate $$T result __sampledType(T) %sampled;\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    __glsl_extension(GL_ARB_sparse_texture_clamp)\n")
SLANG_RAW("    T Sample(SamplerState s, vector<float, Shape.dimensions+isArray> location, constexpr vector<int, Shape.planeDimensions> offset, float clamp)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("            case cpp:\n")
SLANG_RAW("            case hlsl:\n")
SLANG_RAW("                __intrinsic_asm \".Sample\";\n")
SLANG_RAW("            case glsl:\n")
SLANG_RAW("                __intrinsic_asm \"$ctextureOffsetClampARB($p, $2, $3, $4)$z\";\n")
SLANG_RAW("            case spirv:\n")
SLANG_RAW("                return spirv_asm\n")
SLANG_RAW("                {\n")
SLANG_RAW("                    OpCapability MinLod;\n")
SLANG_RAW("                    %sampledImage : __sampledImageType(this) = OpSampledImage $this $s;\n")
SLANG_RAW("                    %sampled : __sampledType(T) = OpImageSampleImplicitLod %sampledImage $location None|ConstOffset|MinLod $offset $clamp;\n")
SLANG_RAW("                    __truncate $$T result __sampledType(T) %sampled;\n")
SLANG_RAW("                };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    __target_intrinsic(hlsl)\n")
SLANG_RAW("    T Sample(SamplerState s, vector<float, Shape.dimensions+isArray> location, constexpr vector<int, Shape.planeDimensions> offset, float clamp, out uint status)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        status = 0;\n")
SLANG_RAW("        return Sample(s, location, offset, clamp);\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    T SampleBias(SamplerState s, vector<float, Shape.dimensions+isArray> location, float bias)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("            case cpp:\n")
SLANG_RAW("            case hlsl:\n")
SLANG_RAW("            __intrinsic_asm \".SampleBias\";\n")
SLANG_RAW("            case glsl:\n")
SLANG_RAW("            __intrinsic_asm \"$ctexture($p, $2, $3)$z\";\n")
SLANG_RAW("            case spirv:\n")
SLANG_RAW("            return spirv_asm\n")
SLANG_RAW("            {\n")
SLANG_RAW("                %sampledImage : __sampledImageType(this) = OpSampledImage $this $s;\n")
SLANG_RAW("                %sampled : __sampledType(T) = OpImageSampleImplicitLod %sampledImage $location None|Bias $bias;\n")
SLANG_RAW("                __truncate $$T result __sampledType(T) %sampled;\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    T SampleBias(SamplerState s, vector<float, Shape.dimensions+isArray> location, float bias, constexpr vector<int, Shape.planeDimensions> offset)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("            case cpp:\n")
SLANG_RAW("            case hlsl:\n")
SLANG_RAW("            __intrinsic_asm \".SampleBias\";\n")
SLANG_RAW("            case glsl:\n")
SLANG_RAW("            __intrinsic_asm \"$ctextureOffset($p, $2, $4, $3)$z\";\n")
SLANG_RAW("            case spirv:\n")
SLANG_RAW("            return spirv_asm\n")
SLANG_RAW("            {\n")
SLANG_RAW("                %sampledImage : __sampledImageType(this) = OpSampledImage $this $s;\n")
SLANG_RAW("                %sampled : __sampledType(T) = OpImageSampleImplicitLod %sampledImage $location None|Bias|ConstOffset $bias $offset;\n")
SLANG_RAW("                __truncate $$T result __sampledType(T) %sampled;\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(glsl, \"texture($p, $2)\")\n")
SLANG_RAW("    float __glsl_texture(SamplerComparisonState s, vector<float, Shape.dimensions+isArray+1> value);\n")
SLANG_RAW("\n")
SLANG_RAW("    __glsl_extension(GL_EXT_texture_shadow_lod)\n")
SLANG_RAW("    __target_intrinsic(glsl, \"textureOffset($p, $2, $3)\")\n")
SLANG_RAW("    float __glsl_texture_offset(SamplerComparisonState s, vector<float, Shape.dimensions+isArray+1> value, constexpr vector<int, Shape.planeDimensions> offset);\n")
SLANG_RAW("\n")
SLANG_RAW("    __glsl_extension(GL_EXT_texture_shadow_lod)\n")
SLANG_RAW("    __target_intrinsic(glsl, \"textureLod($p, $2, 0)\")\n")
SLANG_RAW("    float __glsl_texture_level_zero(SamplerComparisonState s, vector<float, Shape.dimensions+isArray+1> value);\n")
SLANG_RAW("\n")
SLANG_RAW("    __glsl_extension(GL_EXT_texture_shadow_lod)\n")
SLANG_RAW("    __target_intrinsic(glsl, \"textureLodOffset($p, $2, 0, $3)\")\n")
SLANG_RAW("    float __glsl_texture_offset_level_zero(SamplerComparisonState s, vector<float, Shape.dimensions+isArray+1> value, constexpr vector<int, Shape.planeDimensions> offset);\n")
SLANG_RAW("\n")
SLANG_RAW("    [__readNone] [ForceInline]\n")
SLANG_RAW("    float SampleCmp(SamplerComparisonState s, vector<float, Shape.dimensions+isArray> location, float compareValue)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("            return __glsl_texture(s, __makeVector(location,compareValue));\n")
SLANG_RAW("        case hlsl:\n")
SLANG_RAW("            __intrinsic_asm \".SampleCmp\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            return spirv_asm\n")
SLANG_RAW("            {\n")
SLANG_RAW("                %sampledImage : __sampledImageType(this) = OpSampledImage $this $s;\n")
SLANG_RAW("                result:$$float = OpImageSampleDrefImplicitLod %sampledImage $location $compareValue;\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__readNone] [ForceInline]\n")
SLANG_RAW("    float SampleCmpLevelZero(SamplerComparisonState s, vector<float, Shape.dimensions+isArray> location, float compareValue)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("            return __glsl_texture_level_zero(s, __makeVector(location,compareValue));\n")
SLANG_RAW("        case hlsl:\n")
SLANG_RAW("            __intrinsic_asm \".SampleCmpLevelZero\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            const float zeroFloat = 0.0f;\n")
SLANG_RAW("            return spirv_asm\n")
SLANG_RAW("            {\n")
SLANG_RAW("                %sampledImage : __sampledImageType(this) = OpSampledImage $this $s;\n")
SLANG_RAW("                result:$$float = OpImageSampleDrefExplicitLod %sampledImage $location $compareValue Lod $zeroFloat;\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__readNone] [ForceInline]\n")
SLANG_RAW("    float SampleCmp(SamplerComparisonState s, vector<float, Shape.dimensions+isArray> location, float compareValue, constexpr vector<int, Shape.planeDimensions> offset)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("            return __glsl_texture_offset(s, __makeVector(location,compareValue), offset);\n")
SLANG_RAW("        case hlsl:\n")
SLANG_RAW("            __intrinsic_asm \".SampleCmp\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            return spirv_asm\n")
SLANG_RAW("            {\n")
SLANG_RAW("                %sampledImage : __sampledImageType(this) = OpSampledImage $this $s;\n")
SLANG_RAW("                result:$$float = OpImageSampleDrefImplicitLod %sampledImage $location $compareValue ConstOffset $offset;\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__readNone] [ForceInline]\n")
SLANG_RAW("    float SampleCmpLevelZero(SamplerComparisonState s, vector<float, Shape.dimensions+isArray> location, float compareValue, constexpr vector<int, Shape.planeDimensions> offset)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("            return __glsl_texture_offset_level_zero(s, __makeVector(location,compareValue), offset);\n")
SLANG_RAW("        case hlsl:\n")
SLANG_RAW("            __intrinsic_asm \".SampleCmpLevelZero\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            const float zeroFloat = 0.0f;\n")
SLANG_RAW("            return spirv_asm\n")
SLANG_RAW("            {\n")
SLANG_RAW("                %sampledImage : __sampledImageType(this) = OpSampledImage $this $s;\n")
SLANG_RAW("                result:$$float = OpImageSampleDrefExplicitLod %sampledImage $location $compareValue Lod|ConstOffset $zeroFloat $offset;\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    T SampleGrad(SamplerState s, vector<float, Shape.dimensions+isArray> location, vector<float, Shape.planeDimensions> gradX, vector<float, Shape.planeDimensions> gradY)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("            case cpp:\n")
SLANG_RAW("            case hlsl:\n")
SLANG_RAW("            __intrinsic_asm \".SampleGrad\";\n")
SLANG_RAW("            case glsl:\n")
SLANG_RAW("            __intrinsic_asm \"$ctextureGrad($p, $2, $3, $4)$z\";\n")
SLANG_RAW("            case spirv:\n")
SLANG_RAW("                return spirv_asm\n")
SLANG_RAW("                {\n")
SLANG_RAW("                    %sampledImage : __sampledImageType(this) = OpSampledImage $this $s;\n")
SLANG_RAW("                    %sampled : __sampledType(T) = OpImageSampleExplicitLod %sampledImage $location None|Grad $gradX $gradY;\n")
SLANG_RAW("                    __truncate $$T result __sampledType(T) %sampled;\n")
SLANG_RAW("                };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    T SampleGrad(SamplerState s, vector<float, Shape.dimensions+isArray> location, vector<float, Shape.planeDimensions> gradX, vector<float, Shape.planeDimensions> gradY, constexpr vector<int, Shape.planeDimensions> offset)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("            case cpp:\n")
SLANG_RAW("            case hlsl:\n")
SLANG_RAW("            __intrinsic_asm \".SampleGrad\";\n")
SLANG_RAW("            case glsl:\n")
SLANG_RAW("            __intrinsic_asm \"$ctextureGradOffset($p, $2, $3, $4, $5)$z\";\n")
SLANG_RAW("            case spirv:\n")
SLANG_RAW("                return spirv_asm\n")
SLANG_RAW("                {\n")
SLANG_RAW("                    %sampledImage : __sampledImageType(this) = OpSampledImage $this $s;\n")
SLANG_RAW("                    %sampled : __sampledType(T) = OpImageSampleExplicitLod %sampledImage $location None|Grad|ConstOffset $gradX $gradY $offset;\n")
SLANG_RAW("                    __truncate $$T result __sampledType(T) %sampled;\n")
SLANG_RAW("\n")
SLANG_RAW("                };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    __glsl_extension(GL_ARB_sparse_texture_clamp)\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    T SampleGrad(SamplerState s, vector<float, Shape.dimensions+isArray> location, vector<float, Shape.planeDimensions> gradX, vector<float, Shape.planeDimensions> gradY, constexpr vector<int, Shape.planeDimensions> offset, float lodClamp)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("            case cpp:\n")
SLANG_RAW("            case hlsl:\n")
SLANG_RAW("            __intrinsic_asm \".SampleGrad\";\n")
SLANG_RAW("            case glsl:\n")
SLANG_RAW("            __intrinsic_asm \"$ctextureGradOffsetClampARB($p, $2, $3, $4, $5, $6)$z\";\n")
SLANG_RAW("            case spirv:\n")
SLANG_RAW("                return spirv_asm\n")
SLANG_RAW("                {\n")
SLANG_RAW("                    OpCapability MinLod;\n")
SLANG_RAW("                    %sampledImage : __sampledImageType(this) = OpSampledImage $this $s;\n")
SLANG_RAW("                    %sampled : __sampledType(T) = OpImageSampleExplicitLod %sampledImage $location None|Grad|ConstOffset|MinLod $gradX $gradY $offset $lodClamp;\n")
SLANG_RAW("                    __truncate $$T result __sampledType(T) %sampled;\n")
SLANG_RAW("                };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    T SampleLevel(SamplerState s, vector<float, Shape.dimensions+isArray> location, float level)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("            case cpp:\n")
SLANG_RAW("            case hlsl:\n")
SLANG_RAW("                __intrinsic_asm \".SampleLevel\";\n")
SLANG_RAW("            case glsl:\n")
SLANG_RAW("                __intrinsic_asm \"$ctextureLod($p, $2, $3)$z\";\n")
SLANG_RAW("            case cuda:\n")
SLANG_RAW("                if (isArray != 0)\n")
SLANG_RAW("                {\n")
SLANG_RAW("                    switch(Shape.flavor)\n")
SLANG_RAW("                    {\n")
SLANG_RAW("                    case ")
SLANG_SPLICE(SLANG_TEXTURE_1D
)
SLANG_RAW(":\n")
SLANG_RAW("                        __intrinsic_asm \"tex1DLayeredLod<$T0>($0, ($2).x, int(($2).y), ($3))\";\n")
SLANG_RAW("                    case ")
SLANG_SPLICE(SLANG_TEXTURE_2D
)
SLANG_RAW(":\n")
SLANG_RAW("                        __intrinsic_asm \"tex2DLayeredLod<$T0>($0, ($2).x, ($2).y, int(($2).z), ($3))\";\n")
SLANG_RAW("                    case ")
SLANG_SPLICE(SLANG_TEXTURE_CUBE
)
SLANG_RAW(":\n")
SLANG_RAW("                        __intrinsic_asm \"texCubemapLayeredLod<$T0>($0, ($2).x, ($2).y, ($2).z, int(($2).w), ($3))\";\n")
SLANG_RAW("                    default:\n")
SLANG_RAW("                        __intrinsic_asm \"<invalid intrinsic>\";\n")
SLANG_RAW("                    }\n")
SLANG_RAW("                }\n")
SLANG_RAW("                else\n")
SLANG_RAW("                {\n")
SLANG_RAW("                    switch(Shape.flavor)\n")
SLANG_RAW("                    {\n")
SLANG_RAW("                    case ")
SLANG_SPLICE(SLANG_TEXTURE_1D
)
SLANG_RAW(":\n")
SLANG_RAW("                        __intrinsic_asm \"tex1DLod<$T0>($0, ($2), ($3))\";\n")
SLANG_RAW("                    case ")
SLANG_SPLICE(SLANG_TEXTURE_2D
)
SLANG_RAW(":\n")
SLANG_RAW("                        __intrinsic_asm \"tex2DLod<$T0>($0, ($2).x, ($2).y, ($3))\";\n")
SLANG_RAW("                    case ")
SLANG_SPLICE(SLANG_TEXTURE_3D
)
SLANG_RAW(":\n")
SLANG_RAW("                        __intrinsic_asm \"tex3DLod<$T0>($0, ($2).x, ($2).y, ($2).z, ($3))\";\n")
SLANG_RAW("                    case ")
SLANG_SPLICE(SLANG_TEXTURE_CUBE
)
SLANG_RAW(":\n")
SLANG_RAW("                        __intrinsic_asm \"texCubemapLod<$T0>($0, ($2).x, ($2).y, ($2).z, ($3))\";\n")
SLANG_RAW("                    }\n")
SLANG_RAW("                }\n")
SLANG_RAW("            case spirv:\n")
SLANG_RAW("            return spirv_asm\n")
SLANG_RAW("            {\n")
SLANG_RAW("                %sampledImage : __sampledImageType(this) = OpSampledImage $this $s;\n")
SLANG_RAW("                %sampled : __sampledType(T) = OpImageSampleExplicitLod %sampledImage $location None|Lod $level;\n")
SLANG_RAW("                __truncate $$T result __sampledType(T) %sampled;\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    T SampleLevel(SamplerState s, vector<float, Shape.dimensions+isArray> location, float level, constexpr vector<int, Shape.planeDimensions> offset)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("            case cpp:\n")
SLANG_RAW("            case hlsl:\n")
SLANG_RAW("                __intrinsic_asm \".SampleLevel\";\n")
SLANG_RAW("            case glsl:\n")
SLANG_RAW("                __intrinsic_asm \"$ctextureLodOffset($p, $2, $3, $4)$z\";\n")
SLANG_RAW("            case spirv:\n")
SLANG_RAW("                return spirv_asm\n")
SLANG_RAW("                {\n")
SLANG_RAW("                    %sampledImage : __sampledImageType(this) = OpSampledImage $this $s;\n")
SLANG_RAW("                    %sampled : __sampledType(T) = OpImageSampleExplicitLod %sampledImage $location None|Lod|ConstOffset $level $offset;\n")
SLANG_RAW("                    __truncate $$T result __sampledType(T) %sampled;\n")
SLANG_RAW("                };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Texture.GetDimensions\n")

const char* kTextureShapeTypeNames[] = {
    "__Shape1D", "__Shape2D", "__Shape3D", "__ShapeCube"};
for (int shapeIndex = 0; shapeIndex < 4; shapeIndex++)
for (int isArray = 0; isArray <= 1; isArray++)
for (int isMS = 0; isMS <= 1; isMS++) {
    if (isMS)
    {
        if (shapeIndex != kStdlibShapeIndex2D)
            continue;
    }
    if (isArray)
    {
        if (shapeIndex == kStdlibShapeIndex3D)
            continue;
    }
    auto shapeTypeName = kTextureShapeTypeNames[shapeIndex];
    TextureTypeInfo textureTypeInfo(kBaseTextureShapes[shapeIndex], isArray, isMS, 0, sb, path);
SLANG_RAW("#line 970 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T, let sampleCount:int, let access:int, let isShadow:int, let isCombined:int, let format:int>\n")
SLANG_RAW("extension __TextureImpl<T,")
SLANG_SPLICE(shapeTypeName
)
SLANG_RAW(",")
SLANG_SPLICE(isArray
)
SLANG_RAW(",")
SLANG_SPLICE(isMS
)
SLANG_RAW(",sampleCount,access,isShadow,isCombined,format>\n")
SLANG_RAW("{\n")

    textureTypeInfo.writeGetDimensionFunctions();
    
SLANG_RAW("#line 977 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")

}
SLANG_RAW("#line 982 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("// Texture.GetSamplePosition(int s);\n")
SLANG_RAW("__generic<T, Shape: __ITextureShape, let isArray:int, let sampleCount:int, let access:int, let isShadow:int, let isCombined:int, let format:int>\n")
SLANG_RAW("extension __TextureImpl<T,Shape,isArray,1,sampleCount,access,isShadow,isCombined,format>\n")
SLANG_RAW("{\n")
SLANG_RAW("    float2 GetSamplePosition(int s);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_MakeArray
)
SLANG_RAW(")\n")
SLANG_RAW("Array<T,4> __makeArray<T>(T v0, T v1, T v2, T v3);\n")
SLANG_RAW("\n")
SLANG_RAW("// Gather for scalar textures.\n")
SLANG_RAW("__generic<TElement, T, Shape: __ITextureShape, let isArray:int, let sampleCount:int, let access:int, let isShadow:int, let format:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("vector<TElement,4> __glsl_gather(__TextureImpl<T, Shape, isArray, 0, sampleCount, access, isShadow, 0, format> texture, SamplerState s, vector<float, Shape.dimensions+isArray> location, int component)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"textureGather($p, $2, $3)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            %sampledImage : __sampledImageType(texture) = OpSampledImage $texture $s;\n")
SLANG_RAW("            result:$$vector<TElement,4> = OpImageGather %sampledImage $location $component;\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<TElement, T, Shape: __ITextureShape, let isArray:int, let sampleCount:int, let access:int, let isShadow:int, let format:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("vector<TElement,4> __glsl_gather_offset(__TextureImpl<T, Shape, isArray, 0, sampleCount, access, isShadow, 0, format> texture, SamplerState s, vector<float, Shape.dimensions+isArray> location, int component, vector<int, Shape.planeDimensions> offset)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"textureGatherOffset($p, $2, $3, $4)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            %sampledImage : __sampledImageType(texture) = OpSampledImage $texture $s;\n")
SLANG_RAW("            result:$$vector<TElement,4> = OpImageGather %sampledImage $location $component ConstOffset $offset;\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<TElement, T, Shape: __ITextureShape, let isArray:int, let sampleCount:int, let access:int, let isShadow:int, let format:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("vector<TElement,4> __glsl_gather_offsets(__TextureImpl<T, Shape, isArray, 0, sampleCount, access, isShadow, 0, format> texture, SamplerState s, vector<float, Shape.dimensions+isArray> location, int component,\n")
SLANG_RAW("    vector<int, Shape.planeDimensions> offset1,\n")
SLANG_RAW("    vector<int, Shape.planeDimensions> offset2,\n")
SLANG_RAW("    vector<int, Shape.planeDimensions> offset3,\n")
SLANG_RAW("    vector<int, Shape.planeDimensions> offset4)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"textureGatherOffsets($p, $2, $3, $T4[]($4, $5, $6, $7))\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        let offsets = __makeArray(offset1,offset2,offset3,offset4);\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            OpCapability ImageGatherExtended;\n")
SLANG_RAW("            %sampledImage : __sampledImageType(texture) = OpSampledImage $texture $s;\n")
SLANG_RAW("            result:$$vector<TElement,4> = OpImageGather %sampledImage $location $component ConstOffsets $offsets;\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<TElement, T, Shape: __ITextureShape, let isArray:int, let sampleCount:int, let access:int, let isShadow:int, let format:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("vector<TElement,4> __glsl_gatherCmp(__TextureImpl<T, Shape, isArray, 0, sampleCount, access, isShadow, 0, format> texture, SamplerComparisonState s, vector<float, Shape.dimensions+isArray> location, int componentIndex, TElement compareValue)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"textureGather($p, $2, $4)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            %sampledImage : __sampledImageType(texture) = OpSampledImage $texture $s;\n")
SLANG_RAW("            result:$$vector<TElement,4> = OpImageDrefGather %sampledImage $location $compareValue;\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<TElement, T, Shape: __ITextureShape, let isArray:int, let sampleCount:int, let access:int, let isShadow:int, let format:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("vector<TElement,4> __glsl_gatherCmp_offset(__TextureImpl<T, Shape, isArray, 0, sampleCount, access, isShadow, 0, format> texture, SamplerComparisonState s, vector<float, Shape.dimensions+isArray> location, int componentIndex, TElement compareValue, vector<int, Shape.planeDimensions> offset)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"textureGatherOffset($p, $2, $4, $5)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            %sampledImage : __sampledImageType(texture) = OpSampledImage $texture $s;\n")
SLANG_RAW("            result:$$vector<TElement,4> = OpImageDrefGather %sampledImage $location $compareValue ConstOffset $offset;\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<TElement, T, Shape: __ITextureShape, let isArray:int, let sampleCount:int, let access:int, let isShadow:int, let format:int>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("vector<TElement,4> __glsl_gatherCmp_offsets(__TextureImpl<T, Shape, isArray, 0, sampleCount, access, isShadow, 0, format> texture, SamplerComparisonState s, vector<float, Shape.dimensions+isArray> location, int componentIndex, TElement compareValue,\n")
SLANG_RAW("    vector<int, Shape.planeDimensions> offset1,\n")
SLANG_RAW("    vector<int, Shape.planeDimensions> offset2,\n")
SLANG_RAW("    vector<int, Shape.planeDimensions> offset3,\n")
SLANG_RAW("    vector<int, Shape.planeDimensions> offset4\n")
SLANG_RAW("    )\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"textureGatherOffsets($p, $2, $4, $T5[]($5, $6, $7, $8))\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        let offsets = __makeArray(offset1,offset2,offset3,offset4);\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            OpCapability ImageGatherExtended;\n")
SLANG_RAW("            %sampledImage : __sampledImageType(texture) = OpSampledImage $texture $s;\n")
SLANG_RAW("            result:$$vector<TElement,4> = OpImageDrefGather %sampledImage $location $compareValue ConstOffsets $offsets;\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")

for (int isScalarTexture = 0; isScalarTexture <= 1; isScalarTexture++) {
    if (isScalarTexture == 0)
    {
        sb << "__generic<T:__BuiltinArithmeticType, Shape: __ITextureShape, let isArray:int, let sampleCount:int, let isShadow:int, let format:int>\n";
        sb << "extension __TextureImpl<T,Shape,isArray,0,sampleCount,0,isShadow,0,format>\n";
    }
    else
    {
        sb << "__generic<T:__BuiltinArithmeticType, let N:int, Shape: __ITextureShape, let isArray:int, let sampleCount:int, let isShadow:int, let format:int>\n";
        sb << "extension __TextureImpl<vector<T,N>,Shape,isArray,0,sampleCount,0,isShadow,0,format>\n";
    }
SLANG_RAW("#line 1111 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("{ // begin extension for gather\n")

    // Gather component
    for (int isCmp = 0; isCmp <= 1; ++isCmp) {
        const char* cmp = isCmp ? "Cmp" : "";
        const char* cmpParam = isCmp? "T compareValue, " : "";
        const char* compareArg = isCmp ? "compareValue, " : "";
        const char* samplerStateType = isCmp ? "SamplerComparisonState" : "SamplerState";
        const char* componentNames[] = {"", "Red", "Green", "Blue", "Alpha"};
        for (auto componentId = 0;  componentId < 4; componentId++) {
            auto component = componentNames[componentId];
            auto componentIndex = componentId == 0 ? 0 : componentId - 1;
    
SLANG_RAW("#line 1124 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    vector<T,4> Gather")
SLANG_SPLICE(cmp
)
SLANG_SPLICE(component
)
SLANG_RAW("(")
SLANG_SPLICE(samplerStateType
)
SLANG_RAW(" s, vector<float, Shape.dimensions+isArray> location, ")
SLANG_SPLICE(cmpParam
)
SLANG_RAW(")\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".Gather")
SLANG_SPLICE(cmp
)
SLANG_SPLICE(component
)
SLANG_RAW("\";\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            return __glsl_gather")
SLANG_SPLICE(cmp
)
SLANG_RAW("<T>(this, s, location, ")
SLANG_SPLICE(componentIndex
)
SLANG_RAW(", ")
SLANG_SPLICE(compareArg
)
SLANG_RAW(");\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    vector<T,4> Gather")
SLANG_SPLICE(cmp
)
SLANG_SPLICE(component
)
SLANG_RAW("(")
SLANG_SPLICE(samplerStateType
)
SLANG_RAW(" s, vector<float, Shape.dimensions+isArray> location, ")
SLANG_SPLICE(cmpParam
)
SLANG_RAW(" vector<int, Shape.planeDimensions> offset)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".Gather")
SLANG_SPLICE(cmp
)
SLANG_SPLICE(component
)
SLANG_RAW("\";\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            return __glsl_gather")
SLANG_SPLICE(cmp
)
SLANG_RAW("_offset<T>(this, s, location, ")
SLANG_SPLICE(componentIndex
)
SLANG_RAW(", ")
SLANG_SPLICE(compareArg
)
SLANG_RAW(" offset);\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    vector<T,4> Gather")
SLANG_SPLICE(cmp
)
SLANG_SPLICE(component
)
SLANG_RAW("(")
SLANG_SPLICE(samplerStateType
)
SLANG_RAW(" s, vector<float, Shape.dimensions+isArray> location, ")
SLANG_SPLICE(cmpParam
)
SLANG_RAW("\n")
SLANG_RAW("        vector<int, Shape.planeDimensions> offset1,\n")
SLANG_RAW("        vector<int, Shape.planeDimensions> offset2,\n")
SLANG_RAW("        vector<int, Shape.planeDimensions> offset3,\n")
SLANG_RAW("        vector<int, Shape.planeDimensions> offset4)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".Gather")
SLANG_SPLICE(cmp
)
SLANG_SPLICE(component
)
SLANG_RAW("\";\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            return __glsl_gather")
SLANG_SPLICE(cmp
)
SLANG_RAW("_offsets<T>(this, s, location, ")
SLANG_SPLICE(componentIndex
)
SLANG_RAW(", ")
SLANG_SPLICE(compareArg
)
SLANG_RAW(" offset1,offset2,offset3,offset4);\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")

    } // for (component)
    } // for (isCmp)
    
SLANG_RAW("#line 1165 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("} // end extension for gather\n")
SLANG_RAW("\n")

} // for (isScalarTexture)
SLANG_RAW("#line 1170 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("// Load/Subscript for readonly, no MS textures\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T, Shape: __ITextureShape, let isArray:int, let sampleCount:int, let isShadow:int, let isCombined:int, let format:int>\n")
SLANG_RAW("extension __TextureImpl<T,Shape,isArray,0,sampleCount,0,isShadow,isCombined,format>\n")
SLANG_RAW("{\n")
SLANG_RAW("    static const int isMS = 0;\n")
SLANG_RAW("    static const int access = ")
SLANG_SPLICE(kStdlibResourceAccessReadOnly
)
SLANG_RAW(";\n")
SLANG_RAW("\n")
SLANG_RAW("    __glsl_extension(GL_EXT_samplerless_texture_functions)\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    T __glsl_load(vector<int, Shape.dimensions+isArray> location)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __intrinsic_asm \"$ctexelFetch($0, ($1), 0)$z\";\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    __glsl_extension(GL_EXT_samplerless_texture_functions)\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    T Load(vector<int, Shape.dimensions+isArray+1> location)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case cpp:\n")
SLANG_RAW("        case hlsl:\n")
SLANG_RAW("            __intrinsic_asm \".Load\";\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("            __intrinsic_asm \"$ctexelFetch($0, ($1).$w1b, ($1).$w1e)$z\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            const int lodLoc = Shape.dimensions+isArray;\n")
SLANG_RAW("            let coord = __vectorReshape<Shape.dimensions+isArray>(location);\n")
SLANG_RAW("            let lod = location[lodLoc];\n")
SLANG_RAW("            if (isCombined != 0)\n")
SLANG_RAW("            {\n")
SLANG_RAW("                return spirv_asm\n")
SLANG_RAW("                {\n")
SLANG_RAW("                    %image:__imageType(this) = OpImage $this;\n")
SLANG_RAW("                    %sampled:__sampledType(T) = OpImageFetch %image $coord Lod $lod;\n")
SLANG_RAW("                    __truncate $$T result __sampledType(T) %sampled;\n")
SLANG_RAW("                };\n")
SLANG_RAW("            }\n")
SLANG_RAW("            else\n")
SLANG_RAW("            {\n")
SLANG_RAW("                return spirv_asm\n")
SLANG_RAW("                {\n")
SLANG_RAW("                    %sampled:__sampledType(T) = OpImageFetch $this $coord Lod $lod;\n")
SLANG_RAW("                    __truncate $$T result __sampledType(T) %sampled;\n")
SLANG_RAW("                };\n")
SLANG_RAW("            }\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    __glsl_extension(GL_EXT_samplerless_texture_functions)\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    T Load(vector<int, Shape.dimensions+isArray+1> location, constexpr vector<int, Shape.planeDimensions> offset)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("            case cpp:\n")
SLANG_RAW("            case hlsl:\n")
SLANG_RAW("            __intrinsic_asm \".Load\";\n")
SLANG_RAW("            case glsl:\n")
SLANG_RAW("            __intrinsic_asm \"$ctexelFetchOffset($0, ($1).$w1b, ($1).$w1e, ($2))$z\";\n")
SLANG_RAW("            case spirv:\n")
SLANG_RAW("                const int lodLoc = Shape.dimensions+isArray;\n")
SLANG_RAW("                let coord = __vectorReshape<Shape.dimensions+isArray>(location);\n")
SLANG_RAW("                let lod = location[lodLoc];\n")
SLANG_RAW("                if (isCombined != 0)\n")
SLANG_RAW("                {\n")
SLANG_RAW("                    return spirv_asm\n")
SLANG_RAW("                    {\n")
SLANG_RAW("                        %image:__imageType(this) = OpImage $this;\n")
SLANG_RAW("                        %sampled:__sampledType(T) = OpImageFetch %image $coord Lod|ConstOffset $lod $offset;\n")
SLANG_RAW("                        __truncate $$T result __sampledType(T) %sampled;\n")
SLANG_RAW("                    };\n")
SLANG_RAW("                }\n")
SLANG_RAW("                else\n")
SLANG_RAW("                {\n")
SLANG_RAW("                    return spirv_asm\n")
SLANG_RAW("                    {\n")
SLANG_RAW("                        %sampled:__sampledType(T) = OpImageFetch $this $coord Lod|ConstOffset $lod $offset;\n")
SLANG_RAW("                        __truncate $$T result __sampledType(T) %sampled;\n")
SLANG_RAW("                    };\n")
SLANG_RAW("                }\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    __target_intrinsic(hlsl)\n")
SLANG_RAW("    T Load(vector<int, Shape.dimensions+isArray+1> location, constexpr vector<int, Shape.planeDimensions> offset, out uint status)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        status = 0;\n")
SLANG_RAW("        return Load(location, offset);\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    __subscript(vector<uint, Shape.dimensions+isArray> location) -> T\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __glsl_extension(GL_EXT_samplerless_texture_functions)\n")
SLANG_RAW("        [__readNone]\n")
SLANG_RAW("        [ForceInline]\n")
SLANG_RAW("        get\n")
SLANG_RAW("        {\n")
SLANG_RAW("            __target_switch\n")
SLANG_RAW("            {\n")
SLANG_RAW("                case cpp:\n")
SLANG_RAW("                case hlsl:\n")
SLANG_RAW("                    __intrinsic_asm \".operator[]\";\n")
SLANG_RAW("                case glsl:\n")
SLANG_RAW("                    return __glsl_load(location);\n")
SLANG_RAW("                case spirv:\n")
SLANG_RAW("                    if (isCombined != 0)\n")
SLANG_RAW("                    {\n")
SLANG_RAW("                        return spirv_asm\n")
SLANG_RAW("                        {\n")
SLANG_RAW("                            %image:__imageType(this) = OpImage $this;\n")
SLANG_RAW("                            %sampled:__sampledType(T) = OpImageFetch %image $location;\n")
SLANG_RAW("                            __truncate $$T result __sampledType(T) %sampled;\n")
SLANG_RAW("                        };\n")
SLANG_RAW("                    }\n")
SLANG_RAW("                    else\n")
SLANG_RAW("                    {\n")
SLANG_RAW("                        return spirv_asm\n")
SLANG_RAW("                        {\n")
SLANG_RAW("                            %sampled:__sampledType(T) = OpImageFetch $this $location;\n")
SLANG_RAW("                            __truncate $$T result __sampledType(T) %sampled;\n")
SLANG_RAW("                        };\n")
SLANG_RAW("                    }\n")
SLANG_RAW("            }\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Texture Load/Subscript for readonly, MS textures\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T, Shape: __ITextureShape, let isArray:int, let sampleCount:int, let isShadow:int, let isCombined:int, let format:int>\n")
SLANG_RAW("extension __TextureImpl<T,Shape,isArray,1,sampleCount,0,isShadow,isCombined,format>\n")
SLANG_RAW("{\n")
SLANG_RAW("    static const int access = ")
SLANG_SPLICE(kStdlibResourceAccessReadOnly
)
SLANG_RAW(";\n")
SLANG_RAW("    static const int isMS = 1;\n")
SLANG_RAW("\n")
SLANG_RAW("    __glsl_extension(GL_EXT_samplerless_texture_functions)\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    T Load(vector<int, Shape.dimensions+isArray> location, int sampleIndex)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("            case cpp:\n")
SLANG_RAW("            case hlsl:\n")
SLANG_RAW("            __intrinsic_asm \".Load\";\n")
SLANG_RAW("            case glsl:\n")
SLANG_RAW("                __intrinsic_asm \"$ctexelFetch($0, $1, ($2))$z\";\n")
SLANG_RAW("            case spirv:\n")
SLANG_RAW("                if (isCombined != 0)\n")
SLANG_RAW("                {\n")
SLANG_RAW("                    return spirv_asm\n")
SLANG_RAW("                    {\n")
SLANG_RAW("                        %image:__imageType(this) = OpImage $this;\n")
SLANG_RAW("                        %sampled:__sampledType(T) = OpImageFetch %image $location Sample $sampleIndex;\n")
SLANG_RAW("                        __truncate $$T result __sampledType(T) %sampled;\n")
SLANG_RAW("                    };\n")
SLANG_RAW("                }\n")
SLANG_RAW("                else\n")
SLANG_RAW("                {\n")
SLANG_RAW("                    return spirv_asm\n")
SLANG_RAW("                    {\n")
SLANG_RAW("                        %sampled:__sampledType(T) = OpImageFetch $this $location Sample $sampleIndex;\n")
SLANG_RAW("                        __truncate $$T result __sampledType(T) %sampled;\n")
SLANG_RAW("                    };\n")
SLANG_RAW("                }\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    __glsl_extension(GL_EXT_samplerless_texture_functions)\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    T Load(vector<int, Shape.dimensions+isArray> location, int sampleIndex, constexpr vector<int, Shape.planeDimensions> offset)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("            case cpp:\n")
SLANG_RAW("            case hlsl:\n")
SLANG_RAW("            __intrinsic_asm \".Load\";\n")
SLANG_RAW("            case glsl:\n")
SLANG_RAW("            __intrinsic_asm \"$ctexelFetchOffset($0, $1, ($2), ($3))$z\";\n")
SLANG_RAW("            case spirv:\n")
SLANG_RAW("                if (isCombined != 0)\n")
SLANG_RAW("                {\n")
SLANG_RAW("                    return spirv_asm\n")
SLANG_RAW("                    {\n")
SLANG_RAW("                        %image:__imageType(this) = OpImage $this;\n")
SLANG_RAW("                        %sampled:__sampledType(T) = OpImageFetch %image $location ConstOffset|Sample $offset $sampleIndex;\n")
SLANG_RAW("                        __truncate $$T result __sampledType(T) %sampled;\n")
SLANG_RAW("                    };\n")
SLANG_RAW("                }\n")
SLANG_RAW("                else\n")
SLANG_RAW("                {\n")
SLANG_RAW("                    return spirv_asm\n")
SLANG_RAW("                    {\n")
SLANG_RAW("                        %sampled:__sampledType(T) = OpImageFetch $this $location ConstOffset|Sample $offset  $sampleIndex;\n")
SLANG_RAW("                        __truncate $$T result __sampledType(T) %sampled;\n")
SLANG_RAW("                    };\n")
SLANG_RAW("                }\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    __target_intrinsic(hlsl)\n")
SLANG_RAW("    T Load(vector<int, Shape.dimensions+isArray> location, int sampleIndex, constexpr vector<int, Shape.planeDimensions> offset, out uint status)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        status = 0;\n")
SLANG_RAW("        return Load(location, sampleIndex, offset);\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    __subscript(vector<uint, Shape.dimensions+isArray> location, int sampleIndex) -> T\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __glsl_extension(GL_EXT_samplerless_texture_functions)\n")
SLANG_RAW("        [__readNone]\n")
SLANG_RAW("        [ForceInline]\n")
SLANG_RAW("        get\n")
SLANG_RAW("        {\n")
SLANG_RAW("            __target_switch\n")
SLANG_RAW("            {\n")
SLANG_RAW("                case cpp:\n")
SLANG_RAW("                case hlsl:\n")
SLANG_RAW("                    __intrinsic_asm \"($0).sample[$2][$1]\";\n")
SLANG_RAW("                case glsl:\n")
SLANG_RAW("                case spirv:\n")
SLANG_RAW("                case cuda:\n")
SLANG_RAW("                    return Load(location, sampleIndex);\n")
SLANG_RAW("            }\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Load/Subscript for readwrite textures\n")

    for (int access = kStdlibResourceAccessReadWrite; access<=kStdlibResourceAccessRasterizerOrdered; access++) {
        const char* glslIntrinsic = "$cimageLoad($0, $1)$z";
        const char* glslIntrinsicOffset = "$cimageLoad($0, ($1)+($2))$z";
        const char* glslIntrinsicMS = "$cimageLoad($0, $1, $2)$z";
        const char* glslIntrinsicMSOffset = "$cimageLoad($0, ($1)+($3), $2)$z";
SLANG_RAW("#line 1416 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("__generic<T, Shape: __ITextureShape, let isArray:int, let sampleCount:int, let isShadow:int, let format:int>\n")
SLANG_RAW("extension __TextureImpl<T,Shape,isArray,0,sampleCount,")
SLANG_SPLICE(access
)
SLANG_RAW(",isShadow, 0,format>\n")
SLANG_RAW("{\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    T Load(vector<int, Shape.dimensions+isArray> location)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("            case cpp:\n")
SLANG_RAW("            case hlsl:\n")
SLANG_RAW("                __intrinsic_asm \".Load\";\n")
SLANG_RAW("            case glsl:\n")
SLANG_RAW("                __intrinsic_asm \"")
SLANG_SPLICE(glslIntrinsic
)
SLANG_RAW("\";\n")
SLANG_RAW("            case cuda:\n")
SLANG_RAW("                if (isArray != 0)\n")
SLANG_RAW("                {\n")
SLANG_RAW("                    switch(Shape.flavor)\n")
SLANG_RAW("                    {\n")
SLANG_RAW("                    case ")
SLANG_SPLICE(SLANG_TEXTURE_1D
)
SLANG_RAW(":\n")
SLANG_RAW("                        __intrinsic_asm \"surf1DLayeredread$C<$T0>($0, ($1).x * $E, ($1).y, SLANG_CUDA_BOUNDARY_MODE)\";\n")
SLANG_RAW("                    case ")
SLANG_SPLICE(SLANG_TEXTURE_2D
)
SLANG_RAW(":\n")
SLANG_RAW("                        __intrinsic_asm \"surf2DLayeredread$C<$T0>($0, ($1).x * $E, ($1).y, ($1).z, SLANG_CUDA_BOUNDARY_MODE)\";\n")
SLANG_RAW("                    case ")
SLANG_SPLICE(SLANG_TEXTURE_3D
)
SLANG_RAW(":\n")
SLANG_RAW("                        __intrinsic_asm \"surf3DLayeredread$C<$T0>($0, ($1).x * $E, ($1).y, ($1).z, ($1).w, SLANG_CUDA_BOUNDARY_MODE)\";\n")
SLANG_RAW("                    default:\n")
SLANG_RAW("                        __intrinsic_asm \"<invalid intrinsic>\";\n")
SLANG_RAW("                    }\n")
SLANG_RAW("                }\n")
SLANG_RAW("                else\n")
SLANG_RAW("                {\n")
SLANG_RAW("                    switch(Shape.flavor)\n")
SLANG_RAW("                    {\n")
SLANG_RAW("                    case ")
SLANG_SPLICE(SLANG_TEXTURE_1D
)
SLANG_RAW(":\n")
SLANG_RAW("                        __intrinsic_asm \"surf1Dread$C<$T0>($0, ($1) * $E, SLANG_CUDA_BOUNDARY_MODE)\";\n")
SLANG_RAW("                    case ")
SLANG_SPLICE(SLANG_TEXTURE_2D
)
SLANG_RAW(":\n")
SLANG_RAW("                        __intrinsic_asm \"surf2Dread$C<$T0>($0, ($1).x * $E, ($1).y, SLANG_CUDA_BOUNDARY_MODE)\";\n")
SLANG_RAW("                    case ")
SLANG_SPLICE(SLANG_TEXTURE_3D
)
SLANG_RAW(":\n")
SLANG_RAW("                        __intrinsic_asm \"surf3Dread$C<$T0>($0, ($1).x * $E, ($1).y, ($1).z, SLANG_CUDA_BOUNDARY_MODE)\";\n")
SLANG_RAW("                    default:\n")
SLANG_RAW("                        __intrinsic_asm \"<invalid intrinsic>\";\n")
SLANG_RAW("                    }\n")
SLANG_RAW("                }\n")
SLANG_RAW("            case spirv:\n")
SLANG_RAW("                return spirv_asm\n")
SLANG_RAW("                {\n")
SLANG_RAW("                    %sampled:__sampledType(T) = OpImageRead $this $location;\n")
SLANG_RAW("                    __truncate $$T result __sampledType(T) %sampled;\n")
SLANG_RAW("                };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    T Load(vector<int, Shape.dimensions+isArray> location, vector<int, Shape.dimensions+isArray> offset)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("            case cpp:\n")
SLANG_RAW("            case hlsl:\n")
SLANG_RAW("                __intrinsic_asm \".Load\";\n")
SLANG_RAW("            case glsl:\n")
SLANG_RAW("                __intrinsic_asm \"")
SLANG_SPLICE(glslIntrinsicOffset
)
SLANG_RAW("\";\n")
SLANG_RAW("            case spirv:\n")
SLANG_RAW("                return spirv_asm\n")
SLANG_RAW("                {\n")
SLANG_RAW("                    %sampled:__sampledType(T) = OpImageRead $this $location ConstOffset $offset;\n")
SLANG_RAW("                    __truncate $$T result __sampledType(T) %sampled;\n")
SLANG_RAW("                };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    T Load(vector<int, Shape.dimensions+isArray> location, vector<int, Shape.dimensions+isArray> offset, out uint status)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case hlsl:\n")
SLANG_RAW("        case cpp:\n")
SLANG_RAW("            __intrinsic_asm \".Load\";\n")
SLANG_RAW("        default:\n")
SLANG_RAW("            status = 0;\n")
SLANG_RAW("            return Load(location, offset);\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    void __glslImageStore(vector<int, Shape.dimensions+isArray> location, T value)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __intrinsic_asm \"imageStore($0, $1, $V2)\";\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    __subscript(vector<uint, Shape.dimensions+isArray> location) -> T\n")
SLANG_RAW("    {\n")
SLANG_RAW("        [__readNone]\n")
SLANG_RAW("        [ForceInline]\n")
SLANG_RAW("        get\n")
SLANG_RAW("        {\n")
SLANG_RAW("            __target_switch\n")
SLANG_RAW("            {\n")
SLANG_RAW("                case cpp:\n")
SLANG_RAW("                case hlsl:\n")
SLANG_RAW("                    __intrinsic_asm \".operator[]\";\n")
SLANG_RAW("                case glsl:\n")
SLANG_RAW("                case spirv:\n")
SLANG_RAW("                case cuda:\n")
SLANG_RAW("                    return Load(location);\n")
SLANG_RAW("            }\n")
SLANG_RAW("        }\n")
SLANG_RAW("\n")
SLANG_RAW("        [nonmutating]\n")
SLANG_RAW("        [ForceInline]\n")
SLANG_RAW("        set(T newValue)\n")
SLANG_RAW("        {\n")
SLANG_RAW("            __target_switch\n")
SLANG_RAW("            {\n")
SLANG_RAW("                case cpp:\n")
SLANG_RAW("                case hlsl:\n")
SLANG_RAW("                __intrinsic_asm \".operator[]\";\n")
SLANG_RAW("                case glsl:\n")
SLANG_RAW("                    __glslImageStore(location, newValue);\n")
SLANG_RAW("                case cuda:\n")
SLANG_RAW("                    if (isArray != 0)\n")
SLANG_RAW("                    {\n")
SLANG_RAW("                        switch(Shape.flavor)\n")
SLANG_RAW("                        {\n")
SLANG_RAW("                        case ")
SLANG_SPLICE(SLANG_TEXTURE_1D
)
SLANG_RAW(":\n")
SLANG_RAW("                            __intrinsic_asm \"surf1DLayeredwrite$C<$T0>($2, $0, ($1).x * $E, ($1).y, SLANG_CUDA_BOUNDARY_MODE)\";\n")
SLANG_RAW("                        case ")
SLANG_SPLICE(SLANG_TEXTURE_2D
)
SLANG_RAW(":\n")
SLANG_RAW("                            __intrinsic_asm \"surf2DLayeredwrite$C<$T0>($2, $0, ($1).x * $E, ($1).y, ($1).z, SLANG_CUDA_BOUNDARY_MODE)\";\n")
SLANG_RAW("                        case ")
SLANG_SPLICE(SLANG_TEXTURE_3D
)
SLANG_RAW(":\n")
SLANG_RAW("                            __intrinsic_asm \"surf3DLayeredwrite$C<$T0>($2, $0, ($1).x * $E, ($1).y, ($1).z, ($1).w, SLANG_CUDA_BOUNDARY_MODE)\";\n")
SLANG_RAW("                        default:\n")
SLANG_RAW("                            __intrinsic_asm \"<invalid intrinsic>\";\n")
SLANG_RAW("                        }\n")
SLANG_RAW("                    }\n")
SLANG_RAW("                    else\n")
SLANG_RAW("                    {\n")
SLANG_RAW("                        switch(Shape.flavor)\n")
SLANG_RAW("                        {\n")
SLANG_RAW("                        case ")
SLANG_SPLICE(SLANG_TEXTURE_1D
)
SLANG_RAW(":\n")
SLANG_RAW("                            __intrinsic_asm \"surf1Dwrite$C<$T0>($2, $0, ($1) * $E, SLANG_CUDA_BOUNDARY_MODE)\";\n")
SLANG_RAW("                        case ")
SLANG_SPLICE(SLANG_TEXTURE_2D
)
SLANG_RAW(":\n")
SLANG_RAW("                            __intrinsic_asm \"surf2Dwrite$C<$T0>($2, $0, ($1).x * $E, ($1).y, SLANG_CUDA_BOUNDARY_MODE)\";\n")
SLANG_RAW("                        case ")
SLANG_SPLICE(SLANG_TEXTURE_3D
)
SLANG_RAW(":\n")
SLANG_RAW("                            __intrinsic_asm \"surf3Dwrite$C<$T0>($2, $0, ($1).x * $E, ($1).y, ($1).z, SLANG_CUDA_BOUNDARY_MODE)\";\n")
SLANG_RAW("                        default:\n")
SLANG_RAW("                            __intrinsic_asm \"<invalid intrinsic>\";\n")
SLANG_RAW("                        }\n")
SLANG_RAW("                    }\n")
SLANG_RAW("                case spirv:\n")
SLANG_RAW("                    return spirv_asm\n")
SLANG_RAW("                    {\n")
SLANG_RAW("                        OpImageWrite $this $location $newValue;\n")
SLANG_RAW("                    };\n")
SLANG_RAW("            }\n")
SLANG_RAW("        }\n")
SLANG_RAW("\n")
SLANG_RAW("        __intrinsic_op(")
SLANG_SPLICE(kIROp_ImageSubscript
)
SLANG_RAW(") ref;\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")

if (access == kStdlibResourceAccessReadWrite) {
SLANG_RAW("#line 1581 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("// RW MS textures.\n")
SLANG_RAW("__generic<T, Shape: __ITextureShape, let isArray:int, let sampleCount:int, let isShadow:int, let format:int>\n")
SLANG_RAW("extension __TextureImpl<T,Shape,isArray,1,sampleCount,")
SLANG_SPLICE(access
)
SLANG_RAW(",isShadow, 0,format>\n")
SLANG_RAW("{\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    T Load(vector<int, Shape.dimensions+isArray> location, int sampleIndex)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("            case cpp:\n")
SLANG_RAW("            case hlsl:\n")
SLANG_RAW("                __intrinsic_asm \".Load\";\n")
SLANG_RAW("            case glsl:\n")
SLANG_RAW("                __intrinsic_asm \"")
SLANG_SPLICE(glslIntrinsicMS
)
SLANG_RAW("\";\n")
SLANG_RAW("            case spirv:\n")
SLANG_RAW("                return spirv_asm\n")
SLANG_RAW("                {\n")
SLANG_RAW("                    %sampled:__sampledType(T) = OpImageRead $this $location Sample $sampleIndex;\n")
SLANG_RAW("                    __truncate $$T result __sampledType(T) %sampled;\n")
SLANG_RAW("                };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    T Load(vector<int, Shape.dimensions+isArray> location, int sampleIndex, vector<int, Shape.dimensions+isArray> offset)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("            case cpp:\n")
SLANG_RAW("            case hlsl:\n")
SLANG_RAW("                __intrinsic_asm \".Load\";\n")
SLANG_RAW("            case glsl:\n")
SLANG_RAW("                __intrinsic_asm \"")
SLANG_SPLICE(glslIntrinsicMSOffset
)
SLANG_RAW("\";\n")
SLANG_RAW("            case spirv:\n")
SLANG_RAW("                return spirv_asm\n")
SLANG_RAW("                {\n")
SLANG_RAW("                    %sampled:__sampledType(T) = OpImageRead $this $location ConstOffset|Sample $offset $sampleIndex;\n")
SLANG_RAW("                    __truncate $$T result __sampledType(T) %sampled;\n")
SLANG_RAW("                };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    T Load(vector<int, Shape.dimensions+isArray> location, int sampleIndex, vector<int, Shape.dimensions+isArray> offset, out uint status)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case hlsl:\n")
SLANG_RAW("        case cpp:\n")
SLANG_RAW("            __intrinsic_asm \".Load\";\n")
SLANG_RAW("        default:\n")
SLANG_RAW("            status = 0;\n")
SLANG_RAW("            return Load(location, sampleIndex, offset);\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    void __glslImageStore(vector<int, Shape.dimensions+isArray> location, int sampleIndex, T value)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __intrinsic_asm \"imageStore($0, $1, $2, $V3)\";\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    __subscript(vector<uint, Shape.dimensions+isArray> location, int sampleIndex) -> T\n")
SLANG_RAW("    {\n")
SLANG_RAW("        [__readNone]\n")
SLANG_RAW("        [ForceInline]\n")
SLANG_RAW("        get\n")
SLANG_RAW("        {\n")
SLANG_RAW("            __target_switch\n")
SLANG_RAW("            {\n")
SLANG_RAW("                case cpp:\n")
SLANG_RAW("                case hlsl:\n")
SLANG_RAW("                    __intrinsic_asm \"$0.sample[$2][$1]\";\n")
SLANG_RAW("                case glsl:\n")
SLANG_RAW("                case spirv:\n")
SLANG_RAW("                case cuda:\n")
SLANG_RAW("                    return Load(location, sampleIndex);\n")
SLANG_RAW("            }\n")
SLANG_RAW("        }\n")
SLANG_RAW("\n")
SLANG_RAW("        [nonmutating]\n")
SLANG_RAW("        [ForceInline]\n")
SLANG_RAW("        set(T newValue)\n")
SLANG_RAW("        {\n")
SLANG_RAW("            __target_switch\n")
SLANG_RAW("            {\n")
SLANG_RAW("                case cpp:\n")
SLANG_RAW("                case hlsl:\n")
SLANG_RAW("                __intrinsic_asm \"$0.sample[$2][$1]\";\n")
SLANG_RAW("                case glsl:\n")
SLANG_RAW("                    __glslImageStore(location, sampleIndex, newValue);\n")
SLANG_RAW("                case spirv:\n")
SLANG_RAW("                    return spirv_asm\n")
SLANG_RAW("                    {\n")
SLANG_RAW("                        OpImageWrite $this $location $newValue Sample $sampleIndex;\n")
SLANG_RAW("                    };\n")
SLANG_RAW("            }\n")
SLANG_RAW("        }\n")
SLANG_RAW("\n")
SLANG_RAW("        __intrinsic_op(")
SLANG_SPLICE(kIROp_ImageSubscript
)
SLANG_RAW(") ref;\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")

} // if (access == kStdlibResourceAccessReadWrite) // for RW MS textures.
} // for (access).
SLANG_RAW("#line 1690 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("// Texture type aliases.\n")
SLANG_RAW("// T, Shape: __ITextureShape, let isArray:int, let isMS:int, let sampleCount:int, let access:int, let isShadow:int, let isCombined:int, let format:int\n")

    const char* shapeTypeNames[] = {"1D", "2D", "3D", "Cube"};
    const char* accessPrefix[] = {"", "RW", "RasterizerOrdered", "Feedback"};
    const char* arrayPostFix[] = {"", "Array"};
    const char* msPostFix[] = {"", "MS"};
    for (int shape = 0; shape < 4; shape++)
    for (int isArray = 0; isArray<=1; isArray++)
    for (int isMS = 0; isMS<=1; isMS++)
    for (int isCombined = 0; isCombined<=1; isCombined++)
    for (int access = kStdlibResourceAccessReadOnly; access<=kStdlibResourceAccessFeedback; access++) {
        if (access != kStdlibResourceAccessReadOnly)
        {
            // No RW Cube.
            if (shape == kStdlibShapeIndexCube) continue;
        }
        if (access == kStdlibResourceAccessFeedback)
        {
            // Feedback only defined for Texture2D and Texture2DArray.
            if (shape != 1) continue;
            if (isMS) continue;
            if (isCombined) continue;
        }
        if (isMS)
        {
            // Only Texture2DMS.
            if (shape != kStdlibShapeIndex2D)
                continue;
            // Only Texture2DMS or RWTexture2DMS.
            if (access >= kStdlibShapeIndex3D)
                continue;
        }
        // No 3D Array.
        if (shape == kStdlibShapeIndex3D && isArray == 1)
            continue;
        const char* textureTypeName = isCombined ? "Sampler" : "Texture";
SLANG_RAW("#line 1729 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("typealias ")
SLANG_SPLICE(accessPrefix[access]
)
SLANG_SPLICE(textureTypeName
)
SLANG_SPLICE(shapeTypeNames[shape]
)
SLANG_SPLICE(arrayPostFix[isArray]
)
SLANG_SPLICE(msPostFix[isMS]
)
SLANG_RAW("<T=float4, let sampleCount:int=0, let format:int=0> = __TextureImpl<T, __Shape")
SLANG_SPLICE(shapeTypeNames[shape]
)
SLANG_RAW(", ")
SLANG_SPLICE(isArray
)
SLANG_RAW(", ")
SLANG_SPLICE(isMS
)
SLANG_RAW(", sampleCount, ")
SLANG_SPLICE(access
)
SLANG_RAW(", 0, ")
SLANG_SPLICE(isCombined
)
SLANG_RAW(", format>;\n")

}
SLANG_RAW("#line 1733 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("// AtomicAdd\n")
SLANG_RAW("\n")
SLANG_RAW("// Make the GLSL atomicAdd available.\n")
SLANG_RAW("// We have separate int/float implementations, as the float version requires some specific extensions\n")
SLANG_RAW("// https://www.khronos.org/registry/OpenGL/extensions/NV/NV_shader_atomic_float.txt\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_version(430)\n")
SLANG_RAW("__glsl_extension(GL_EXT_shader_atomic_float)\n")
SLANG_RAW("float __atomicAdd(__ref float value, float amount)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"atomicAdd($0, $1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            OpExtension \"SPV_EXT_shader_atomic_float_add\";\n")
SLANG_RAW("            OpCapability AtomicFloat32AddEXT;\n")
SLANG_RAW("            result:$$float = OpAtomicFAddEXT &value Device None $amount\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Helper for hlsl, using NVAPI\n")
SLANG_RAW("__target_intrinsic(hlsl, \"NvInterlockedAddUint64($0, $1, $2)\")\n")
SLANG_RAW("[__requiresNVAPI]\n")
SLANG_RAW("uint2 __atomicAdd(RWByteAddressBuffer buf, uint offset, uint2);\n")
SLANG_RAW("\n")
SLANG_RAW("// atomic add for hlsl using SM6.6\n")
SLANG_RAW("__target_intrinsic(hlsl, \"$0.InterlockedAdd64($1, $2, $3)\")\n")
SLANG_RAW("void __atomicAdd(RWByteAddressBuffer buf, uint offset, int64_t value, out int64_t originalValue);\n")
SLANG_RAW("__target_intrinsic(hlsl, \"$0.InterlockedAdd64($1, $2, $3)\")\n")
SLANG_RAW("void __atomicAdd(RWByteAddressBuffer buf, uint offset, uint64_t value, out uint64_t originalValue);\n")
SLANG_RAW("\n")
SLANG_RAW("// Int versions require glsl 4.30\n")
SLANG_RAW("// https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/atomicAdd.xhtml\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_version(430)\n")
SLANG_RAW("int __atomicAdd(__ref int value, int amount)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"atomicAdd($0, $1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            result:$$int = OpAtomicIAdd &value Device None $amount;\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_version(430)\n")
SLANG_RAW("uint __atomicAdd(__ref uint value, uint amount)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"atomicAdd($0, $1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            result:$$uint = OpAtomicIAdd &value Device None $amount;\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_version(430)\n")
SLANG_RAW("__glsl_extension(GL_EXT_shader_atomic_int64)\n")
SLANG_RAW("int64_t __atomicAdd(__ref int64_t value, int64_t amount)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"atomicAdd($0, $1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            OpCapability Int64Atomics;\n")
SLANG_RAW("            result:$$int64_t = OpAtomicIAdd &value Device None $amount\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"atomicAdd($0, $1)\")\n")
SLANG_RAW("__glsl_version(430)\n")
SLANG_RAW("__glsl_extension(GL_EXT_shader_atomic_int64)\n")
SLANG_RAW("uint64_t __atomicAdd(__ref uint64_t value, uint64_t amount)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"atomicAdd($0, $1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            OpCapability Int64Atomics;\n")
SLANG_RAW("            result:$$uint64_t = OpAtomicIAdd &value Device None $amount\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Cas - Compare and swap\n")
SLANG_RAW("\n")
SLANG_RAW("// Helper for HLSL, using NVAPI\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(hlsl, \"NvInterlockedCompareExchangeUint64($0, $1, $2, $3)\")\n")
SLANG_RAW("[__requiresNVAPI]\n")
SLANG_RAW("uint2 __cas(RWByteAddressBuffer buf, uint offset, uint2 compareValue, uint2 value);\n")
SLANG_RAW("\n")
SLANG_RAW("// CAS using SM6.6\n")
SLANG_RAW("__target_intrinsic(hlsl, \"$0.InterlockedCompareExchange64($1, $2, $3, $4)\")\n")
SLANG_RAW("void __cas(RWByteAddressBuffer buf, uint offset, in int64_t compare_value, in int64_t value, out int64_t original_value);\n")
SLANG_RAW("__target_intrinsic(hlsl, \"$0.InterlockedCompareExchange64($1, $2, $3, $4)\")\n")
SLANG_RAW("void __cas(RWByteAddressBuffer buf, uint offset, in uint64_t compare_value, in uint64_t value, out uint64_t original_value);\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_version(430)\n")
SLANG_RAW("__glsl_extension(GL_EXT_shader_atomic_int64)\n")
SLANG_RAW("int64_t __cas(__ref int64_t ioValue, int64_t compareValue, int64_t newValue)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"atomicCompSwap($0, $1, $2)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            OpCapability Int64Atomics;\n")
SLANG_RAW("            result:$$int64_t = OpAtomicCompareExchange &ioValue Device None None $newValue $compareValue\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_version(430)\n")
SLANG_RAW("__glsl_extension(GL_EXT_shader_atomic_int64)\n")
SLANG_RAW("uint64_t __cas(__ref uint64_t ioValue, uint64_t compareValue, uint64_t newValue)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"atomicCompSwap($0, $1, $2)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            OpCapability Int64Atomics;\n")
SLANG_RAW("            result:$$uint64_t = OpAtomicCompareExchange &ioValue Device None None $newValue $compareValue\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Max\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(hlsl, \"NvInterlockedMaxUint64($0, $1, $2)\")\n")
SLANG_RAW("[__requiresNVAPI]\n")
SLANG_RAW("uint2 __atomicMax(RWByteAddressBuffer buf, uint offset, uint2 value);\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_version(430)\n")
SLANG_RAW("__glsl_extension(GL_EXT_shader_atomic_int64)\n")
SLANG_RAW("uint64_t __atomicMax(__ref uint64_t ioValue, uint64_t value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"atomicMax($0, $1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            OpCapability Int64Atomics;\n")
SLANG_RAW("            result:$$uint64_t = OpAtomicUMax &ioValue Device None $value\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Min\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(hlsl, \"NvInterlockedMinUint64($0, $1, $2)\")\n")
SLANG_RAW("[__requiresNVAPI]\n")
SLANG_RAW("uint2 __atomicMin(RWByteAddressBuffer buf, uint offset, uint2 value);\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_version(430)\n")
SLANG_RAW("__glsl_extension(GL_EXT_shader_atomic_int64)\n")
SLANG_RAW("uint64_t __atomicMin(__ref uint64_t ioValue, uint64_t value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"atomicMin($0, $1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            OpCapability Int64Atomics;\n")
SLANG_RAW("            result:$$uint64_t = OpAtomicUMin &ioValue Device None $value\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// And\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(hlsl, \"NvInterlockedAndUint64($0, $1, $2)\")\n")
SLANG_RAW("[__requiresNVAPI]\n")
SLANG_RAW("uint2 __atomicAnd(RWByteAddressBuffer buf, uint offset, uint2 value);\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_version(430)\n")
SLANG_RAW("__glsl_extension(GL_EXT_shader_atomic_int64)\n")
SLANG_RAW("uint64_t __atomicAnd(__ref uint64_t ioValue, uint64_t value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"atomicAnd($0, $1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            OpCapability Int64Atomics;\n")
SLANG_RAW("            result:$$uint64_t = OpAtomicAnd &ioValue Device None $value\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Or\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(hlsl, \"NvInterlockedOrUint64($0, $1, $2)\")\n")
SLANG_RAW("[__requiresNVAPI]\n")
SLANG_RAW("uint2 __atomicOr(RWByteAddressBuffer buf, uint offset, uint2 value);\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_version(430)\n")
SLANG_RAW("__glsl_extension(GL_EXT_shader_atomic_int64)\n")
SLANG_RAW("uint64_t __atomicOr(__ref uint64_t ioValue, uint64_t value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"atomicOr($0, $1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            OpCapability Int64Atomics;\n")
SLANG_RAW("            result:$$uint64_t = OpAtomicOr &ioValue Device None $value\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Xor\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(hlsl, \"NvInterlockedXorUint64($0, $1, $2)\")\n")
SLANG_RAW("[__requiresNVAPI]\n")
SLANG_RAW("uint2 __atomicXor(RWByteAddressBuffer buf, uint offset, uint2 value);\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_version(430)\n")
SLANG_RAW("__glsl_extension(GL_EXT_shader_atomic_int64)\n")
SLANG_RAW("uint64_t __atomicXor(__ref uint64_t ioValue, uint64_t value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"atomicXor($0, $1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            OpCapability Int64Atomics;\n")
SLANG_RAW("            result:$$uint64_t = OpAtomicXor &ioValue Device None $value\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Exchange\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(hlsl, \"NvInterlockedExchangeUint64($0, $1, $2)\")\n")
SLANG_RAW("[__requiresNVAPI]\n")
SLANG_RAW("uint2 __atomicExchange(RWByteAddressBuffer buf, uint offset, uint2 value);\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_version(430)\n")
SLANG_RAW("__glsl_extension(GL_EXT_shader_atomic_int64)\n")
SLANG_RAW("uint64_t __atomicExchange(__ref uint64_t ioValue, uint64_t value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"atomicExchange($0, $1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            OpCapability Int64Atomics;\n")
SLANG_RAW("            result:$$uint64_t = OpAtomicExchange &ioValue Device None $value\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Conversion between uint64_t and uint2\n")
SLANG_RAW("\n")
SLANG_RAW("uint2 __asuint2(uint64_t i)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return uint2(uint(i), uint(uint64_t(i) >> 32));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("uint64_t __asuint64(uint2 i)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return (uint64_t(i.y) << 32) | i.x;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("//\n")
SLANG_RAW("\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_ByteAddressBufferLoad
)
SLANG_RAW(")\n")
SLANG_RAW("T __byteAddressBufferLoad<T>(ByteAddressBuffer buffer, int offset);\n")
SLANG_RAW("\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_ByteAddressBufferLoad
)
SLANG_RAW(")\n")
SLANG_RAW("T __byteAddressBufferLoad<T>(RWByteAddressBuffer buffer, int offset);\n")
SLANG_RAW("\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_ByteAddressBufferLoad
)
SLANG_RAW(")\n")
SLANG_RAW("T __byteAddressBufferLoad<T>(RasterizerOrderedByteAddressBuffer buffer, int offset);\n")
SLANG_RAW("\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_ByteAddressBufferStore
)
SLANG_RAW(")\n")
SLANG_RAW("void __byteAddressBufferStore<T>(RWByteAddressBuffer buffer, int offset, T value);\n")
SLANG_RAW("\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_ByteAddressBufferStore
)
SLANG_RAW(")\n")
SLANG_RAW("void __byteAddressBufferStore<T>(RasterizerOrderedByteAddressBuffer buffer, int offset, T value);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("__magic_type(HLSLStructuredBufferType)\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_HLSLStructuredBufferType
)
SLANG_RAW(")\n")
SLANG_RAW("struct StructuredBuffer\n")
SLANG_RAW("{\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    [__unsafeForceInlineEarly]\n")
SLANG_RAW("    void GetDimensions(\n")
SLANG_RAW("        out uint numStructs,\n")
SLANG_RAW("        out uint stride)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        let rs = __structuredBufferGetDimensions(this);\n")
SLANG_RAW("        numStructs = rs.x;\n")
SLANG_RAW("        stride = rs.y;\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_StructuredBufferLoad
)
SLANG_RAW(")\n")
SLANG_RAW("    __target_intrinsic(glsl, \"$0._data[$1]\")\n")
SLANG_RAW("    __target_intrinsic(spirv, \"%addr = OpAccessChain resultType*StorageBuffer resultId _0 const(int, 0) _1; OpLoad resultType resultId %addr;\")\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    T Load(int location);\n")
SLANG_RAW("\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_StructuredBufferLoadStatus
)
SLANG_RAW(")\n")
SLANG_RAW("    T Load(int location, out uint status);\n")
SLANG_RAW("\n")
SLANG_RAW("    __subscript(uint index) -> T\n")
SLANG_RAW("    {\n")
SLANG_RAW("        [__readNone]\n")
SLANG_RAW("        __intrinsic_op(")
SLANG_SPLICE(kIROp_StructuredBufferLoad
)
SLANG_RAW(")\n")
SLANG_RAW("        get;\n")
SLANG_RAW("    };\n")
SLANG_RAW("};\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("__magic_type(HLSLConsumeStructuredBufferType)\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_HLSLConsumeStructuredBufferType
)
SLANG_RAW(")\n")
SLANG_RAW("struct ConsumeStructuredBuffer\n")
SLANG_RAW("{\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_StructuredBufferConsume
)
SLANG_RAW(")\n")
SLANG_RAW("    T Consume();\n")
SLANG_RAW("\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    void GetDimensions(\n")
SLANG_RAW("        out uint numStructs,\n")
SLANG_RAW("        out uint stride)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        let result = __structuredBufferGetDimensions(this);\n")
SLANG_RAW("        numStructs = result.x;\n")
SLANG_RAW("        stride = result.y;\n")
SLANG_RAW("    }\n")
SLANG_RAW("};\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T, let N : int>\n")
SLANG_RAW("__magic_type(HLSLInputPatchType)\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_HLSLInputPatchType
)
SLANG_RAW(")\n")
SLANG_RAW("struct InputPatch\n")
SLANG_RAW("{\n")
SLANG_RAW("    __subscript(uint index) -> T;\n")
SLANG_RAW("};\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T, let N : int>\n")
SLANG_RAW("__magic_type(HLSLOutputPatchType)\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_HLSLOutputPatchType
)
SLANG_RAW(")\n")
SLANG_RAW("struct OutputPatch\n")
SLANG_RAW("{\n")
SLANG_RAW("    __subscript(uint index) -> T;\n")
SLANG_RAW("};\n")
SLANG_RAW("\n")

static const struct {
    IROp op;
    char const* name;
} kMutableByteAddressBufferCases[] =
{
    { kIROp_HLSLRWByteAddressBufferType,                "RWByteAddressBuffer" },
    { kIROp_HLSLRasterizerOrderedByteAddressBufferType, "RasterizerOrderedByteAddressBuffer" },
};
for(auto item : kMutableByteAddressBufferCases) {
SLANG_RAW("#line 2118 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("__magic_type(HLSL")
SLANG_SPLICE(item.name
)
SLANG_RAW("Type)\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(item.op
)
SLANG_RAW(")\n")
SLANG_RAW("struct ")
SLANG_SPLICE(item.name
)
SLANG_RAW("\n")
SLANG_RAW("{\n")
SLANG_RAW("    // Note(tfoley): supports all operations from `ByteAddressBuffer`\n")
SLANG_RAW("    // TODO(tfoley): can this be made a sub-type?\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(hlsl)\n")
SLANG_RAW("    __target_intrinsic(cpp)\n")
SLANG_RAW("    __target_intrinsic(cuda)\n")
SLANG_RAW("    [__unsafeForceInlineEarly]\n")
SLANG_RAW("    void GetDimensions(out uint dim);\n")
SLANG_RAW("\n")
SLANG_RAW("    [__unsafeForceInlineEarly]\n")
SLANG_RAW("    __specialized_for_target(spirv)\n")
SLANG_RAW("    __specialized_for_target(glsl)\n")
SLANG_RAW("    void GetDimensions(out uint dim)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        dim = __structuredBufferGetDimensions(__getEquivalentStructuredBuffer<uint>(this)).x*4;\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(hlsl)\n")
SLANG_RAW("    [__NoSideEffect]\n")
SLANG_RAW("    uint Load(int location)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        return __byteAddressBufferLoad<uint>(this, location);\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__NoSideEffect]\n")
SLANG_RAW("    uint Load(int location, out uint status);\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(hlsl)\n")
SLANG_RAW("    [__NoSideEffect]\n")
SLANG_RAW("    uint2 Load2(int location)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        return __byteAddressBufferLoad<uint2>(this, location);\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__NoSideEffect]\n")
SLANG_RAW("    uint2 Load2(int location, out uint status);\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(hlsl)\n")
SLANG_RAW("    [__NoSideEffect]\n")
SLANG_RAW("    uint3 Load3(int location)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        return __byteAddressBufferLoad<uint3>(this, location);\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__NoSideEffect]\n")
SLANG_RAW("    uint3 Load3(int location, out uint status);\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(hlsl)\n")
SLANG_RAW("    [__NoSideEffect]\n")
SLANG_RAW("    uint4 Load4(int location)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        return __byteAddressBufferLoad<uint4>(this, location);\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__NoSideEffect]\n")
SLANG_RAW("    uint4 Load4(int location, out uint status);\n")
SLANG_RAW("\n")
SLANG_RAW("    [__NoSideEffect]\n")
SLANG_RAW("    T Load<T>(int location)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        return __byteAddressBufferLoad<T>(this, location);\n")
SLANG_RAW("    }\n")

    if (item.op == kIROp_HLSLRWByteAddressBufferType)
    {
SLANG_RAW("#line 2189 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("    // float32 and int64 atomic support. This is a Slang specific extension, it uses\n")
SLANG_RAW("    // GL_EXT_shader_atomic_float on Vulkan\n")
SLANG_RAW("    // NvAPI support on DX\n")
SLANG_RAW("    // NOTE! To use this feature on HLSL based targets the path to 'nvHLSLExtns.h' from the NvAPI SDK must\n")
SLANG_RAW("    // be set. That this include will be added to the *output* that is passed to a downstram compiler.\n")
SLANG_RAW("    // Also note that you *can* include NVAPI headers in your Slang source, and directly use NVAPI functions\n")
SLANG_RAW("    // Directly using NVAPI functions does *not* add the #include on the output\n")
SLANG_RAW("    // Finally note you can *mix* NVAPI direct calls, and use of NVAPI intrinsics below. This doesn't cause\n")
SLANG_RAW("    // any clashes, as Slang will emit any NVAPI function it parsed (say via a include in Slang source) with\n")
SLANG_RAW("    // unique functions.\n")
SLANG_RAW("    //\n")
SLANG_RAW("    // https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VK_EXT_shader_atomic_float\n")
SLANG_RAW("    // https://htmlpreview.github.io/?https://github.com/KhronosGroup/SPIRV-Registry/blob/master/extensions/EXT/SPV_EXT_shader_atomic_float_add.html\n")
SLANG_RAW("\n")
SLANG_RAW("    // F32 Add\n")
SLANG_RAW("\n")
SLANG_RAW("    __cuda_sm_version(2.0)\n")
SLANG_RAW("    [__requiresNVAPI]\n")
SLANG_RAW("    void InterlockedAddF32(uint byteAddress, float valueToAdd, out float originalValue)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \"($3 = NvInterlockedAddFp32($0, $1, $2))\";\n")
SLANG_RAW("        case cuda: __intrinsic_asm \"(*$3 = atomicAdd($0._getPtrAt<float>($1), $2))\";\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            {\n")
SLANG_RAW("                let buf = __getEquivalentStructuredBuffer<float>(this);\n")
SLANG_RAW("                originalValue = __atomicAdd(buf[byteAddress / 4], valueToAdd);\n")
SLANG_RAW("                return;\n")
SLANG_RAW("            }\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    // Without returning original value\n")
SLANG_RAW("\n")
SLANG_RAW("    [__requiresNVAPI]\n")
SLANG_RAW("    __cuda_sm_version(2.0)\n")
SLANG_RAW("    void InterlockedAddF32(uint byteAddress, float valueToAdd)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \"(NvInterlockedAddFp32($0, $1, $2))\";\n")
SLANG_RAW("        case cuda: __intrinsic_asm \"atomicAdd($0._getPtrAt<float>($1), $2)\";\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            {\n")
SLANG_RAW("                let buf = __getEquivalentStructuredBuffer<float>(this);\n")
SLANG_RAW("                __atomicAdd(buf[byteAddress / 4], valueToAdd);\n")
SLANG_RAW("                return;\n")
SLANG_RAW("            }\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    // Int64 Add\n")
SLANG_RAW("    __cuda_sm_version(6.0)\n")
SLANG_RAW("    void InterlockedAddI64(uint byteAddress, int64_t valueToAdd, out int64_t originalValue)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case cuda: __intrinsic_asm \"(*$3 = atomicAdd($0._getPtrAt<uint64_t>($1), $2))\";\n")
SLANG_RAW("        case hlsl:\n")
SLANG_RAW("            originalValue = __asuint64(__atomicAdd(this, byteAddress, __asuint2(valueToAdd)));\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            {\n")
SLANG_RAW("                let buf = __getEquivalentStructuredBuffer<int64_t>(this);\n")
SLANG_RAW("                originalValue = __atomicAdd(buf[byteAddress / 8], valueToAdd);\n")
SLANG_RAW("            }\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    // Without returning original value\n")
SLANG_RAW("    __cuda_sm_version(6.0)\n")
SLANG_RAW("    __target_intrinsic(cuda, \"atomicAdd($0._getPtrAt<uint64_t>($1), $2)\")\n")
SLANG_RAW("    void InterlockedAddI64(uint byteAddress, int64_t valueToAdd);\n")
SLANG_RAW("\n")
SLANG_RAW("    __specialized_for_target(hlsl)\n")
SLANG_RAW("    void InterlockedAddI64(uint byteAddress, int64_t valueToAdd)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __atomicAdd(this, byteAddress, __asuint2(valueToAdd));\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    __specialized_for_target(glsl)\n")
SLANG_RAW("    __specialized_for_target(spirv)\n")
SLANG_RAW("    void InterlockedAddI64(uint byteAddress, int64_t valueToAdd)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        let buf = __getEquivalentStructuredBuffer<int64_t>(this);\n")
SLANG_RAW("        __atomicAdd(buf[byteAddress / 8], valueToAdd);\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    // Cas uint64_t\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(cuda, \"(*$4 = atomicCAS($0._getPtrAt<uint64_t>($1), $2, $3))\")\n")
SLANG_RAW("    void InterlockedCompareExchangeU64(uint byteAddress, uint64_t compareValue, uint64_t value, out uint64_t outOriginalValue);\n")
SLANG_RAW("\n")
SLANG_RAW("    __specialized_for_target(hlsl)\n")
SLANG_RAW("    void InterlockedCompareExchangeU64(uint byteAddress, uint64_t compareValue, uint64_t value, out uint64_t outOriginalValue)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        outOriginalValue = __asuint64(__cas(this, byteAddress, __asuint2(compareValue), __asuint2(value)));\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    __specialized_for_target(glsl)\n")
SLANG_RAW("    __specialized_for_target(spirv)\n")
SLANG_RAW("    void InterlockedCompareExchangeU64(uint byteAddress, uint64_t compareValue, uint64_t value, out uint64_t outOriginalValue)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        let buf = __getEquivalentStructuredBuffer<uint64_t>(this);\n")
SLANG_RAW("        outOriginalValue = __cas(buf[byteAddress / 8], compareValue, value);\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    // Max\n")
SLANG_RAW("\n")
SLANG_RAW("    __cuda_sm_version(3.5)\n")
SLANG_RAW("    __target_intrinsic(cuda, \"atomicMax($0._getPtrAt<uint64_t>($1), $2)\")\n")
SLANG_RAW("    uint64_t InterlockedMaxU64(uint byteAddress, uint64_t value);\n")
SLANG_RAW("\n")
SLANG_RAW("    __specialized_for_target(hlsl)\n")
SLANG_RAW("    uint64_t InterlockedMaxU64(uint byteAddress, uint64_t value) { return __asuint64(__atomicMax(this, byteAddress, __asuint2(value))); }\n")
SLANG_RAW("\n")
SLANG_RAW("    __specialized_for_target(glsl)\n")
SLANG_RAW("    __specialized_for_target(spirv)\n")
SLANG_RAW("    uint64_t InterlockedMaxU64(uint byteAddress, uint64_t value)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        let buf = __getEquivalentStructuredBuffer<uint64_t>(this);\n")
SLANG_RAW("        return __atomicMax(buf[byteAddress / 8], value);\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    // Min\n")
SLANG_RAW("\n")
SLANG_RAW("    __cuda_sm_version(3.5)\n")
SLANG_RAW("    __target_intrinsic(cuda, \"atomicMin($0._getPtrAt<uint64_t>($1), $2)\")\n")
SLANG_RAW("    uint64_t InterlockedMinU64(uint byteAddress, uint64_t value);\n")
SLANG_RAW("\n")
SLANG_RAW("    __specialized_for_target(hlsl)\n")
SLANG_RAW("    uint64_t InterlockedMinU64(uint byteAddress, uint64_t value) { return __asuint64(__atomicMin(this, byteAddress, __asuint2(value))); }\n")
SLANG_RAW("\n")
SLANG_RAW("    __specialized_for_target(glsl)\n")
SLANG_RAW("    __specialized_for_target(spirv)\n")
SLANG_RAW("    uint64_t InterlockedMinU64(uint byteAddress, uint64_t value)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        let buf = __getEquivalentStructuredBuffer<uint64_t>(this);\n")
SLANG_RAW("        return __atomicMin(buf[byteAddress / 8], value);\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    // And\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(cuda, \"atomicAnd($0._getPtrAt<uint64_t>($1), $2)\")\n")
SLANG_RAW("    uint64_t InterlockedAndU64(uint byteAddress, uint64_t value);\n")
SLANG_RAW("\n")
SLANG_RAW("    __specialized_for_target(hlsl)\n")
SLANG_RAW("    uint64_t InterlockedAndU64(uint byteAddress, uint64_t value) { return __asuint64(__atomicAnd(this, byteAddress, __asuint2(value))); }\n")
SLANG_RAW("\n")
SLANG_RAW("    __specialized_for_target(glsl)\n")
SLANG_RAW("    __specialized_for_target(spirv)\n")
SLANG_RAW("    uint64_t InterlockedAndU64(uint byteAddress, uint64_t value)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        let buf = __getEquivalentStructuredBuffer<uint64_t>(this);\n")
SLANG_RAW("        return __atomicAnd(buf[byteAddress / 8], value);\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    // Or\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(cuda, \"atomicOr($0._getPtrAt<uint64_t>($1), $2)\")\n")
SLANG_RAW("    uint64_t InterlockedOrU64(uint byteAddress, uint64_t value);\n")
SLANG_RAW("\n")
SLANG_RAW("    __specialized_for_target(hlsl)\n")
SLANG_RAW("    uint64_t InterlockedOrU64(uint byteAddress, uint64_t value) { return __asuint64(__atomicOr(this, byteAddress, __asuint2(value))); }\n")
SLANG_RAW("\n")
SLANG_RAW("    __specialized_for_target(glsl)\n")
SLANG_RAW("    __specialized_for_target(spirv)\n")
SLANG_RAW("    uint64_t InterlockedOrU64(uint byteAddress, uint64_t value)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        let buf = __getEquivalentStructuredBuffer<uint64_t>(this);\n")
SLANG_RAW("        return __atomicOr(buf[byteAddress / 8], value);\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    // Xor\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(cuda, \"atomicXor($0._getPtrAt<uint64_t>($1), $2)\")\n")
SLANG_RAW("    uint64_t InterlockedXorU64(uint byteAddress, uint64_t value);\n")
SLANG_RAW("\n")
SLANG_RAW("    __specialized_for_target(hlsl)\n")
SLANG_RAW("    uint64_t InterlockedXorU64(uint byteAddress, uint64_t value) { return __asuint64(__atomicXor(this, byteAddress, __asuint2(value))); }\n")
SLANG_RAW("\n")
SLANG_RAW("    __specialized_for_target(glsl)\n")
SLANG_RAW("    __specialized_for_target(spirv)\n")
SLANG_RAW("    uint64_t InterlockedXorU64(uint byteAddress, uint64_t value)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        let buf = __getEquivalentStructuredBuffer<uint64_t>(this);\n")
SLANG_RAW("        return __atomicXor(buf[byteAddress / 8], value);\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    // Exchange\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(cuda, \"atomicExch($0._getPtrAt<uint64_t>($1), $2)\")\n")
SLANG_RAW("    uint64_t InterlockedExchangeU64(uint byteAddress, uint64_t value);\n")
SLANG_RAW("\n")
SLANG_RAW("    __specialized_for_target(hlsl)\n")
SLANG_RAW("    uint64_t InterlockedExchangeU64(uint byteAddress, uint64_t value) { return __asuint64(__atomicExchange(this, byteAddress, __asuint2(value))); }\n")
SLANG_RAW("\n")
SLANG_RAW("    __specialized_for_target(glsl)\n")
SLANG_RAW("    __specialized_for_target(spirv)\n")
SLANG_RAW("    uint64_t InterlockedExchangeU64(uint byteAddress, uint64_t value)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        let buf = __getEquivalentStructuredBuffer<uint64_t>(this);\n")
SLANG_RAW("        return __atomicExchange(buf[byteAddress / 8], value);\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    // SM6.6 6 64bit atomics.\n")
SLANG_RAW("    __specialized_for_target(hlsl)\n")
SLANG_RAW("    void InterlockedAdd64(uint byteAddress, int64_t valueToAdd, out int64_t outOriginalValue)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __atomicAdd(this, byteAddress, valueToAdd, outOriginalValue);\n")
SLANG_RAW("    }\n")
SLANG_RAW("    __specialized_for_target(glsl)\n")
SLANG_RAW("    __specialized_for_target(spirv)\n")
SLANG_RAW("    void InterlockedAdd64(uint byteAddress, int64_t valueToAdd, out int64_t originalValue)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        let buf = __getEquivalentStructuredBuffer<int64_t>(this);\n")
SLANG_RAW("        originalValue = __atomicAdd(buf[byteAddress / 8], valueToAdd);\n")
SLANG_RAW("    }\n")
SLANG_RAW("    __specialized_for_target(hlsl)\n")
SLANG_RAW("    void InterlockedAdd64(uint byteAddress, uint64_t valueToAdd, out uint64_t outOriginalValue)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __atomicAdd(this, byteAddress, valueToAdd, outOriginalValue);\n")
SLANG_RAW("    }\n")
SLANG_RAW("    __specialized_for_target(glsl)\n")
SLANG_RAW("    __specialized_for_target(spirv)\n")
SLANG_RAW("    void InterlockedAdd64(uint byteAddress, uint64_t valueToAdd, out uint64_t originalValue)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        let buf = __getEquivalentStructuredBuffer<uint64_t>(this);\n")
SLANG_RAW("        originalValue = __atomicAdd(buf[byteAddress / 8], valueToAdd);\n")
SLANG_RAW("    }\n")
SLANG_RAW("    __specialized_for_target(hlsl)\n")
SLANG_RAW("    void InterlockedCompareExchange64(uint byteAddress, int64_t compareValue, int64_t value, out int64_t outOriginalValue)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __cas(this, byteAddress, compareValue, value, outOriginalValue);\n")
SLANG_RAW("    }\n")
SLANG_RAW("    __specialized_for_target(glsl)\n")
SLANG_RAW("    __specialized_for_target(spirv)\n")
SLANG_RAW("    void InterlockedCompareExchange64(uint byteAddress, int64_t compareValue, int64_t value, out int64_t outOriginalValue)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        let buf = __getEquivalentStructuredBuffer<int64_t>(this);\n")
SLANG_RAW("        outOriginalValue = __cas(buf[byteAddress / 8], compareValue, value);\n")
SLANG_RAW("    }\n")
SLANG_RAW("    __specialized_for_target(hlsl)\n")
SLANG_RAW("    void InterlockedCompareExchange64(uint byteAddress, uint64_t compareValue, uint64_t value, out uint64_t outOriginalValue)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __cas(this, byteAddress, compareValue, value, outOriginalValue);\n")
SLANG_RAW("    }\n")
SLANG_RAW("    __specialized_for_target(glsl)\n")
SLANG_RAW("    __specialized_for_target(spirv)\n")
SLANG_RAW("    void InterlockedCompareExchange64(uint byteAddress, uint64_t compareValue, uint64_t value, out uint64_t outOriginalValue)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        let buf = __getEquivalentStructuredBuffer<uint64_t>(this);\n")
SLANG_RAW("        outOriginalValue = __cas(buf[byteAddress / 8], compareValue, value);\n")
SLANG_RAW("    }\n")

    } // endif (type == RWByteAddressBuffer)
SLANG_RAW("#line 2450 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("    // Added operations:\n")
SLANG_RAW("    void InterlockedAdd(\n")
SLANG_RAW("        UINT dest,\n")
SLANG_RAW("        UINT value,\n")
SLANG_RAW("        out UINT original_value)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl: __intrinsic_asm \"($3 = atomicAdd($0._data[$1/4], $2))\";\n")
SLANG_RAW("        case cuda: __intrinsic_asm \"(*$3 = atomicAdd($0._getPtrAt<uint32_t>($1), $2))\";\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".InterlockedAdd\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            let buf = __getEquivalentStructuredBuffer<uint>(this);\n")
SLANG_RAW("            ::InterlockedAdd(buf[dest / 4], value, original_value);\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    void InterlockedAdd(\n")
SLANG_RAW("        UINT dest,\n")
SLANG_RAW("        UINT value)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl: __intrinsic_asm \"atomicAdd($0._data[$1/4], $2)\";\n")
SLANG_RAW("        case cuda: __intrinsic_asm \"atomicAdd($0._getPtrAt<uint32_t>($1), $2)\";\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".InterlockedAdd\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            let buf = __getEquivalentStructuredBuffer<uint>(this);\n")
SLANG_RAW("            ::InterlockedAdd(buf[dest / 4], value);\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    void InterlockedAnd(\n")
SLANG_RAW("        UINT dest,\n")
SLANG_RAW("        UINT value,\n")
SLANG_RAW("        out UINT original_value)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl: __intrinsic_asm \"$3 = atomicAnd($0._data[$1/4], $2)\";\n")
SLANG_RAW("        case cuda: __intrinsic_asm \"(*$3 = atomicAnd($0._getPtrAt<uint32_t>($1), $2))\";\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".InterlockedAnd\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            let buf = __getEquivalentStructuredBuffer<uint>(this);\n")
SLANG_RAW("            ::InterlockedAnd(buf[dest / 4], value, original_value);\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    void InterlockedAnd(\n")
SLANG_RAW("        UINT dest,\n")
SLANG_RAW("        UINT value)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl: __intrinsic_asm \"atomicAnd($0._data[$1/4], $2)\";\n")
SLANG_RAW("        case cuda: __intrinsic_asm \"atomicAnd($0._getPtrAt<uint32_t>($1), $2)\";\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".InterlockedAnd\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            let buf = __getEquivalentStructuredBuffer<uint>(this);\n")
SLANG_RAW("            ::InterlockedAnd(buf[dest / 4], value);\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    void InterlockedCompareExchange(\n")
SLANG_RAW("        UINT dest,\n")
SLANG_RAW("        UINT compare_value,\n")
SLANG_RAW("        UINT value,\n")
SLANG_RAW("        out UINT original_value)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl: __intrinsic_asm \"($4 = atomicCompSwap($0._data[$1/4], $2, $3))\";\n")
SLANG_RAW("        case cuda: __intrinsic_asm \"(*$4 = atomicCAS($0._getPtrAt<uint32_t>($1), $2, $3))\";\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".InterlockedCompareExchange\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            let buf = __getEquivalentStructuredBuffer<uint>(this);\n")
SLANG_RAW("            ::InterlockedCompareExchange(buf[dest / 4], compare_value, value, original_value);\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    void InterlockedCompareStore(\n")
SLANG_RAW("        UINT dest,\n")
SLANG_RAW("        UINT compare_value,\n")
SLANG_RAW("        UINT value)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl: __intrinsic_asm \"atomicCompSwap($0._data[$1/4], $2, $3)\";\n")
SLANG_RAW("        case cuda: __intrinsic_asm \"atomicCAS($0._getPtrAt<uint32_t>($1), $2, $3)\";\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".InterlockedCompareStore\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            let buf = __getEquivalentStructuredBuffer<uint>(this);\n")
SLANG_RAW("            ::InterlockedCompareStore(buf[dest / 4], compare_value, value);\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    void InterlockedExchange(\n")
SLANG_RAW("        UINT dest,\n")
SLANG_RAW("        UINT value,\n")
SLANG_RAW("        out UINT original_value)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl: __intrinsic_asm \"($3 = atomicExchange($0._data[$1/4], $2))\";\n")
SLANG_RAW("        case cuda: __intrinsic_asm \"(*$3 = atomicExch($0._getPtrAt<uint32_t>($1), $2))\";\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".InterlockedExchange\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            let buf = __getEquivalentStructuredBuffer<uint>(this);\n")
SLANG_RAW("            ::InterlockedExchange(buf[dest / 4], value, original_value);\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    void InterlockedMax(\n")
SLANG_RAW("        UINT dest,\n")
SLANG_RAW("        UINT value,\n")
SLANG_RAW("        out UINT original_value)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl: __intrinsic_asm \"($3 = atomicMax($0._data[$1/4], $2))\";\n")
SLANG_RAW("        case cuda: __intrinsic_asm \"(*$3 = atomicMax($0._getPtrAt<uint32_t>($1), $2))\";\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".InterlockedMax\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            let buf = __getEquivalentStructuredBuffer<uint>(this);\n")
SLANG_RAW("            ::InterlockedMax(buf[dest / 4], value, original_value);\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    void InterlockedMax(\n")
SLANG_RAW("        UINT dest,\n")
SLANG_RAW("        UINT value)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl: __intrinsic_asm \"atomicMax($0._data[$1/4], $2)\";\n")
SLANG_RAW("        case cuda: __intrinsic_asm \"atomicMax($0._getPtrAt<uint32_t>($1), $2)\";\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".InterlockedMax\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            let buf = __getEquivalentStructuredBuffer<uint>(this);\n")
SLANG_RAW("            ::InterlockedMax(buf[dest / 4], value);\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    void InterlockedMin(\n")
SLANG_RAW("        UINT dest,\n")
SLANG_RAW("        UINT value,\n")
SLANG_RAW("        out UINT original_value)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl: __intrinsic_asm \"($3 = atomicMin($0._data[$1/4], $2))\";\n")
SLANG_RAW("        case cuda: __intrinsic_asm \"(*$3 = atomicMin($0._getPtrAt<uint32_t>($1), $2))\";\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".InterlockedMin\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            let buf = __getEquivalentStructuredBuffer<uint>(this);\n")
SLANG_RAW("            ::InterlockedMin(buf[dest / 4], value, original_value);\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    void InterlockedMin(\n")
SLANG_RAW("        UINT dest,\n")
SLANG_RAW("        UINT value)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl: __intrinsic_asm \"atomicMin($0._data[$1/4], $2)\";\n")
SLANG_RAW("        case cuda: __intrinsic_asm \"atomicMin($0._getPtrAt<uint32_t>($1), $2)\";\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".InterlockedMin\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            let buf = __getEquivalentStructuredBuffer<uint>(this);\n")
SLANG_RAW("            ::InterlockedMin(buf[dest / 4], value);\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    void InterlockedOr(\n")
SLANG_RAW("        UINT dest,\n")
SLANG_RAW("        UINT value,\n")
SLANG_RAW("        out UINT original_value)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl: __intrinsic_asm \"($3 = atomicOr($0._data[$1/4], $2))\";\n")
SLANG_RAW("        case cuda: __intrinsic_asm \"(*$3 = atomicOr($0._getPtrAt<uint32_t>($1), $2))\";\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".InterlockedOr\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            let buf = __getEquivalentStructuredBuffer<uint>(this);\n")
SLANG_RAW("            ::InterlockedOr(buf[dest / 4], value, original_value);\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    void InterlockedOr(\n")
SLANG_RAW("        UINT dest,\n")
SLANG_RAW("        UINT value)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl: __intrinsic_asm \"atomicOr($0._data[$1/4], $2)\";\n")
SLANG_RAW("        case cuda: __intrinsic_asm \"atomicOr($0._getPtrAt<uint32_t>($1), $2)\";\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".InterlockedOr\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            let buf = __getEquivalentStructuredBuffer<uint>(this);\n")
SLANG_RAW("            ::InterlockedOr(buf[dest / 4], value);\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    void InterlockedXor(\n")
SLANG_RAW("        UINT dest,\n")
SLANG_RAW("        UINT value,\n")
SLANG_RAW("        out UINT original_value)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl: __intrinsic_asm \"($3 = atomicXor($0._data[$1/4], $2))\";\n")
SLANG_RAW("        case cuda: __intrinsic_asm \"(*$3 = atomicXor($0._getPtrAt<uint32_t>($1), $2))\";\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".InterlockedXor\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            let buf = __getEquivalentStructuredBuffer<uint>(this);\n")
SLANG_RAW("            ::InterlockedXor(buf[dest / 4], value, original_value);\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    void InterlockedXor(\n")
SLANG_RAW("        UINT dest,\n")
SLANG_RAW("        UINT value)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl: __intrinsic_asm \"atomicXor($0._data[$1/4], $2)\";\n")
SLANG_RAW("        case cuda: __intrinsic_asm \"atomicXor($0._getPtrAt<uint32_t>($1), $2)\";\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".InterlockedXor\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            let buf = __getEquivalentStructuredBuffer<uint>(this);\n")
SLANG_RAW("            ::InterlockedXor(buf[dest / 4], value);\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(hlsl)\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    void Store(\n")
SLANG_RAW("        uint address,\n")
SLANG_RAW("        uint value)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __byteAddressBufferStore(this, address, value);\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(hlsl)\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    void Store2(uint address, uint2 value)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __byteAddressBufferStore(this, address, value);\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(hlsl)\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    void Store3(\n")
SLANG_RAW("        uint address,\n")
SLANG_RAW("        uint3 value)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __byteAddressBufferStore(this, address, value);\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(hlsl)\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    void Store4(\n")
SLANG_RAW("        uint address,\n")
SLANG_RAW("        uint4 value)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __byteAddressBufferStore(this, address, value);\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    void Store<T>(int offset, T value)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __byteAddressBufferStore(this, offset, value);\n")
SLANG_RAW("    }\n")
SLANG_RAW("};\n")
SLANG_RAW("\n")

}
SLANG_RAW("#line 2730 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")

static const struct {
    IROp op;
    char const* name;
} kMutableStructuredBufferCases[] =
{
    { kIROp_HLSLRWStructuredBufferType,                "RWStructuredBuffer" },
    { kIROp_HLSLRasterizerOrderedStructuredBufferType, "RasterizerOrderedStructuredBuffer" },
};
for(auto item : kMutableStructuredBufferCases) {
SLANG_RAW("#line 2742 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("__magic_type(HLSL")
SLANG_SPLICE(item.name
)
SLANG_RAW("Type)\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(item.op
)
SLANG_RAW(")\n")
SLANG_RAW("struct ")
SLANG_SPLICE(item.name
)
SLANG_RAW("\n")
SLANG_RAW("{\n")
SLANG_RAW("    uint DecrementCounter();\n")
SLANG_RAW("\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    [__unsafeForceInlineEarly]\n")
SLANG_RAW("    __target_intrinsic(hlsl)\n")
SLANG_RAW("    void GetDimensions(\n")
SLANG_RAW("        out uint numStructs,\n")
SLANG_RAW("        out uint stride)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        let rs = __structuredBufferGetDimensions(this);\n")
SLANG_RAW("        numStructs = rs.x;\n")
SLANG_RAW("        stride = rs.y;\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    uint IncrementCounter();\n")
SLANG_RAW("\n")
SLANG_RAW("    [__NoSideEffect]\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_RWStructuredBufferLoad
)
SLANG_RAW(")\n")
SLANG_RAW("    T Load(int location);\n")
SLANG_RAW("\n")
SLANG_RAW("    [__NoSideEffect]\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_RWStructuredBufferLoadStatus
)
SLANG_RAW(")\n")
SLANG_RAW("    T Load(int location, out uint status);\n")
SLANG_RAW("\n")
SLANG_RAW("    __subscript(uint index) -> T\n")
SLANG_RAW("    {\n")
SLANG_RAW("        [__NoSideEffect]\n")
SLANG_RAW("        __intrinsic_op(")
SLANG_SPLICE(kIROp_RWStructuredBufferGetElementPtr
)
SLANG_RAW(")\n")
SLANG_RAW("        ref;\n")
SLANG_RAW("    }\n")
SLANG_RAW("};\n")
SLANG_RAW("\n")

}
SLANG_RAW("#line 2783 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("__magic_type(HLSLPointStreamType)\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_HLSLPointStreamType
)
SLANG_RAW(")\n")
SLANG_RAW("struct PointStream\n")
SLANG_RAW("{\n")
SLANG_RAW("    [KnownBuiltin(\"GeometryStreamAppend\")]\n")
SLANG_RAW("    void Append(T value)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl: __intrinsic_asm \"EmitVertex()\";\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".Append\";\n")
SLANG_RAW("        case spirv: spirv_asm { OpEmitVertex; };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [KnownBuiltin(\"GeometryStreamRestart\")]\n")
SLANG_RAW("    void RestartStrip()\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl: __intrinsic_asm \"EndPrimitive()\";\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".RestartStrip\";\n")
SLANG_RAW("        case spirv: spirv_asm { OpEndPrimitive; };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("};\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("__magic_type(HLSLLineStreamType)\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_HLSLLineStreamType
)
SLANG_RAW(")\n")
SLANG_RAW("struct LineStream\n")
SLANG_RAW("{\n")
SLANG_RAW("    [KnownBuiltin(\"GeometryStreamAppend\")]\n")
SLANG_RAW("    void Append(T value)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl: __intrinsic_asm \"EmitVertex()\";\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".Append\";\n")
SLANG_RAW("        case spirv: spirv_asm { OpEmitVertex; };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [KnownBuiltin(\"GeometryStreamRestart\")]\n")
SLANG_RAW("    void RestartStrip()\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl: __intrinsic_asm \"EndPrimitive()\";\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".RestartStrip\";\n")
SLANG_RAW("        case spirv: spirv_asm { OpEndPrimitive; };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("};\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("__magic_type(HLSLTriangleStreamType)\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_HLSLTriangleStreamType
)
SLANG_RAW(")\n")
SLANG_RAW("struct TriangleStream\n")
SLANG_RAW("{\n")
SLANG_RAW("    [KnownBuiltin(\"GeometryStreamAppend\")]\n")
SLANG_RAW("    void Append(T value)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl: __intrinsic_asm \"EmitVertex()\";\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".Append\";\n")
SLANG_RAW("        case spirv: spirv_asm { OpEmitVertex; };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [KnownBuiltin(\"GeometryStreamRestart\")]\n")
SLANG_RAW("    void RestartStrip()\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl: __intrinsic_asm \"EndPrimitive()\";\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".RestartStrip\";\n")
SLANG_RAW("        case spirv: spirv_asm { OpEndPrimitive; };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("};\n")
SLANG_RAW("\n")
SLANG_RAW("#define VECTOR_MAP_UNARY(TYPE, COUNT, FUNC, VALUE) \\\n")
SLANG_RAW("    vector<TYPE,COUNT> result; for(int i = 0; i < COUNT; ++i) { result[i] = FUNC(VALUE[i]); } return result\n")
SLANG_RAW("\n")
SLANG_RAW("#define MATRIX_MAP_UNARY(TYPE, ROWS, COLS, FUNC, VALUE) \\\n")
SLANG_RAW("    matrix<TYPE,ROWS,COLS> result; for(int i = 0; i < ROWS; ++i) { result[i] = FUNC(VALUE[i]); } return result\n")
SLANG_RAW("\n")
SLANG_RAW("#define VECTOR_MAP_BINARY(TYPE, COUNT, FUNC, LEFT, RIGHT) \\\n")
SLANG_RAW("    vector<TYPE,COUNT> result; for(int i = 0; i < COUNT; ++i) { result[i] = FUNC(LEFT[i], RIGHT[i]); } return result\n")
SLANG_RAW("\n")
SLANG_RAW("#define MATRIX_MAP_BINARY(TYPE, ROWS, COLS, FUNC, LEFT, RIGHT) \\\n")
SLANG_RAW("    matrix<TYPE,ROWS,COLS> result; for(int i = 0; i < ROWS; ++i) { result[i] = FUNC(LEFT[i], RIGHT[i]); } return result\n")
SLANG_RAW("\n")
SLANG_RAW("#define VECTOR_MAP_TRINARY(TYPE, COUNT, FUNC, A, B, C) \\\n")
SLANG_RAW("    vector<TYPE,COUNT> result; for(int i = 0; i < COUNT; ++i) { result[i] = FUNC(A[i], B[i], C[i]); } return result\n")
SLANG_RAW("\n")
SLANG_RAW("#define MATRIX_MAP_TRINARY(TYPE, ROWS, COLS, FUNC, A, B, C) \\\n")
SLANG_RAW("    matrix<TYPE,ROWS,COLS> result; for(int i = 0; i < ROWS; ++i) { result[i] = FUNC(A[i], B[i], C[i]); } return result\n")
SLANG_RAW("\n")
SLANG_RAW("// Try to terminate the current draw or dispatch call (HLSL SM 4.0)\n")
SLANG_RAW("void abort();\n")
SLANG_RAW("\n")
SLANG_RAW("// Absolute value (HLSL SM 1.0)\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinIntegerType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(cuda, \"$P_abs($0)\")\n")
SLANG_RAW("__target_intrinsic(cpp, \"$P_abs($0)\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 fi(FAbs, SAbs) _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T abs(T x);\n")
SLANG_RAW("/*{\n")
SLANG_RAW("    // Note: this simple definition may not be appropriate for floating-point inputs\n")
SLANG_RAW("    return x < 0 ? -x : x;\n")
SLANG_RAW("}*/\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinIntegerType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 fi(FAbs, SAbs) _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T, N> abs(vector<T, N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_UNARY(T, N, abs, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinIntegerType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T,N,M> abs(matrix<T,N,M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_UNARY(T, N, M, abs, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(cuda, \"$P_abs($0)\")\n")
SLANG_RAW("__target_intrinsic(cpp, \"$P_abs($0)\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 fi(FAbs, SAbs) _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T abs(T x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 fi(FAbs, SAbs) _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T, N> abs(vector<T, N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_UNARY(T, N, abs, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T,N,M> abs(matrix<T,N,M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_UNARY(T, N, M, abs, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Inverse cosine (HLSL SM 1.0)\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(cuda, \"$P_acos($0)\")\n")
SLANG_RAW("__target_intrinsic(cpp, \"$P_acos($0)\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Acos _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T acos(T x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Acos _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T, N> acos(vector<T, N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_UNARY(T, N, acos, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T, N, M> acos(matrix<T, N, M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_UNARY(T, N, M, acos, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Test if all components are non-zero (HLSL SM 1.0)\n")
SLANG_RAW("__generic<T : __BuiltinType>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("bool all(T x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    default:\n")
SLANG_RAW("        __intrinsic_asm \"bool($0)\";\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        __intrinsic_asm \"all\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        let zero = __default<T>();\n")
SLANG_RAW("        if (__isInt<T>())\n")
SLANG_RAW("            return spirv_asm\n")
SLANG_RAW("            {\n")
SLANG_RAW("                OpINotEqual $$bool result $x $zero\n")
SLANG_RAW("            };\n")
SLANG_RAW("        else if (__isFloat<T>())\n")
SLANG_RAW("            return spirv_asm\n")
SLANG_RAW("            {\n")
SLANG_RAW("                OpFUnordNotEqual $$bool result $x $zero\n")
SLANG_RAW("            };\n")
SLANG_RAW("        else if (__isBool<T>())\n")
SLANG_RAW("            return __slang_noop_cast<bool>(x);\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("bool all(vector<T,N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        __intrinsic_asm \"all\";\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"all(bvec$N0($0))\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isBool<T>())\n")
SLANG_RAW("            return spirv_asm\n")
SLANG_RAW("            {\n")
SLANG_RAW("                OpAll $$bool result $x\n")
SLANG_RAW("            };\n")
SLANG_RAW("        else if (__isInt<T>())\n")
SLANG_RAW("        {\n")
SLANG_RAW("            let zero = __default<vector<T,N>>();\n")
SLANG_RAW("            return spirv_asm\n")
SLANG_RAW("            {\n")
SLANG_RAW("                OpINotEqual $$vector<bool,N> %castResult $x $zero;\n")
SLANG_RAW("                OpAll $$bool result %castResult\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("        else\n")
SLANG_RAW("        {\n")
SLANG_RAW("            let zero = __default<T>();\n")
SLANG_RAW("            return spirv_asm\n")
SLANG_RAW("            {\n")
SLANG_RAW("                OpFUnordNotEqual $$vector<bool,N> %castResult $x $zero;\n")
SLANG_RAW("                OpAll $$bool result %castResult\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    default:\n")
SLANG_RAW("        bool result = true;\n")
SLANG_RAW("        for(int i = 0; i < N; ++i)\n")
SLANG_RAW("            result = result && all(x[i]);\n")
SLANG_RAW("        return result;\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("bool all(matrix<T,N,M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    bool result = true;\n")
SLANG_RAW("    for(int i = 0; i < N; ++i)\n")
SLANG_RAW("        result = result && all(x[i]);\n")
SLANG_RAW("    return result;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Barrier for writes to all memory spaces (HLSL SM 5.0)\n")
SLANG_RAW("__glsl_extension(GL_KHR_memory_scope_semantics)\n")
SLANG_RAW("void AllMemoryBarrier()\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"AllMemoryBarrier\";\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"memoryBarrier(gl_ScopeDevice, (gl_StorageSemanticsShared|gl_StorageSemanticsImage|gl_StorageSemanticsBuffer), gl_SemanticsAcquireRelease)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"__threadfence()\";\n")
SLANG_RAW("    case spirv: spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            OpMemoryBarrier Device AcquireRelease|UniformMemory|WorkgroupMemory|ImageMemory;\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Thread-group sync and barrier for writes to all memory spaces (HLSL SM 5.0)\n")
SLANG_RAW("__glsl_extension(GL_KHR_memory_scope_semantics)\n")
SLANG_RAW("void AllMemoryBarrierWithGroupSync()\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"AllMemoryBarrierWithGroupSync\";\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"controlBarrier(gl_ScopeWorkgroup, gl_ScopeDevice, (gl_StorageSemanticsShared|gl_StorageSemanticsImage|gl_StorageSemanticsBuffer), gl_SemanticsAcquireRelease)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"__syncthreads()\";\n")
SLANG_RAW("    case spirv: spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            OpControlBarrier Workgroup Device AcquireRelease|UniformMemory|WorkgroupMemory|ImageMemory;\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Test if any components is non-zero (HLSL SM 1.0)\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("bool any(T x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    default:\n")
SLANG_RAW("        __intrinsic_asm \"bool($0)\";\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        __intrinsic_asm \"any\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        let zero = __default<T>();\n")
SLANG_RAW("        if (__isInt<T>())\n")
SLANG_RAW("            return spirv_asm\n")
SLANG_RAW("            {\n")
SLANG_RAW("                OpINotEqual $$bool result $x $zero\n")
SLANG_RAW("            };\n")
SLANG_RAW("        else if (__isFloat<T>())\n")
SLANG_RAW("            return spirv_asm\n")
SLANG_RAW("            {\n")
SLANG_RAW("                OpFUnordNotEqual $$bool result $x $zero\n")
SLANG_RAW("            };\n")
SLANG_RAW("        else if (__isBool<T>())\n")
SLANG_RAW("            return __slang_noop_cast<bool>(x);\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("bool any(vector<T, N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        __intrinsic_asm \"any\";\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"any(bvec$N0($0))\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isBool<T>())\n")
SLANG_RAW("            return spirv_asm\n")
SLANG_RAW("            {\n")
SLANG_RAW("                OpAny $$bool result $x\n")
SLANG_RAW("            };\n")
SLANG_RAW("        else if (__isInt<T>())\n")
SLANG_RAW("        {\n")
SLANG_RAW("            let zero = __default<vector<T,N>>();\n")
SLANG_RAW("            return spirv_asm\n")
SLANG_RAW("            {\n")
SLANG_RAW("                OpINotEqual $$vector<bool,N> %castResult $x $zero;\n")
SLANG_RAW("                OpAny $$bool result %castResult\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("        else\n")
SLANG_RAW("        {\n")
SLANG_RAW("            let zero = __default<T>();\n")
SLANG_RAW("            return spirv_asm\n")
SLANG_RAW("            {\n")
SLANG_RAW("                OpFUnordNotEqual $$vector<bool,N> %castResult $x $zero;\n")
SLANG_RAW("                OpAny $$bool result %castResult\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    default:\n")
SLANG_RAW("        bool result = false;\n")
SLANG_RAW("        for(int i = 0; i < N; ++i)\n")
SLANG_RAW("            result = result || any(x[i]);\n")
SLANG_RAW("        return result;\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("bool any(matrix<T, N, M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    bool result = false;\n")
SLANG_RAW("    for(int i = 0; i < N; ++i)\n")
SLANG_RAW("        result = result || any(x[i]);\n")
SLANG_RAW("    return result;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("// Reinterpret bits as a double (HLSL SM 5.0)\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl, \"packDouble2x32(uvec2($0, $1))\")\n")
SLANG_RAW("__target_intrinsic(cpp, \"$P_asdouble($0, $1)\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"$P_asdouble($0, $1)\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"%v = OpCompositeConstruct _type(uint2) resultId _0 _1; OpExtInst resultType resultId glsl450 59 %v\")\n")
SLANG_RAW("__glsl_extension(GL_ARB_gpu_shader5)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("double asdouble(uint lowbits, uint highbits);\n")
SLANG_RAW("\n")
SLANG_RAW("// Reinterpret bits as a float (HLSL SM 4.0)\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl, \"intBitsToFloat\")\n")
SLANG_RAW("__target_intrinsic(cpp, \"$P_asfloat($0)\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"$P_asfloat($0)\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpBitcast resultType resultId _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("float asfloat(int x);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl, \"uintBitsToFloat\")\n")
SLANG_RAW("__target_intrinsic(cpp, \"$P_asfloat($0)\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"$P_asfloat($0)\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpBitcast resultType resultId _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("float asfloat(uint x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl, \"intBitsToFloat\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpBitcast resultType resultId _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<float, N> asfloat(vector< int, N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_UNARY(float, N, asfloat, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl, \"uintBitsToFloat\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpBitcast resultType resultId _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<float,N> asfloat(vector<uint,N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_UNARY(float, N, asfloat, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<float,N,M> asfloat(matrix< int,N,M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_UNARY(float, N, M, asfloat, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<float,N,M> asfloat(matrix<uint,N,M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_UNARY(float, N, M, asfloat, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// No op\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("float asfloat(float x)\n")
SLANG_RAW("{ return x; }\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let N : int>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<float,N> asfloat(vector<float,N> x)\n")
SLANG_RAW("{ return x; }\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let N : int, let M : int>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<float,N,M> asfloat(matrix<float,N,M> x)\n")
SLANG_RAW("{ return x; }\n")
SLANG_RAW("\n")
SLANG_RAW("// Inverse sine (HLSL SM 1.0)\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(cuda, \"$P_asin($0)\")\n")
SLANG_RAW("__target_intrinsic(cpp, \"$P_asin($0)\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Asin _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T asin(T x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Asin _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T, N> asin(vector<T, N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_UNARY(T,N,asin,x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T, N, M> asin(matrix<T, N, M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_UNARY(T,N,M,asin,x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Reinterpret bits as an int (HLSL SM 4.0)\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl, \"floatBitsToInt\")\n")
SLANG_RAW("__target_intrinsic(cpp, \"$P_asint($0)\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"$P_asint($0)\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpBitcast resultType resultId _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("int asint(float x);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl, \"int($0)\")\n")
SLANG_RAW("__target_intrinsic(cpp, \"$P_asint($0)\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"$P_asint($0)\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpBitcast resultType resultId _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("int asint(uint x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl, \"floatBitsToInt\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpBitcast resultType resultId _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<int, N> asint(vector<float, N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_UNARY(int, N, asint, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl, \"ivec$N0($0)\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpBitcast resultType resultId _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<int, N> asint(vector<uint, N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_UNARY(int, N, asint, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<int, N, M> asint(matrix<float, N, M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_UNARY(int, N, M, asint, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<int, N, M> asint(matrix<uint, N, M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_UNARY(int, N, M, asint, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// No op\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("int asint(int x)\n")
SLANG_RAW("{ return x; }\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let N : int>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<int,N> asint(vector<int,N> x)\n")
SLANG_RAW("{ return x; }\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let N : int, let M : int>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<int,N,M> asint(matrix<int,N,M> x)\n")
SLANG_RAW("{ return x; }\n")
SLANG_RAW("\n")
SLANG_RAW("// Reinterpret bits of double as a uint (HLSL SM 5.0)\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_extension(GL_ARB_gpu_shader5)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("void asuint(double value, out uint lowbits, out uint highbits)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"asuint\";\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"{ uvec2 v = unpackDouble2x32($0); $1 = v.x; $2 = v.y; }\";\n")
SLANG_RAW("    case cpp:\n")
SLANG_RAW("    case cuda:\n")
SLANG_RAW("        __intrinsic_asm \"$P_asuint($0, $1, $2)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        let uv = spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            result : $$uint2 = OpBitcast $value;\n")
SLANG_RAW("        };\n")
SLANG_RAW("        lowbits = uv.x;\n")
SLANG_RAW("        highbits = uv.y;\n")
SLANG_RAW("        return;\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Reinterpret bits as a uint (HLSL SM 4.0)\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl, \"floatBitsToUint\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpBitcast resultType resultId _0\")\n")
SLANG_RAW("__target_intrinsic(cpp, \"$P_asuint($0)\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"$P_asuint($0)\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("uint asuint(float x);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl, \"uint($0)\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpBitcast resultType resultId _0\")\n")
SLANG_RAW("__target_intrinsic(cpp, \"$P_asuint($0)\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"$P_asuint($0)\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("uint asuint(int x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl, \"floatBitsToUint\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpBitcast resultType resultId _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<uint,N> asuint(vector<float,N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_UNARY(uint, N, asuint, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl, \"uvec$N0($0)\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpBitcast resultType resultId _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<uint, N> asuint(vector<int, N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_UNARY(uint, N, asuint, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<uint,N,M> asuint(matrix<float,N,M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_UNARY(uint, N, M, asuint, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<uint, N, M> asuint(matrix<int, N, M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_UNARY(uint, N, M, asuint, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("uint asuint(uint x)\n")
SLANG_RAW("{ return x; }\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let N : int>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<uint,N> asuint(vector<uint,N> x)\n")
SLANG_RAW("{ return x; }\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let N : int, let M : int>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<uint,N,M> asuint(matrix<uint,N,M> x)\n")
SLANG_RAW("{ return x; }\n")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("// 16-bit bitcast ops (HLSL SM 6.2)\n")
SLANG_RAW("//\n")
SLANG_RAW("// TODO: We need to map these to GLSL/SPIR-V\n")
SLANG_RAW("// operations that don't require an intermediate\n")
SLANG_RAW("// conversion to fp32.\n")
SLANG_RAW("\n")
SLANG_RAW("// Identity cases:\n")
SLANG_RAW("\n")
SLANG_RAW("[__unsafeForceInlineEarly][__readNone] float16_t asfloat16(float16_t value) { return value; }\n")
SLANG_RAW("[__unsafeForceInlineEarly][__readNone] vector<float16_t,N> asfloat16<let N : int>(vector<float16_t,N> value) { return value; }\n")
SLANG_RAW("[__unsafeForceInlineEarly][__readNone] matrix<float16_t,R,C> asfloat16<let R : int, let C : int>(matrix<float16_t,R,C> value) { return value; }\n")
SLANG_RAW("\n")
SLANG_RAW("[__unsafeForceInlineEarly][__readNone] int16_t asint16(int16_t value) { return value; }\n")
SLANG_RAW("[__unsafeForceInlineEarly][__readNone] vector<int16_t,N> asint16<let N : int>(vector<int16_t,N> value) { return value; }\n")
SLANG_RAW("[__unsafeForceInlineEarly][__readNone] matrix<int16_t,R,C> asint16<let R : int, let C : int>(matrix<int16_t,R,C> value) { return value; }\n")
SLANG_RAW("\n")
SLANG_RAW("[__unsafeForceInlineEarly][__readNone] uint16_t asuint16(uint16_t value) { return value; }\n")
SLANG_RAW("[__unsafeForceInlineEarly][__readNone] vector<uint16_t,N> asuint16<let N : int>(vector<uint16_t,N> value) { return value; }\n")
SLANG_RAW("[__unsafeForceInlineEarly][__readNone] matrix<uint16_t,R,C> asuint16<let R : int, let C : int>(matrix<uint16_t,R,C> value) { return value; }\n")
SLANG_RAW("\n")
SLANG_RAW("// Signed<->unsigned cases:\n")
SLANG_RAW("\n")
SLANG_RAW("[__unsafeForceInlineEarly][__readNone] int16_t asint16(uint16_t value) { return value; }\n")
SLANG_RAW("[__unsafeForceInlineEarly][__readNone] vector<int16_t,N> asint16<let N : int>(vector<uint16_t,N> value) { return value; }\n")
SLANG_RAW("[__unsafeForceInlineEarly][__readNone] matrix<int16_t,R,C> asint16<let R : int, let C : int>(matrix<uint16_t,R,C> value) { return value; }\n")
SLANG_RAW("\n")
SLANG_RAW("[__unsafeForceInlineEarly][__readNone] uint16_t asuint16(int16_t value) { return value; }\n")
SLANG_RAW("[__unsafeForceInlineEarly][__readNone] vector<uint16_t,N> asuint16<let N : int>(vector<int16_t,N> value) { return value; }\n")
SLANG_RAW("[__unsafeForceInlineEarly][__readNone] matrix<uint16_t,R,C> asuint16<let R : int, let C : int>(matrix<int16_t,R,C> value) { return value; }\n")
SLANG_RAW("\n")
SLANG_RAW("// Float->unsigned cases:\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl, \"uint16_t(packHalf2x16(vec2($0, 0.0)))\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"__half_as_ushort\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpBitcast resultType resultId _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("uint16_t asuint16(float16_t value);\n")
SLANG_RAW("\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<uint16_t,N> asuint16<let N : int>(vector<float16_t,N> value)\n")
SLANG_RAW("{ VECTOR_MAP_UNARY(uint16_t, N, asuint16, value); }\n")
SLANG_RAW("\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<uint16_t,R,C> asuint16<let R : int, let C : int>(matrix<float16_t,R,C> value)\n")
SLANG_RAW("{ MATRIX_MAP_UNARY(uint16_t, R, C, asuint16, value); }\n")
SLANG_RAW("\n")
SLANG_RAW("// Unsigned->float cases:\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl, \"float16_t(unpackHalf2x16($0).x)\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"__ushort_as_half\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpBitcast resultType resultId _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("float16_t asfloat16(uint16_t value);\n")
SLANG_RAW("\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<float16_t,N> asfloat16<let N : int>(vector<uint16_t,N> value)\n")
SLANG_RAW("{ VECTOR_MAP_UNARY(float16_t, N, asfloat16, value); }\n")
SLANG_RAW("\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<float16_t,R,C> asfloat16<let R : int, let C : int>(matrix<uint16_t,R,C> value)\n")
SLANG_RAW("{ MATRIX_MAP_UNARY(float16_t, R, C, asfloat16, value); }\n")
SLANG_RAW("\n")
SLANG_RAW("// Float<->signed cases:\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(cuda, \"__half_as_short\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpBitcast resultType resultId _0\")\n")
SLANG_RAW("[__unsafeForceInlineEarly][__readNone] int16_t asint16(float16_t value) { return asuint16(value); }\n")
SLANG_RAW("__target_intrinsic(hlsl) [__unsafeForceInlineEarly][__readNone] vector<int16_t,N> asint16<let N : int>(vector<float16_t,N> value) { return asuint16(value); }\n")
SLANG_RAW("__target_intrinsic(hlsl) [__unsafeForceInlineEarly][__readNone] matrix<int16_t,R,C> asint16<let R : int, let C : int>(matrix<float16_t,R,C> value) { return asuint16(value); }\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(cuda, \"__short_as_half\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpBitcast resultType resultId _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[__unsafeForceInlineEarly] float16_t asfloat16(int16_t value) { return asfloat16(asuint16(value)); }\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(hlsl) [__unsafeForceInlineEarly][__readNone] vector<float16_t,N> asfloat16<let N : int>(vector<int16_t,N> value) { return asfloat16(asuint16(value)); }\n")
SLANG_RAW("__target_intrinsic(hlsl) [__unsafeForceInlineEarly][__readNone] matrix<float16_t,R,C> asfloat16<let R : int, let C : int>(matrix<int16_t,R,C> value) { return asfloat16(asuint16(value)); }\n")
SLANG_RAW("\n")
SLANG_RAW("// Inverse tangent (HLSL SM 1.0)\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(cuda, \"$P_atan($0)\")\n")
SLANG_RAW("__target_intrinsic(cpp, \"$P_atan($0)\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Atan _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T atan(T x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Atan _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T, N> atan(vector<T, N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_UNARY(T, N, atan, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T, N, M> atan(matrix<T, N, M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_UNARY(T, N, M, atan, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl,\"atan($0,$1)\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"$P_atan2($0, $1)\")\n")
SLANG_RAW("__target_intrinsic(cpp, \"$P_atan2($0, $1)\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Atan2 _0 _1\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T atan2(T y, T x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl,\"atan($0,$1)\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Atan2 _0 _1\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T, N> atan2(vector<T, N> y, vector<T, N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_BINARY(T, N, atan2, y, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T,N,M> atan2(matrix<T,N,M> y, matrix<T,N,M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_BINARY(T, N, M, atan2, y, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Ceiling (HLSL SM 1.0)\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(cuda, \"$P_ceil($0)\")\n")
SLANG_RAW("__target_intrinsic(cpp, \"$P_ceil($0)\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Ceil _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T ceil(T x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Ceil _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T, N> ceil(vector<T, N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_UNARY(T, N, ceil, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T, N, M> ceil(matrix<T, N, M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_UNARY(T, N, M, ceil, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("// Check access status to tiled resource\n")
SLANG_RAW("bool CheckAccessFullyMapped(uint status);\n")
SLANG_RAW("\n")
SLANG_RAW("// Clamp (HLSL SM 1.0)\n")
SLANG_RAW("__generic<T : __BuiltinIntegerType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 fus(FClamp, UClamp, SClamp) _0 _1 _2\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T clamp(T x, T minBound, T maxBound)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return min(max(x, minBound), maxBound);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinIntegerType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 fus(FClamp, UClamp, SClamp) _0 _1 _2\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T, N> clamp(vector<T, N> x, vector<T, N> minBound, vector<T, N> maxBound)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return min(max(x, minBound), maxBound);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinIntegerType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T,N,M> clamp(matrix<T,N,M> x, matrix<T,N,M> minBound, matrix<T,N,M> maxBound)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return min(max(x, minBound), maxBound);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 fus(FClamp, UClamp, SClamp) _0 _1 _2\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T clamp(T x, T minBound, T maxBound)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return min(max(x, minBound), maxBound);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 fus(FClamp, UClamp, SClamp) _0 _1 _2\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T, N> clamp(vector<T, N> x, vector<T, N> minBound, vector<T, N> maxBound)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return min(max(x, minBound), maxBound);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T,N,M> clamp(matrix<T,N,M> x, matrix<T,N,M> minBound, matrix<T,N,M> maxBound)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return min(max(x, minBound), maxBound);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Clip (discard) fragment conditionally\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("void clip(T x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    if(x < T(0)) discard;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("void clip(vector<T,N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    if(any(x < T(0))) discard;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("void clip(matrix<T,N,M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    if(any(x < T(0))) discard;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Cosine\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(cuda, \"$P_cos($0)\")\n")
SLANG_RAW("__target_intrinsic(cpp, \"$P_cos($0)\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Cos _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T cos(T x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Cos _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T, N> cos(vector<T, N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_UNARY(T,N, cos, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T, N, M> cos(matrix<T, N, M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_UNARY(T, N, M, cos, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Hyperbolic cosine\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(cuda, \"$P_cosh($0)\")\n")
SLANG_RAW("__target_intrinsic(cpp, \"$P_cosh($0)\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Cosh _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T cosh(T x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Cosh _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T,N> cosh(vector<T,N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_UNARY(T,N, cosh, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T, N, M> cosh(matrix<T, N, M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_UNARY(T, N, M, cosh, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Population count\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("uint countbits(uint value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        __intrinsic_asm \"countbits\";\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"bitCount\";\n")
SLANG_RAW("    case cuda:\n")
SLANG_RAW("    case cpp:\n")
SLANG_RAW("        __intrinsic_asm \"$P_countbits($0)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {OpBitCount $$uint result $value};\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Cross product\n")
SLANG_RAW("// TODO: SPIRV does not support integer vectors.\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Cross _0 _1\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T,3> cross(vector<T,3> left, vector<T,3> right)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return vector<T,3>(\n")
SLANG_RAW("        left.y * right.z - left.z * right.y,\n")
SLANG_RAW("        left.z * right.x - left.x * right.z,\n")
SLANG_RAW("        left.x * right.y - left.y * right.x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinIntegerType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Cross _0 _1\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T, 3> cross(vector<T, 3> left, vector<T, 3> right)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return vector<T, 3>(\n")
SLANG_RAW("        left.y * right.z - left.z * right.y,\n")
SLANG_RAW("        left.z * right.x - left.x * right.z,\n")
SLANG_RAW("        left.x * right.y - left.y * right.x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Convert encoded color\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("int4 D3DCOLORtoUBYTE4(float4 color)\n")
SLANG_RAW("{\n")
SLANG_RAW("    let scaled = color.zyxw * 255.001999f;\n")
SLANG_RAW("    return int4(scaled);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Partial-difference derivatives\n")

const char* diffDimensions[2] = {"x", "y"};
for (auto xOrY : diffDimensions) {
SLANG_RAW("#line 3817 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T dd")
SLANG_SPLICE(xOrY
)
SLANG_RAW("(T x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("    case cpp:\n")
SLANG_RAW("    case cuda:\n")
SLANG_RAW("        __intrinsic_asm \"dd")
SLANG_SPLICE(xOrY
)
SLANG_RAW("\";\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"dFd")
SLANG_SPLICE(xOrY
)
SLANG_RAW("\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {OpDPd")
SLANG_SPLICE(xOrY
)
SLANG_RAW(" $$T result $x};\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T, N> dd")
SLANG_SPLICE(xOrY
)
SLANG_RAW("(vector<T, N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("    case cpp:\n")
SLANG_RAW("    case cuda:\n")
SLANG_RAW("        __intrinsic_asm \"dd")
SLANG_SPLICE(xOrY
)
SLANG_RAW("\";\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"dFd")
SLANG_SPLICE(xOrY
)
SLANG_RAW("\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {OpDPd")
SLANG_SPLICE(xOrY
)
SLANG_RAW(" $$vector<T, N> result $x};\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T, N, M> dd")
SLANG_SPLICE(xOrY
)
SLANG_RAW("(matrix<T, N, M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_UNARY(T, N, M, dd")
SLANG_SPLICE(xOrY
)
SLANG_RAW(", x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__glsl_extension(GL_ARB_derivative_control)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T dd")
SLANG_SPLICE(xOrY
)
SLANG_RAW("_coarse(T x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"dd")
SLANG_SPLICE(xOrY
)
SLANG_RAW("_coarse\";\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"dFd")
SLANG_SPLICE(xOrY
)
SLANG_RAW("Coarse\";\n")
SLANG_RAW("    case spirv: return spirv_asm {OpCapability DerivativeControl; result:$$T = OpDPd")
SLANG_SPLICE(xOrY
)
SLANG_RAW("Coarse $x};\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_ARB_derivative_control)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T, N> dd")
SLANG_SPLICE(xOrY
)
SLANG_RAW("_coarse(vector<T, N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"dd")
SLANG_SPLICE(xOrY
)
SLANG_RAW("_coarse\";\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"dFd")
SLANG_SPLICE(xOrY
)
SLANG_RAW("Coarse\";\n")
SLANG_RAW("    case spirv: return spirv_asm {OpCapability DerivativeControl; result:$$vector<T,N> = OpDPd")
SLANG_SPLICE(xOrY
)
SLANG_RAW("Coarse $x};\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T, N, M> dd")
SLANG_SPLICE(xOrY
)
SLANG_RAW("_coarse(matrix<T, N, M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_UNARY(T, N, M, dd")
SLANG_SPLICE(xOrY
)
SLANG_RAW("_coarse, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__glsl_extension(GL_ARB_derivative_control)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T dd")
SLANG_SPLICE(xOrY
)
SLANG_RAW("_fine(T x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"dd")
SLANG_SPLICE(xOrY
)
SLANG_RAW("_fine\";\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"dFd")
SLANG_SPLICE(xOrY
)
SLANG_RAW("Fine\";\n")
SLANG_RAW("    case spirv: return spirv_asm {OpCapability DerivativeControl; result:$$T = OpDPd")
SLANG_SPLICE(xOrY
)
SLANG_RAW("Fine $x};\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_ARB_derivative_control)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T, N> dd")
SLANG_SPLICE(xOrY
)
SLANG_RAW("_fine(vector<T, N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"dd")
SLANG_SPLICE(xOrY
)
SLANG_RAW("_fine\";\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"dFd")
SLANG_SPLICE(xOrY
)
SLANG_RAW("Fine\";\n")
SLANG_RAW("    case spirv: return spirv_asm {OpCapability DerivativeControl; result:$$vector<T,N> = OpDPd")
SLANG_SPLICE(xOrY
)
SLANG_RAW("Fine $x};\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T, N, M> dd")
SLANG_SPLICE(xOrY
)
SLANG_RAW("_fine(matrix<T, N, M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_UNARY(T, N, M, dd")
SLANG_SPLICE(xOrY
)
SLANG_RAW("_fine, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")

} // for (xOrY)
SLANG_RAW("#line 3930 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("// Radians to degrees\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Degrees _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T degrees(T x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return x * (T(180) / T.getPi());\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Degrees _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T, N> degrees(vector<T, N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_UNARY(T, N, degrees, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T, N, M> degrees(matrix<T, N, M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_UNARY(T, N, M, degrees, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Matrix determinant\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Determinant _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[PreferCheckpoint]\n")
SLANG_RAW("T determinant(matrix<T,N,N> m);\n")
SLANG_RAW("\n")
SLANG_RAW("// Barrier for device memory\n")
SLANG_RAW("__glsl_extension(GL_KHR_memory_scope_semantics)\n")
SLANG_RAW("void DeviceMemoryBarrier()\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"DeviceMemoryBarrier\";\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"memoryBarrier(gl_ScopeDevice, (gl_StorageSemanticsImage|gl_StorageSemanticsBuffer), gl_SemanticsAcquireRelease)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"__threadfence()\";\n")
SLANG_RAW("    case spirv: spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            OpMemoryBarrier Device AcquireRelease|UniformMemory|ImageMemory;\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_extension(GL_KHR_memory_scope_semantics)\n")
SLANG_RAW("void DeviceMemoryBarrierWithGroupSync()\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"DeviceMemoryBarrierWithGroupSync\";\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"controlBarrier(gl_ScopeWorkgroup, gl_ScopeDevice, (gl_StorageSemanticsImage|gl_StorageSemanticsBuffer), gl_SemanticsAcquireRelease)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"__syncthreads()\";\n")
SLANG_RAW("    case spirv: spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            OpControlBarrier Workgroup Device AcquireRelease|UniformMemory|ImageMemory;\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Vector distance\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Distance _0 _1\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T distance(vector<T, N> x, vector<T, N> y)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return length(x - y);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T distance(T x, T y)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return length(x - y);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Vector dot product\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpDot resultType resultId _0 _1\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T dot(vector<T, N> x, vector<T, N> y)\n")
SLANG_RAW("{\n")
SLANG_RAW("    T result = T(0);\n")
SLANG_RAW("    for(int i = 0; i < N; ++i)\n")
SLANG_RAW("        result += x[i] * y[i];\n")
SLANG_RAW("    return result;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinIntegerType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T dot(vector<T, N> x, vector<T, N> y)\n")
SLANG_RAW("{\n")
SLANG_RAW("    T result = T(0);\n")
SLANG_RAW("    for(int i = 0; i < N; ++i)\n")
SLANG_RAW("        result += x[i] * y[i];\n")
SLANG_RAW("    return result;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("// Helper for computing distance terms for lighting (obsolete)\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType> vector<T,4> dst(vector<T,4> x, vector<T,4> y);\n")
SLANG_RAW("\n")
SLANG_RAW("// Given a RWByteAddressBuffer allow it to be interpreted as a RWStructuredBuffer\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_GetEquivalentStructuredBuffer
)
SLANG_RAW(")\n")
SLANG_RAW("RWStructuredBuffer<T> __getEquivalentStructuredBuffer<T>(RWByteAddressBuffer b);\n")
SLANG_RAW("\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_GetEquivalentStructuredBuffer
)
SLANG_RAW(")\n")
SLANG_RAW("StructuredBuffer<T> __getEquivalentStructuredBuffer<T>(ByteAddressBuffer b);\n")
SLANG_RAW("\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_GetEquivalentStructuredBuffer
)
SLANG_RAW(")\n")
SLANG_RAW("RasterizerOrderedStructuredBuffer<T> __getEquivalentStructuredBuffer<T>(RasterizerOrderedByteAddressBuffer b);\n")
SLANG_RAW("\n")
SLANG_RAW("// Error message\n")
SLANG_RAW("\n")
SLANG_RAW("// void errorf( string format, ... );\n")
SLANG_RAW("\n")
SLANG_RAW("// Attribute evaluation\n")
SLANG_RAW("\n")
SLANG_RAW("// TODO: The matrix cases of these functions won't actuall work\n")
SLANG_RAW("// when compiled to GLSL, since they only support scalar/vector\n")
SLANG_RAW("\n")
SLANG_RAW("// TODO: Should these be constrains to `__BuiltinFloatingPointType`?\n")
SLANG_RAW("// TODO: SPIRV-direct does not support non-floating-point types.\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType>\n")
SLANG_RAW("__target_intrinsic(glsl, interpolateAtCentroid)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 InterpolateAtCentroid _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T EvaluateAttributeAtCentroid(T x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int>\n")
SLANG_RAW("__target_intrinsic(glsl, interpolateAtCentroid)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 InterpolateAtCentroid _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T,N> EvaluateAttributeAtCentroid(vector<T,N> x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(glsl, interpolateAtCentroid)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T,N,M> EvaluateAttributeAtCentroid(matrix<T,N,M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_UNARY(T, N, M, EvaluateAttributeAtCentroid, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType>\n")
SLANG_RAW("__target_intrinsic(glsl, \"interpolateAtSample($0, int($1))\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 InterpolateAtSample _0 _1\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T EvaluateAttributeAtSample(T x, uint sampleindex);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int>\n")
SLANG_RAW("__target_intrinsic(glsl, \"interpolateAtSample($0, int($1))\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 InterpolateAtSample _0 _1\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T,N> EvaluateAttributeAtSample(vector<T,N> x, uint sampleindex);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(glsl, \"interpolateAtSample($0, int($1))\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T,N,M> EvaluateAttributeAtSample(matrix<T,N,M> x, uint sampleindex)\n")
SLANG_RAW("{\n")
SLANG_RAW("    matrix<T,N,M> result;\n")
SLANG_RAW("    for(int i = 0; i < N; ++i)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        result[i] = EvaluateAttributeAtSample(x[i], sampleindex);\n")
SLANG_RAW("    }\n")
SLANG_RAW("    return result;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType>\n")
SLANG_RAW("__target_intrinsic(glsl, \"interpolateAtOffset($0, vec2($1) / 16.0f)\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"%foffset = OpConvertSToF _type(float2) resultId _1; %offsetdiv16 = 136 _type(float2) resultId %foffset const(float2, 16.0, 16.0); OpExtInst resultType resultId glsl450 78 _0 %offsetdiv16\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T EvaluateAttributeSnapped(T x, int2 offset);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int>\n")
SLANG_RAW("__target_intrinsic(glsl, \"interpolateAtOffset($0, vec2($1) / 16.0f)\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"%foffset = OpConvertSToF _type(float2) resultId _1; %offsetdiv16 = 136 _type(float2) resultId %foffset const(float2, 16.0, 16.0); OpExtInst resultType resultId glsl450 78 _0 %offsetdiv16\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T,N> EvaluateAttributeSnapped(vector<T,N> x, int2 offset);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(glsl, \"interpolateAtOffset($0, vec2($1) / 16.0f)\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T,N,M> EvaluateAttributeSnapped(matrix<T,N,M> x, int2 offset)\n")
SLANG_RAW("{\n")
SLANG_RAW("    matrix<T,N,M> result;\n")
SLANG_RAW("    for(int i = 0; i < N; ++i)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        result[i] = EvaluateAttributeSnapped(x[i], offset);\n")
SLANG_RAW("    }\n")
SLANG_RAW("    return result;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Base-e exponent\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(cuda, \"$P_exp($0)\")\n")
SLANG_RAW("__target_intrinsic(cpp, \"$P_exp($0)\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Exp _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T exp(T x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Exp _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T, N> exp(vector<T, N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_UNARY(T, N, exp, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T, N, M> exp(matrix<T, N, M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_UNARY(T, N, M, exp, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Base-2 exponent\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(cuda, \"$P_exp2($0)\")\n")
SLANG_RAW("__target_intrinsic(cpp, \"$P_exp2($0)\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Exp2 _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T exp2(T x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Exp2 _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T,N> exp2(vector<T,N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_UNARY(T, N, exp2, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T,N,M> exp2(matrix<T,N,M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_UNARY(T, N, M, exp2, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("// Convert 16-bit float stored in low bits of integer\n")
SLANG_RAW("__target_intrinsic(glsl, \"unpackHalf2x16($0).x\")\n")
SLANG_RAW("__glsl_version(420)\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__cuda_sm_version(6.0)\n")
SLANG_RAW("__target_intrinsic(cuda, \"__half2float(__ushort_as_half($0))\")\n")
SLANG_RAW("__target_intrinsic(spirv, R\"(\n")
SLANG_RAW("                    %lowBits = OpUConvert _type(uint16_t) resultId _0;\n")
SLANG_RAW("                    %half = OpBitcast _type(half) resultId %lowBits;\n")
SLANG_RAW("                    OpFConvert resultType resultId %half)\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("float f16tof32(uint value);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<float, N> f16tof32(vector<uint, N> value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_UNARY(float, N, f16tof32, value);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("// Convert to 16-bit float stored in low bits of integer\n")
SLANG_RAW("__target_intrinsic(glsl, \"packHalf2x16(vec2($0,0.0))\")\n")
SLANG_RAW("__glsl_version(420)\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__cuda_sm_version(6.0)\n")
SLANG_RAW("__target_intrinsic(cuda, \"__half_as_ushort(__float2half($0))\")\n")
SLANG_RAW("__target_intrinsic(spirv, R\"(\n")
SLANG_RAW("                    %half = OpFConvert _type(half) resultId _0;\n")
SLANG_RAW("                    %lowBits = OpBitcast _type(uint16_t) resultId %half;\n")
SLANG_RAW("                    OpUConvert resultType resultId %lowBits)\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("uint f32tof16(float value);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<uint, N> f32tof16(vector<float, N> value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_UNARY(uint, N, f32tof16, value);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n")
SLANG_RAW("// The following is Slang specific and NOT part of standard HLSL\n")
SLANG_RAW("// It's not clear what happens with float16 time in HLSL -> can the float16 coerce to uint for example? If so that would\n")
SLANG_RAW("// give the wrong result\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"unpackHalf2x16($0).x\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"__half2float\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpFConvert resultType resultId _0\")\n")
SLANG_RAW("__glsl_version(420)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("float f16tof32(float16_t value);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(cuda, \"__half2float\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpFConvert resultType resultId _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<float, N> f16tof32(vector<float16_t, N> value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_UNARY(float, N, f16tof32, value);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Convert to float16_t\n")
SLANG_RAW("__target_intrinsic(glsl, \"packHalf2x16(vec2($0,0.0))\")\n")
SLANG_RAW("__glsl_version(420)\n")
SLANG_RAW("__target_intrinsic(cuda, \"__float2half\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpFConvert resultType resultId _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("float16_t f32tof16_(float value);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let N : int>\n")
SLANG_RAW("__target_intrinsic(cuda, \"__float2half\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpFConvert resultType resultId _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<float16_t, N> f32tof16_(vector<float, N> value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_UNARY(float16_t, N, f32tof16, value);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n")
SLANG_RAW("\n")
SLANG_RAW("// Flip surface normal to face forward, if needed\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 FaceForward _0 _1 _2\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T,N> faceforward(vector<T,N> n, vector<T,N> i, vector<T,N> ng)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return dot(ng, i) < T(0.0f) ? n : -n;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Find first set bit starting at high bit and working down\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl,\"findMSB\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"$P_firstbithigh($0)\")\n")
SLANG_RAW("__target_intrinsic(cpp, \"$P_firstbithigh($0)\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 FindSMsb _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("int firstbithigh(int value);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl,\"findMSB\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 FindSMsb _0\")\n")
SLANG_RAW("__generic<let N : int>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<int, N> firstbithigh(vector<int, N> value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_UNARY(int, N, firstbithigh, value);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl,\"findMSB\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"$P_firstbithigh($0)\")\n")
SLANG_RAW("__target_intrinsic(cpp, \"$P_firstbithigh($0)\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 FindUMsb _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("uint firstbithigh(uint value);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl,\"findMSB\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 FindUMsb _0\")\n")
SLANG_RAW("__generic<let N : int>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<uint,N> firstbithigh(vector<uint,N> value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_UNARY(uint, N, firstbithigh, value);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Find first set bit starting at low bit and working up\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl,\"findLSB\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"$P_firstbitlow($0)\")\n")
SLANG_RAW("__target_intrinsic(cpp, \"$P_firstbitlow($0)\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 FindILsb _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("int firstbitlow(int value);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl,\"findLSB\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 FindILsb _0\")\n")
SLANG_RAW("__generic<let N : int>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<int,N> firstbitlow(vector<int,N> value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_UNARY(int, N, firstbitlow, value);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl,\"findLSB\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"$P_firstbitlow($0)\")\n")
SLANG_RAW("__target_intrinsic(cpp, \"$P_firstbitlow($0)\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 FindILsb _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("uint firstbitlow(uint value);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl,\"findLSB\")\n")
SLANG_RAW("__generic<let N : int>\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 FindILsb _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<uint,N> firstbitlow(vector<uint,N> value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_UNARY(uint, N, firstbitlow, value);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Floor (HLSL SM 1.0)\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(cuda, \"$P_floor($0)\")\n")
SLANG_RAW("__target_intrinsic(cpp, \"$P_floor($0)\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Floor _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T floor(T x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Floor _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T, N> floor(vector<T, N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_UNARY(T, N, floor, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T, N, M> floor(matrix<T, N, M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_UNARY(T, N, M, floor, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Fused multiply-add for doubles\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(cuda, \"$P_fma($0, $1, $2)\")\n")
SLANG_RAW("__target_intrinsic(cpp, \"$P_fma($0, $1, $2)\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Fma _0 _1 _2\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("double fma(double a, double b, double c);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Fma _0 _1 _2\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<double, N> fma(vector<double, N> a, vector<double, N> b, vector<double, N> c)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_TRINARY(double, N, fma, a, b, c);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<double, N, M> fma(matrix<double, N, M> a, matrix<double, N, M> b, matrix<double, N, M> c)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_TRINARY(double, N, M, fma, a, b, c);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Floating point remainder of x/y\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(cuda, \"$P_fmod($0, $1)\")\n")
SLANG_RAW("__target_intrinsic(cpp, \"$P_fmod($0, $1)\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T fmod(T x, T y)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return x - y * trunc(x/y);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T, N> fmod(vector<T, N> x, vector<T, N> y)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_BINARY(T, N, fmod, x, y);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T, N, M> fmod(matrix<T, N, M> x, matrix<T, N, M> y)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_BINARY(T, N, M, fmod, x, y);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Fractional part\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl, fract)\n")
SLANG_RAW("__target_intrinsic(cuda, \"$P_frac($0)\")\n")
SLANG_RAW("__target_intrinsic(cpp, \"$P_frac($0)\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Fract _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T frac(T x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl, fract)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Fract _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T, N> frac(vector<T, N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_UNARY(T, N, frac, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T, N, M> frac(matrix<T, N, M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_UNARY(T, N, M, frac, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Split float into mantissa and exponent\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(cpp, \"$P_frexp($0, $1)\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"$P_frexp($0, $1)\")\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Frexp _0 _1\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T frexp(T x, out int exp);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Frexp _0 _1\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T, N> frexp(vector<T, N> x, out vector<int, N> exp)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_BINARY(T, N, frexp, x, exp);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int, let L : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T, N, M> frexp(matrix<T, N, M> x, out matrix<int, N, M, L> exp)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_BINARY(T, N, M, frexp, x, exp);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Texture filter width\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpFwidth resultType resultId _0\")\n")
SLANG_RAW("T fwidth(T x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpFwidth resultType resultId _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T, N> fwidth(vector<T, N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_UNARY(T, N, fwidth, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T, N, M> fwidth(matrix<T, N, M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_UNARY(T, N, M, fwidth, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("/// Get the value of a vertex attribute at a specific vertex.\n")
SLANG_RAW("///\n")
SLANG_RAW("/// The `GetAttributeAtVertex()` function can be used in a fragment shader\n")
SLANG_RAW("/// to get the value of the given `attribute` at the vertex of the primitive\n")
SLANG_RAW("/// that corresponds to the given `vertexIndex`.\n")
SLANG_RAW("///\n")
SLANG_RAW("/// Note that the `attribute` must have been a declared varying input to\n")
SLANG_RAW("/// the fragment shader with the `nointerpolation` modifier.\n")
SLANG_RAW("///\n")
SLANG_RAW("/// This function can be applied to scalars, vectors, and matrices of\n")
SLANG_RAW("/// built-in scalar types.\n")
SLANG_RAW("///\n")
SLANG_RAW("__generic<T : __BuiltinType>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("__glsl_version(450)\n")
SLANG_RAW("T GetAttributeAtVertex(T attribute, uint vertexIndex)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        __intrinsic_asm \"GetAttributeAtVertex\";\n")
SLANG_RAW("    case GL_NV_fragment_shader_barycentric:\n")
SLANG_RAW("    case GL_EXT_fragment_shader_barycentric: \n")
SLANG_RAW("        __intrinsic_asm \"$0[$1]\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            %_ptr_Input_T = OpTypePointer Input $$T;\n")
SLANG_RAW("            %addr = OpAccessChain %_ptr_Input_T $attribute $vertexIndex;\n")
SLANG_RAW("            result:$$T = OpLoad %addr;\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("/// Get the value of a vertex attribute at a specific vertex.\n")
SLANG_RAW("///\n")
SLANG_RAW("/// The `GetAttributeAtVertex()` function can be used in a fragment shader\n")
SLANG_RAW("/// to get the value of the given `attribute` at the vertex of the primitive\n")
SLANG_RAW("/// that corresponds to the given `vertexIndex`.\n")
SLANG_RAW("///\n")
SLANG_RAW("/// Note that the `attribute` must have been a declared varying input to\n")
SLANG_RAW("/// the fragment shader with the `nointerpolation` modifier.\n")
SLANG_RAW("///\n")
SLANG_RAW("/// This function can be applied to scalars, vectors, and matrices of\n")
SLANG_RAW("/// built-in scalar types.\n")
SLANG_RAW("///\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("__glsl_version(450)\n")
SLANG_RAW("vector<T,N> GetAttributeAtVertex(vector<T,N> attribute, uint vertexIndex)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        __intrinsic_asm \"GetAttributeAtVertex\";\n")
SLANG_RAW("    case GL_NV_fragment_shader_barycentric:\n")
SLANG_RAW("    case GL_EXT_fragment_shader_barycentric: \n")
SLANG_RAW("        __intrinsic_asm \"$0[$1]\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            %_ptr_Input_vectorT = OpTypePointer Input $$vector<T,N>;\n")
SLANG_RAW("            %addr = OpAccessChain %_ptr_Input_vectorT $attribute $vertexIndex;\n")
SLANG_RAW("            result:$$vector<T,N> = OpLoad %addr;\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("/// Get the value of a vertex attribute at a specific vertex.\n")
SLANG_RAW("///\n")
SLANG_RAW("/// The `GetAttributeAtVertex()` function can be used in a fragment shader\n")
SLANG_RAW("/// to get the value of the given `attribute` at the vertex of the primitive\n")
SLANG_RAW("/// that corresponds to the given `vertexIndex`.\n")
SLANG_RAW("///\n")
SLANG_RAW("/// Note that the `attribute` must have been a declared varying input to\n")
SLANG_RAW("/// the fragment shader with the `nointerpolation` modifier.\n")
SLANG_RAW("///\n")
SLANG_RAW("/// This function can be applied to scalars, vectors, and matrices of\n")
SLANG_RAW("/// built-in scalar types.\n")
SLANG_RAW("///\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int, let M : int>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("__glsl_version(450)\n")
SLANG_RAW("matrix<T,N,M> GetAttributeAtVertex(matrix<T,N,M> attribute, uint vertexIndex)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        __intrinsic_asm \"GetAttributeAtVertex\";\n")
SLANG_RAW("    case GL_NV_fragment_shader_barycentric:\n")
SLANG_RAW("    case GL_EXT_fragment_shader_barycentric: \n")
SLANG_RAW("        __intrinsic_asm \"$0[$1]\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            %_ptr_Input_matrixT = OpTypePointer Input $$matrix<T,N,M>;\n")
SLANG_RAW("            %addr = OpAccessChain %_ptr_Input_matrixT $attribute $vertexIndex;\n")
SLANG_RAW("            result:$$matrix<T,N,M> = OpLoad %addr;\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Get number of samples in render target\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("uint GetRenderTargetSampleCount();\n")
SLANG_RAW("\n")
SLANG_RAW("// Get position of given sample\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("float2 GetRenderTargetSamplePosition(int Index);\n")
SLANG_RAW("\n")
SLANG_RAW("// Group memory barrier\n")
SLANG_RAW("__glsl_extension(GL_KHR_memory_scope_semantics)\n")
SLANG_RAW("void GroupMemoryBarrier()\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"memoryBarrier(gl_ScopeWorkgroup, gl_StorageSemanticsShared, gl_SemanticsAcquireRelease)\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"GroupMemoryBarrier\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"__threadfence_block\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            OpMemoryBarrier Workgroup AcquireRelease|WorkgroupMemory\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("void __subgroupBarrier()\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupBarrier\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"GroupMemoryBarrierWithGroupSync\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"__syncthreads()\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            OpControlBarrier Subgroup Subgroup AcquireRelease|WorkgroupMemory|ImageMemory|UniformMemory\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("void GroupMemoryBarrierWithGroupSync()\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"barrier\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"GroupMemoryBarrierWithGroupSync\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"__syncthreads()\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            OpControlBarrier Workgroup Workgroup AcquireRelease|WorkgroupMemory\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Atomics\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_version(430)\n")
SLANG_RAW("void InterlockedAdd(__ref  int dest,  int value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"InterlockedAdd\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"atomicAdd($0, $1)\";\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"$atomicAdd($A, $1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            result:$$int = OpAtomicIAdd &dest Device None $value \n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_version(430)\n")
SLANG_RAW("void InterlockedAdd(__ref uint dest, uint value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"InterlockedAdd\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"atomicAdd((int*)$0, $1)\";\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"$atomicAdd($A, $1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            result:$$uint = OpAtomicIAdd &dest Device None $value \n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("void InterlockedAdd(__ref uint dest, int value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    InterlockedAdd(dest, (uint)value);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_version(430)\n")
SLANG_RAW("void InterlockedAdd(__ref  int dest,  int value, out  int original_value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"InterlockedAdd\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"(*$2 = atomicAdd($0, $1))\";\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"($2 = $atomicAdd($A, $1))\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            %original:$$int = OpAtomicIAdd &dest Device None $value;\n")
SLANG_RAW("            OpStore &original_value %original\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_version(430)\n")
SLANG_RAW("void InterlockedAdd(__ref uint dest, uint value, out uint original_value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"InterlockedAdd\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"(*$2 = (uint)atomicAdd((int*)$0, $1))\";\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"($2 = $atomicAdd($A, $1))\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            %original:$$uint = OpAtomicIAdd &dest Device None $value;\n")
SLANG_RAW("            OpStore &original_value %original\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_version(430)\n")
SLANG_RAW("void InterlockedAnd(__ref  int dest,  int value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"InterlockedAnd\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"atomicAnd($0, $1)\";\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"$atomicAnd($A, $1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            result:$$int = OpAtomicAnd &dest Device None $value;\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_version(430)\n")
SLANG_RAW("void InterlockedAnd(__ref uint dest, uint value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"InterlockedAnd\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"atomicAnd((int*)$0, $1)\";\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"$atomicAnd($A, $1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            result:$$uint = OpAtomicAnd &dest Device None $value;\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_version(430)\n")
SLANG_RAW("void InterlockedAnd(__ref  int dest,  int value, out  int original_value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"InterlockedAnd\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"(*$2 = atomicAnd($0, $1))\";\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"($2 = $atomicAnd($A, $1))\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            %original:$$int = OpAtomicAnd &dest Device None $value;\n")
SLANG_RAW("            OpStore &original_value %original\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_version(430)\n")
SLANG_RAW("void InterlockedAnd(__ref uint dest, uint value, out uint original_value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"InterlockedAnd\";\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"($2 = atomicAnd($0, $1))\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"(*$2 = atomicAnd((int*)$0, $1))\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            %original:$$uint = OpAtomicAnd &dest Device None $value;\n")
SLANG_RAW("            OpStore &original_value %original\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_version(430)\n")
SLANG_RAW("void InterlockedCompareExchange(__ref  int dest,  int compare_value,  int value, out  int original_value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"InterlockedCompareExchange\";\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"($3 = $atomicCompSwap($A, $1, $2))\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"(*$3 = atomicCAS($0, $1, $2))\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            %original:$$int = OpAtomicCompareExchange &dest Device None None $value $compare_value;\n")
SLANG_RAW("            OpStore &original_value %original\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_version(430)\n")
SLANG_RAW("void InterlockedCompareExchange(__ref uint dest, uint compare_value, uint value, out uint original_value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"InterlockedCompareExchange\";\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"($3 = $atomicCompSwap($A, $1, $2))\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"(*$3 = (uint)atomicCAS((int*)$0, $1, $2))\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            %original:$$uint = OpAtomicCompareExchange &dest Device None None $value $compare_value;\n")
SLANG_RAW("            OpStore &original_value %original\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_version(430)\n")
SLANG_RAW("void InterlockedCompareStore(__ref int dest,  int compare_value,  int value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"InterlockedCompareStore\";\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"$atomicCompSwap($A, $1, $2)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"atomicCAS($0, $1, $2)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            result:$$int = OpAtomicCompareExchange &dest Device None None $value $compare_value;\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_version(430)\n")
SLANG_RAW("void InterlockedCompareStore(__ref uint dest, uint compare_value, uint value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"InterlockedCompareStore\";\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"$atomicCompSwap($A, $1, $2)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"atomicCAS((int*)$0, $1, $2)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            result:$$uint = OpAtomicCompareExchange &dest Device None None $value $compare_value;\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_version(430)\n")
SLANG_RAW("void InterlockedExchange(__ref  int dest,  int value, out  int original_value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"InterlockedExchange\";\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"($2 = $atomicExchange($A, $1))\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"(*$2 = atomicExch($0, $1))\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            %r:$$int = OpAtomicExchange &dest Device None $value;\n")
SLANG_RAW("            OpStore &original_value %r\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_version(430)\n")
SLANG_RAW("void InterlockedExchange(__ref uint dest, uint value, out uint original_value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"InterlockedExchange\";\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"($2 = $atomicExchange($A, $1))\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"(*$2 = (uint)atomicExch((int*)$0, $1))\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            %r:$$uint = OpAtomicExchange &dest Device None $value;\n")
SLANG_RAW("            OpStore &original_value %r\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_version(430)\n")
SLANG_RAW("void InterlockedMax(__ref  int dest,  int value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"InterlockedMax\";\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"$atomicMax($A, $1)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"atomicMax($0, $1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            result:$$int = OpAtomicSMax &dest Device None $value;\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_version(430)\n")
SLANG_RAW("void InterlockedMax(__ref uint dest, uint value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"InterlockedMax\";\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"$atomicMax($A, $1)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"atomicMax((int*)$0, $1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            result:$$uint = OpAtomicUMax &dest Device None $value;\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_version(430)\n")
SLANG_RAW("void InterlockedMax(__ref  int dest,  int value, out  int original_value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"InterlockedMax\";\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"($2 = $atomicMax($A, $1))\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"(*$2 = atomicMax($0, $1))\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            %v:$$int = OpAtomicSMax &dest Device None $value;\n")
SLANG_RAW("            OpStore &original_value %v\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_version(430)\n")
SLANG_RAW("void InterlockedMax(__ref uint dest, uint value, out uint original_value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"InterlockedMax\";\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"($2 = $atomicMax($A, $1))\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"(*$2 = (uint)atomicMax((int*)$0, $1))\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            %v:$$uint = OpAtomicUMax &dest Device None $value;\n")
SLANG_RAW("            OpStore &original_value %v\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_version(430)\n")
SLANG_RAW("void InterlockedMin(__ref  int dest,  int value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"InterlockedMin\";\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"$atomicMin($A, $1)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"atomicMin($0, $1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            result:$$int = OpAtomicSMin &dest Device None $value;\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_version(430)\n")
SLANG_RAW("void InterlockedMin(__ref uint dest, uint value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"InterlockedMin\";\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"$atomicMin($A, $1)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"atomicMin((int*)$0, $1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            result:$$uint = OpAtomicUMin &dest Device None $value;\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_version(430)\n")
SLANG_RAW("void InterlockedMin(__ref  int dest,  int value, out  int original_value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"InterlockedMin\";\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"($2 = $atomicMin($A, $1))\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"(*$2 = atomicMin($0, $1))\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            %v:$$int = OpAtomicSMin &dest Device None $value;\n")
SLANG_RAW("            OpStore &original_value %v\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_version(430)\n")
SLANG_RAW("void InterlockedMin(__ref uint dest, uint value, out uint original_value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"InterlockedMin\";\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"($2 = $atomicMin($A, $1))\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"(*$2 = (uint)atomicMin((int*)$0, $1))\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            %v:$$uint = OpAtomicUMin &dest Device None $value;\n")
SLANG_RAW("            OpStore &original_value %v\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_version(430)\n")
SLANG_RAW("void InterlockedOr(__ref  int dest,  int value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"InterlockedOr\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"atomicOr((int*)$0, $1)\";\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"$atomicOr($A, $1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            result:$$int = OpAtomicOr &dest Device None $value;\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_version(430)\n")
SLANG_RAW("void InterlockedOr(__ref uint dest, uint value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"InterlockedOr\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"atomicOr((int*)$0, $1)\";\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"$atomicOr($A, $1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            result:$$uint = OpAtomicOr &dest Device None $value;\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_version(430)\n")
SLANG_RAW("void InterlockedOr(__ref  int dest,  int value, out  int original_value)\n")
SLANG_RAW("{\n")
SLANG_RAW("     __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"InterlockedOr\";\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"($2 = atomicOr($0, $1))\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"(*$2 = atomicOr($0, $1))\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            %original:$$int = OpAtomicOr &dest Device None $value;\n")
SLANG_RAW("            OpStore &original_value %original\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_version(430)\n")
SLANG_RAW("void InterlockedOr(__ref uint dest, uint value, out uint original_value)\n")
SLANG_RAW("{\n")
SLANG_RAW("     __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"InterlockedOr\";\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"($2 = atomicOr($0, $1))\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"(*$2 = atomicOr((int*)$0, $1))\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            %original:$$uint = OpAtomicOr &dest Device None $value;\n")
SLANG_RAW("            OpStore &original_value %original\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_version(430)\n")
SLANG_RAW("void InterlockedXor(__ref  int dest,  int value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"InterlockedXor\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"atomicXor((int*)$0, $1)\";\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"$atomicXor($A, $1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            result:$$int = OpAtomicXor &dest Device None $value;\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_version(430)\n")
SLANG_RAW("void InterlockedXor(__ref uint dest, uint value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"InterlockedXor\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"atomicXor((int*)$0, $1)\";\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"$atomicXor($A, $1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            result:$$uint = OpAtomicXor &dest Device None $value;\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_version(430)\n")
SLANG_RAW("void InterlockedXor(__ref  int dest,  int value, out  int original_value)\n")
SLANG_RAW("{\n")
SLANG_RAW("     __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"InterlockedXor\";\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"($2 = atomicXor($0, $1))\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"(*$2 = atomicXor($0, $1))\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            %original:$$int = OpAtomicXor &dest Device None $value;\n")
SLANG_RAW("            OpStore &original_value %original\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_version(430)\n")
SLANG_RAW("void InterlockedXor(__ref uint dest, uint value, out uint original_value)\n")
SLANG_RAW("{\n")
SLANG_RAW("     __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"InterlockedXor\";\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"($2 = atomicXor($0, $1))\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"(*$2 = (uint)atomicXor((int*)$0, $1))\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            %original:$$uint = OpAtomicXor &dest Device None $value;\n")
SLANG_RAW("            OpStore &original_value %original\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Is floating-point value finite?\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("bool isfinite(T x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"isfinite\";\n")
SLANG_RAW("    case cuda:\n")
SLANG_RAW("    case cpp:\n")
SLANG_RAW("        __intrinsic_asm \"$P_isfinite($0)\";\n")
SLANG_RAW("    default:\n")
SLANG_RAW("        return !(isinf(x) || isnan(x));\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<bool, N> isfinite(vector<T, N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"isfinite\";\n")
SLANG_RAW("    default:\n")
SLANG_RAW("        VECTOR_MAP_UNARY(bool, N, isfinite, x);\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<bool, N, M> isfinite(matrix<T, N, M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_UNARY(bool, N, M, isfinite, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Is floating-point value infinite?\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("bool isinf(T x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"isinf\";\n")
SLANG_RAW("    case cuda:\n")
SLANG_RAW("    case cpp:\n")
SLANG_RAW("        __intrinsic_asm \"$P_isinf($0)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm { result:$$bool = OpIsInf $x};\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<bool, N> isinf(vector<T, N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"isinf\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm { result:$$vector<bool,N> = OpIsInf $x};\n")
SLANG_RAW("    default:\n")
SLANG_RAW("        VECTOR_MAP_UNARY(bool, N, isinf, x);\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<bool, N, M> isinf(matrix<T, N, M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_UNARY(bool, N, M, isinf, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Is floating-point value not-a-number?\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("bool isnan(T x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"isnan\";\n")
SLANG_RAW("    case cuda:\n")
SLANG_RAW("    case cpp:\n")
SLANG_RAW("        __intrinsic_asm \"$P_isnan($0)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm { result:$$bool = OpIsNan $x};\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<bool, N> isnan(vector<T, N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"isnan\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm { result:$$vector<bool, N> = OpIsNan $x};\n")
SLANG_RAW("    default:\n")
SLANG_RAW("        VECTOR_MAP_UNARY(bool, N, isnan, x);\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<bool, N, M> isnan(matrix<T, N, M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_UNARY(bool, N, M, isnan, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Construct float from mantissa and exponent\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T ldexp(T x, T exp)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return x * exp2(exp);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T, N> ldexp(vector<T, N> x, vector<T, N> exp)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return x * exp2(exp);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T, N, M> ldexp(matrix<T, N, M> x, matrix<T, N, M> exp)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_BINARY(T, N, M, ldexp, x, exp);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Vector length\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Length _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T length(vector<T, N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return sqrt(dot(x, x));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Scalar float length\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("T length(T x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return abs(x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Linear interpolation\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl, mix)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 FMix _0 _1 _2\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T lerp(T x, T y, T s)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return x * (T(1.0f) - s) + y * s;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl, mix)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 FMix _0 _1 _2\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T, N> lerp(vector<T, N> x, vector<T, N> y, vector<T, N> s)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return x * (T(1.0f) - s) + y * s;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T,N,M> lerp(matrix<T,N,M> x, matrix<T,N,M> y, matrix<T,N,M> s)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_TRINARY(T, N, M, lerp, x, y, s);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Legacy lighting function (obsolete)\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("float4 lit(float n_dot_l, float n_dot_h, float m)\n")
SLANG_RAW("{\n")
SLANG_RAW("    let ambient = 1.0f;\n")
SLANG_RAW("    let diffuse = max(n_dot_l, 0.0f);\n")
SLANG_RAW("    let specular = step(0.0f, n_dot_l) * max(pow(n_dot_h, m), 0.0f);\n")
SLANG_RAW("    return float4(ambient, diffuse, specular, 1.0f);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Base-e logarithm\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(cuda, \"$P_log($0)\")\n")
SLANG_RAW("__target_intrinsic(cpp, \"$P_log($0)\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Log _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T log(T x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Log _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T, N> log(vector<T, N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_UNARY(T, N, log, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T, N, M> log(matrix<T, N, M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_UNARY(T, N, M, log, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Base-10 logarithm\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl, \"(log( $0 ) * $S0( 0.43429448190325182765112891891661) )\" )\n")
SLANG_RAW("__target_intrinsic(cuda, \"$P_log10($0)\")\n")
SLANG_RAW("__target_intrinsic(cpp, \"$P_log10($0)\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"%baseElog = OpExtInst resultType resultId glsl450 Log _0; OpFMul resultType resultId %baseElog const(_p,0.43429448190325182765112891891661)\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T log10(T x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl, \"(log( $0 ) * $S0(0.43429448190325182765112891891661) )\" )\n")
SLANG_RAW("__target_intrinsic(spirv, \"%baseElog = OpExtInst resultType resultId glsl450 Log _0; OpVectorTimesScalar resultType resultId %baseElog const(_p,0.43429448190325182765112891891661)\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T,N> log10(vector<T,N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_UNARY(T, N, log10, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T,N,M> log10(matrix<T,N,M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_UNARY(T, N, M, log10, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Base-2 logarithm\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(cuda, \"$P_log2($0)\")\n")
SLANG_RAW("__target_intrinsic(cpp, \"$P_log2($0)\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Log2 _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T log2(T x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Log2 _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T,N> log2(vector<T,N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_UNARY(T, N, log2, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T,N,M> log2(matrix<T,N,M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_UNARY(T, N, M, log2, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// multiply-add\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl, fma)\n")
SLANG_RAW("__target_intrinsic(cuda, \"$P_fma($0, $1, $2)\")\n")
SLANG_RAW("__target_intrinsic(cpp, \"$P_fma($0, $1, $2)\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Fma _0 _1 _2\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T mad(T mvalue, T avalue, T bvalue);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl, fma)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Fma _0 _1 _2\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T, N> mad(vector<T, N> mvalue, vector<T, N> avalue, vector<T, N> bvalue)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_TRINARY(T, N, mad, mvalue, avalue, bvalue);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T, N, M> mad(matrix<T, N, M> mvalue, matrix<T, N, M> avalue, matrix<T, N, M> bvalue)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_TRINARY(T, N, M, mad, mvalue, avalue, bvalue);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinIntegerType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl, fma)\n")
SLANG_RAW("__target_intrinsic(cuda, \"$P_fma($0, $1, $2)\")\n")
SLANG_RAW("__target_intrinsic(cpp, \"$P_fma($0, $1, $2)\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Fma _0 _1 _2\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T mad(T mvalue, T avalue, T bvalue);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinIntegerType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl, fma)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Fma _0 _1 _2\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T, N> mad(vector<T, N> mvalue, vector<T, N> avalue, vector<T, N> bvalue)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_TRINARY(T, N, mad, mvalue, avalue, bvalue);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinIntegerType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T, N, M> mad(matrix<T, N, M> mvalue, matrix<T, N, M> avalue, matrix<T, N, M> bvalue)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_TRINARY(T, N, M, mad, mvalue, avalue, bvalue);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("// maximum\n")
SLANG_RAW("__generic<T : __BuiltinIntegerType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(cuda, \"$P_max($0, $1)\")\n")
SLANG_RAW("__target_intrinsic(cpp, \"$P_max($0, $1)\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 fus(FMax, UMax, SMax) _0 _1\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T max(T x, T y);\n")
SLANG_RAW("// Note: a stdlib implementation of `max` (or `min`) will require splitting\n")
SLANG_RAW("// floating-point and integer cases apart, because the floating-point\n")
SLANG_RAW("// version needs to correctly handle the case where one of the inputs\n")
SLANG_RAW("// is not-a-number.\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinIntegerType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 fus(FMax, UMax, SMax) _0 _1\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T, N> max(vector<T, N> x, vector<T, N> y)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_BINARY(T, N, max, x, y);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinIntegerType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T, N, M> max(matrix<T, N, M> x, matrix<T, N, M> y)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_BINARY(T, N, M, max, x, y);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(cuda, \"$P_max($0, $1)\")\n")
SLANG_RAW("__target_intrinsic(cpp, \"$P_max($0, $1)\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 fus(FMax, UMax, SMax) _0 _1\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T max(T x, T y);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 fus(FMax, UMax, SMax) _0 _1\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T, N> max(vector<T, N> x, vector<T, N> y)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_BINARY(T, N, max, x, y);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T, N, M> max(matrix<T, N, M> x, matrix<T, N, M> y)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_BINARY(T, N, M, max, x, y);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// minimum\n")
SLANG_RAW("__generic<T : __BuiltinIntegerType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(cuda, \"$P_min($0, $1)\")\n")
SLANG_RAW("__target_intrinsic(cpp, \"$P_min($0, $1)\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 fus(FMin, UMin, SMin) _0 _1\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T min(T x, T y);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinIntegerType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 fus(FMin, UMin, SMin) _0 _1\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T,N> min(vector<T,N> x, vector<T,N> y)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_BINARY(T, N, min, x, y);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinIntegerType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T,N,M> min(matrix<T,N,M> x, matrix<T,N,M> y)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_BINARY(T, N, M, min, x, y);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(cuda, \"$P_min($0, $1)\")\n")
SLANG_RAW("__target_intrinsic(cpp, \"$P_min($0, $1)\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 fus(FMin, UMin, SMin) _0 _1\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T min(T x, T y);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 fus(FMin, UMin, SMin) _0 _1\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T,N> min(vector<T,N> x, vector<T,N> y)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_BINARY(T, N, min, x, y);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T,N,M> min(matrix<T,N,M> x, matrix<T,N,M> y)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_BINARY(T, N, M, min, x, y);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// split into integer and fractional parts (both with same sign)\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Modf _0 _1\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T modf(T x, out T ip);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T,N> modf(vector<T,N> x, out vector<T,N> ip)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_BINARY(T, N, modf, x, ip);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int, let L : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T,N,M> modf(matrix<T,N,M> x, out matrix<T,N,M,L> ip)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_BINARY(T, N, M, modf, x, ip);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// msad4 (whatever that is)\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("uint4 msad4(uint reference, uint2 source, uint4 accum)\n")
SLANG_RAW("{\n")
SLANG_RAW("    int4 bytesRef = (reference >> uint4(24, 16, 8, 0)) & 0xFF;\n")
SLANG_RAW("    int4 bytesX   = (source.x  >> uint4(24, 16, 8, 0)) & 0xFF;\n")
SLANG_RAW("    int4 bytesY   = (source.y  >> uint4(24, 16, 8, 0)) & 0xFF;\n")
SLANG_RAW("\n")
SLANG_RAW("    uint4 mask = select(bytesRef == 0, 0, 0xFFFFFFFFu);\n")
SLANG_RAW("\n")
SLANG_RAW("    uint4 result = accum;\n")
SLANG_RAW("    result += mask.x & abs(bytesRef - int4(bytesX.x,           bytesY.y, bytesY.z, bytesY.w));\n")
SLANG_RAW("    result += mask.y & abs(bytesRef - int4(bytesX.x, bytesX.y,           bytesY.z, bytesY.w));\n")
SLANG_RAW("    result += mask.z & abs(bytesRef - int4(bytesX.x, bytesX.y, bytesX.z,           bytesY.w));\n")
SLANG_RAW("    result += mask.w & abs(bytesRef - int4(bytesX.x, bytesX.y, bytesX.z, bytesX.w));\n")
SLANG_RAW("    return result;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// General inner products\n")
SLANG_RAW("\n")
SLANG_RAW("// scalar-scalar\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType>\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_Mul
)
SLANG_RAW(")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T mul(T x, T y);\n")
SLANG_RAW("\n")
SLANG_RAW("// scalar-vector and vector-scalar\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int>\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_Mul
)
SLANG_RAW(")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T, N> mul(vector<T, N> x, T y);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int>\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_Mul
)
SLANG_RAW(")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T, N> mul(T x, vector<T, N> y);\n")
SLANG_RAW("\n")
SLANG_RAW("// scalar-matrix and matrix-scalar\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int, let M :int>\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_Mul
)
SLANG_RAW(")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T, N, M> mul(matrix<T, N, M> x, T y);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int, let M :int>\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_Mul
)
SLANG_RAW(")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T, N, M> mul(T x, matrix<T, N, M> y);\n")
SLANG_RAW("\n")
SLANG_RAW("// vector-vector (dot product)\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl, \"dot\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T mul(vector<T, N> x, vector<T, N> y)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return dot(x, y);\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : __BuiltinIntegerType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T mul(vector<T, N> x, vector<T, N> y)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return dot(x, y);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// vector-matrix\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl, \"($1 * $0)\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpMatrixTimesVector resultType resultId _1 _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T, M> mul(vector<T, N> left, matrix<T, N, M> right)\n")
SLANG_RAW("{\n")
SLANG_RAW("    vector<T,M> result;\n")
SLANG_RAW("    for( int j = 0; j < M; ++j )\n")
SLANG_RAW("    {\n")
SLANG_RAW("        T sum = T(0);\n")
SLANG_RAW("        for( int i = 0; i < N; ++i )\n")
SLANG_RAW("        {\n")
SLANG_RAW("            sum += left[i] * right[i][j];\n")
SLANG_RAW("        }\n")
SLANG_RAW("        result[j] = sum;\n")
SLANG_RAW("    }\n")
SLANG_RAW("    return result;\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : __BuiltinIntegerType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl, \"($1 * $0)\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T, M> mul(vector<T, N> left, matrix<T, N, M> right)\n")
SLANG_RAW("{\n")
SLANG_RAW("    vector<T,M> result;\n")
SLANG_RAW("    for( int j = 0; j < M; ++j )\n")
SLANG_RAW("    {\n")
SLANG_RAW("        T sum = T(0);\n")
SLANG_RAW("        for( int i = 0; i < N; ++i )\n")
SLANG_RAW("        {\n")
SLANG_RAW("            sum += left[i] * right[i][j];\n")
SLANG_RAW("        }\n")
SLANG_RAW("        result[j] = sum;\n")
SLANG_RAW("    }\n")
SLANG_RAW("    return result;\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : __BuiltinLogicalType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl, \"($1 * $0)\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T, M> mul(vector<T, N> left, matrix<T, N, M> right)\n")
SLANG_RAW("{\n")
SLANG_RAW("    vector<T,M> result;\n")
SLANG_RAW("    for( int j = 0; j < M; ++j )\n")
SLANG_RAW("    {\n")
SLANG_RAW("        T sum = T(0);\n")
SLANG_RAW("        for( int i = 0; i < N; ++i )\n")
SLANG_RAW("        {\n")
SLANG_RAW("            sum |= left[i] & right[i][j];\n")
SLANG_RAW("        }\n")
SLANG_RAW("        result[j] = sum;\n")
SLANG_RAW("    }\n")
SLANG_RAW("    return result;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// matrix-vector\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl, \"($1 * $0)\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpVectorTimesMatrix resultType resultId _1 _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T,N> mul(matrix<T,N,M> left, vector<T,M> right)\n")
SLANG_RAW("{\n")
SLANG_RAW("    vector<T,N> result;\n")
SLANG_RAW("    for( int i = 0; i < N; ++i )\n")
SLANG_RAW("    {\n")
SLANG_RAW("        T sum = T(0);\n")
SLANG_RAW("        for( int j = 0; j < M; ++j )\n")
SLANG_RAW("        {\n")
SLANG_RAW("            sum += left[i][j] * right[j];\n")
SLANG_RAW("        }\n")
SLANG_RAW("        result[i] = sum;\n")
SLANG_RAW("    }\n")
SLANG_RAW("    return result;\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : __BuiltinIntegerType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl, \"($1 * $0)\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T,N> mul(matrix<T,N,M> left, vector<T,M> right)\n")
SLANG_RAW("{\n")
SLANG_RAW("    vector<T,N> result;\n")
SLANG_RAW("    for( int i = 0; i < N; ++i )\n")
SLANG_RAW("    {\n")
SLANG_RAW("        T sum = T(0);\n")
SLANG_RAW("        for( int j = 0; j < M; ++j )\n")
SLANG_RAW("        {\n")
SLANG_RAW("            sum += left[i][j] * right[j];\n")
SLANG_RAW("        }\n")
SLANG_RAW("        result[i] = sum;\n")
SLANG_RAW("    }\n")
SLANG_RAW("    return result;\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : __BuiltinLogicalType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl, \"($1 * $0)\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T,N> mul(matrix<T,N,M> left, vector<T,M> right)\n")
SLANG_RAW("{\n")
SLANG_RAW("    vector<T,N> result;\n")
SLANG_RAW("    for( int i = 0; i < N; ++i )\n")
SLANG_RAW("    {\n")
SLANG_RAW("        T sum = T(0);\n")
SLANG_RAW("        for( int j = 0; j < M; ++j )\n")
SLANG_RAW("        {\n")
SLANG_RAW("            sum |= left[i][j] & right[j];\n")
SLANG_RAW("        }\n")
SLANG_RAW("        result[i] = sum;\n")
SLANG_RAW("    }\n")
SLANG_RAW("    return result;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// matrix-matrix\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let R : int, let N : int, let C : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl, \"($1 * $0)\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpMatrixTimesMatrix resultType resultId _1 _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T,R,C> mul(matrix<T,R,N> right, matrix<T,N,C> left)\n")
SLANG_RAW("{\n")
SLANG_RAW("    matrix<T,R,C> result;\n")
SLANG_RAW("    for( int r = 0; r < R; ++r)\n")
SLANG_RAW("    for( int c = 0; c < C; ++c)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        T sum = T(0);\n")
SLANG_RAW("        for( int i = 0; i < N; ++i )\n")
SLANG_RAW("        {\n")
SLANG_RAW("            sum += left[r][i] * right[i][c];\n")
SLANG_RAW("        }\n")
SLANG_RAW("        result[r][c] = sum;\n")
SLANG_RAW("    }\n")
SLANG_RAW("    return result;\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : __BuiltinIntegerType, let R : int, let N : int, let C : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl, \"($1 * $0)\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T,R,C> mul(matrix<T,R,N> right, matrix<T,N,C> left)\n")
SLANG_RAW("{\n")
SLANG_RAW("    matrix<T,R,C> result;\n")
SLANG_RAW("    for( int r = 0; r < R; ++r)\n")
SLANG_RAW("    for( int c = 0; c < C; ++c)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        T sum = T(0);\n")
SLANG_RAW("        for( int i = 0; i < N; ++i )\n")
SLANG_RAW("        {\n")
SLANG_RAW("            sum += left[r][i] * right[i][c];\n")
SLANG_RAW("        }\n")
SLANG_RAW("        result[r][c] = sum;\n")
SLANG_RAW("    }\n")
SLANG_RAW("    return result;\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : __BuiltinLogicalType, let R : int, let N : int, let C : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl, \"($1 * $0)\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T,R,C> mul(matrix<T,R,N> right, matrix<T,N,C> left)\n")
SLANG_RAW("{\n")
SLANG_RAW("    matrix<T,R,C> result;\n")
SLANG_RAW("    for( int r = 0; r < R; ++r)\n")
SLANG_RAW("    for( int c = 0; c < C; ++c)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        T sum = T(0);\n")
SLANG_RAW("        for( int i = 0; i < N; ++i )\n")
SLANG_RAW("        {\n")
SLANG_RAW("            sum |= left[r][i] & right[i][c];\n")
SLANG_RAW("        }\n")
SLANG_RAW("        result[r][c] = sum;\n")
SLANG_RAW("    }\n")
SLANG_RAW("    return result;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// noise (deprecated)\n")
SLANG_RAW("\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[deprecated(\"Always returns 0\")]\n")
SLANG_RAW("float noise(float x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return 0;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[deprecated(\"Always returns 0\")]\n")
SLANG_RAW("__generic<let N : int> float noise(vector<float, N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return 0;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("/// Indicate that an index may be non-uniform at execution time.\n")
SLANG_RAW("///\n")
SLANG_RAW("/// Shader Model 5.1 and 6.x introduce support for dynamic indexing\n")
SLANG_RAW("/// of arrays of resources, but place the restriction that *by default*\n")
SLANG_RAW("/// the implementation can assume that any value used as an index into\n")
SLANG_RAW("/// such arrays will be dynamically uniform across an entire `Draw` or `Dispatch`\n")
SLANG_RAW("/// (when using instancing, the value must be uniform across all instances;\n")
SLANG_RAW("/// it does not seem that the restriction extends to draws within a multi-draw).\n")
SLANG_RAW("///\n")
SLANG_RAW("/// In order to indicate to the implementation that it cannot make the\n")
SLANG_RAW("/// uniformity assumption, a shader programmer is required to pass the index\n")
SLANG_RAW("/// to the `NonUniformResourceIndex` function before using it as an index.\n")
SLANG_RAW("/// The function superficially acts like an identity function.\n")
SLANG_RAW("///\n")
SLANG_RAW("/// Note: a future version of Slang may take responsibility for inserting calls\n")
SLANG_RAW("/// to this function as necessary in output code, rather than make this\n")
SLANG_RAW("/// the user's responsibility, so that the default behavior of the language\n")
SLANG_RAW("/// is more semantically \"correct.\"\n")
SLANG_RAW("__glsl_extension(GL_EXT_nonuniform_qualifier)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("uint NonUniformResourceIndex(uint index)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        __intrinsic_asm \"NonUniformResourceIndex\";\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"nonuniformEXT\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            OpCapability ShaderNonUniform;\n")
SLANG_RAW("            OpDecorate $index NonUniform;\n")
SLANG_RAW("        };\n")
SLANG_RAW("        return index;\n")
SLANG_RAW("    default:\n")
SLANG_RAW("        return index;\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_extension(GL_EXT_nonuniform_qualifier)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("int NonUniformResourceIndex(int index)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        __intrinsic_asm \"NonUniformResourceIndex\";\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"nonuniformEXT\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            OpCapability ShaderNonUniform;\n")
SLANG_RAW("            OpDecorate $index NonUniform;\n")
SLANG_RAW("        };\n")
SLANG_RAW("        return index;\n")
SLANG_RAW("    default:\n")
SLANG_RAW("        return index;\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("/// HLSL allows NonUniformResourceIndex around non int/uint types.\n")
SLANG_RAW("/// It's effect is presumably to ignore it, which the following implementation does.\n")
SLANG_RAW("/// We should also look to add a warning for this scenario.\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("[deprecated(\"NonUniformResourceIndex on a type other than uint/int is deprecated and has no effect\")]\n")
SLANG_RAW("T NonUniformResourceIndex<T>(T value) { return value; }\n")
SLANG_RAW("\n")
SLANG_RAW("// Normalize a vector\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Normalize _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T,N> normalize(vector<T,N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return x / length(x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Raise to a power\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(cuda, \"$P_pow($0, $1)\")\n")
SLANG_RAW("__target_intrinsic(cpp, \"$P_pow($0, $1)\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Pow _0 _1\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T pow(T x, T y);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Pow _0 _1\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T, N> pow(vector<T, N> x, vector<T, N> y)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_BINARY(T, N, pow, x, y);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T,N,M> pow(matrix<T,N,M> x, matrix<T,N,M> y)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_BINARY(T, N, M, pow, x, y);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Output message\n")
SLANG_RAW("// TODO: add check to ensure format is const literal.\n")
SLANG_RAW("\n")

for (int argCount = 0; argCount < 12; argCount++)
{
    StringBuilder paramList;
    StringBuilder argList;
    StringBuilder spirvArgList;
    StringBuilder genericParamList;
    if (argCount > 0)
        genericParamList << "<";
    for (int i = 0; i < argCount; i++)
    {
        if (i > 0)
            genericParamList << ", ";
        genericParamList << "T" << i;

        paramList << ", T" << i << " v" << i;
        argList << ", $" << i+1;
        spirvArgList << " $v" << i;
    }
    if (argCount > 0)
        genericParamList << ">";
    auto params = paramList.toString();
    auto args = argList.toString();
    auto spirvArgs = spirvArgList.toString();
SLANG_RAW("#line 6075 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("__glsl_extension(GL_EXT_debug_printf)\n")
SLANG_RAW("void printf")
SLANG_SPLICE(genericParamList.toString()
)
SLANG_RAW("(NativeString format ")
SLANG_SPLICE(paramList
)
SLANG_RAW(")\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("    case cpp:\n")
SLANG_RAW("    case cuda:\n")
SLANG_RAW("        __intrinsic_asm \"printf\";\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"debugPrintfEXT($0 ")
SLANG_SPLICE(argList
)
SLANG_RAW(")\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        spirv_asm {\n")
SLANG_RAW("          OpExtension \"SPV_KHR_non_semantic_info\";\n")
SLANG_RAW("          result:$$void = OpExtInst debugPrintf 1 $format ")
SLANG_SPLICE(spirvArgs
)
SLANG_RAW(";\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")

}
SLANG_RAW("#line 6096 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("// Tessellation factor fixup routines\n")
SLANG_RAW("\n")
SLANG_RAW("void Process2DQuadTessFactorsAvg(\n")
SLANG_RAW("    in  float4 RawEdgeFactors,\n")
SLANG_RAW("    in  float2 InsideScale,\n")
SLANG_RAW("    out float4 RoundedEdgeTessFactors,\n")
SLANG_RAW("    out float2 RoundedInsideTessFactors,\n")
SLANG_RAW("    out float2 UnroundedInsideTessFactors);\n")
SLANG_RAW("\n")
SLANG_RAW("void Process2DQuadTessFactorsMax(\n")
SLANG_RAW("    in  float4 RawEdgeFactors,\n")
SLANG_RAW("    in  float2 InsideScale,\n")
SLANG_RAW("    out float4 RoundedEdgeTessFactors,\n")
SLANG_RAW("    out float2 RoundedInsideTessFactors,\n")
SLANG_RAW("    out float2 UnroundedInsideTessFactors);\n")
SLANG_RAW("\n")
SLANG_RAW("void Process2DQuadTessFactorsMin(\n")
SLANG_RAW("    in  float4 RawEdgeFactors,\n")
SLANG_RAW("    in  float2 InsideScale,\n")
SLANG_RAW("    out float4 RoundedEdgeTessFactors,\n")
SLANG_RAW("    out float2 RoundedInsideTessFactors,\n")
SLANG_RAW("    out float2 UnroundedInsideTessFactors);\n")
SLANG_RAW("\n")
SLANG_RAW("void ProcessIsolineTessFactors(\n")
SLANG_RAW("    in  float RawDetailFactor,\n")
SLANG_RAW("    in  float RawDensityFactor,\n")
SLANG_RAW("    out float RoundedDetailFactor,\n")
SLANG_RAW("    out float RoundedDensityFactor);\n")
SLANG_RAW("\n")
SLANG_RAW("void ProcessQuadTessFactorsAvg(\n")
SLANG_RAW("    in  float4 RawEdgeFactors,\n")
SLANG_RAW("    in  float InsideScale,\n")
SLANG_RAW("    out float4 RoundedEdgeTessFactors,\n")
SLANG_RAW("    out float2 RoundedInsideTessFactors,\n")
SLANG_RAW("    out float2 UnroundedInsideTessFactors);\n")
SLANG_RAW("\n")
SLANG_RAW("void ProcessQuadTessFactorsMax(\n")
SLANG_RAW("    in  float4 RawEdgeFactors,\n")
SLANG_RAW("    in  float InsideScale,\n")
SLANG_RAW("    out float4 RoundedEdgeTessFactors,\n")
SLANG_RAW("    out float2 RoundedInsideTessFactors,\n")
SLANG_RAW("    out float2 UnroundedInsideTessFactors);\n")
SLANG_RAW("\n")
SLANG_RAW("void ProcessQuadTessFactorsMin(\n")
SLANG_RAW("    in  float4 RawEdgeFactors,\n")
SLANG_RAW("    in  float InsideScale,\n")
SLANG_RAW("    out float4 RoundedEdgeTessFactors,\n")
SLANG_RAW("    out float2 RoundedInsideTessFactors,\n")
SLANG_RAW("    out float2 UnroundedInsideTessFactors);\n")
SLANG_RAW("\n")
SLANG_RAW("void ProcessTriTessFactorsAvg(\n")
SLANG_RAW("    in  float3 RawEdgeFactors,\n")
SLANG_RAW("    in  float InsideScale,\n")
SLANG_RAW("    out float3 RoundedEdgeTessFactors,\n")
SLANG_RAW("    out float RoundedInsideTessFactor,\n")
SLANG_RAW("    out float UnroundedInsideTessFactor);\n")
SLANG_RAW("\n")
SLANG_RAW("void ProcessTriTessFactorsMax(\n")
SLANG_RAW("    in  float3 RawEdgeFactors,\n")
SLANG_RAW("    in  float InsideScale,\n")
SLANG_RAW("    out float3 RoundedEdgeTessFactors,\n")
SLANG_RAW("    out float RoundedInsideTessFactor,\n")
SLANG_RAW("    out float UnroundedInsideTessFactor);\n")
SLANG_RAW("\n")
SLANG_RAW("void ProcessTriTessFactorsMin(\n")
SLANG_RAW("    in  float3 RawEdgeFactors,\n")
SLANG_RAW("    in  float InsideScale,\n")
SLANG_RAW("    out float3 RoundedEdgeTessFactors,\n")
SLANG_RAW("    out float RoundedInsideTessFactors,\n")
SLANG_RAW("    out float UnroundedInsideTessFactors);\n")
SLANG_RAW("\n")
SLANG_RAW("// Degrees to radians\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Radians _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T radians(T x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return x * (T.getPi() / T(180.0f));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Radians _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T, N> radians(vector<T, N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return x * (T.getPi() / T(180.0f));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T, N, M> radians(matrix<T, N, M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return x * (T.getPi() / T(180.0f));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Approximate reciprocal\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T rcp(T x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return T(1.0) / x;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T, N> rcp(vector<T, N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_UNARY(T, N, rcp, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T, N, M> rcp(matrix<T, N, M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_UNARY(T, N, M, rcp, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Reflect incident vector across plane with given normal\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Reflect _0 _1\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T,N> reflect(vector<T,N> i, vector<T,N> n)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return i - T(2) * dot(n,i) * n;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Refract incident vector given surface normal and index of refraction\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Refract _0 _1 _2\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T,N> refract(vector<T,N> i, vector<T,N> n, T eta)\n")
SLANG_RAW("{\n")
SLANG_RAW("    let dotNI = dot(n,i);\n")
SLANG_RAW("    let k = T(1) - eta*eta*(T(1) - dotNI * dotNI);\n")
SLANG_RAW("    if(k < T(0)) return vector<T,N>(T(0));\n")
SLANG_RAW("    return eta * i - (eta * dotNI + sqrt(k)) * n;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Reverse order of bits\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("uint reversebits(uint value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        __intrinsic_asm \"reversebits\";\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"bitfieldReverse\";\n")
SLANG_RAW("    case cuda:\n")
SLANG_RAW("    case cpp:\n")
SLANG_RAW("        __intrinsic_asm \"$P_reversebits($0)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {OpBitReverse $$uint result $value};\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"bitfieldReverse\")\n")
SLANG_RAW("__generic<let N : int>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<uint, N> reversebits(vector<uint, N> value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    default:\n")
SLANG_RAW("        VECTOR_MAP_UNARY(uint, N, reversebits, value);\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"bitfieldReverse\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {OpBitReverse $$vector<uint, N> result $value};\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Round-to-nearest\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(cuda, \"$P_round($0)\")\n")
SLANG_RAW("__target_intrinsic(cpp, \"$P_round($0)\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Round _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T round(T x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Round _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T, N> round(vector<T, N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_UNARY(T, N, round, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T,N,M> round(matrix<T,N,M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_UNARY(T, N, M, round, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Reciprocal of square root\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl, \"inversesqrt($0)\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"$P_rsqrt($0)\")\n")
SLANG_RAW("__target_intrinsic(cpp, \"$P_rsqrt($0)\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 InverseSqrt _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T rsqrt(T x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return T(1.0) / sqrt(x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl, \"inversesqrt($0)\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 InverseSqrt _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T, N> rsqrt(vector<T, N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_UNARY(T, N, rsqrt, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T, N, M> rsqrt(matrix<T, N, M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_UNARY(T, N, M, rsqrt, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Clamp value to [0,1] range\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T saturate(T x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return clamp<T>(x, T(0), T(1));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T,N> saturate(vector<T,N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return clamp<T,N>(x,\n")
SLANG_RAW("        vector<T,N>(T(0)),\n")
SLANG_RAW("        vector<T,N>(T(1)));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T,N,M> saturate(matrix<T,N,M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_UNARY(T, N, M, saturate, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, U:__BuiltinArithmeticType>\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_IntCast
)
SLANG_RAW(")\n")
SLANG_RAW("T __int_cast(U val);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinArithmeticType, U:__BuiltinArithmeticType, let N : int>\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_IntCast
)
SLANG_RAW(")\n")
SLANG_RAW("vector<T,N> __int_cast(vector<U,N> val);\n")
SLANG_RAW("\n")
SLANG_RAW("// Extract sign of value\n")
SLANG_RAW("__generic<T : __BuiltinSignedArithmeticType>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("int sign(T x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"sign\";\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"int(sign($0))\";\n")
SLANG_RAW("    case cuda:\n")
SLANG_RAW("    case cpp:\n")
SLANG_RAW("        __intrinsic_asm \"$P_sign($0)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isFloat<T>())\n")
SLANG_RAW("            return spirv_asm\n")
SLANG_RAW("            {\n")
SLANG_RAW("                %fsign:$$T = OpExtInst glsl450 FSign $x;\n")
SLANG_RAW("                result:$$int = OpConvertFToS %fsign\n")
SLANG_RAW("            };\n")
SLANG_RAW("        else\n")
SLANG_RAW("            return __int_cast<int>(spirv_asm {OpExtInst $$T result glsl450 SSign $x});\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinSignedArithmeticType, let N : int>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<int, N> sign(vector<T, N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"sign\";\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"ivec$N0(sign($0))\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isFloat<T>())\n")
SLANG_RAW("            return spirv_asm\n")
SLANG_RAW("            {\n")
SLANG_RAW("                %fsign:$$vector<T, N> = OpExtInst glsl450 FSign $x;\n")
SLANG_RAW("                result:$$vector<int, N> = OpConvertFToS %fsign\n")
SLANG_RAW("            };\n")
SLANG_RAW("        else\n")
SLANG_RAW("            return __int_cast<int>(spirv_asm {OpExtInst $$vector<T,N> result glsl450 SSign $x});\n")
SLANG_RAW("    default:\n")
SLANG_RAW("        VECTOR_MAP_UNARY(int, N, sign, x);\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinSignedArithmeticType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<int, N, M> sign(matrix<T, N, M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_UNARY(int, N, M, sign, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("// Sine\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(cuda, \"$P_sin($0)\")\n")
SLANG_RAW("__target_intrinsic(cpp, \"$P_sin($0)\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Sin _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T sin(T x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Sin _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T, N> sin(vector<T, N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_UNARY(T, N, sin, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T, N, M> sin(matrix<T, N, M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_UNARY(T, N, M, sin, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Sine and cosine\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(cuda, \"$P_sincos($0, $1, $2)\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("void sincos(T x, out T s, out T c)\n")
SLANG_RAW("{\n")
SLANG_RAW("    s = sin(x);\n")
SLANG_RAW("    c = cos(x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("void sincos(vector<T,N> x, out vector<T,N> s, out vector<T,N> c)\n")
SLANG_RAW("{\n")
SLANG_RAW("    s = sin(x);\n")
SLANG_RAW("    c = cos(x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int, let L1: int, let L2 : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("void sincos(matrix<T,N,M> x, out matrix<T,N,M,L1> s, out matrix<T,N,M,L2> c)\n")
SLANG_RAW("{\n")
SLANG_RAW("    s = sin(x);\n")
SLANG_RAW("    c = cos(x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Hyperbolic Sine\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(cuda, \"$P_sinh($0)\")\n")
SLANG_RAW("__target_intrinsic(cpp, \"$P_sinh($0)\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Sinh _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T sinh(T x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Sinh _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T, N> sinh(vector<T, N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_UNARY(T, N, sinh, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T, N, M> sinh(matrix<T, N, M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_UNARY(T, N, M, sinh, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Smooth step (Hermite interpolation)\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 SmoothStep _0 _1 _2\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T smoothstep(T min, T max, T x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    let t = saturate((x - min) / (max - min));\n")
SLANG_RAW("    return t * t * (T(3.0f) - (t + t));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 SmoothStep _0 _1 _2\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T, N> smoothstep(vector<T, N> min, vector<T, N> max, vector<T, N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_TRINARY(T, N, smoothstep, min, max, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T, N, M> smoothstep(matrix<T, N, M> min, matrix<T, N, M> max, matrix<T, N, M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_TRINARY(T, N, M, smoothstep, min, max, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Square root\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(cuda, \"$P_sqrt($0)\")\n")
SLANG_RAW("__target_intrinsic(cpp, \"$P_sqrt($0)\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Sqrt _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T sqrt(T x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Sqrt _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T, N> sqrt(vector<T, N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_UNARY(T, N, sqrt, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T, N, M> sqrt(matrix<T, N, M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_UNARY(T, N, M, sqrt, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Step function\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Step _0 _1\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T step(T y, T x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return x < y ? T(0.0f) : T(1.0f);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Step _0 _1\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T,N> step(vector<T,N> y, vector<T,N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_BINARY(T, N, step, y, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T, N, M> step(matrix<T, N, M> y, matrix<T, N, M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_BINARY(T, N, M, step, y, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Tangent\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(cuda, \"$P_tan($0)\")\n")
SLANG_RAW("__target_intrinsic(cpp, \"$P_tan($0)\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Tan _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T tan(T x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Tan _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T, N> tan(vector<T, N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_UNARY(T, N, tan, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T, N, M> tan(matrix<T, N, M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_UNARY(T, N, M, tan, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Hyperbolic tangent\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(cuda, \"$P_tanh($0)\")\n")
SLANG_RAW("__target_intrinsic(cpp, \"$P_tanh($0)\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Tanh _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T tanh(T x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Tanh _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T,N> tanh(vector<T,N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_UNARY(T, N, tanh, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T,N,M> tanh(matrix<T,N,M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_UNARY(T, N, M, tanh, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Matrix transpose\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpTranspose resultType resultId _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[PreferRecompute]\n")
SLANG_RAW("matrix<T, M, N> transpose(matrix<T, N, M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    matrix<T,M,N> result;\n")
SLANG_RAW("    for(int r = 0; r < M; ++r)\n")
SLANG_RAW("        for(int c = 0; c < N; ++c)\n")
SLANG_RAW("            result[r][c] = x[c][r];\n")
SLANG_RAW("    return result;\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : __BuiltinIntegerType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpTranspose resultType resultId _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[PreferRecompute]\n")
SLANG_RAW("matrix<T, M, N> transpose(matrix<T, N, M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    matrix<T, M, N> result;\n")
SLANG_RAW("    for (int r = 0; r < M; ++r)\n")
SLANG_RAW("        for (int c = 0; c < N; ++c)\n")
SLANG_RAW("            result[r][c] = x[c][r];\n")
SLANG_RAW("    return result;\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : __BuiltinLogicalType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpTranspose resultType resultId _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[PreferRecompute]\n")
SLANG_RAW("matrix<T, M, N> transpose(matrix<T, N, M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    matrix<T, M, N> result;\n")
SLANG_RAW("    for (int r = 0; r < M; ++r)\n")
SLANG_RAW("        for (int c = 0; c < N; ++c)\n")
SLANG_RAW("            result[r][c] = x[c][r];\n")
SLANG_RAW("    return result;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Truncate to integer\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(cuda, \"$P_trunc($0)\")\n")
SLANG_RAW("__target_intrinsic(cpp, \"$P_trunc($0)\")\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Trunc _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("T trunc(T x);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(glsl)\n")
SLANG_RAW("__target_intrinsic(spirv, \"OpExtInst resultType resultId glsl450 Trunc _0\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("vector<T, N> trunc(vector<T, N> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    VECTOR_MAP_UNARY(T, N, trunc, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinFloatingPointType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("matrix<T, N, M> trunc(matrix<T, N, M> x)\n")
SLANG_RAW("{\n")
SLANG_RAW("    MATRIX_MAP_UNARY(T, N, M, trunc, x);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Slang Specific 'Mask' Wave Intrinsics\n")
SLANG_RAW("\n")
SLANG_RAW("typedef uint WaveMask;\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_ballot)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("WaveMask WaveGetConvergedMask()\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupBallot(true).x\";\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        __intrinsic_asm \"WaveActiveBallot(true).x\";\n")
SLANG_RAW("    case cuda:\n")
SLANG_RAW("        __intrinsic_asm \"__activemask()\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        let _true = true;\n")
SLANG_RAW("        return (spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            OpCapability GroupNonUniformBallot;\n")
SLANG_RAW("            OpGroupNonUniformBallot $$uint4 result Subgroup $_true\n")
SLANG_RAW("        }).x;\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_WaveGetActiveMask
)
SLANG_RAW(")\n")
SLANG_RAW("WaveMask __WaveGetActiveMask();\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_ballot)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("WaveMask WaveGetActiveMask()\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupBallot(true).x\";\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        __intrinsic_asm \"WaveActiveBallot(true).x\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        let _true = true;\n")
SLANG_RAW("        return (spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            OpCapability GroupNonUniformBallot;\n")
SLANG_RAW("            OpGroupNonUniformBallot $$uint4 result Subgroup $_true\n")
SLANG_RAW("        }).x;\n")
SLANG_RAW("    default:\n")
SLANG_RAW("        return __WaveGetActiveMask();\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_basic)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("bool WaveMaskIsFirstLane(WaveMask mask)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupElect()\";\n")
SLANG_RAW("    case cuda:\n")
SLANG_RAW("        __intrinsic_asm \"(($0 & -$0) == (WarpMask(1) << _getLaneId()))\";\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        __intrinsic_asm \"WaveIsFirstLane()\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            OpCapability GroupNonUniformBallot;\n")
SLANG_RAW("            OpGroupNonUniformElect $$bool result Subgroup\n")
SLANG_RAW("        };\n")
SLANG_RAW("    default:\n")
SLANG_RAW("        return false;\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_vote)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("bool WaveMaskAllTrue(WaveMask mask, bool condition)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupAll($1)\";\n")
SLANG_RAW("    case cuda:\n")
SLANG_RAW("        __intrinsic_asm \"(__all_sync($0, $1) != 0)\";\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        __intrinsic_asm \"WaveActiveAllTrue($1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            OpCapability GroupNonUniformBallot;\n")
SLANG_RAW("            OpGroupNonUniformAll $$bool result Subgroup $condition\n")
SLANG_RAW("        };\n")
SLANG_RAW("    default:\n")
SLANG_RAW("        return false;\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_vote)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("bool WaveMaskAnyTrue(WaveMask mask, bool condition)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupAny($1)\";\n")
SLANG_RAW("    case cuda:\n")
SLANG_RAW("        __intrinsic_asm \"(__any_sync($0, $1) != 0)\";\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        __intrinsic_asm \"WaveActiveAnyTrue($1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            OpCapability GroupNonUniformBallot;\n")
SLANG_RAW("            OpGroupNonUniformAny $$bool result Subgroup $condition\n")
SLANG_RAW("        };\n")
SLANG_RAW("    default:\n")
SLANG_RAW("        return false;\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_ballot)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("WaveMask WaveMaskBallot(WaveMask mask, bool condition)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupBallot($1).x\";\n")
SLANG_RAW("    case cuda:\n")
SLANG_RAW("        __intrinsic_asm \"__ballot_sync($0, $1)\";\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        __intrinsic_asm \"WaveActiveBallot($1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return (spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            OpCapability GroupNonUniformBallot;\n")
SLANG_RAW("            OpGroupNonUniformBallot $$uint4 result Subgroup $condition\n")
SLANG_RAW("        }).x;\n")
SLANG_RAW("    default:\n")
SLANG_RAW("        return 0;\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("uint WaveMaskCountBits(WaveMask mask, bool value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case cuda:\n")
SLANG_RAW("        __intrinsic_asm  \"__popc(__ballot_sync($0, $1))\";\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        __intrinsic_asm  \"WaveActiveCountBits($1)\";\n")
SLANG_RAW("    default:\n")
SLANG_RAW("        return _WaveCountBits(WaveActiveBallot(value));\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Waits until all warp lanes named in mask have executed a WaveMaskSharedSync (with the same mask)\n")
SLANG_RAW("// before resuming execution. Guarantees memory ordering in shared memory among threads participating\n")
SLANG_RAW("// in the barrier.\n")
SLANG_RAW("//\n")
SLANG_RAW("// The CUDA intrinsic says it orders *all* memory accesses, which appears to match most closely subgroupBarrier.\n")
SLANG_RAW("//\n")
SLANG_RAW("// TODO(JS):\n")
SLANG_RAW("// For HLSL it's not clear what to do. There is no explicit mechanism to 'reconverge' threads. In the docs it describes\n")
SLANG_RAW("// behavior as\n")
SLANG_RAW("// \"These intrinsics are dependent on active lanes and therefore flow control. In the model of this document, implementations\n")
SLANG_RAW("// must enforce that the number of active lanes exactly corresponds to the programmer429496726642949671684294967193s view of flow control.\"\n")
SLANG_RAW("//\n")
SLANG_RAW("// It seems this can only mean the active threads are the \"threads the program flow would lead to\". This implies a lockstep\n")
SLANG_RAW("// \"straight SIMD\" style interpretation. That being the case this op on HLSL is just a memory barrier without any Sync.\n")
SLANG_RAW("\n")
SLANG_RAW("void AllMemoryBarrierWithWaveMaskSync(WaveMask mask)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case cuda:\n")
SLANG_RAW("        __intrinsic_asm \"__syncwarp($0)\";\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        __intrinsic_asm \"AllMemoryBarrier()\";\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        __subgroupBarrier();\n")
SLANG_RAW("        return;\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// On GLSL, it appears we can't use subgroupMemoryBarrierShared, because it only implies a memory ordering, it does not\n")
SLANG_RAW("// imply convergence. For subgroupBarrier we have from the docs..\n")
SLANG_RAW("// \"The function subgroupBarrier() enforces that all active invocations within a subgroup must execute this function before any\n")
SLANG_RAW("// are allowed to continue their execution\"\n")
SLANG_RAW("// TODO(JS):\n")
SLANG_RAW("// It's not entirely clear what to do here on HLSL.\n")
SLANG_RAW("// Reading the dxc wiki (https://github.com/Microsoft/DirectXShaderCompiler/wiki/Wave-Intrinsics), we have statements like:\n")
SLANG_RAW("//    ... these intrinsics enable the elimination of barrier constructs when the scope of synchronization is within the width of the SIMD processor.\n")
SLANG_RAW("//    Wave: A set of lanes executed simultaneously in the processor. No explicit barriers are required to guarantee that they execute in parallel.\n")
SLANG_RAW("// Which seems to imply at least some memory barriers like Shared might not be needed.\n")
SLANG_RAW("//\n")
SLANG_RAW("// The barrier is left here though, because not only is the barrier make writes before the barrier across the wave appear to others afterwards, it's\n")
SLANG_RAW("// also there to inform the compiler on what order reads and writes can take place. This might seem to be silly because of the 'Active' lanes\n")
SLANG_RAW("// aspect of HLSL seems to make everything in lock step - but that's not quite so, it only has to apparently be that way as far as the programmers\n")
SLANG_RAW("// model appears - divergence could perhaps potentially still happen.\n")
SLANG_RAW("\n")
SLANG_RAW("void GroupMemoryBarrierWithWaveMaskSync(WaveMask mask)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case cuda:\n")
SLANG_RAW("        __intrinsic_asm \"__syncwarp($0)\";\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        __intrinsic_asm \"GroupMemoryBarrier()\";\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        __subgroupBarrier();\n")
SLANG_RAW("        return;\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("void AllMemoryBarrierWithWaveSync()\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case cuda:\n")
SLANG_RAW("        __intrinsic_asm \"__syncwarp()\";\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        __intrinsic_asm \"AllMemoryBarrier()\";\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        __subgroupBarrier();\n")
SLANG_RAW("        return;\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("void GroupMemoryBarrierWithWaveSync()\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case cuda:\n")
SLANG_RAW("        __intrinsic_asm \"__syncwarp()\";\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        __intrinsic_asm \"GroupMemoryBarrier()\";\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        __subgroupBarrier();\n")
SLANG_RAW("        return;\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// NOTE! WaveMaskBroadcastLaneAt is *NOT* standard HLSL\n")
SLANG_RAW("// It is provided as access to subgroupBroadcast which can only take a\n")
SLANG_RAW("// constexpr laneId.\n")
SLANG_RAW("// https://github.com/KhronosGroup/GLSL/blob/master/extensions/khr/GL_KHR_shader_subgroup.txt\n")
SLANG_RAW("// Versions SPIR-V greater than 1.4 loosen this restriction, and allow 'dynamic uniform' index\n")
SLANG_RAW("// If that's the behavior required then client code should use WaveReadLaneAt which works this way.\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_ballot)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("T WaveMaskBroadcastLaneAt(WaveMask mask, T value, constexpr int lane)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupBroadcast($1, $2)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"__shfl_sync($0, $1, $2)\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WaveReadLaneAt($1, $2)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        let ulane = uint(lane);\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            OpCapability GroupNonUniformBallot;\n")
SLANG_RAW("            OpGroupNonUniformBroadcast $$T result Subgroup $value $ulane;\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_ballot)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("vector<T,N> WaveMaskBroadcastLaneAt(WaveMask mask, vector<T,N> value, constexpr int lane)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupBroadcast($1, $2)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"_waveShuffleMultiple($0, $1, $2)\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WaveReadLaneAt($1, $2)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        let ulane = uint(lane);\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            OpCapability GroupNonUniformBallot;\n")
SLANG_RAW("            OpGroupNonUniformBroadcast $$vector<T,N> result Subgroup $value $ulane;\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(cuda, \"_waveShuffleMultiple($0, $1, $2)\")\n")
SLANG_RAW("__target_intrinsic(hlsl, \"WaveReadLaneAt($1, $2)\")\n")
SLANG_RAW("matrix<T,N,M> WaveMaskBroadcastLaneAt(WaveMask mask, matrix<T,N,M> value, constexpr int lane);\n")
SLANG_RAW("\n")
SLANG_RAW("// TODO(JS): If it can be determines that the `laneId` is constExpr, then subgroupBroadcast\n")
SLANG_RAW("// could be used on GLSL. For now we just use subgroupShuffle\n")
SLANG_RAW("__generic<T : __BuiltinType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_shuffle)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("T WaveMaskReadLaneAt(WaveMask mask, T value, int lane)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupShuffle($1, $2)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"__shfl_sync($0, $1, $2)\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WaveReadLaneAt($1, $2)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        let ulane = uint(lane);\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            OpCapability GroupNonUniformShuffle;\n")
SLANG_RAW("            OpGroupNonUniformShuffle $$T result Subgroup $value $ulane;\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int>\n")
SLANG_RAW("__spirv_version(1.3)__glsl_extension(GL_KHR_shader_subgroup_shuffle)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("vector<T,N> WaveMaskReadLaneAt(WaveMask mask, vector<T,N> value, int lane)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupShuffle($1, $2)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"_waveShuffleMultiple($0, $1, $2)\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WaveReadLaneAt($1, $2)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        let ulane = uint(lane);\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            OpCapability GroupNonUniformShuffle;\n")
SLANG_RAW("            OpGroupNonUniformShuffle $$vector<T,N> result Subgroup $value $ulane;\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(cuda, \"_waveShuffleMultiple($0, $1, $2)\")\n")
SLANG_RAW("__target_intrinsic(hlsl, \"WaveReadLaneAt($1, $2)\")\n")
SLANG_RAW("matrix<T,N,M> WaveMaskReadLaneAt(WaveMask mask, matrix<T,N,M> value, int lane);\n")
SLANG_RAW("\n")
SLANG_RAW("// NOTE! WaveMaskShuffle is a NON STANDARD HLSL intrinsic! It will map to WaveReadLaneAt on HLSL\n")
SLANG_RAW("// which means it will only work on hardware which allows arbitrary laneIds which is not true\n")
SLANG_RAW("// in general because it breaks the HLSL standard, which requires it's 'dynamically uniform' across the Wave.\n")
SLANG_RAW("__generic<T : __BuiltinType>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("T WaveMaskShuffle(WaveMask mask, T value, int lane)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return WaveMaskReadLaneAt(mask, value, lane);\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("vector<T,N> WaveMaskShuffle(WaveMask mask, vector<T,N> value, int lane)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return WaveMaskReadLaneAt(mask, value, lane);\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int, let M : int>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("matrix<T,N,M> WaveMaskShuffle(WaveMask mask, matrix<T,N,M> value, int lane)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return WaveMaskReadLaneAt(mask, value, lane);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_ballot)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("uint WaveMaskPrefixCountBits(WaveMask mask, bool value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupBallotExclusiveBitCount(subgroupBallot($1))\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"__popc(__ballot_sync($0, $1)  & _getLaneLtMask())\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WavePrefixCountBits($1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            OpCapability GroupNonUniformBallot;\n")
SLANG_RAW("            %mask:$$uint4 = OpGroupNonUniformBallot Subgroup $value;\n")
SLANG_RAW("            OpGroupNonUniformBallotBitCount $$uint result Subgroup 2 %mask\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Across lane ops\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinIntegerType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("T WaveMaskBitAnd(WaveMask mask, T expr)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupAnd($1)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"_waveAnd($0, $1)\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WaveActiveBitAnd($1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            OpCapability GroupNonUniformArithmetic;\n")
SLANG_RAW("            OpGroupNonUniformBitwiseAnd $$T result Subgroup 0 $expr\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinIntegerType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("vector<T,N> WaveMaskBitAnd(WaveMask mask, vector<T,N> expr)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupAnd($1)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"_waveAndMultiple($0, $1)\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WaveActiveBitAnd($1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            OpCapability GroupNonUniformArithmetic;\n")
SLANG_RAW("            OpGroupNonUniformBitwiseAnd $$vector<T,N> result Subgroup 0 $expr\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : __BuiltinIntegerType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(cuda, \"_waveAndMultiple($0, $1)\")\n")
SLANG_RAW("__target_intrinsic(hlsl, \"WaveActiveBitAnd($1)\")\n")
SLANG_RAW("matrix<T,N,M> WaveMaskBitAnd(WaveMask mask, matrix<T,N,M> expr);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinIntegerType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("T WaveMaskBitOr(WaveMask mask, T expr)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupOr($1)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"_waveOr($0, $1)\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WaveActiveBitOr($1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            OpCapability GroupNonUniformArithmetic;\n")
SLANG_RAW("            OpGroupNonUniformBitwiseOr $$T result Subgroup 0 $expr\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : __BuiltinIntegerType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("vector<T,N> WaveMaskBitOr(WaveMask mask, vector<T,N> expr)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupOr($1)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"_waveOrMultiple($0, $1)\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WaveActiveBitOr($1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            OpCapability GroupNonUniformArithmetic;\n")
SLANG_RAW("            OpGroupNonUniformBitwiseOr $$vector<T,N> result Subgroup 0 $expr\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : __BuiltinIntegerType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(cuda, \"_waveOrMultiple($0, $1)\")\n")
SLANG_RAW("__target_intrinsic(hlsl, \"WaveActiveBitOr($1)\")\n")
SLANG_RAW("matrix<T,N,M> WaveMaskBitOr(WaveMask mask, matrix<T,N,M> expr);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinIntegerType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("T WaveMaskBitXor(WaveMask mask, T expr)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupXor($1)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"_waveXor($0, $1)\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WaveActiveBitXor($1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            OpCapability GroupNonUniformArithmetic;\n")
SLANG_RAW("            OpGroupNonUniformBitwiseXor $$T result Subgroup 0 $expr\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : __BuiltinIntegerType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("vector<T,N> WaveMaskBitXor(WaveMask mask, vector<T,N> expr)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupXor($1)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"_waveXorMultiple($0, $1)\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WaveActiveBitXor($1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            OpCapability GroupNonUniformArithmetic;\n")
SLANG_RAW("            OpGroupNonUniformBitwiseXor $$vector<T,N> result Subgroup 0 $expr\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : __BuiltinIntegerType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(cuda, \"_waveXorMultiple($0, $1)\")\n")
SLANG_RAW("__target_intrinsic(hlsl, \"WaveActiveBitXor($1)\")\n")
SLANG_RAW("matrix<T,N,M> WaveMaskBitXor(WaveMask mask, matrix<T,N,M> expr);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("T WaveMaskMax(WaveMask mask, T expr)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupMax($1)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"_waveMax($0, $1)\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WaveActiveMax($1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isFloat<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformFMax $$T result Subgroup 0 $expr};\n")
SLANG_RAW("        else if (__isSignedInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformSMax $$T result Subgroup 0 $expr};\n")
SLANG_RAW("        else if (__isUnsignedInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformUMax $$T result Subgroup 0 $expr};\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("vector<T,N> WaveMaskMax(WaveMask mask, vector<T,N> expr)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupMax($1)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"_waveMaxMultiple($0, $1)\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WaveActiveMax($1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isFloat<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformFMax $$vector<T,N> result Subgroup 0 $expr};\n")
SLANG_RAW("        else if (__isSignedInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformSMax $$vector<T,N> result Subgroup 0 $expr};\n")
SLANG_RAW("        else if (__isUnsignedInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformUMax $$vector<T,N> result Subgroup 0 $expr};\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(cuda, \"_waveMaxMultiple($0, $1)\")\n")
SLANG_RAW("__target_intrinsic(hlsl, \"WaveActiveMax($1)\")\n")
SLANG_RAW("matrix<T,N,M> WaveMaskMax(WaveMask mask, matrix<T,N,M> expr);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("T WaveMaskMin(WaveMask mask, T expr)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupMin($1)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"_waveMin($0, $1)\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WaveActiveMin($1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isFloat<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformFMin $$T result Subgroup 0 $expr};\n")
SLANG_RAW("        else if (__isSignedInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformSMin $$T result Subgroup 0 $expr};\n")
SLANG_RAW("        else if (__isUnsignedInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformUMin $$T result Subgroup 0 $expr};\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("vector<T,N> WaveMaskMin(WaveMask mask, vector<T,N> expr)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupMin($1)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"_waveMinMultiple($0, $1)\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WaveActiveMin($1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isFloat<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformFMin $$vector<T,N>  result Subgroup 0 $expr};\n")
SLANG_RAW("        else if (__isSignedInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformSMin $$vector<T,N>  result Subgroup 0 $expr};\n")
SLANG_RAW("        else if (__isUnsignedInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformUMin $$vector<T,N>  result Subgroup 0 $expr};\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(cuda, \"_waveMinMultiple($0, $1)\")\n")
SLANG_RAW("__target_intrinsic(hlsl, \"WaveActiveMin($1)\")\n")
SLANG_RAW("matrix<T,N,M> WaveMaskMin(WaveMask mask, matrix<T,N,M> expr);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("T WaveMaskProduct(WaveMask mask, T expr)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupMul($1)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"_waveProduct($0, $1)\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WaveActiveProduct($1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isFloat<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformFMul $$T result Subgroup 0 $expr};\n")
SLANG_RAW("        else if (__isSignedInt<T>())\n")
SLANG_RAW("        {\n")
SLANG_RAW("            return spirv_asm\n")
SLANG_RAW("            {\n")
SLANG_RAW("                OpCapability GroupNonUniformArithmetic;\n")
SLANG_RAW("                // TODO: use the correct integer width\n")
SLANG_RAW("                OpBitcast $$uint %uvalue $expr;\n")
SLANG_RAW("                OpGroupNonUniformIMul $$uint %mulResult Subgroup 0 %uvalue;\n")
SLANG_RAW("                OpBitcast $$T result %mulResult\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("        else if (__isUnsignedInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformIMul $$T result Subgroup 0 $expr};\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("vector<T,N> WaveMaskProduct(WaveMask mask, vector<T,N> expr)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupMul($1)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"_waveProductMultiple($0, $1)\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WaveActiveProduct($1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isFloat<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformFMul $$vector<T,N> result Subgroup 0 $expr};\n")
SLANG_RAW("        else if (__isSignedInt<T>())\n")
SLANG_RAW("        {\n")
SLANG_RAW("            return spirv_asm\n")
SLANG_RAW("            {\n")
SLANG_RAW("                OpCapability GroupNonUniformArithmetic;\n")
SLANG_RAW("                // TODO: use the correct integer width\n")
SLANG_RAW("                OpBitcast $$vector<uint,N> %uvalue $expr;\n")
SLANG_RAW("                OpGroupNonUniformIMul $$vector<uint,N> %mulResult Subgroup 0 %uvalue;\n")
SLANG_RAW("                OpBitcast $$vector<T,N> result %mulResult\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("        else if (__isUnsignedInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformIMul $$vector<T,N> result Subgroup 0 $expr};\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(cuda, \"_waveProductMultiple($0, $1)\")\n")
SLANG_RAW("__target_intrinsic(hlsl, \"WaveActiveProduct($1)\")\n")
SLANG_RAW("matrix<T,N,M> WaveMaskProduct(WaveMask mask, matrix<T,N,M> expr);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("T WaveMaskSum(WaveMask mask, T expr)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupAdd($1)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"_waveSum($0, $1)\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WaveActiveSum($1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isFloat<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformFAdd $$T result Subgroup 0 $expr};\n")
SLANG_RAW("        else if (__isSignedInt<T>())\n")
SLANG_RAW("        {\n")
SLANG_RAW("            return spirv_asm\n")
SLANG_RAW("            {\n")
SLANG_RAW("                OpCapability GroupNonUniformArithmetic;\n")
SLANG_RAW("                // TODO: use the correct integer width\n")
SLANG_RAW("                OpBitcast $$uint %uvalue $expr;\n")
SLANG_RAW("                OpGroupNonUniformIAdd $$uint %mulResult Subgroup 0 %uvalue;\n")
SLANG_RAW("                OpBitcast $$T result %mulResult\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("        else if (__isUnsignedInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformIAdd $$T result Subgroup 0 $expr};\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("vector<T,N> WaveMaskSum(WaveMask mask, vector<T,N> expr)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupAdd($1)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"_waveSumMultiple($0, $1)\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WaveActiveSum($1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isFloat<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformFAdd $$vector<T,N> result Subgroup 0 $expr};\n")
SLANG_RAW("        else if (__isSignedInt<T>())\n")
SLANG_RAW("        {\n")
SLANG_RAW("            return spirv_asm\n")
SLANG_RAW("            {\n")
SLANG_RAW("                OpCapability GroupNonUniformArithmetic; \n")
SLANG_RAW("                // TODO: use the correct integer width\n")
SLANG_RAW("                OpBitcast $$vector<uint,N> %uvalue $expr;\n")
SLANG_RAW("                OpGroupNonUniformIAdd $$vector<uint,N> %mulResult Subgroup 0 %uvalue;\n")
SLANG_RAW("                OpBitcast $$vector<T,N> result %mulResult\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("        else if (__isUnsignedInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformIAdd $$vector<T,N> result Subgroup 0 $expr};\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(cuda, \"_waveSumMultiple($0, $1)\")\n")
SLANG_RAW("__target_intrinsic(hlsl, \"WaveActiveSum($1)\")\n")
SLANG_RAW("matrix<T,N,M> WaveMaskSum(WaveMask mask, matrix<T,N,M> expr);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_vote)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("__cuda_sm_version(7.0)\n")
SLANG_RAW("bool WaveMaskAllEqual(WaveMask mask, T value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupAllEqual($1)\";\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        __intrinsic_asm \"WaveActiveAllEqual($1)\";\n")
SLANG_RAW("    case cuda:\n")
SLANG_RAW("        __intrinsic_asm \"_waveAllEqual($0, $1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            OpCapability GroupNonUniformVote;\n")
SLANG_RAW("            OpGroupNonUniformAllEqual $$bool result Subgroup $value\n")
SLANG_RAW("        };\n")
SLANG_RAW("    default:\n")
SLANG_RAW("        return false;\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_vote)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("__cuda_sm_version(7.0)\n")
SLANG_RAW("bool WaveMaskAllEqual(WaveMask mask, vector<T,N> value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupAllEqual($1)\";\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        __intrinsic_asm \"WaveActiveAllEqual($1)\";\n")
SLANG_RAW("    case cuda:\n")
SLANG_RAW("        __intrinsic_asm \"_waveAllEqualMultiple($0, $1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            OpCapability GroupNonUniformVote;\n")
SLANG_RAW("            OpGroupNonUniformAllEqual $$bool result Subgroup $value\n")
SLANG_RAW("        };\n")
SLANG_RAW("    default:\n")
SLANG_RAW("        return false;\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int, let M : int>\n")
SLANG_RAW("__cuda_sm_version(7.0)\n")
SLANG_RAW("__target_intrinsic(cuda, \"_waveAllEqualMultiple($0, $1)\")\n")
SLANG_RAW("__target_intrinsic(hlsl, \"WaveActiveAllEqual($1)\")\n")
SLANG_RAW("bool WaveMaskAllEqual(WaveMask mask, matrix<T,N,M> value);\n")
SLANG_RAW("\n")
SLANG_RAW("// Prefix\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("T WaveMaskPrefixProduct(WaveMask mask, T expr)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupExclusiveMul($1)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"_wavePrefixProduct($0, $1)\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WavePrefixProduct($1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isFloat<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformFMul $$T result Subgroup ExclusiveScan $expr};\n")
SLANG_RAW("        else if (__isSignedInt<T>())\n")
SLANG_RAW("        {\n")
SLANG_RAW("            return spirv_asm\n")
SLANG_RAW("            {\n")
SLANG_RAW("                OpCapability GroupNonUniformArithmetic;\n")
SLANG_RAW("                // TODO: use the correct integer width\n")
SLANG_RAW("                OpBitcast $$uint %uvalue $expr;\n")
SLANG_RAW("                OpGroupNonUniformIMul $$uint %mulResult Subgroup ExclusiveScan %uvalue;\n")
SLANG_RAW("                OpBitcast $$T result %mulResult\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("        else if (__isUnsignedInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpGroupNonUniformIMul $$T result Subgroup ExclusiveScan $expr};\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("vector<T,N> WaveMaskPrefixProduct(WaveMask mask, vector<T,N> expr)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupExclusiveMul($1)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"_wavePrefixProductMultiple($0, $1)\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WavePrefixProduct($1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isFloat<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformFMul $$vector<T,N> result Subgroup ExclusiveScan $expr};\n")
SLANG_RAW("        else if (__isSignedInt<T>())\n")
SLANG_RAW("        {\n")
SLANG_RAW("            return spirv_asm\n")
SLANG_RAW("            {\n")
SLANG_RAW("                OpCapability GroupNonUniformArithmetic;\n")
SLANG_RAW("                // TODO: use the correct integer width\n")
SLANG_RAW("                OpBitcast $$vector<uint,N> %uvalue $expr;\n")
SLANG_RAW("                OpGroupNonUniformIMul $$vector<uint,N> %mulResult Subgroup ExclusiveScan %uvalue;\n")
SLANG_RAW("                OpBitcast $$vector<T,N> result %mulResult\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("        else if (__isUnsignedInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformIMul $$vector<T,N> result Subgroup ExclusiveScan $expr};\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(cuda, \"_wavePrefixProductMultiple($0, $1)\")\n")
SLANG_RAW("__target_intrinsic(hlsl, \"WavePrefixProduct($1)\")\n")
SLANG_RAW("matrix<T,N,M> WaveMaskPrefixProduct(WaveMask mask, matrix<T,N,M> expr);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("T WaveMaskPrefixSum(WaveMask mask, T expr)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupExclusiveAdd($1)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"_wavePrefixSum($0, $1)\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WavePrefixSum($1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isFloat<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformFAdd $$T result Subgroup ExclusiveScan $expr};\n")
SLANG_RAW("        else if (__isSignedInt<T>())\n")
SLANG_RAW("        {\n")
SLANG_RAW("            return spirv_asm\n")
SLANG_RAW("            {\n")
SLANG_RAW("                OpCapability GroupNonUniformArithmetic;\n")
SLANG_RAW("                // TODO: use the correct integer width\n")
SLANG_RAW("                %uvalue:$$uint = OpBitcast $expr;\n")
SLANG_RAW("                %mulResult:$$uint = OpGroupNonUniformIAdd Subgroup ExclusiveScan %uvalue;\n")
SLANG_RAW("                result:$$T = OpBitcast %mulResult\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("        else if (__isUnsignedInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformIAdd $$T result Subgroup ExclusiveScan $expr};\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("vector<T,N> WaveMaskPrefixSum(WaveMask mask, vector<T,N> expr)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupExclusiveAdd($1)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"_wavePrefixSumMultiple($0, $1)\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WavePrefixSum($1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isFloat<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformFAdd $$vector<T,N> result Subgroup ExclusiveScan $expr};\n")
SLANG_RAW("        else if (__isSignedInt<T>())\n")
SLANG_RAW("        {\n")
SLANG_RAW("            return spirv_asm\n")
SLANG_RAW("            {\n")
SLANG_RAW("                OpCapability GroupNonUniformArithmetic;\n")
SLANG_RAW("                // TODO: use the correct integer width\n")
SLANG_RAW("                %uvalue: $$vector<uint,N> = OpBitcast $expr;\n")
SLANG_RAW("                %mulResult: $$vector<uint,N> = OpGroupNonUniformIAdd Subgroup ExclusiveScan %uvalue;\n")
SLANG_RAW("                result: $$vector<T,N> = OpBitcast  %mulResult\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("        else if (__isUnsignedInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformIAdd $$vector<T,N> result Subgroup ExclusiveScan $expr};\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(cuda, \"_wavePrefixSumMultiple($0, $1)\")\n")
SLANG_RAW("__target_intrinsic(hlsl, \"WavePrefixSum($1)\")\n")
SLANG_RAW("matrix<T,N,M> WaveMaskPrefixSum(WaveMask mask, matrix<T,N,M> expr);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_ballot)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("T WaveMaskReadLaneFirst(WaveMask mask, T expr)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupBroadcastFirst($1)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"_waveReadFirst($0, $1)\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WaveReadLaneFirst($1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {OpCapability GroupNonUniformBallot; OpGroupNonUniformBroadcastFirst $$T result Subgroup $expr};\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_ballot)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("vector<T,N> WaveMaskReadLaneFirst(WaveMask mask, vector<T,N> expr)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupBroadcastFirst($1)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"_waveReadFirstMultiple($0, $1)\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WaveReadLaneFirst($1)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {OpCapability GroupNonUniformBallot; OpGroupNonUniformBroadcastFirst $$vector<T,N> result Subgroup $expr};\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(cuda, \"_waveReadFirstMultiple($0, $1)\")\n")
SLANG_RAW("matrix<T,N,M> WaveMaskReadLaneFirst(WaveMask mask, matrix<T,N,M> expr);\n")
SLANG_RAW("\n")
SLANG_RAW("// WaveMask SM6.5 like intrinsics\n")
SLANG_RAW("\n")
SLANG_RAW("// TODO(JS): On HLSL it only works for 32 bits or less\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType>\n")
SLANG_RAW("__glsl_extension(GL_NV_shader_subgroup_partitioned)\n")
SLANG_RAW("__spirv_version(1.1)\n")
SLANG_RAW("__cuda_sm_version(7.0)\n")
SLANG_RAW("WaveMask WaveMaskMatch(WaveMask mask, T value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupPartitionNV($1).x\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"_waveMatchScalar($0, $1).x\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WaveMatch($1).x\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return (spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            OpCapability GroupNonUniformPartitionedNV;\n")
SLANG_RAW("            OpExtension \"SPV_NV_shader_subgroup_partitioned\";\n")
SLANG_RAW("            OpGroupNonUniformPartitionNV $$uint4 result $value\n")
SLANG_RAW("        }).x;\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_NV_shader_subgroup_partitioned)\n")
SLANG_RAW("__spirv_version(1.1)\n")
SLANG_RAW("__cuda_sm_version(7.0)\n")
SLANG_RAW("WaveMask WaveMaskMatch(WaveMask mask, vector<T,N> value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupPartitionNV($1).x\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"_waveMatchMultiple($0, $1).x\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WaveMatch($1).x\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return (spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            OpCapability GroupNonUniformPartitionedNV;\n")
SLANG_RAW("            OpExtension \"SPV_NV_shader_subgroup_partitioned\";\n")
SLANG_RAW("            OpGroupNonUniformPartitionNV $$uint4 result $value\n")
SLANG_RAW("        }).x;\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl, \"WaveMatch($1).x\")\n")
SLANG_RAW("__glsl_extension(GL_NV_shader_subgroup_partitioned)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("__target_intrinsic(glsl, \"subgroupPartitionNV($1).x\")\n")
SLANG_RAW("__cuda_sm_version(7.0)\n")
SLANG_RAW("__target_intrinsic(cuda, \"_waveMatchMultiple($0, $1)\")\n")
SLANG_RAW("WaveMask WaveMaskMatch(WaveMask mask, matrix<T,N,M> value);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("T WaveMaskPrefixBitAnd(WaveMask mask, T expr)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupExclusiveAnd($1)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"_wavePrefixAnd($0, $1)\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WaveMultiPrefixBitAnd($1, uint4($0, 0, 0, 0))\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformBitwiseAnd $$T result Subgroup ExclusiveScan $expr};\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("vector<T,N> WaveMaskPrefixBitAnd(WaveMask mask, vector<T,N> expr)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupExclusiveAnd($1)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"_wavePrefixAndMultiple($0, $1)\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WaveMultiPrefixBitAnd($1, uint4($0, 0, 0, 0))\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformBitwiseAnd $$vector<T,N> result Subgroup ExclusiveScan $expr};\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl, \"WaveMultiPrefixBitAnd($1, uint4($0, 0, 0, 0))\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"_wavePrefixAndMultiple(_getMultiPrefixMask($0, $1)\")\n")
SLANG_RAW("matrix<T,N,M> WaveMaskPrefixBitAnd(WaveMask mask, matrix<T,N,M> expr);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("T WaveMaskPrefixBitOr(WaveMask mask, T expr)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupExclusiveOr($1)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"_wavePrefixOr($0, $1)\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WaveMultiPrefixBitOr($1, uint4($0, 0, 0, 0))\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformBitwiseAnd $$T result Subgroup ExclusiveScan $expr};\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("vector<T,N> WaveMaskPrefixBitOr(WaveMask mask, vector<T,N> expr)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupExclusiveOr($1)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"_wavePrefixOrMultiple($0, $1)\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WaveMultiPrefixBitOr($1, uint4($0, 0, 0, 0))\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformBitwiseOr $$vector<T,N> result Subgroup ExclusiveScan $expr};\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl, \"WaveMultiPrefixBitOr($1, uint4($0, 0, 0, 0))\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"_wavePrefixOrMultiple($0, $1)\")\n")
SLANG_RAW("matrix<T,N,M> WaveMaskPrefixBitOr(WaveMask mask, matrix<T,N,M> expr);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("T WaveMaskPrefixBitXor(WaveMask mask, T expr)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupExclusiveXor($1)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"_wavePrefixXor($0, $1)\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WaveMultiPrefixBitXor($1, uint4($0, 0, 0, 0))\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformBitwiseXor $$T result Subgroup ExclusiveScan $expr};\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("vector<T,N> WaveMaskPrefixBitXor(WaveMask mask, vector<T,N> expr)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupExclusiveXor($1)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"_wavePrefixXorMultiple($0, $1)\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WaveMultiPrefixBitXor($1, uint4($0, 0, 0, 0))\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformBitwiseXor $$vector<T,N> result Subgroup ExclusiveScan $expr};\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl, \"WaveMultiPrefixBitXor($1, uint4($0, 0, 0, 0))\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"_wavePrefixXorMultiple($0, $1)\")\n")
SLANG_RAW("matrix<T,N,M> WaveMaskPrefixBitXor(WaveMask mask, matrix<T,N,M> expr);\n")
SLANG_RAW("\n")
SLANG_RAW("// Shader model 6.0 stuff\n")
SLANG_RAW("\n")
SLANG_RAW("// Information for GLSL wave/subgroup support\n")
SLANG_RAW("// https://github.com/KhronosGroup/GLSL/blob/master/extensions/khr/GL_KHR_shader_subgroup.txt\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_quad)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("T QuadReadLaneAt(T sourceValue, uint quadLaneID)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        __intrinsic_asm \"QuadReadLaneAt\";\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupQuadBroadcast\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            OpCapability GroupNonUniformQuad;\n")
SLANG_RAW("            result:$$T = OpGroupNonUniformQuadBroadcast Subgroup $sourceValue $quadLaneID;\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_quad)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("vector<T,N> QuadReadLaneAt(vector<T,N> sourceValue, uint quadLaneID)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        __intrinsic_asm \"QuadReadLaneAt\";\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupQuadBroadcast\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            OpCapability GroupNonUniformQuad;\n")
SLANG_RAW("            result:$$vector<T,N> = OpGroupNonUniformQuadBroadcast Subgroup $sourceValue $quadLaneID;\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int, let M : int> matrix<T,N,M> QuadReadLaneAt(matrix<T,N,M> sourceValue, uint quadLaneID);\n")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_quad)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("T QuadReadAcrossX(T localValue)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        __intrinsic_asm \"QuadReadAcrossX\";\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupQuadSwapHorizontal($0)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        uint direction = 0u;\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            OpCapability GroupNonUniformQuad;\n")
SLANG_RAW("            result:$$T = OpGroupNonUniformQuadSwap Subgroup $localValue $direction;\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_quad)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("vector<T,N> QuadReadAcrossX(vector<T,N> localValue)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        __intrinsic_asm \"QuadReadAcrossX\";\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupQuadSwapHorizontal($0)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        uint direction = 0u;\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            OpCapability GroupNonUniformQuad;\n")
SLANG_RAW("            result:$$vector<T,N> = OpGroupNonUniformQuadSwap Subgroup $localValue $direction;\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int, let M : int> matrix<T,N,M> QuadReadAcrossX(matrix<T,N,M> localValue);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_quad)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("T QuadReadAcrossY(T localValue)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        __intrinsic_asm \"QuadReadAcrossY\";\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupQuadSwapVertical($0)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        uint direction = 1u;\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            OpCapability GroupNonUniformQuad;\n")
SLANG_RAW("            result:$$T = OpGroupNonUniformQuadSwap Subgroup $localValue $direction;\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_quad)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("vector<T,N> QuadReadAcrossY(vector<T,N> localValue)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        __intrinsic_asm \"QuadReadAcrossY\";\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupQuadSwapVertical($0)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        uint direction = 1u;\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            OpCapability GroupNonUniformQuad;\n")
SLANG_RAW("            result:$$vector<T,N> = OpGroupNonUniformQuadSwap Subgroup $localValue $direction;\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int, let M : int> matrix<T,N,M> QuadReadAcrossY(matrix<T,N,M> localValue);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_quad)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("T QuadReadAcrossDiagonal(T localValue)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        __intrinsic_asm \"QuadReadAcrossDiagonal\";\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupQuadSwapDiagonal($0)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        uint direction = 2u;\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            OpCapability GroupNonUniformQuad;\n")
SLANG_RAW("            result:$$T = OpGroupNonUniformQuadSwap Subgroup $localValue $direction;\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_quad)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("vector<T,N> QuadReadAcrossDiagonal(vector<T,N> localValue)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        __intrinsic_asm \"QuadReadAcrossDiagonal\";\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupQuadSwapDiagonal($0)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        uint direction = 2u;\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            OpCapability GroupNonUniformQuad;\n")
SLANG_RAW("            result:$$vector<T,N> = OpGroupNonUniformQuadSwap Subgroup $localValue $direction;\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int, let M : int> matrix<T,N,M> QuadReadAcrossDiagonal(matrix<T,N,M> localValue);\n")
SLANG_RAW("\n")
SLANG_RAW("// WaveActiveBitAnd, WaveActiveBitOr, WaveActiveBitXor\n")

struct WaveActiveBitOpEntry { const char* hlslName; const char* glslName; const char* spirvName; };
const WaveActiveBitOpEntry kWaveActiveBitOpEntries[] = {{"BitAnd", "And", "BitwiseAnd"}, {"BitOr", "Or", "BitwiseOr"}, {"BitXor", "Xor", "BitwiseXor"}};
for (auto opName : kWaveActiveBitOpEntries) {
SLANG_RAW("#line 7988 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinIntegerType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("T WaveActive")
SLANG_SPLICE(opName.hlslName
)
SLANG_RAW("(T expr)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroup")
SLANG_SPLICE(opName.glslName
)
SLANG_RAW("($0)\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WaveActive")
SLANG_SPLICE(opName.hlslName
)
SLANG_RAW("\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniform")
SLANG_SPLICE(opName.spirvName
)
SLANG_RAW(" $$T result Subgroup Reduce $expr};\n")
SLANG_RAW("    default:\n")
SLANG_RAW("        return WaveMask")
SLANG_SPLICE(opName.hlslName
)
SLANG_RAW("(WaveGetActiveMask(), expr);\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinIntegerType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("vector<T, N> WaveActive")
SLANG_SPLICE(opName.hlslName
)
SLANG_RAW("(vector<T, N> expr)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroup")
SLANG_SPLICE(opName.glslName
)
SLANG_RAW("($0)\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WaveActive")
SLANG_SPLICE(opName.hlslName
)
SLANG_RAW("\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniform")
SLANG_SPLICE(opName.spirvName
)
SLANG_RAW(" $$vector<T, N> result Subgroup Reduce $expr};\n")
SLANG_RAW("    default:\n")
SLANG_RAW("        return WaveMask")
SLANG_SPLICE(opName.hlslName
)
SLANG_RAW("(WaveGetActiveMask(), expr);\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinIntegerType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("matrix<T, N, M> WaveActive")
SLANG_SPLICE(opName.hlslName
)
SLANG_RAW("(matrix<T, N, M> expr)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return WaveMask")
SLANG_SPLICE(opName.hlslName
)
SLANG_RAW("(WaveGetActiveMask(), expr);\n")
SLANG_RAW("}\n")

} // WaveActiveBitAnd, WaveActiveBitOr, WaveActiveBitXor
SLANG_RAW("#line 8030 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("// WaveActiveMin/Max\n")

const char* kWaveActiveMinMaxNames[] = {"Min", "Max"};
for (const char* opName : kWaveActiveMinMaxNames) {
SLANG_RAW("#line 8036 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("T WaveActive")
SLANG_SPLICE(opName
)
SLANG_RAW("(T expr)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroup")
SLANG_SPLICE(opName
)
SLANG_RAW("($0)\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WaveActive")
SLANG_SPLICE(opName
)
SLANG_RAW("\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isFloat<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformF")
SLANG_SPLICE(opName
)
SLANG_RAW(" $$T result Subgroup Reduce $expr};\n")
SLANG_RAW("        else if (__isUnsignedInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformU")
SLANG_SPLICE(opName
)
SLANG_RAW(" $$T result Subgroup Reduce $expr};\n")
SLANG_RAW("        else\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformS")
SLANG_SPLICE(opName
)
SLANG_RAW(" $$T result Subgroup Reduce $expr};\n")
SLANG_RAW("    default:\n")
SLANG_RAW("        return WaveMask")
SLANG_SPLICE(opName
)
SLANG_RAW("(WaveGetActiveMask(), expr);\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("vector<T, N> WaveActive")
SLANG_SPLICE(opName
)
SLANG_RAW("(vector<T, N> expr)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroup")
SLANG_SPLICE(opName
)
SLANG_RAW("($0)\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WaveActive")
SLANG_SPLICE(opName
)
SLANG_RAW("\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isFloat<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformF")
SLANG_SPLICE(opName
)
SLANG_RAW(" $$vector<T, N> result Subgroup Reduce $expr};\n")
SLANG_RAW("        else if (__isUnsignedInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformU")
SLANG_SPLICE(opName
)
SLANG_RAW(" $$vector<T, N> result Subgroup Reduce $expr};\n")
SLANG_RAW("        else\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformS")
SLANG_SPLICE(opName
)
SLANG_RAW(" $$vector<T, N> result Subgroup Reduce $expr};\n")
SLANG_RAW("    default:\n")
SLANG_RAW("        return WaveMask")
SLANG_SPLICE(opName
)
SLANG_RAW("(WaveGetActiveMask(), expr);\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("matrix<T, N, M> WaveActive")
SLANG_SPLICE(opName
)
SLANG_RAW("(matrix<T, N, M> expr)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return WaveMask")
SLANG_SPLICE(opName
)
SLANG_RAW("(WaveGetActiveMask(), expr);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")

} // WaveActiveMinMax.
SLANG_RAW("#line 8089 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("// WaveActiveProduct/Sum\n")

struct WaveActiveProductSumEntry { const char* hlslName; const char* glslName; };
const WaveActiveProductSumEntry kWaveActivProductSumNames[] = {{"Product", "Mul"}, {"Sum", "Add"}};
for (auto opName : kWaveActivProductSumNames) {
SLANG_RAW("#line 8096 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("T WaveActive")
SLANG_SPLICE(opName.hlslName
)
SLANG_RAW("(T expr)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroup")
SLANG_SPLICE(opName.glslName
)
SLANG_RAW("($0)\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WaveActive")
SLANG_SPLICE(opName.hlslName
)
SLANG_RAW("\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isFloat<T>())\n")
SLANG_RAW("            return spirv_asm {\n")
SLANG_RAW("                OpCapability GroupNonUniformArithmetic;\n")
SLANG_RAW("                OpGroupNonUniformF")
SLANG_SPLICE(opName.glslName
)
SLANG_RAW(" $$T result Subgroup 0 $expr\n")
SLANG_RAW("            };\n")
SLANG_RAW("        else if (__isSignedInt<T>())\n")
SLANG_RAW("        {\n")
SLANG_RAW("            return spirv_asm\n")
SLANG_RAW("            {\n")
SLANG_RAW("                OpCapability GroupNonUniformArithmetic;\n")
SLANG_RAW("                // TODO: use the correct integer width\n")
SLANG_RAW("                OpBitcast $$uint %uvalue $expr;\n")
SLANG_RAW("                OpGroupNonUniformI")
SLANG_SPLICE(opName.glslName
)
SLANG_RAW(" $$uint %mulResult Subgroup 0 %uvalue;\n")
SLANG_RAW("                OpBitcast $$T result %mulResult\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("        else if (__isUnsignedInt<T>())\n")
SLANG_RAW("            return spirv_asm\n")
SLANG_RAW("            {\n")
SLANG_RAW("                OpCapability GroupNonUniformArithmetic;\n")
SLANG_RAW("                OpGroupNonUniformI")
SLANG_SPLICE(opName.glslName
)
SLANG_RAW(" $$T result Subgroup 0 $expr\n")
SLANG_RAW("            };\n")
SLANG_RAW("    default:\n")
SLANG_RAW("        return WaveMask")
SLANG_SPLICE(opName.hlslName
)
SLANG_RAW("(WaveGetActiveMask(), expr);\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("vector<T,N> WaveActive")
SLANG_SPLICE(opName.hlslName
)
SLANG_RAW("(vector<T,N> expr)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroup")
SLANG_SPLICE(opName.glslName
)
SLANG_RAW("($0)\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WaveActive")
SLANG_SPLICE(opName.hlslName
)
SLANG_RAW("\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isFloat<T>())\n")
SLANG_RAW("            return spirv_asm {\n")
SLANG_RAW("                OpCapability GroupNonUniformArithmetic;\n")
SLANG_RAW("                OpGroupNonUniformF")
SLANG_SPLICE(opName.glslName
)
SLANG_RAW(" $$vector<T,N> result Subgroup 0 $expr\n")
SLANG_RAW("            };\n")
SLANG_RAW("        else if (__isSignedInt<T>())\n")
SLANG_RAW("        {\n")
SLANG_RAW("            return spirv_asm\n")
SLANG_RAW("            {\n")
SLANG_RAW("                OpCapability GroupNonUniformArithmetic;\n")
SLANG_RAW("                // TODO: use the correct integer width\n")
SLANG_RAW("                OpBitcast $$vector<uint,N> %uvalue $expr;\n")
SLANG_RAW("                OpGroupNonUniformI")
SLANG_SPLICE(opName.glslName
)
SLANG_RAW(" $$vector<uint,N> %")
SLANG_SPLICE(opName.glslName
)
SLANG_RAW("Result Subgroup 0 %uvalue;\n")
SLANG_RAW("                OpBitcast $$vector<T,N> result %")
SLANG_SPLICE(opName.glslName
)
SLANG_RAW("Result\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("        else if (__isUnsignedInt<T>())\n")
SLANG_RAW("            return spirv_asm\n")
SLANG_RAW("            {\n")
SLANG_RAW("                OpCapability GroupNonUniformArithmetic;\n")
SLANG_RAW("                OpGroupNonUniformI")
SLANG_SPLICE(opName.glslName
)
SLANG_RAW(" $$vector<T,N> result Subgroup 0 $expr\n")
SLANG_RAW("            };\n")
SLANG_RAW("    default:\n")
SLANG_RAW("        return WaveMask")
SLANG_SPLICE(opName.hlslName
)
SLANG_RAW("(WaveGetActiveMask(), expr);\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("matrix<T, N, M> WaveActive")
SLANG_SPLICE(opName.hlslName
)
SLANG_RAW("(matrix<T, N, M> expr)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return WaveMask")
SLANG_SPLICE(opName.hlslName
)
SLANG_RAW("(WaveGetActiveMask(), expr);\n")
SLANG_RAW("}\n")

} // WaveActiveProduct/WaveActiveProductSum.
SLANG_RAW("#line 8181 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_vote)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("bool WaveActiveAllEqual(T value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupAllEqual($0)\";\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        __intrinsic_asm \"WaveActiveAllEqual\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            OpCapability GroupNonUniformVote;\n")
SLANG_RAW("            OpGroupNonUniformAllEqual $$bool result Subgroup $value\n")
SLANG_RAW("        };\n")
SLANG_RAW("    default:\n")
SLANG_RAW("        return WaveMaskAllEqual(WaveGetActiveMask(), value);\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_vote)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("bool WaveActiveAllEqual(vector<T,N> value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupAllEqual($0)\";\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        __intrinsic_asm \"WaveActiveAllEqual\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            OpCapability GroupNonUniformVote;\n")
SLANG_RAW("            OpGroupNonUniformAllEqual $$bool result Subgroup $value\n")
SLANG_RAW("        };\n")
SLANG_RAW("    default:\n")
SLANG_RAW("        return WaveMaskAllEqual(WaveGetActiveMask(), value);\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("bool WaveActiveAllEqual(matrix<T, N, M> value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return WaveMaskAllEqual(WaveGetActiveMask(), value);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_vote)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("bool WaveActiveAllTrue(bool condition)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupAll($0)\";\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        __intrinsic_asm \"WaveActiveAllTrue($0)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            OpCapability GroupNonUniformVote;\n")
SLANG_RAW("            OpGroupNonUniformAll $$bool result Subgroup $condition\n")
SLANG_RAW("        };\n")
SLANG_RAW("    default:\n")
SLANG_RAW("        return WaveMaskAllTrue(WaveGetActiveMask(), condition);\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_vote)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("bool WaveActiveAnyTrue(bool condition)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupAny($0)\";\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        __intrinsic_asm \"WaveActiveAnyTrue($0)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            OpCapability GroupNonUniformVote;\n")
SLANG_RAW("            OpGroupNonUniformAny $$bool result Subgroup $condition\n")
SLANG_RAW("        };\n")
SLANG_RAW("    default:\n")
SLANG_RAW("        return WaveMaskAnyTrue(WaveGetActiveMask(), condition);\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_ballot)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("uint4 WaveActiveBallot(bool condition)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupBallot($0)\";\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        __intrinsic_asm \"WaveActiveBallot\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            OpCapability GroupNonUniformBallot;\n")
SLANG_RAW("            OpGroupNonUniformBallot $$uint4 result Subgroup $condition\n")
SLANG_RAW("        };\n")
SLANG_RAW("    default:\n")
SLANG_RAW("        return WaveMaskBallot(WaveGetActiveMask(), condition);\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("uint WaveActiveCountBits(bool value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return WaveMaskCountBits(WaveGetActiveMask(), value);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_basic)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("uint WaveGetLaneCount()\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm  \"(gl_SubgroupSize)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm  \"(warpSize)\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm  \"WaveGetLaneCount()\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            OpCapability GroupNonUniform;\n")
SLANG_RAW("            result:$$uint = OpLoad builtin(SubgroupSize:uint)\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_basic)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("uint WaveGetLaneIndex()\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm  \"(gl_SubgroupInvocationID)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm  \"_getLaneId()\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm  \"WaveGetLaneIndex()\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            OpCapability GroupNonUniform;\n")
SLANG_RAW("            result:$$uint = OpLoad builtin(SubgroupLocalInvocationId:uint)\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_basic)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("bool WaveIsFirstLane()\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"subgroupElect()\";\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        __intrinsic_asm \"WaveIsFirstLane()\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            OpCapability GroupNonUniformBallot;\n")
SLANG_RAW("            OpGroupNonUniformElect $$bool result Subgroup\n")
SLANG_RAW("        };\n")
SLANG_RAW("    default:\n")
SLANG_RAW("        return WaveMaskIsFirstLane(WaveGetActiveMask());\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// It's useful to have a wave uint4 version of countbits, because some wave functions return uint4.\n")
SLANG_RAW("// This implementation tries to limit the amount of work required by the actual lane count.\n")
SLANG_RAW("uint _WaveCountBits(uint4 value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            OpCapability GroupNonUniformBallot;\n")
SLANG_RAW("            OpGroupNonUniformBallotBitCount $$uint result Subgroup Reduce $value\n")
SLANG_RAW("        };\n")
SLANG_RAW("    default:\n")
SLANG_RAW("        // Assume since WaveGetLaneCount should be known at compile time, the branches will hopefully boil away\n")
SLANG_RAW("        const uint waveLaneCount = WaveGetLaneCount();\n")
SLANG_RAW("        switch ((waveLaneCount - 1) / 32)\n")
SLANG_RAW("        {\n")
SLANG_RAW("            default:\n")
SLANG_RAW("            case 0: return countbits(value.x);\n")
SLANG_RAW("            case 1: return countbits(value.x) + countbits(value.y);\n")
SLANG_RAW("            case 2: return countbits(value.x) + countbits(value.y) + countbits(value.z);\n")
SLANG_RAW("            case 3: return countbits(value.x) + countbits(value.y) + countbits(value.z) + countbits(value.w);\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("// Prefix\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("T WavePrefixProduct(T expr)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupExclusiveMul($0)\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WavePrefixProduct\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isFloat<T>())\n")
SLANG_RAW("            return spirv_asm {\n")
SLANG_RAW("                OpCapability GroupNonUniformArithmetic;\n")
SLANG_RAW("                OpGroupNonUniformFMul $$T result Subgroup ExclusiveScan $expr\n")
SLANG_RAW("            };\n")
SLANG_RAW("        else if (__isSignedInt<T>())\n")
SLANG_RAW("        {\n")
SLANG_RAW("            return spirv_asm\n")
SLANG_RAW("            {\n")
SLANG_RAW("                OpCapability GroupNonUniformArithmetic;\n")
SLANG_RAW("                // TODO: use the correct integer width\n")
SLANG_RAW("                OpBitcast $$uint %uvalue $expr;\n")
SLANG_RAW("                OpGroupNonUniformIMul $$uint %mulResult Subgroup ExclusiveScan %uvalue;\n")
SLANG_RAW("                OpBitcast $$T result %mulResult\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("        else if (__isUnsignedInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformIMul $$T result Subgroup ExclusiveScan $expr};\n")
SLANG_RAW("    default:\n")
SLANG_RAW("        return WaveMaskPrefixProduct(WaveGetActiveMask(), expr);\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("vector<T,N> WavePrefixProduct(vector<T,N> expr)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupExclusiveMul($0)\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WavePrefixProduct\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isFloat<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformFMul $$vector<T,N> result Subgroup ExclusiveScan $expr};\n")
SLANG_RAW("        else if (__isSignedInt<T>())\n")
SLANG_RAW("        {\n")
SLANG_RAW("            return spirv_asm\n")
SLANG_RAW("            {\n")
SLANG_RAW("                OpCapability GroupNonUniformArithmetic;\n")
SLANG_RAW("                // TODO: use the correct integer width\n")
SLANG_RAW("                OpBitcast $$vector<uint,N> %uvalue $expr;\n")
SLANG_RAW("                OpGroupNonUniformIMul $$vector<uint,N> %mulResult Subgroup ExclusiveScan %uvalue;\n")
SLANG_RAW("                OpBitcast $$vector<T,N> result %mulResult\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("        else if (__isUnsignedInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformIMul $$vector<T,N> result Subgroup ExclusiveScan $expr};\n")
SLANG_RAW("    default:\n")
SLANG_RAW("        return WaveMaskPrefixProduct(WaveGetActiveMask(), expr);\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("matrix<T, N, M> WavePrefixProduct(matrix<T, N, M> expr)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return WaveMaskPrefixProduct(WaveGetActiveMask(), expr);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("T WavePrefixSum(T expr)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupExclusiveAdd($0)\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WavePrefixSum\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isFloat<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformFAdd $$T result Subgroup ExclusiveScan $expr};\n")
SLANG_RAW("        else if (__isSignedInt<T>())\n")
SLANG_RAW("        {\n")
SLANG_RAW("            return spirv_asm\n")
SLANG_RAW("            {\n")
SLANG_RAW("                OpCapability GroupNonUniformArithmetic;\n")
SLANG_RAW("                // TODO: use the correct integer width\n")
SLANG_RAW("                %uvalue:$$uint = OpBitcast $expr;\n")
SLANG_RAW("                %mulResult:$$uint = OpGroupNonUniformIAdd Subgroup ExclusiveScan %uvalue;\n")
SLANG_RAW("                result:$$T = OpBitcast %mulResult\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("        else if (__isUnsignedInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformIAdd $$T result Subgroup ExclusiveScan $expr};\n")
SLANG_RAW("    default:\n")
SLANG_RAW("        return WaveMaskPrefixSum(WaveGetActiveMask(), expr);\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("vector<T,N> WavePrefixSum(vector<T,N> expr)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupExclusiveAdd($0)\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WavePrefixSum\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        if (__isFloat<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformFAdd $$vector<T,N> result Subgroup ExclusiveScan $expr};\n")
SLANG_RAW("        else if (__isSignedInt<T>())\n")
SLANG_RAW("        {\n")
SLANG_RAW("            return spirv_asm\n")
SLANG_RAW("            {\n")
SLANG_RAW("                OpCapability GroupNonUniformArithmetic;\n")
SLANG_RAW("                // TODO: use the correct integer width\n")
SLANG_RAW("                %uvalue:$$vector<uint,N> = OpBitcast $expr;\n")
SLANG_RAW("                %mulResult:$$vector<uint,N> = OpGroupNonUniformIAdd Subgroup ExclusiveScan %uvalue;\n")
SLANG_RAW("                result:$$vector<T,N> = OpBitcast %mulResult\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("        else if (__isUnsignedInt<T>())\n")
SLANG_RAW("            return spirv_asm {OpCapability GroupNonUniformArithmetic; OpGroupNonUniformIAdd $$vector<T,N> result Subgroup ExclusiveScan $expr};\n")
SLANG_RAW("    default:\n")
SLANG_RAW("        return WaveMaskPrefixSum(WaveGetActiveMask(), expr);\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("matrix<T,N,M> WavePrefixSum(matrix<T,N,M> expr)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return WaveMaskPrefixSum(WaveGetActiveMask(), expr);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_ballot)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("T WaveReadLaneFirst(T expr)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupBroadcastFirst($0)\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WaveReadLaneFirst\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {OpCapability GroupNonUniformBallot; OpGroupNonUniformBroadcastFirst $$T result Subgroup $expr};\n")
SLANG_RAW("    default:\n")
SLANG_RAW("        return WaveMaskReadLaneFirst(WaveGetActiveMask(), expr);\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_ballot)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("vector<T,N> WaveReadLaneFirst(vector<T,N> expr)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupBroadcastFirst($0)\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WaveReadLaneFirst\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {OpCapability GroupNonUniformBallot; OpGroupNonUniformBroadcastFirst $$vector<T,N> result Subgroup $expr};\n")
SLANG_RAW("    default:\n")
SLANG_RAW("        return WaveMaskReadLaneFirst(WaveGetActiveMask(), expr);\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("matrix<T,N,M> WaveReadLaneFirst(matrix<T,N,M> expr)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return WaveMaskReadLaneFirst(WaveGetActiveMask(), expr);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// NOTE! WaveBroadcastLaneAt is *NOT* standard HLSL\n")
SLANG_RAW("// It is provided as access to subgroupBroadcast which can only take a\n")
SLANG_RAW("// constexpr laneId.\n")
SLANG_RAW("// https://github.com/KhronosGroup/GLSL/blob/master/extensions/khr/GL_KHR_shader_subgroup.txt\n")
SLANG_RAW("// Versions SPIR-V greater than 1.4 loosen this restriction, and allow 'dynamic uniform' index\n")
SLANG_RAW("// If that's the behavior required then client code should use WaveReadLaneAt which works this way.\n")
SLANG_RAW("__generic<T : __BuiltinType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_ballot)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("T WaveBroadcastLaneAt(T value, constexpr int lane)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupBroadcast($0, $1)\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WaveReadLaneAt\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        let ulane = uint(lane);\n")
SLANG_RAW("        return spirv_asm {OpCapability GroupNonUniformBallot; OpGroupNonUniformBroadcast $$T result Subgroup $value $ulane};\n")
SLANG_RAW("    default:\n")
SLANG_RAW("        return WaveMaskBroadcastLaneAt(WaveGetActiveMask(), value, lane);\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_ballot)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("vector<T,N> WaveBroadcastLaneAt(vector<T,N> value, constexpr int lane)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupBroadcast($0, $1)\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WaveReadLaneAt\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        let ulane = uint(lane);\n")
SLANG_RAW("        return spirv_asm {OpCapability GroupNonUniformBallot; OpGroupNonUniformBroadcast $$vector<T,N> result Subgroup $value $ulane};\n")
SLANG_RAW("    default:\n")
SLANG_RAW("        return WaveMaskBroadcastLaneAt(WaveGetActiveMask(), value, lane);\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(cuda, \"_waveShuffleMultiple(_getActiveMask(), $0, $1)\")\n")
SLANG_RAW("__target_intrinsic(hlsl, \"WaveReadLaneAt\")\n")
SLANG_RAW("matrix<T, N, M> WaveBroadcastLaneAt(matrix<T, N, M> value, constexpr int lane)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return WaveMaskBroadcastLaneAt(WaveGetActiveMask(), value, lane);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// TODO(JS): If it can be determines that the `laneId` is constExpr, then subgroupBroadcast\n")
SLANG_RAW("// could be used on GLSL. For now we just use subgroupShuffle\n")
SLANG_RAW("__generic<T : __BuiltinType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_shuffle)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("T WaveReadLaneAt(T value, int lane)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupShuffle($0, $1)\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WaveReadLaneAt\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        let ulane = uint(lane);\n")
SLANG_RAW("        return spirv_asm {OpCapability GroupNonUniformShuffle; OpGroupNonUniformShuffle $$T result Subgroup $value $ulane};\n")
SLANG_RAW("    default:\n")
SLANG_RAW("        return WaveMaskReadLaneAt(WaveGetActiveMask(), value, lane);\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int>\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_shuffle)\n")
SLANG_RAW("vector<T,N> WaveReadLaneAt(vector<T,N> value, int lane)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupShuffle($0, $1)\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WaveReadLaneAt\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        let ulane = uint(lane);\n")
SLANG_RAW("        return spirv_asm {OpCapability GroupNonUniformShuffle; OpGroupNonUniformShuffle $$vector<T,N> result Subgroup $value $ulane};\n")
SLANG_RAW("    default:\n")
SLANG_RAW("        return WaveMaskReadLaneAt(WaveGetActiveMask(), value, lane);\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(cuda, \"_waveShuffleMultiple(_getActiveMask(), $0, $1)\")\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("matrix<T, N, M> WaveReadLaneAt(matrix<T, N, M> value, int lane)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return WaveMaskReadLaneAt(WaveGetActiveMask(), value, lane);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// NOTE! WaveShuffle is a NON STANDARD HLSL intrinsic! It will map to WaveReadLaneAt on HLSL\n")
SLANG_RAW("// which means it will only work on hardware which allows arbitrary laneIds which is not true\n")
SLANG_RAW("// in general because it breaks the HLSL standard, which requires it's 'dynamically uniform' across the Wave.\n")
SLANG_RAW("__generic<T : __BuiltinType>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_shuffle)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("T WaveShuffle(T value, int lane)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupShuffle($0, $1)\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WaveReadLaneAt\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        let ulane = uint(lane);\n")
SLANG_RAW("        return spirv_asm {OpCapability GroupNonUniformShuffle; OpGroupNonUniformShuffle $$T result Subgroup $value $ulane};\n")
SLANG_RAW("    default:\n")
SLANG_RAW("        return WaveMaskShuffle(WaveGetActiveMask(), value, lane);\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int>\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_shuffle)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("vector<T,N> WaveShuffle(vector<T,N> value, int lane)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupShuffle($0, $1)\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WaveReadLaneAt\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        let ulane = uint(lane);\n")
SLANG_RAW("        return spirv_asm {OpCapability GroupNonUniformShuffle; OpGroupNonUniformShuffle $$vector<T,N> result Subgroup $value $ulane};\n")
SLANG_RAW("    default:\n")
SLANG_RAW("        return WaveMaskShuffle(WaveGetActiveMask(), value, lane);\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl, \"WaveReadLaneAt\")\n")
SLANG_RAW("matrix<T, N, M> WaveShuffle(matrix<T, N, M> value, int lane)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return WaveMaskShuffle(WaveGetActiveMask(), value, lane);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_ballot)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("uint WavePrefixCountBits(bool value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupBallotExclusiveBitCount(subgroupBallot($0))\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WavePrefixCountBits($0)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            OpCapability GroupNonUniformBallot;\n")
SLANG_RAW("            %mask:$$uint4 = OpGroupNonUniformBallot Subgroup $value;\n")
SLANG_RAW("            OpGroupNonUniformBallotBitCount $$uint result Subgroup 2 %mask\n")
SLANG_RAW("        };\n")
SLANG_RAW("    default:\n")
SLANG_RAW("        return WaveMaskPrefixCountBits(WaveGetActiveMask(), value);\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_ballot)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("uint4 WaveGetConvergedMulti()\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"subgroupBallot(true)\";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"WaveActiveBallot(true)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"make_uint4(__activemask(), 0, 0, 0)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        let _true = true;\n")
SLANG_RAW("        return spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            OpCapability GroupNonUniformBallot;\n")
SLANG_RAW("            OpGroupNonUniformBallot $$uint4 result Subgroup $_true\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("uint4 WaveGetActiveMulti()\n")
SLANG_RAW("{\n")
SLANG_RAW("    return WaveGetConvergedMulti();\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Shader model 6.5 stuff\n")
SLANG_RAW("// https://github.com/microsoft/DirectX-Specs/blob/master/d3d/HLSL_ShaderModel6_5.md\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("uint4 WaveMatch(T value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return WaveMaskMatch(WaveGetActiveMask(), value);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("uint4 WaveMatch(vector<T,N> value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return WaveMaskMatch(WaveGetActiveMask(), value);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("uint4 WaveMatch(matrix<T,N,M> value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return WaveMaskMatch(WaveGetActiveMask(), value);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(cuda, \"_popc(__ballot_sync(($1).x, $0) & _getLaneLtMask())\")\n")
SLANG_RAW("uint WaveMultiPrefixCountBits(bool value, uint4 mask);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("__target_intrinsic(glsl, \"subgroupExclusiveAnd($0)\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"_wavePrefixAnd(_getMultiPrefixMask(($1).x), $0)\")\n")
SLANG_RAW("T WaveMultiPrefixBitAnd(T expr, uint4 mask);\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("__target_intrinsic(glsl, \"subgroupExclusiveAnd($0)\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"_wavePrefixAndMultiple(_getMultiPrefixMask(($1).x), $0)\")\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int>\n")
SLANG_RAW("vector<T,N> WaveMultiPrefixBitAnd(vector<T,N> expr, uint4 mask);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(cuda, \"_wavePrefixAndMultiple(_getMultiPrefixMask(($1).x), $0)\")\n")
SLANG_RAW("matrix<T,N,M> WaveMultiPrefixBitAnd(matrix<T,N,M> expr, uint4 mask);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("//__target_intrinsic(glsl, \"subgroupExclusiveOr($0)\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"_wavePrefixOr(, _getMultiPrefixMask(($1).x), $0)\")\n")
SLANG_RAW("T WaveMultiPrefixBitOr(T expr, uint4 mask);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("//__target_intrinsic(glsl, \"subgroupExclusiveOr($0)\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"_wavePrefixOrMultiple(_getMultiPrefixMask(($1).x), $0)\")\n")
SLANG_RAW("vector<T,N> WaveMultiPrefixBitOr(vector<T,N> expr, uint4 mask);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(cuda, \"_wavePrefixOrMultiple(_getMultiPrefixMask(($1).x), $0)\")\n")
SLANG_RAW("matrix<T,N,M> WaveMultiPrefixBitOr(matrix<T,N,M> expr, uint4 mask);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("__target_intrinsic(glsl, \"subgroupExclusiveXor($0)\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"_wavePrefixXor(_getMultiPrefixMask(($1).x), $0)\")\n")
SLANG_RAW("T WaveMultiPrefixBitXor(T expr, uint4 mask);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__glsl_extension(GL_KHR_shader_subgroup_arithmetic)\n")
SLANG_RAW("__spirv_version(1.3)\n")
SLANG_RAW("__target_intrinsic(glsl, \"subgroupExclusiveXor($0)\")\n")
SLANG_RAW("__target_intrinsic(cuda, \"_wavePrefixXorMultiple(_getMultiPrefixMask(($1).x), $0)\")\n")
SLANG_RAW("vector<T,N> WaveMultiPrefixBitXor(vector<T,N> expr, uint4 mask);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(cuda, \"_wavePrefixXorMultiple(_getMultiPrefixMask(($1).x), $0)\")\n")
SLANG_RAW("matrix<T,N,M> WaveMultiPrefixBitXor(matrix<T,N,M> expr, uint4 mask);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(cuda, \"_wavePrefixProduct(_getMultiPrefixMask(($1).x), $0)\")\n")
SLANG_RAW("T WaveMultiPrefixProduct(T value, uint4 mask);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(cuda, \"_wavePrefixProductMultiple(_getMultiPrefixMask(($1).x), $0)\")\n")
SLANG_RAW("vector<T,N> WaveMultiPrefixProduct(vector<T,N> value, uint4 mask);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(cuda, \"_wavePrefixProductMultiple(_getMultiPrefixMask(($1).x), $0)\")\n")
SLANG_RAW("matrix<T,N,M> WaveMultiPrefixProduct(matrix<T,N,M> value, uint4 mask);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(cuda, \"_wavePrefixSum(_getMultiPrefixMask(($1).x), $0)\")\n")
SLANG_RAW("T WaveMultiPrefixSum(T value, uint4 mask);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(cuda, \"_wavePrefixSumMultiple(_getMultiPrefixMask(($1).x), $0 )\")\n")
SLANG_RAW("vector<T,N> WaveMultiPrefixSum(vector<T,N> value, uint4 mask);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int, let M : int>\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("__target_intrinsic(cuda, \"_wavePrefixSumMultiple(_getMultiPrefixMask(($1).x), $0)\")\n")
SLANG_RAW("matrix<T,N,M> WaveMultiPrefixSum(matrix<T,N,M> value, uint4 mask);\n")
SLANG_RAW("\n")
SLANG_RAW("// `typedef`s to help with the fact that HLSL has been sorta-kinda case insensitive at various points\n")
SLANG_RAW("typedef Texture2D texture2D;\n")
SLANG_RAW("\n")


// Buffer types

static const struct {
    char const*         name;
    SlangResourceAccess access;
} kBaseBufferAccessLevels[] = {
    { "",                   SLANG_RESOURCE_ACCESS_READ },
    { "RW",                 SLANG_RESOURCE_ACCESS_READ_WRITE },
    { "RasterizerOrdered",  SLANG_RESOURCE_ACCESS_RASTER_ORDERED },
};
static const int kBaseBufferAccessLevelCount = sizeof(kBaseBufferAccessLevels) / sizeof(kBaseBufferAccessLevels[0]);

for (int aa = 0; aa < kBaseBufferAccessLevelCount; ++aa)
{
    auto access = kBaseBufferAccessLevels[aa].access;
    sb << "__generic<T,let format:int=0>\n";
    sb << "typealias ";
    sb << kBaseBufferAccessLevels[aa].name;
    sb << "Buffer = __TextureImpl<T, __ShapeBuffer, 0, 0, 0, " << aa << ", 0, 0, format>;\n";
    
    bool isReadOnly = aa == 0;

    char const* glslTextureSizeFunc = (isReadOnly) ? "textureSize" : "imageSize";
    char const* glslLoadFuncName = (isReadOnly) ? "texelFetch" : "imageLoad";
    char const* spvLoadInstName = (isReadOnly) ? "OpImageFetch" : "OpImageRead";
SLANG_RAW("#line 8898 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T, let format:int>\n")
SLANG_RAW("extension __TextureImpl<T, __ShapeBuffer, 0, 0, 0, ")
SLANG_SPLICE(aa
)
SLANG_RAW(", 0, 0, format>\n")
SLANG_RAW("{\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    void GetDimensions(out uint dim)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".GetDimensions\";\n")
SLANG_RAW("        case glsl: __intrinsic_asm \"($1 = ")
SLANG_SPLICE(glslTextureSizeFunc
)
SLANG_RAW("($0))\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            dim = spirv_asm {\n")
SLANG_RAW("                OpCapability ImageQuery;\n")
SLANG_RAW("                result:$$uint = OpImageQuerySize $this;\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    __glsl_extension(GL_EXT_samplerless_texture_functions)\n")
SLANG_RAW("    ")
SLANG_SPLICE(isReadOnly?"[__readNone] ":""
)
SLANG_RAW("\n")
SLANG_RAW("    T Load(int location)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".Load\";\n")
SLANG_RAW("        case glsl: __intrinsic_asm \"")
SLANG_SPLICE(glslLoadFuncName
)
SLANG_RAW("($0, $1)$z\";\n")
SLANG_RAW("        case spirv: return spirv_asm {\n")
SLANG_RAW("                %sampled:__sampledType(T) = ")
SLANG_SPLICE(spvLoadInstName
)
SLANG_RAW(" $this $location;\n")
SLANG_RAW("                __truncate $$T result __sampledType(T) %sampled;\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    ")
SLANG_SPLICE(isReadOnly?"[__readNone] ":""
)
SLANG_RAW("\n")
SLANG_RAW("    T Load(int location, out uint status);\n")
SLANG_RAW("\n")
SLANG_RAW("    __subscript(uint index) -> T {\n")
SLANG_RAW("\n")
SLANG_RAW("        ")
SLANG_SPLICE(isReadOnly?"[__readNone] ":""
)
SLANG_RAW("\n")
SLANG_RAW("        [ForceInline]\n")
SLANG_RAW("        get { return Load((int)index); }\n")

        if (access != SLANG_RESOURCE_ACCESS_READ) {
SLANG_RAW("#line 8943 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("            [nonmutating] set\n")
SLANG_RAW("            {\n")
SLANG_RAW("                __target_switch\n")
SLANG_RAW("                {\n")
SLANG_RAW("                case hlsl: __intrinsic_asm \"($0)[$1] = $2\";\n")
SLANG_RAW("                case glsl: __intrinsic_asm \"imageStore($0, int($1), $V2)\";\n")
SLANG_RAW("                case spirv: spirv_asm {\n")
SLANG_RAW("                        OpImageWrite $this $index $newValue;\n")
SLANG_RAW("                    };\n")
SLANG_RAW("                }\n")
SLANG_RAW("            }\n")
SLANG_RAW("\n")
SLANG_RAW("            __intrinsic_op(")
SLANG_SPLICE(kIROp_ImageSubscript
)
SLANG_RAW(")\n")
SLANG_RAW("            ref;\n")

        } // access != SLANG_RESOURCE_ACCESS_READ
SLANG_RAW("#line 8960 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("        }\n")
SLANG_RAW("    \n")
SLANG_RAW("\n")
SLANG_RAW("    };  // end extension\n")

}
SLANG_RAW("#line 8968 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("// DirectX Raytracing (DXR) Support\n")
SLANG_RAW("//\n")
SLANG_RAW("// The following is based on the experimental DXR SDK v0.09.01.\n")
SLANG_RAW("//\n")
SLANG_RAW("// Numbering follows the sections in the \"D3D12 Raytracing Functional Spec\" v0.09 (2018-03-12)\n")
SLANG_RAW("//\n")
SLANG_RAW("\n")
SLANG_RAW("// 10.1.1 - Ray Flags\n")
SLANG_RAW("\n")
SLANG_RAW("typedef uint RAY_FLAG;\n")
SLANG_RAW("\n")
SLANG_RAW("static const RAY_FLAG RAY_FLAG_NONE                             = 0x00;\n")
SLANG_RAW("static const RAY_FLAG RAY_FLAG_FORCE_OPAQUE                     = 0x01;\n")
SLANG_RAW("static const RAY_FLAG RAY_FLAG_FORCE_NON_OPAQUE                 = 0x02;\n")
SLANG_RAW("static const RAY_FLAG RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH  = 0x04;\n")
SLANG_RAW("static const RAY_FLAG RAY_FLAG_SKIP_CLOSEST_HIT_SHADER          = 0x08;\n")
SLANG_RAW("static const RAY_FLAG RAY_FLAG_CULL_BACK_FACING_TRIANGLES       = 0x10;\n")
SLANG_RAW("static const RAY_FLAG RAY_FLAG_CULL_FRONT_FACING_TRIANGLES      = 0x20;\n")
SLANG_RAW("static const RAY_FLAG RAY_FLAG_CULL_OPAQUE                      = 0x40;\n")
SLANG_RAW("static const RAY_FLAG RAY_FLAG_CULL_NON_OPAQUE                  = 0x80;\n")
SLANG_RAW("static const RAY_FLAG RAY_FLAG_SKIP_TRIANGLES                   = 0x100;\n")
SLANG_RAW("static const RAY_FLAG RAY_FLAG_SKIP_PROCEDURAL_PRIMITIVES       = 0x200;\n")
SLANG_RAW("\n")
SLANG_RAW("// 10.1.2 - Ray Description Structure\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(hlsl, RayDesc)\n")
SLANG_RAW("__target_intrinsic(cuda, RayDesc)\n")
SLANG_RAW("struct RayDesc\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_intrinsic(hlsl, Origin)\n")
SLANG_RAW("    __target_intrinsic(cuda, Origin)\n")
SLANG_RAW("    float3 Origin;\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(hlsl, TMin)\n")
SLANG_RAW("    __target_intrinsic(cuda, TMin)\n")
SLANG_RAW("    float  TMin;\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(hlsl, Direction)\n")
SLANG_RAW("    __target_intrinsic(cuda, Direction)\n")
SLANG_RAW("    float3 Direction;\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(hlsl, TMax)\n")
SLANG_RAW("    __target_intrinsic(cuda, TMax)\n")
SLANG_RAW("    float  TMax;\n")
SLANG_RAW("};\n")
SLANG_RAW("\n")
SLANG_RAW("// 10.1.3 - Ray Acceleration Structure\n")
SLANG_RAW("\n")
SLANG_RAW("__builtin\n")
SLANG_RAW("__magic_type(RaytracingAccelerationStructureType)\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_RaytracingAccelerationStructureType
)
SLANG_RAW(")\n")
SLANG_RAW("struct RaytracingAccelerationStructure {};\n")
SLANG_RAW("\n")
SLANG_RAW("// 10.1.4 - Subobject Definitions\n")
SLANG_RAW("\n")
SLANG_RAW("// TODO: We may decide to support these, but their reliance on C++ implicit\n")
SLANG_RAW("// constructor call syntax (`SomeType someVar(arg0, arg1);`) makes them\n")
SLANG_RAW("// annoying for the current Slang parsing strategy, and using global variables\n")
SLANG_RAW("// for this stuff comes across as a kludge rather than the best possible design.\n")
SLANG_RAW("\n")
SLANG_RAW("// 10.1.5 - Intersection Attributes Structure\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(hlsl, BuiltInTriangleIntersectionAttributes)\n")
SLANG_RAW("struct BuiltInTriangleIntersectionAttributes\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_intrinsic(hlsl, barycentrics)\n")
SLANG_RAW("    float2 barycentrics;\n")
SLANG_RAW("};\n")
SLANG_RAW("\n")
SLANG_RAW("// 10.2 Shaders\n")
SLANG_RAW("\n")
SLANG_RAW("// Right now new shader stages need to be added directly to the compiler\n")
SLANG_RAW("// implementation, rather than being something that can be declared in the stdlib.\n")
SLANG_RAW("\n")
SLANG_RAW("// 10.3 - Intrinsics\n")
SLANG_RAW("\n")
SLANG_RAW("// 10.3.1\n")
SLANG_RAW("\n")
SLANG_RAW("// `executeCallableNV` is the GLSL intrinsic that will be used to implement\n")
SLANG_RAW("// `CallShader()` for GLSL-based targets.\n")
SLANG_RAW("//\n")
SLANG_RAW("__target_intrinsic(GL_NV_ray_tracing, \"executeCallableNV\")\n")
SLANG_RAW("__target_intrinsic(GL_EXT_ray_tracing, \"executeCallableEXT\")\n")
SLANG_RAW("void __executeCallable(uint shaderIndex, int payloadLocation);\n")
SLANG_RAW("\n")
SLANG_RAW("// Next is the custom intrinsic that will compute the payload location\n")
SLANG_RAW("// for a type being used in a `CallShader()` call for GLSL-based targets.\n")
SLANG_RAW("//\n")
SLANG_RAW("__generic<Payload>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_GetVulkanRayTracingPayloadLocation
)
SLANG_RAW(")\n")
SLANG_RAW("int __callablePayloadLocation(__ref Payload payload);\n")
SLANG_RAW("\n")
SLANG_RAW("// Now we provide a hard-coded definition of `CallShader()` for GLSL-based\n")
SLANG_RAW("// targets, which maps the generic HLSL operation into the non-generic\n")
SLANG_RAW("// GLSL equivalent.\n")
SLANG_RAW("//\n")
SLANG_RAW("__generic<Payload>\n")
SLANG_RAW("void CallShader(uint shaderIndex, inout Payload payload)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"CallShader\";\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        {\n")
SLANG_RAW("            [__vulkanCallablePayload]\n")
SLANG_RAW("            static Payload p;\n")
SLANG_RAW("\n")
SLANG_RAW("            p = payload;\n")
SLANG_RAW("            __executeCallable(shaderIndex, __callablePayloadLocation(p));\n")
SLANG_RAW("            payload = p;\n")
SLANG_RAW("        }\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        {\n")
SLANG_RAW("            [__vulkanCallablePayload]\n")
SLANG_RAW("            static Payload p;\n")
SLANG_RAW("\n")
SLANG_RAW("            p = payload;\n")
SLANG_RAW("            spirv_asm {\n")
SLANG_RAW("                OpExecuteCallableKHR $shaderIndex &p\n")
SLANG_RAW("            };\n")
SLANG_RAW("            payload = p;\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// 10.3.2\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(GL_NV_ray_tracing, \"traceNV\")\n")
SLANG_RAW("__target_intrinsic(GL_EXT_ray_tracing, \"traceRayEXT\")\n")
SLANG_RAW("void __traceRay(\n")
SLANG_RAW("    RaytracingAccelerationStructure AccelerationStructure,\n")
SLANG_RAW("    uint                            RayFlags,\n")
SLANG_RAW("    uint                            InstanceInclusionMask,\n")
SLANG_RAW("    uint                            RayContributionToHitGroupIndex,\n")
SLANG_RAW("    uint                            MultiplierForGeometryContributionToHitGroupIndex,\n")
SLANG_RAW("    uint                            MissShaderIndex,\n")
SLANG_RAW("    float3                          Origin,\n")
SLANG_RAW("    float                           TMin,\n")
SLANG_RAW("    float3                          Direction,\n")
SLANG_RAW("    float                           TMax,\n")
SLANG_RAW("    int                             PayloadLocation);\n")
SLANG_RAW("\n")
SLANG_RAW("// TODO: Slang's parsing logic currently puts modifiers on\n")
SLANG_RAW("// the `GenericDecl` rather than the inner decl when\n")
SLANG_RAW("// using our default syntax, which seems wrong. We need\n")
SLANG_RAW("// to fix this, but for now using the expanded `__generic`\n")
SLANG_RAW("// syntax works in a pinch.\n")
SLANG_RAW("//\n")
SLANG_RAW("__generic<Payload>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_GetVulkanRayTracingPayloadLocation
)
SLANG_RAW(")\n")
SLANG_RAW("int __rayPayloadLocation(__ref Payload payload);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<payload_t>\n")
SLANG_RAW("void TraceRay(\n")
SLANG_RAW("    RaytracingAccelerationStructure AccelerationStructure,\n")
SLANG_RAW("    uint                            RayFlags,\n")
SLANG_RAW("    uint                            InstanceInclusionMask,\n")
SLANG_RAW("    uint                            RayContributionToHitGroupIndex,\n")
SLANG_RAW("    uint                            MultiplierForGeometryContributionToHitGroupIndex,\n")
SLANG_RAW("    uint                            MissShaderIndex,\n")
SLANG_RAW("    RayDesc                         Ray,\n")
SLANG_RAW("    inout payload_t                 Payload)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"TraceRay\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"traceOptiXRay\";\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("    {\n")
SLANG_RAW("        [__vulkanRayPayload]\n")
SLANG_RAW("        static payload_t p;\n")
SLANG_RAW("\n")
SLANG_RAW("        p = Payload;\n")
SLANG_RAW("        __traceRay(\n")
SLANG_RAW("            AccelerationStructure,\n")
SLANG_RAW("            RayFlags,\n")
SLANG_RAW("            InstanceInclusionMask,\n")
SLANG_RAW("            RayContributionToHitGroupIndex,\n")
SLANG_RAW("            MultiplierForGeometryContributionToHitGroupIndex,\n")
SLANG_RAW("            MissShaderIndex,\n")
SLANG_RAW("            Ray.Origin,\n")
SLANG_RAW("            Ray.TMin,\n")
SLANG_RAW("            Ray.Direction,\n")
SLANG_RAW("            Ray.TMax,\n")
SLANG_RAW("            __rayPayloadLocation(p));\n")
SLANG_RAW("        Payload = p;\n")
SLANG_RAW("    }\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("    {\n")
SLANG_RAW("        [__vulkanRayPayload]\n")
SLANG_RAW("        static payload_t p;\n")
SLANG_RAW("\n")
SLANG_RAW("        p = Payload;\n")
SLANG_RAW("        let origin = Ray.Origin;\n")
SLANG_RAW("        let direction = Ray.Direction;\n")
SLANG_RAW("        let tmin = Ray.TMin;\n")
SLANG_RAW("        let tmax = Ray.TMax;\n")
SLANG_RAW("        spirv_asm {\n")
SLANG_RAW("            OpTraceRayKHR \n")
SLANG_RAW("                /**/ $AccelerationStructure\n")
SLANG_RAW("                /**/ $RayFlags\n")
SLANG_RAW("                /**/ $InstanceInclusionMask\n")
SLANG_RAW("                /**/ $RayContributionToHitGroupIndex\n")
SLANG_RAW("                /**/ $MultiplierForGeometryContributionToHitGroupIndex\n")
SLANG_RAW("                /**/ $MissShaderIndex\n")
SLANG_RAW("                /**/ $origin\n")
SLANG_RAW("                /**/ $tmin\n")
SLANG_RAW("                /**/ $direction\n")
SLANG_RAW("                /**/ $tmax\n")
SLANG_RAW("                /**/ &p;\n")
SLANG_RAW("        };\n")
SLANG_RAW("        Payload = p;\n")
SLANG_RAW("    }\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// NOTE!\n")
SLANG_RAW("// The name of the following functions may change when DXR supports\n")
SLANG_RAW("// a feature similar to the `GL_NV_ray_tracing_motion_blur` extension\n")
SLANG_RAW("//\n")
SLANG_RAW("// https://github.com/KhronosGroup/GLSL/blob/master/extensions/nv/GLSL_NV_ray_tracing_motion_blur.txt\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(glsl, \"traceRayMotionNV\")\n")
SLANG_RAW("__glsl_version(460)\n")
SLANG_RAW("__glsl_extension(GL_NV_ray_tracing_motion_blur)\n")
SLANG_RAW("__glsl_extension(GL_EXT_ray_tracing)\n")
SLANG_RAW("void __traceMotionRay(\n")
SLANG_RAW("    RaytracingAccelerationStructure AccelerationStructure,\n")
SLANG_RAW("    uint                            RayFlags,\n")
SLANG_RAW("    uint                            InstanceInclusionMask,\n")
SLANG_RAW("    uint                            RayContributionToHitGroupIndex,\n")
SLANG_RAW("    uint                            MultiplierForGeometryContributionToHitGroupIndex,\n")
SLANG_RAW("    uint                            MissShaderIndex,\n")
SLANG_RAW("    float3                          Origin,\n")
SLANG_RAW("    float                           TMin,\n")
SLANG_RAW("    float3                          Direction,\n")
SLANG_RAW("    float                           TMax,\n")
SLANG_RAW("    float                           CurrentTime,\n")
SLANG_RAW("    int                             PayloadLocation);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<payload_t>\n")
SLANG_RAW("void TraceMotionRay(\n")
SLANG_RAW("    RaytracingAccelerationStructure AccelerationStructure,\n")
SLANG_RAW("    uint                            RayFlags,\n")
SLANG_RAW("    uint                            InstanceInclusionMask,\n")
SLANG_RAW("    uint                            RayContributionToHitGroupIndex,\n")
SLANG_RAW("    uint                            MultiplierForGeometryContributionToHitGroupIndex,\n")
SLANG_RAW("    uint                            MissShaderIndex,\n")
SLANG_RAW("    RayDesc                         Ray,\n")
SLANG_RAW("    float                           CurrentTime,\n")
SLANG_RAW("    inout payload_t                 Payload)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"TraceMotionRay\";\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("    {\n")
SLANG_RAW("        [__vulkanRayPayload]\n")
SLANG_RAW("        static payload_t p;\n")
SLANG_RAW("\n")
SLANG_RAW("        p = Payload;\n")
SLANG_RAW("        __traceMotionRay(\n")
SLANG_RAW("            AccelerationStructure,\n")
SLANG_RAW("            RayFlags,\n")
SLANG_RAW("            InstanceInclusionMask,\n")
SLANG_RAW("            RayContributionToHitGroupIndex,\n")
SLANG_RAW("            MultiplierForGeometryContributionToHitGroupIndex,\n")
SLANG_RAW("            MissShaderIndex,\n")
SLANG_RAW("            Ray.Origin,\n")
SLANG_RAW("            Ray.TMin,\n")
SLANG_RAW("            Ray.Direction,\n")
SLANG_RAW("            Ray.TMax,\n")
SLANG_RAW("            CurrentTime,\n")
SLANG_RAW("            __rayPayloadLocation(p));\n")
SLANG_RAW("        Payload = p;\n")
SLANG_RAW("    }\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("    {\n")
SLANG_RAW("        [__vulkanRayPayload]\n")
SLANG_RAW("        static payload_t p;\n")
SLANG_RAW("        \n")
SLANG_RAW("        let origin = Ray.Origin;\n")
SLANG_RAW("        let direction = Ray.Direction;\n")
SLANG_RAW("        let tmin = Ray.TMin;\n")
SLANG_RAW("        let tmax = Ray.TMax;\n")
SLANG_RAW("\n")
SLANG_RAW("        p = Payload;\n")
SLANG_RAW("        spirv_asm {\n")
SLANG_RAW("            OpCapability RayTracingMotionBlurNV;\n")
SLANG_RAW("            OpExtension \"SPV_NV_ray_tracing_motion_blur\";\n")
SLANG_RAW("\n")
SLANG_RAW("            OpTraceRayMotionNV\n")
SLANG_RAW("                /**/ $AccelerationStructure\n")
SLANG_RAW("                /**/ $RayFlags\n")
SLANG_RAW("                /**/ $InstanceInclusionMask\n")
SLANG_RAW("                /**/ $RayContributionToHitGroupIndex\n")
SLANG_RAW("                /**/ $MultiplierForGeometryContributionToHitGroupIndex\n")
SLANG_RAW("                /**/ $MissShaderIndex\n")
SLANG_RAW("                /**/ $origin\n")
SLANG_RAW("                /**/ $tmin\n")
SLANG_RAW("                /**/ $direction\n")
SLANG_RAW("                /**/ $tmax\n")
SLANG_RAW("                /**/ $CurrentTime\n")
SLANG_RAW("                /**/ &p;\n")
SLANG_RAW("        };\n")
SLANG_RAW("        Payload = p;\n")
SLANG_RAW("    }\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// 10.3.3\n")
SLANG_RAW("__target_intrinsic(hlsl)\n")
SLANG_RAW("bool ReportHit<A>(float tHit, uint hitKind, A attributes);\n")
SLANG_RAW("\n")
SLANG_RAW("bool __reportIntersection(float tHit, uint hitKind)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case GL_EXT_ray_tracing: __intrinsic_asm \"reportIntersectionEXT\";\n")
SLANG_RAW("    case GL_NV_ray_tracing: __intrinsic_asm \"reportIntersectionNV\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            result:$$bool = OpReportIntersectionKHR $tHit $hitKind;\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<A>\n")
SLANG_RAW("__specialized_for_target(glsl)\n")
SLANG_RAW("__specialized_for_target(spirv)\n")
SLANG_RAW("bool ReportHit(float tHit, uint hitKind, A attributes)\n")
SLANG_RAW("{\n")
SLANG_RAW("    [__vulkanHitAttributes]\n")
SLANG_RAW("    static A a;\n")
SLANG_RAW("\n")
SLANG_RAW("    a = attributes;\n")
SLANG_RAW("    return __reportIntersection(tHit, hitKind);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// 10.3.4\n")
SLANG_RAW("void IgnoreHit()\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"IgnoreHit\";\n")
SLANG_RAW("    case GL_EXT_ray_tracing: __intrinsic_asm \"ignoreIntersectionEXT;\";\n")
SLANG_RAW("    case GL_NV_ray_tracing: __intrinsic_asm \"ignoreIntersectionNV\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"optixIgnoreIntersection\";\n")
SLANG_RAW("    case spirv: spirv_asm { OpIgnoreIntersectionKHR; %_ = OpLabel };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// 10.3.5\n")
SLANG_RAW("void AcceptHitAndEndSearch()\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"AcceptHitAndEndSearch\";\n")
SLANG_RAW("    case GL_EXT_ray_tracing: __intrinsic_asm \"terminateRayEXT;\";\n")
SLANG_RAW("    case GL_NV_ray_tracing: __intrinsic_asm \"terminateRayNV\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"optixTerminateRay\";\n")
SLANG_RAW("    case spirv: spirv_asm { OpTerminateRayKHR; %_ = OpLabel };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// 10.4 - System Values and Special Semantics\n")
SLANG_RAW("\n")
SLANG_RAW("// TODO: Many of these functions need to be restricted so that\n")
SLANG_RAW("// they can only be accessed from specific stages.\n")
SLANG_RAW("\n")
SLANG_RAW("// 10.4.1 - Ray Dispatch System Values\n")
SLANG_RAW("\n")
SLANG_RAW("uint3 DispatchRaysIndex()\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl:  __intrinsic_asm \"DispatchRaysIndex\";\n")
SLANG_RAW("    case GL_EXT_ray_tracing: __intrinsic_asm \"(gl_LaunchIDEXT)\";\n")
SLANG_RAW("    case GL_NV_ray_tracing: __intrinsic_asm \"(gl_LaunchIDNV)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"optixGetLaunchIndex\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            result:$$uint3 = OpLoad builtin(LaunchIdKHR:uint3);\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("uint3 DispatchRaysDimensions()\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl:  __intrinsic_asm \"DispatchRaysDimensions\";\n")
SLANG_RAW("    case GL_EXT_ray_tracing: __intrinsic_asm \"(gl_LaunchSizeEXT)\";\n")
SLANG_RAW("    case GL_NV_ray_tracing: __intrinsic_asm \"(gl_LaunchSizeNV)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"optixGetLaunchDimensions\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            result:$$uint3 = OpLoad builtin(LaunchSizeKHR:uint3);\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// 10.4.2 - Ray System Values\n")
SLANG_RAW("\n")
SLANG_RAW("float3 WorldRayOrigin()\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl:  __intrinsic_asm \"WorldRayOrigin\";\n")
SLANG_RAW("    case GL_EXT_ray_tracing: __intrinsic_asm \"(gl_WorldRayOriginEXT)\";\n")
SLANG_RAW("    case GL_NV_ray_tracing: __intrinsic_asm \"(gl_WorldRayOriginNV)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"optixGetWorldRayOrigin\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            result:$$float3 = OpLoad builtin(WorldRayOriginKHR:float3);\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("float3 WorldRayDirection()\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl:  __intrinsic_asm \"WorldRayDirection\";\n")
SLANG_RAW("    case GL_EXT_ray_tracing: __intrinsic_asm \"(gl_WorldRayDirectionEXT)\";\n")
SLANG_RAW("    case GL_NV_ray_tracing: __intrinsic_asm \"(gl_WorldRayDirectionNV)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"optixGetWorldRayDirection\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            result:$$float3 = OpLoad builtin(WorldRayDirectionKHR:float3);\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("float RayTMin()\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl:  __intrinsic_asm \"RayTMin\";\n")
SLANG_RAW("    case GL_EXT_ray_tracing: __intrinsic_asm \"(gl_RayTminEXT)\";\n")
SLANG_RAW("    case GL_NV_ray_tracing: __intrinsic_asm \"(gl_RayTminNV)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"optixGetRayTmin\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            result:$$float = OpLoad builtin(RayTminKHR:float);\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Note: The `RayTCurrent()` intrinsic should translate to\n")
SLANG_RAW("// either `gl_HitTNV` (for hit shaders) or `gl_RayTmaxNV`\n")
SLANG_RAW("// (for intersection shaders). Right now we are handling this\n")
SLANG_RAW("// during code emission, for simplicity.\n")
SLANG_RAW("//\n")
SLANG_RAW("// TODO: Once the compiler supports a more refined concept\n")
SLANG_RAW("// of profiles/capabilities and overloading based on them,\n")
SLANG_RAW("// we should simply provide two overloads here, specialized\n")
SLANG_RAW("// to the appropriate Vulkan stages.\n")
SLANG_RAW("//\n")
SLANG_RAW("float RayTCurrent()\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl:  __intrinsic_asm \"RayTCurrent\";\n")
SLANG_RAW("    case GL_EXT_ray_tracing: __intrinsic_asm \"(gl_RayTmaxEXT)\";\n")
SLANG_RAW("    case GL_NV_ray_tracing: __intrinsic_asm \"(gl_RayTmaxNV)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"optixGetRayTmax\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            result:$$float = OpLoad builtin(RayTmaxKHR:float);\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("uint RayFlags()\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl:  __intrinsic_asm \"RayFlags\";\n")
SLANG_RAW("    case GL_EXT_ray_tracing: __intrinsic_asm \"(gl_IncomingRayFlagsEXT)\";\n")
SLANG_RAW("    case GL_NV_ray_tracing: __intrinsic_asm \"(gl_IncomingRayFlagsNV)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"optixGetRayFlags\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            result:$$uint = OpLoad builtin(IncomingRayFlagsKHR:uint);\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// 10.4.3 - Primitive/Object Space System Values\n")
SLANG_RAW("\n")
SLANG_RAW("uint InstanceIndex()\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl:  __intrinsic_asm \"InstanceIndex\";\n")
SLANG_RAW("    case __glslRayTracing: __intrinsic_asm \"(gl_InstanceID)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"optixGetInstanceIndex\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            result:$$uint = OpLoad builtin(InstanceId:uint);\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("uint InstanceID()\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl:  __intrinsic_asm \"InstanceID\";\n")
SLANG_RAW("    case GL_EXT_ray_tracing: __intrinsic_asm \"(gl_InstanceCustomIndexEXT)\";\n")
SLANG_RAW("    case GL_NV_ray_tracing:  __intrinsic_asm \"(gl_InstanceCustomIndexNV)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"optixGetInstanceId\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            result:$$uint = OpLoad builtin(InstanceCustomIndexKHR:uint);\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("uint PrimitiveIndex()\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl:  __intrinsic_asm \"PrimitiveIndex\";\n")
SLANG_RAW("    case __glslRayTracing:  __intrinsic_asm \"(gl_PrimitiveID)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"optixGetPrimitiveIndex\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            result:$$uint = OpLoad builtin(PrimitiveId:uint);\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("float3 ObjectRayOrigin()\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl:  __intrinsic_asm \"ObjectRayOrigin\";\n")
SLANG_RAW("    case GL_EXT_ray_tracing: __intrinsic_asm \"(gl_ObjectRayOriginEXT)\";\n")
SLANG_RAW("    case GL_NV_ray_tracing:  __intrinsic_asm \"(gl_ObjectRayOriginNV)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"optixGetObjectRayOrigin\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            result:$$float3 = OpLoad builtin(ObjectRayOriginKHR:float3);\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("float3 ObjectRayDirection()\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl:  __intrinsic_asm \"ObjectRayDirection\";\n")
SLANG_RAW("    case GL_EXT_ray_tracing: __intrinsic_asm \"(gl_ObjectRayDirectionEXT)\";\n")
SLANG_RAW("    case GL_NV_ray_tracing:  __intrinsic_asm \"(gl_ObjectRayDirectionNV)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"optixGetObjectRayDirection\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            result:$$float3 = OpLoad builtin(ObjectRayDirectionKHR:float3);\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// TODO: optix has an optixGetObjectToWorldTransformMatrix function that returns 12\n")
SLANG_RAW("// floats by reference.\n")
SLANG_RAW("float3x4 ObjectToWorld3x4()\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl:  __intrinsic_asm \"ObjectToWorld3x4\";\n")
SLANG_RAW("    case GL_EXT_ray_tracing: __intrinsic_asm \"transpose(gl_ObjectToWorldEXT)\";\n")
SLANG_RAW("    case GL_NV_ray_tracing:  __intrinsic_asm \"transpose(gl_ObjectToWorldNV)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            %mat = OpLoad builtin(ObjectToWorldKHR:float4x3);\n")
SLANG_RAW("            result:$$float3x4 = OpTranspose %mat;\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("float3x4 WorldToObject3x4()\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl:  __intrinsic_asm \"WorldToObject3x4\";\n")
SLANG_RAW("    case GL_EXT_ray_tracing: __intrinsic_asm \"transpose(gl_WorldToObjectEXT)\";\n")
SLANG_RAW("    case GL_NV_ray_tracing:  __intrinsic_asm \"transpose(gl_WorldToObjectNV)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            %mat = OpLoad builtin(WorldToObjectKHR:float4x3);\n")
SLANG_RAW("            result:$$float3x4 = OpTranspose %mat;\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("float4x3 ObjectToWorld4x3()\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl:  __intrinsic_asm \"ObjectToWorld4x3\";\n")
SLANG_RAW("    case GL_EXT_ray_tracing: __intrinsic_asm \"(gl_ObjectToWorldEXT)\";\n")
SLANG_RAW("    case GL_NV_ray_tracing:  __intrinsic_asm \"(gl_ObjectToWorldNV)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            result:$$float4x3 = OpLoad builtin(ObjectToWorldKHR:float4x3);\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("float4x3 WorldToObject4x3()\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl:  __intrinsic_asm \"WorldToObject4x3\";\n")
SLANG_RAW("    case GL_EXT_ray_tracing: __intrinsic_asm \"(gl_WorldToObjectEXT)\";\n")
SLANG_RAW("    case GL_NV_ray_tracing:  __intrinsic_asm \"(gl_WorldToObjectNV)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            result:$$float4x3 = OpLoad builtin(WorldToObjectKHR:float4x3);\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// NOTE!\n")
SLANG_RAW("// The name of the following functions may change when DXR supports\n")
SLANG_RAW("// a feature similar to the `GL_NV_ray_tracing_motion_blur` extension\n")
SLANG_RAW("\n")
SLANG_RAW("__glsl_version(460)\n")
SLANG_RAW("__glsl_extension(GL_NV_ray_tracing_motion_blur)\n")
SLANG_RAW("__glsl_extension(GL_EXT_ray_tracing)\n")
SLANG_RAW("float RayCurrentTime()\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl:  __intrinsic_asm \"RayCurrentTime\";\n")
SLANG_RAW("    case glsl:  __intrinsic_asm \"(gl_CurrentRayTimeNV)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            result:$$float = OpLoad builtin(CurrentRayTimeNV:float);\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Note: The provisional DXR spec included these unadorned\n")
SLANG_RAW("// `ObjectToWorld()` and `WorldToObject()` functions, so\n")
SLANG_RAW("// we will forward them to the new names as a convience\n")
SLANG_RAW("// for users who are porting their code.\n")
SLANG_RAW("//\n")
SLANG_RAW("// TODO: Should we provide a deprecation warning on these\n")
SLANG_RAW("// declarations, so that users can know they aren't coding\n")
SLANG_RAW("// against the final spec?\n")
SLANG_RAW("//\n")
SLANG_RAW("float3x4 ObjectToWorld() { return ObjectToWorld3x4(); }\n")
SLANG_RAW("float3x4 WorldToObject() { return WorldToObject3x4(); }\n")
SLANG_RAW("\n")
SLANG_RAW("// 10.4.4 - Hit Specific System values\n")
SLANG_RAW("uint HitKind()\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl:  __intrinsic_asm \"HitKind\";\n")
SLANG_RAW("    case GL_EXT_ray_tracing:  __intrinsic_asm \"(gl_HitKindEXT)\";\n")
SLANG_RAW("    case GL_NV_ray_tracing:  __intrinsic_asm \"(gl_HitKindNV)\";\n")
SLANG_RAW("    case cuda:  __intrinsic_asm \"optixGetHitKind\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            result:$$uint = OpLoad builtin(HitKindKHR:uint);\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Pre-defined hit kinds (not documented explicitly)\n")
SLANG_RAW("static const uint HIT_KIND_TRIANGLE_FRONT_FACE  = 254;\n")
SLANG_RAW("static const uint HIT_KIND_TRIANGLE_BACK_FACE   = 255;\n")
SLANG_RAW("\n")
SLANG_RAW("//\n")
SLANG_RAW("// Shader Model 6.4\n")
SLANG_RAW("//\n")
SLANG_RAW("\n")
SLANG_RAW("// Treats `left` and `right` as 4-component vectors of `UInt8` and computes `dot(left, right) + acc`\n")
SLANG_RAW("uint dot4add_u8packed(uint left, uint right, uint acc);\n")
SLANG_RAW("\n")
SLANG_RAW("// Treats `left` and `right` as 4-component vectors of `Int8` and computes `dot(left, right) + acc`\n")
SLANG_RAW("int dot4add_i8packed(uint left, uint right, int acc);\n")
SLANG_RAW("\n")
SLANG_RAW("// Computes `dot(left, right) + acc`.\n")
SLANG_RAW("//\n")
SLANG_RAW("// May not produce infinities or NaNs for intermediate results that overflow the range of `half`\n")
SLANG_RAW("float dot2add(float2 left, float2 right, float acc);\n")
SLANG_RAW("\n")
SLANG_RAW("//\n")
SLANG_RAW("// Shader Model 6.5\n")
SLANG_RAW("//\n")
SLANG_RAW("\n")
SLANG_RAW("//\n")
SLANG_RAW("// Mesh Shaders\n")
SLANG_RAW("//\n")
SLANG_RAW("\n")
SLANG_RAW("// Set the number of output vertices and primitives for a mesh shader invocation.\n")
SLANG_RAW("__glsl_extension(GL_EXT_mesh_shader)\n")
SLANG_RAW("__glsl_version(450)\n")
SLANG_RAW("void SetMeshOutputCounts(uint vertexCount, uint primitiveCount)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        __intrinsic_asm \"SetMeshOutputCounts\";\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"SetMeshOutputsEXT\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            OpCapability MeshShadingEXT;\n")
SLANG_RAW("            OpExtension \"SPV_EXT_mesh_shader\";\n")
SLANG_RAW("            OpSetMeshOutputsEXT $vertexCount $primitiveCount;\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Specify the number of downstream mesh shader thread groups to invoke from an amplification shader,\n")
SLANG_RAW("// and provide the values for per-mesh payload parameters.\n")
SLANG_RAW("//\n")
SLANG_RAW("// This function doesn't return.\n")
SLANG_RAW("//\n")
SLANG_RAW("[KnownBuiltin(\"DispatchMesh\")]\n")
SLANG_RAW("void DispatchMesh<P>(uint threadGroupCountX, uint threadGroupCountY, uint threadGroupCountZ, __ref P meshPayload)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        __intrinsic_asm \"DispatchMesh\";\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        // This intrinsic doesn't take into account writing meshPayload. That\n")
SLANG_RAW("        // is dealt with separately by 'legalizeDispatchMeshPayloadForGLSL'.\n")
SLANG_RAW("        __intrinsic_asm \"EmitMeshTasksEXT($0, $1, $2)\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            OpCapability MeshShadingEXT;\n")
SLANG_RAW("            OpExtension \"SPV_EXT_mesh_shader\";\n")
SLANG_RAW("            OpEmitMeshTasksEXT $threadGroupCountX $threadGroupCountY $threadGroupCountZ &meshPayload;\n")
SLANG_RAW("            // OpEmitMeshTasksExt is a terminator, so we need to start a new\n")
SLANG_RAW("            // block to hold whatever comes after this intrinsic\n")
SLANG_RAW("            %_ = OpLabel\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("//\n")
SLANG_RAW("// \"Sampler feedback\" types `FeedbackTexture2D` and `FeedbackTexture2DArray`.\n")
SLANG_RAW("//\n")
SLANG_RAW("\n")
SLANG_RAW("// https://microsoft.github.io/DirectX-Specs/d3d/SamplerFeedback.html\n")
SLANG_RAW("\n")
SLANG_RAW("// The docs describe these as 'types' but their syntax makes them seem enum like, and enum is a simpler way to implement them\n")
SLANG_RAW("// But slang enums are always 'enum class like', so I use an empty struct type here\n")
SLANG_RAW("\n")
SLANG_RAW("[sealed]\n")
SLANG_RAW("[builtin]\n")
SLANG_RAW("interface __BuiltinSamplerFeedbackType {};\n")
SLANG_RAW("\n")
SLANG_RAW("[sealed]\n")
SLANG_RAW("__magic_type(FeedbackType, ")
SLANG_SPLICE(int(FeedbackType::Kind::MinMip)
)
SLANG_RAW(")\n")
SLANG_RAW("__target_intrinsic(hlsl, SAMPLER_FEEDBACK_MIN_MIP)\n")
SLANG_RAW("struct SAMPLER_FEEDBACK_MIN_MIP : __BuiltinSamplerFeedbackType {};\n")
SLANG_RAW("\n")
SLANG_RAW("[sealed]\n")
SLANG_RAW("__magic_type(FeedbackType, ")
SLANG_SPLICE(int(FeedbackType::Kind::MipRegionUsed)
)
SLANG_RAW(")\n")
SLANG_RAW("__target_intrinsic(hlsl, SAMPLER_FEEDBACK_MIP_REGION_USED)\n")
SLANG_RAW("struct SAMPLER_FEEDBACK_MIP_REGION_USED : __BuiltinSamplerFeedbackType {};\n")
SLANG_RAW("\n")
SLANG_RAW("// All of these objects are write-only resources that point to a special kind of unordered access view meant for sampler feedback.\n")
SLANG_RAW("__generic<T:__BuiltinSamplerFeedbackType>\n")
SLANG_RAW("extension __TextureImpl<T,__Shape2D, 0, 0, 0, ")
SLANG_SPLICE(kStdlibResourceAccessFeedback
)
SLANG_RAW(", 0, 0, 0>\n")
SLANG_RAW("{\n")
SLANG_RAW("    // With Clamp\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(hlsl, \"($0).WriteSamplerFeedback($1, $2, $3, $4)\")\n")
SLANG_RAW("    __target_intrinsic(cpp, \"($0).WriteSamplerFeedback($1, $2, $3, $4)\")\n")
SLANG_RAW("    void WriteSamplerFeedback<S>(Texture2D<S> tex, SamplerState samp, float2 location, float clamp);\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(hlsl, \"($0).WriteSamplerFeedbackBias($1, $2, $3, $4, $5)\")\n")
SLANG_RAW("    __target_intrinsic(cpp, \"($0).WriteSamplerFeedbackBias($1, $2, $3, $4, $5)\")\n")
SLANG_RAW("    void WriteSamplerFeedbackBias<S>(Texture2D<S> tex, SamplerState samp, float2 location, float bias, float clamp);\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(hlsl, \"($0).WriteSamplerFeedbackGrad($1, $2, $3, $4, $5, $6)\")\n")
SLANG_RAW("    __target_intrinsic(cpp, \"($0).WriteSamplerFeedbackGrad($1, $2, $3, $4, $5, $6)\")\n")
SLANG_RAW("    void WriteSamplerFeedbackGrad<S>(Texture2D<S> tex, SamplerState samp, float2 location, float2 ddx, float2 ddy, float clamp);\n")
SLANG_RAW("\n")
SLANG_RAW("    // Level\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(hlsl, \"($0).WriteSamplerFeedbackLevel($1, $2, $3, $4)\")\n")
SLANG_RAW("    __target_intrinsic(cpp, \"($0).WriteSamplerFeedbackLevel($1, $2, $3, $4)\")\n")
SLANG_RAW("    void WriteSamplerFeedbackLevel<S>(Texture2D<S> tex, SamplerState samp, float2 location, float lod);\n")
SLANG_RAW("\n")
SLANG_RAW("    // Without Clamp\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(hlsl, \"($0).WriteSamplerFeedback($1, $2, $3)\")\n")
SLANG_RAW("    __target_intrinsic(cpp, \"($0).WriteSamplerFeedback($1, $2, $3)\")\n")
SLANG_RAW("    void WriteSamplerFeedback<S>(Texture2D<S> tex, SamplerState samp, float2 location);\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(hlsl, \"($0).WriteSamplerFeedbackBias($1, $2, $3, $4)\")\n")
SLANG_RAW("    __target_intrinsic(cpp, \"($0).WriteSamplerFeedbackBias($1, $2, $3, $4)\")\n")
SLANG_RAW("    void WriteSamplerFeedbackBias<S>(Texture2D<S> tex, SamplerState samp, float2 location, float bias);\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(hlsl, \"($0).WriteSamplerFeedbackGrad($1, $2, $3, $4, $5)\")\n")
SLANG_RAW("    __target_intrinsic(cpp, \"($0).WriteSamplerFeedbackGrad($1, $2, $3, $4, $5)\")\n")
SLANG_RAW("    void WriteSamplerFeedbackGrad<S>(Texture2D<S> tex, SamplerState samp, float2 location, float2 ddx, float2 ddy);\n")
SLANG_RAW("};\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinSamplerFeedbackType>\n")
SLANG_RAW("extension __TextureImpl<T,__Shape2D, 1, 0, 0, ")
SLANG_SPLICE(kStdlibResourceAccessFeedback
)
SLANG_RAW(", 0, 0, 0>\n")
SLANG_RAW("{\n")
SLANG_RAW("    // With Clamp\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(hlsl, \"($0).WriteSamplerFeedback($1, $2, $3, $4)\")\n")
SLANG_RAW("    __target_intrinsic(cpp, \"($0).WriteSamplerFeedback($1, $2, $3, $4)\")\n")
SLANG_RAW("    void WriteSamplerFeedback<S>(Texture2DArray<S> texArray, SamplerState samp, float3 location, float clamp);\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(hlsl, \"($0).WriteSamplerFeedbackBias($1, $2, $3, $4, $5)\")\n")
SLANG_RAW("    __target_intrinsic(cpp, \"($0).WriteSamplerFeedbackBias($1, $2, $3, $4, $5)\")\n")
SLANG_RAW("    void WriteSamplerFeedbackBias<S>(Texture2DArray<S> texArray, SamplerState samp, float3 location, float bias, float clamp);\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(hlsl, \"($0).WriteSamplerFeedbackGrad($1, $2, $3, $4, $5, $6)\")\n")
SLANG_RAW("    __target_intrinsic(cpp, \"($0).WriteSamplerFeedbackGrad($1, $2, $3, $4, $5, $6)\")\n")
SLANG_RAW("    void WriteSamplerFeedbackGrad<S>(Texture2DArray<S> texArray, SamplerState samp, float3 location, float3 ddx, float3 ddy, float clamp);\n")
SLANG_RAW("\n")
SLANG_RAW("    // Level\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(hlsl, \"($0).WriteSamplerFeedbackLevel($1, $2, $3, $4)\")\n")
SLANG_RAW("    __target_intrinsic(cpp, \"($0).WriteSamplerFeedbackLevel($1, $2, $3, $4)\")\n")
SLANG_RAW("    void WriteSamplerFeedbackLevel<S>(Texture2DArray<S> texArray, SamplerState samp, float3 location, float lod);\n")
SLANG_RAW("\n")
SLANG_RAW("    // Without Clamp\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(hlsl, \"($0).WriteSamplerFeedback($1, $2, $3)\")\n")
SLANG_RAW("    __target_intrinsic(cpp, \"($0).WriteSamplerFeedback($1, $2, $3)\")\n")
SLANG_RAW("    void WriteSamplerFeedback<S>(Texture2DArray<S> texArray, SamplerState samp, float3 location);\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(hlsl, \"($0).WriteSamplerFeedbackBias($1, $2, $3, $4)\")\n")
SLANG_RAW("    __target_intrinsic(cpp, \"($0).WriteSamplerFeedbackBias($1, $2, $3, $4)\")\n")
SLANG_RAW("    void WriteSamplerFeedbackBias<S>(Texture2DArray<S> texArray, SamplerState samp, float3 location, float bias);\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(hlsl, \"($0).WriteSamplerFeedbackGrad($1, $2, $3, $4, $5)\")\n")
SLANG_RAW("    __target_intrinsic(cpp, \"($0).WriteSamplerFeedbackGrad($1, $2, $3, $4, $5)\")\n")
SLANG_RAW("    void WriteSamplerFeedbackGrad<S>(Texture2DArray<S> texArray, SamplerState samp, float3 location, float3 ddx, float3 ddy);\n")
SLANG_RAW("};\n")
SLANG_RAW("\n")
SLANG_RAW("//\n")
SLANG_RAW("// DXR 1.1 and `TraceRayInline` support\n")
SLANG_RAW("//\n")
SLANG_RAW("\n")
SLANG_RAW("// Get the index of the geometry that was hit in an intersection, any-hit, or closest-hit shader\n")
SLANG_RAW("__target_intrinsic(GL_EXT_ray_tracing, \"(gl_GeometryIndexEXT)\")\n")
SLANG_RAW("uint GeometryIndex()\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"GeometryIndex\";\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"(gl_GeometryIndexEXT)\";\n")
SLANG_RAW("    case spirv: return spirv_asm {\n")
SLANG_RAW("            result:$$uint = OpLoad builtin(RayGeometryIndexKHR:uint);\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Status of whether a (closest) hit has been committed in a `RayQuery`.\n")
SLANG_RAW("typedef uint COMMITTED_STATUS;\n")
SLANG_RAW("\n")
SLANG_RAW("// No hit committed.\n")
SLANG_RAW("static const COMMITTED_STATUS COMMITTED_NOTHING = 0;\n")
SLANG_RAW("\n")
SLANG_RAW("// Closest hit is a triangle.\n")
SLANG_RAW("//\n")
SLANG_RAW("// This could be an opaque triangle hit found by the fixed-function\n")
SLANG_RAW("// traversal and intersection implementation, or a non-opaque\n")
SLANG_RAW("// triangle hit committed by user code with `RayQuery.CommitNonOpaqueTriangleHit`\n")
SLANG_RAW("//\n")
SLANG_RAW("static const COMMITTED_STATUS COMMITTED_TRIANGLE_HIT = 1;\n")
SLANG_RAW("\n")
SLANG_RAW("// Closest hit is a procedural primitive.\n")
SLANG_RAW("//\n")
SLANG_RAW("// A procedural hit primitive is committed using `RayQuery.CommitProceduralPrimitiveHit`.\n")
SLANG_RAW("static const COMMITTED_STATUS COMMITTED_PROCEDURAL_PRIMITIVE_HIT = 2;\n")
SLANG_RAW("\n")
SLANG_RAW("// Type of candidate hit that a `RayQuery` is pausing at.\n")
SLANG_RAW("//\n")
SLANG_RAW("// A `RayQuery` can automatically commit hits with opaque triangles,\n")
SLANG_RAW("// but yields to user code for other hits to allow them to be\n")
SLANG_RAW("// dismissed or committed.\n")
SLANG_RAW("//\n")
SLANG_RAW("typedef uint CANDIDATE_TYPE;\n")
SLANG_RAW("\n")
SLANG_RAW("// Candidate hit is a non-opaque triangle.\n")
SLANG_RAW("static const CANDIDATE_TYPE CANDIDATE_NON_OPAQUE_TRIANGLE = 0;\n")
SLANG_RAW("\n")
SLANG_RAW("// Candidate hit is a procedural primitive.\n")
SLANG_RAW("static const CANDIDATE_TYPE CANDIDATE_PROCEDURAL_PRIMITIVE = 1;\n")
SLANG_RAW("\n")
SLANG_RAW("// Handle to state of an in-progress ray-tracing query.\n")
SLANG_RAW("//\n")
SLANG_RAW("// The ray query is effectively a coroutine that user shader\n")
SLANG_RAW("// code can resume to continue tracing the ray, and which yields\n")
SLANG_RAW("// back to the user code at interesting events along the ray.\n")
SLANG_RAW("//\n")
SLANG_RAW("// Note: The treatment of the `RayQuery` type in Slang does not\n")
SLANG_RAW("// perfectly match its semantics in vanilla HLSL in some corner\n")
SLANG_RAW("// cases. Specifically, a `RayQuery` in vanilla HLSL is an\n")
SLANG_RAW("// opaque handle to mutable storage, and assigning a `RayQuery`\n")
SLANG_RAW("// or passing one as a parameter will only copy the *handle*,\n")
SLANG_RAW("// potentially resulting in aliasing of the underlying mutable\n")
SLANG_RAW("// storage.\n")
SLANG_RAW("//\n")
SLANG_RAW("// In contrast, Slang considers a `RayQuery` to own its mutable\n")
SLANG_RAW("// state, and (because the API does not support cloning of queries),\n")
SLANG_RAW("// `RayQuery` values are non-copyable (aka \"move-only\").\n")
SLANG_RAW("//\n")
SLANG_RAW("// The main place where this arises as a consideration is when\n")
SLANG_RAW("// passing a `RayQuery` down into a function that will perform\n")
SLANG_RAW("// mutating operations on it (e.g., `TraceRay` or `Proceed`):\n")
SLANG_RAW("//\n")
SLANG_RAW("//      void myFunc( inout RayQuery<FLAGS> q )\n")
SLANG_RAW("//      {\n")
SLANG_RAW("//          q.Proceed();\n")
SLANG_RAW("//      }\n")
SLANG_RAW("//\n")
SLANG_RAW("// In Slang, a parameter like `q` above should be declared `inout`.\n")
SLANG_RAW("// HLSL does not care about whether `q` is declared `inout` or not.\n")
SLANG_RAW("//\n")
SLANG_RAW("__glsl_extension(GL_EXT_ray_query)\n")
SLANG_RAW("__glsl_version(460)\n")
SLANG_RAW("[__NonCopyableType]\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_RayQueryType
)
SLANG_RAW(")\n")
SLANG_RAW("struct RayQuery <let rayFlagsGeneric : RAY_FLAG = RAY_FLAG_NONE>\n")
SLANG_RAW("{\n")
SLANG_RAW("    // Create a new ray query, initialized to its default state.\n")
SLANG_RAW("    //\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_AllocateOpaqueHandle
)
SLANG_RAW(")\n")
SLANG_RAW("    __init();\n")
SLANG_RAW("\n")
SLANG_RAW("    \n")
SLANG_RAW("    __target_intrinsic(glsl, \"rayQueryInitializeEXT($0, $1, $2, $3, $4, $5, $6, $7)\")\n")
SLANG_RAW("    __glsl_extension(GL_EXT_ray_query)\n")
SLANG_RAW("    __glsl_version(460)\n")
SLANG_RAW("    [mutating]\n")
SLANG_RAW("    void __rayQueryInitializeEXT(\n")
SLANG_RAW("        RaytracingAccelerationStructure accelerationStructure,\n")
SLANG_RAW("        RAY_FLAG                        rayFlags,\n")
SLANG_RAW("        uint                            instanceInclusionMask,\n")
SLANG_RAW("        float3                          origin,\n")
SLANG_RAW("        float                           tMin,\n")
SLANG_RAW("        float3                          direction,\n")
SLANG_RAW("        float                           tMax)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl: __intrinsic_asm \"rayQueryInitializeEXT($0, $1, $2, $3, $4, $5, $6, $7)\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            spirv_asm {\n")
SLANG_RAW("                OpRayQueryInitializeKHR &this $accelerationStructure $rayFlags $instanceInclusionMask $origin $tMin $direction $tMax;\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    // Initialize a ray-tracing query.\n")
SLANG_RAW("    //\n")
SLANG_RAW("    // This method may be called on a \"fresh\" ray query, or\n")
SLANG_RAW("    // on one that is already tracing a ray. In the latter\n")
SLANG_RAW("    // case any state related to the ray previously being\n")
SLANG_RAW("    // traced is overwritten.\n")
SLANG_RAW("    //\n")
SLANG_RAW("    // The `rayFlags` here will be bitwise ORed with\n")
SLANG_RAW("    // the `rayFlags` passed as a generic argument to\n")
SLANG_RAW("    // `RayQuery` to get the effective ray flags, which\n")
SLANG_RAW("    // must obey any API-imposed restrictions.\n")
SLANG_RAW("    //\n")
SLANG_RAW("    [__unsafeForceInlineEarly]\n")
SLANG_RAW("    [mutating]\n")
SLANG_RAW("    void TraceRayInline(\n")
SLANG_RAW("        RaytracingAccelerationStructure accelerationStructure,\n")
SLANG_RAW("        RAY_FLAG                        rayFlags,\n")
SLANG_RAW("        uint                            instanceInclusionMask,\n")
SLANG_RAW("        RayDesc                         ray)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".TraceRayInline\";\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            __rayQueryInitializeEXT(\n")
SLANG_RAW("                accelerationStructure,\n")
SLANG_RAW("                rayFlags | rayFlagsGeneric,\n")
SLANG_RAW("                instanceInclusionMask,\n")
SLANG_RAW("                ray.Origin,\n")
SLANG_RAW("                ray.TMin,\n")
SLANG_RAW("                ray.Direction,\n")
SLANG_RAW("                ray.TMax);\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("    \n")
SLANG_RAW("    // Resume the ray query coroutine.\n")
SLANG_RAW("    //\n")
SLANG_RAW("    // If the coroutine suspends because of encountering\n")
SLANG_RAW("    // a candidate hit that cannot be resolved with fixed-funciton\n")
SLANG_RAW("    // logic, this function returns `true`, and the `Candidate*()`\n")
SLANG_RAW("    // functions should be used by application code to resolve\n")
SLANG_RAW("    // the candidate hit (by either committing or ignoring it).\n")
SLANG_RAW("    //\n")
SLANG_RAW("    // If the coroutine terminates because traversal is\n")
SLANG_RAW("    // complete (or has been aborted), this function returns\n")
SLANG_RAW("    // `false`, and application code should use the `Committed*()`\n")
SLANG_RAW("    // functions to appropriately handle the closest hit (it any)\n")
SLANG_RAW("    // that was found.\n")
SLANG_RAW("    //\n")
SLANG_RAW("    __glsl_extension(GL_EXT_ray_query)\n")
SLANG_RAW("    __glsl_version(460)\n")
SLANG_RAW("    [mutating]\n")
SLANG_RAW("    bool Proceed()\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".Proceed\";\n")
SLANG_RAW("        case glsl: __intrinsic_asm \"rayQueryProceedEXT\";\n")
SLANG_RAW("        case spirv: return spirv_asm\n")
SLANG_RAW("            {\n")
SLANG_RAW("                result:$$bool = OpRayQueryProceedKHR &this\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    // Causes the ray query to terminate.\n")
SLANG_RAW("    //\n")
SLANG_RAW("    // This function cases the ray query to act as if\n")
SLANG_RAW("    // traversal has terminated, so that subsequent\n")
SLANG_RAW("    // `Proceed()` calls will return `false`.\n")
SLANG_RAW("    //\n")
SLANG_RAW("    __glsl_extension(GL_EXT_ray_query)\n")
SLANG_RAW("    __glsl_version(460)\n")
SLANG_RAW("    [mutating]\n")
SLANG_RAW("    void Abort()\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".Abort\";\n")
SLANG_RAW("        case glsl: __intrinsic_asm \"rayQueryTerminateEXT\";\n")
SLANG_RAW("        case spirv: spirv_asm { OpRayQueryTerminateKHR &this };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    // Commit the current non-opaque triangle hit.\n")
SLANG_RAW("    __glsl_extension(GL_EXT_ray_query)\n")
SLANG_RAW("    __glsl_version(460)\n")
SLANG_RAW("    [__NoSideEffect]\n")
SLANG_RAW("    [mutating]\n")
SLANG_RAW("    void CommitNonOpaqueTriangleHit()\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".CommitNonOpaqueTriangleHit\";\n")
SLANG_RAW("        case glsl: __intrinsic_asm \"rayQueryConfirmIntersectionEXT\";\n")
SLANG_RAW("        case spirv: spirv_asm { OpRayQueryConfirmIntersectionKHR &this };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    // Commit the current procedural primitive hit, with hit time `t`.\n")
SLANG_RAW("    __glsl_extension(GL_EXT_ray_query)\n")
SLANG_RAW("    __glsl_version(460)\n")
SLANG_RAW("    [__NoSideEffect]\n")
SLANG_RAW("    [mutating]\n")
SLANG_RAW("    void CommitProceduralPrimitiveHit(float t)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".CommitProceduralPrimitiveHit\";\n")
SLANG_RAW("        case glsl: __intrinsic_asm \"rayQueryGenerateIntersectionEXT\";\n")
SLANG_RAW("        case spirv: spirv_asm { OpRayQueryGenerateIntersectionKHR &this $t };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    // Get the type of candidate hit being considered.\n")
SLANG_RAW("    //\n")
SLANG_RAW("    // The ray query coroutine will suspend when it encounters\n")
SLANG_RAW("    // a hit that cannot be resolved with fixed-function logic\n")
SLANG_RAW("    // (either a non-opaque triangle or a procedural primitive).\n")
SLANG_RAW("    // In either of those cases, `CandidateType()` will return\n")
SLANG_RAW("    // the kind of candidate hit that must be resolved by\n")
SLANG_RAW("    // user code.\n")
SLANG_RAW("    //\n")
SLANG_RAW("    __glsl_extension(GL_EXT_ray_query)\n")
SLANG_RAW("    __glsl_version(460)\n")
SLANG_RAW("    [__NoSideEffect]\n")
SLANG_RAW("    CANDIDATE_TYPE CandidateType()\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".CandidateType\";\n")
SLANG_RAW("        case glsl: __intrinsic_asm \"rayQueryGetIntersectionTypeEXT($0, false)\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            uint RayQueryCandidateIntersectionKHR = 0;\n")
SLANG_RAW("            return spirv_asm {\n")
SLANG_RAW("                result:$$CANDIDATE_TYPE = OpRayQueryGetIntersectionTypeKHR &this $RayQueryCandidateIntersectionKHR;\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    // Get the status of the committed (closest) hit, if any.\n")
SLANG_RAW("    __glsl_extension(GL_EXT_ray_query)\n")
SLANG_RAW("    __glsl_version(460)\n")
SLANG_RAW("    [__NoSideEffect]\n")
SLANG_RAW("    COMMITTED_STATUS CommittedStatus()\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".CommittedStatus\";\n")
SLANG_RAW("        case glsl: __intrinsic_asm \"rayQueryGetIntersectionTypeEXT($0, true)\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            uint RayQueryCommittedIntersectionKHR = 1;\n")
SLANG_RAW("            return spirv_asm\n")
SLANG_RAW("            {\n")
SLANG_RAW("                result:$$COMMITTED_STATUS = OpRayQueryGetIntersectionTypeKHR &this $RayQueryCommittedIntersectionKHR;\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    __glsl_extension(GL_EXT_ray_query)\n")
SLANG_RAW("    __glsl_version(460)\n")
SLANG_RAW("    [__NoSideEffect]\n")
SLANG_RAW("    bool CandidateProceduralPrimitiveNonOpaque()\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".CandidateProceduralPrimitiveNonOpaque\";\n")
SLANG_RAW("        case glsl: __intrinsic_asm \"(!rayQueryGetIntersectionCandidateAABBOpaqueEXT($0, false))\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            uint iCandidateOrCommitted = 0;\n")
SLANG_RAW("            return spirv_asm\n")
SLANG_RAW("            {\n")
SLANG_RAW("                %rr:$$bool = OpRayQueryGetIntersectionCandidateAABBOpaqueKHR &this;\n")
SLANG_RAW("                result:$$bool = OpLogicalNot %rr;\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    __glsl_extension(GL_EXT_ray_query)\n")
SLANG_RAW("    __glsl_version(460)\n")
SLANG_RAW("    [__NoSideEffect]\n")
SLANG_RAW("    float CandidateTriangleRayT()\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".CandidateTriangleRayT\";\n")
SLANG_RAW("        case glsl: __intrinsic_asm \"rayQueryGetIntersectionTEXT($0, false)\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            uint iCandidateOrCommitted = 0;\n")
SLANG_RAW("            return spirv_asm\n")
SLANG_RAW("            {\n")
SLANG_RAW("                result:$$float = OpRayQueryGetIntersectionTKHR &this $iCandidateOrCommitted;\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("    __glsl_extension(GL_EXT_ray_query)\n")
SLANG_RAW("    __glsl_version(460)\n")
SLANG_RAW("    [__NoSideEffect]\n")
SLANG_RAW("    float CommittedRayT()\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".CommittedRayT\";\n")
SLANG_RAW("        case glsl: __intrinsic_asm \"rayQueryGetIntersectionTEXT($0, true)\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            uint iCandidateOrCommitted = 1;\n")
SLANG_RAW("            return spirv_asm\n")
SLANG_RAW("            {\n")
SLANG_RAW("                result:$$float = OpRayQueryGetIntersectionTKHR &this $iCandidateOrCommitted;\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")

    const char* kCandidateCommitted[] = {"Candidate", "Committed"};

    // Access Candidate and Committed Matrices.
    for (uint32_t candidateOrCommitted = 0; candidateOrCommitted < 2; candidateOrCommitted++)
    {
        auto ccName = kCandidateCommitted[candidateOrCommitted];
        auto ccTF = candidateOrCommitted == 0 ? "false" : "true";
SLANG_RAW("#line 10160 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("    // CandidateObjectToWorld3x4, CandidateWorldToObject4x3\n")
SLANG_RAW("    // CommittedObjectToWorld3x4, CommittedObjectToWorld4x3\n")

    const char* kRayQueryMatrixNames[] = {"ObjectToWorld", "WorldToObject"};
    for (auto matName : kRayQueryMatrixNames) {
    
SLANG_RAW("#line 10167 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("    __glsl_extension(GL_EXT_ray_query)\n")
SLANG_RAW("    __glsl_version(460)\n")
SLANG_RAW("    [__NoSideEffect]\n")
SLANG_RAW("    float3x4 ")
SLANG_SPLICE(ccName
)
SLANG_SPLICE(matName
)
SLANG_RAW("3x4()\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl: __intrinsic_asm \"transpose(rayQueryGetIntersection")
SLANG_SPLICE(matName
)
SLANG_RAW("EXT($0, ")
SLANG_SPLICE(ccTF
)
SLANG_RAW("))\";\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".")
SLANG_SPLICE(ccName
)
SLANG_SPLICE(matName
)
SLANG_RAW("3x4\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            uint iCandidateOrCommitted = ")
SLANG_SPLICE(candidateOrCommitted
)
SLANG_RAW(";\n")
SLANG_RAW("            return spirv_asm {\n")
SLANG_RAW("                %m:$$float4x3 = OpRayQueryGetIntersection")
SLANG_SPLICE(matName
)
SLANG_RAW("KHR &this $iCandidateOrCommitted;\n")
SLANG_RAW("                result:$$float3x4 = OpTranspose %m;\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    __glsl_extension(GL_EXT_ray_query)\n")
SLANG_RAW("    __glsl_version(460)\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    float4x3 ")
SLANG_SPLICE(ccName
)
SLANG_SPLICE(matName
)
SLANG_RAW("4x3()\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl: __intrinsic_asm \"rayQueryGetIntersection")
SLANG_SPLICE(matName
)
SLANG_RAW("EXT($0, ")
SLANG_SPLICE(ccTF
)
SLANG_RAW(")\";\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".")
SLANG_SPLICE(ccName
)
SLANG_SPLICE(matName
)
SLANG_RAW("4x3\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            uint iCandidateOrCommitted = ")
SLANG_SPLICE(candidateOrCommitted
)
SLANG_RAW(";\n")
SLANG_RAW("            return spirv_asm {\n")
SLANG_RAW("                result:$$float4x3 = OpRayQueryGetIntersection")
SLANG_SPLICE(matName
)
SLANG_RAW("KHR &this $iCandidateOrCommitted;\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")

    } // ObjectToWorld/WorldToObject.

    // Access Candidate and Committed properties.
    struct RayQueryMethodEntry
    {
        const char* type;
        const char* hlslName;
        const char* glslName;
    };
    const RayQueryMethodEntry rayQueryMethods[] = {
        {"uint", "InstanceIndex", "InstanceId"},
        {"uint", "InstanceID", "InstanceCustomIndex"},
        {"uint", "PrimitiveIndex", "PrimitiveIndex"},
        {"uint", "GeometryIndex", "GeometryIndex"},
        {"uint", "InstanceContributionToHitGroupIndex", "InstanceShaderBindingTableRecordOffset"},
        {"float3", "ObjectRayOrigin", "ObjectRayOrigin"},
        {"float3", "ObjectRayDirection", "ObjectRayDirection"},
        {"bool", "TriangleFrontFace", "FrontFace"},
        {"float2", "TriangleBarycentrics", "Barycentrics"},
    };
    for (auto method : rayQueryMethods) {
SLANG_RAW("#line 10226 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("    __glsl_extension(GL_EXT_ray_query)\n")
SLANG_RAW("    __glsl_version(460)\n")
SLANG_RAW("    [__NoSideEffect]\n")
SLANG_RAW("    ")
SLANG_SPLICE(method.type
)
SLANG_RAW(" ")
SLANG_SPLICE(ccName
)
SLANG_SPLICE(method.hlslName
)
SLANG_RAW("()\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".")
SLANG_SPLICE(ccName
)
SLANG_SPLICE(method.hlslName
)
SLANG_RAW("\";\n")
SLANG_RAW("        case glsl: __intrinsic_asm \"rayQueryGetIntersection")
SLANG_SPLICE(method.glslName
)
SLANG_RAW("EXT($0, ")
SLANG_SPLICE(ccTF
)
SLANG_RAW(")\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            uint iCandidateOrCommitted = ")
SLANG_SPLICE(candidateOrCommitted
)
SLANG_RAW(";\n")
SLANG_RAW("            return spirv_asm {\n")
SLANG_RAW("                result:$$")
SLANG_SPLICE(method.type
)
SLANG_RAW(" = OpRayQueryGetIntersection")
SLANG_SPLICE(method.glslName
)
SLANG_RAW("KHR &this $iCandidateOrCommitted;\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")

    } // Candidate/Committed properties.
    } // for ("Candidate", "Committed")
SLANG_RAW("#line 10247 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("    // Access properties of the ray being traced.\n")
SLANG_RAW("\n")
SLANG_RAW("    __glsl_extension(GL_EXT_ray_query)\n")
SLANG_RAW("    __glsl_version(460)\n")
SLANG_RAW("    [__NoSideEffect]\n")
SLANG_RAW("    uint RayFlags()\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".RayFlags\";\n")
SLANG_RAW("        case glsl: __intrinsic_asm \"rayQueryGetRayFlagsEXT\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            return spirv_asm {\n")
SLANG_RAW("                result:$$uint = OpRayQueryGetRayFlagsKHR &this;\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    __glsl_extension(GL_EXT_ray_query)\n")
SLANG_RAW("    __glsl_version(460)\n")
SLANG_RAW("    [__NoSideEffect]\n")
SLANG_RAW("    float3 WorldRayOrigin()\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".WorldRayOrigin\";\n")
SLANG_RAW("        case glsl: __intrinsic_asm \"rayQueryGetWorldRayOriginEXT\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            return spirv_asm {\n")
SLANG_RAW("                result:$$float3 = OpRayQueryGetWorldRayOriginKHR &this;\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    __glsl_extension(GL_EXT_ray_query)\n")
SLANG_RAW("    __glsl_version(460)\n")
SLANG_RAW("    [__NoSideEffect]\n")
SLANG_RAW("    float3 WorldRayDirection()\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".WorldRayDirection\";\n")
SLANG_RAW("        case glsl: __intrinsic_asm \"rayQueryGetWorldRayDirectionEXT\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            return spirv_asm {\n")
SLANG_RAW("                result:$$float3 = OpRayQueryGetWorldRayDirectionKHR &this;\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    __glsl_extension(GL_EXT_ray_query)\n")
SLANG_RAW("    __glsl_version(460)\n")
SLANG_RAW("    [__NoSideEffect]\n")
SLANG_RAW("    float RayTMin()\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".RayTMin\";\n")
SLANG_RAW("        case glsl: __intrinsic_asm \"rayQueryGetRayTMinEXT\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            return spirv_asm {\n")
SLANG_RAW("                result:$$float = OpRayQueryGetRayTMinKHR &this;\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    };\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("//\n")
SLANG_RAW("// Vulkan/SPIR-V specific features\n")
SLANG_RAW("//\n")
SLANG_RAW("\n")
SLANG_RAW("struct VkSubpassInput<T>\n")
SLANG_RAW("{\n")
SLANG_RAW("    T SubpassLoad();\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("struct VkSubpassInputMS<T>\n")
SLANG_RAW("{\n")
SLANG_RAW("    T SubpassLoad(int sampleIndex);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("///\n")
SLANG_RAW("/// Shader Execution Reordering (SER)\n")
SLANG_RAW("///\n")
SLANG_RAW("/// NOTE! This API is currently experimental and may change in the future as SER is made available\n")
SLANG_RAW("/// in different APIs and downstream compilers.\n")
SLANG_RAW("///\n")
SLANG_RAW("/// Based on the NVAPI on D3D12 only currently.\n")
SLANG_RAW("///\n")
SLANG_RAW("/// White paper on SER on NVAPI https://developer.nvidia.com/sites/default/files/akamai/gameworks/ser-whitepaper.pdf\n")
SLANG_RAW("///\n")
SLANG_RAW("/// The NVAPI headers (R520) required for this functionality to work can be found here...\n")
SLANG_RAW("///\n")
SLANG_RAW("/// https://developer.nvidia.com/rtx/path-tracing/nvapi/get-started\n")
SLANG_RAW("///\n")
SLANG_RAW("/// For VK the specification is currently in this PR\n")
SLANG_RAW("///\n")
SLANG_RAW("/// https://github.com/KhronosGroup/GLSL/pull/196/files\n")
SLANG_RAW("\n")
SLANG_RAW("/// Internal helper functions\n")
SLANG_RAW("\n")
SLANG_RAW("// This is a bit of a hack for GLSL HitObjectAttributes\n")
SLANG_RAW("// It relies on [ForceInline] removing the surrounding function and just inserting the *contained* `t` as a global\n")
SLANG_RAW("// The __ref should indicate the desire for the returned value to not be a copy of t, but *t*.\n")
SLANG_RAW("// In practive __ref doesn't have this effect in practice.\n")
SLANG_RAW("// \n")
SLANG_RAW("// We need this to be able access the payload outside of a function (which is all that TraceRay for example needs)\n")
SLANG_RAW("// We access the HitObjectAttributes via this function for the desired type, and it acts *as if* it's just an access\n")
SLANG_RAW("// to the global t.\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("Ref<T> __hitObjectAttributes<T>()\n")
SLANG_RAW("{\n")
SLANG_RAW("    [__vulkanHitObjectAttributes]   \n")
SLANG_RAW("    static T t;\n")
SLANG_RAW("    return t;\n")
SLANG_RAW("}\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("Ptr<T> __allocHitObjectAttributes<T>()\n")
SLANG_RAW("{\n")
SLANG_RAW("    [__vulkanHitObjectAttributes]   \n")
SLANG_RAW("    static T t;\n")
SLANG_RAW("    return &t;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Next is the custom intrinsic that will compute the hitObjectAttributes location\n")
SLANG_RAW("// for GLSL-based targets.\n")
SLANG_RAW("//\n")
SLANG_RAW("__generic<Attributes>\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_GetVulkanRayTracingPayloadLocation
)
SLANG_RAW(")\n")
SLANG_RAW("int __hitObjectAttributesLocation(__ref Attributes attributes);\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Immutable data type representing a ray hit or a miss. Can be used to invoke hit or miss shading,\n")
SLANG_RAW("    /// or as a key in ReorderThread. Created by one of several methods described below. HitObject\n")
SLANG_RAW("    /// and its related functions are available in raytracing shader types only.\n")
SLANG_RAW("[__requiresNVAPI]\n")
SLANG_RAW("__glsl_extension(GL_NV_shader_invocation_reorder)\n")
SLANG_RAW("__glsl_extension(GL_EXT_ray_tracing)\n")
SLANG_RAW("[__NonCopyableType]\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_HitObjectType
)
SLANG_RAW(")\n")
SLANG_RAW("struct HitObject\n")
SLANG_RAW("{\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_AllocateOpaqueHandle
)
SLANG_RAW(")\n")
SLANG_RAW("    __init();\n")
SLANG_RAW("\n")
SLANG_RAW("        /// Executes ray traversal (including anyhit and intersection shaders) like TraceRay, but returns the\n")
SLANG_RAW("        /// resulting hit information as a HitObject and does not trigger closesthit or miss shaders.\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    static HitObject TraceRay<payload_t>(\n")
SLANG_RAW("        RaytracingAccelerationStructure AccelerationStructure,\n")
SLANG_RAW("        uint RayFlags,\n")
SLANG_RAW("        uint InstanceInclusionMask,\n")
SLANG_RAW("        uint RayContributionToHitGroupIndex,\n")
SLANG_RAW("        uint MultiplierForGeometryContributionToHitGroupIndex,\n")
SLANG_RAW("        uint MissShaderIndex,\n")
SLANG_RAW("        RayDesc Ray,\n")
SLANG_RAW("        inout payload_t Payload)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case hlsl:\n")
SLANG_RAW("            {\n")
SLANG_RAW("                HitObject hitObj;\n")
SLANG_RAW("                __hlslTraceRay(\n")
SLANG_RAW("                    AccelerationStructure, \n")
SLANG_RAW("                    RayFlags, \n")
SLANG_RAW("                    InstanceInclusionMask, \n")
SLANG_RAW("                    RayContributionToHitGroupIndex, \n")
SLANG_RAW("                    MultiplierForGeometryContributionToHitGroupIndex, \n")
SLANG_RAW("                    MissShaderIndex, \n")
SLANG_RAW("                    Ray, \n")
SLANG_RAW("                    Payload,\n")
SLANG_RAW("                    hitObj);\n")
SLANG_RAW("                return hitObj;\n")
SLANG_RAW("            }\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("            {\n")
SLANG_RAW("                [__vulkanRayPayload]\n")
SLANG_RAW("                static payload_t p;\n")
SLANG_RAW("\n")
SLANG_RAW("                // Save the payload\n")
SLANG_RAW("                p = Payload;\n")
SLANG_RAW("\n")
SLANG_RAW("                __glslTraceRay(\n")
SLANG_RAW("                    __return_val,\n")
SLANG_RAW("                    AccelerationStructure,\n")
SLANG_RAW("                    RayFlags,                                           // Assumes D3D/VK have some RayFlags values\n")
SLANG_RAW("                    InstanceInclusionMask,                              // cullMask\n")
SLANG_RAW("                    RayContributionToHitGroupIndex,                     // sbtRecordOffset\n")
SLANG_RAW("                    MultiplierForGeometryContributionToHitGroupIndex,   // sbtRecordStride\n")
SLANG_RAW("                    MissShaderIndex,\n")
SLANG_RAW("                    Ray.Origin,\n")
SLANG_RAW("                    Ray.TMin,\n")
SLANG_RAW("                    Ray.Direction, \n")
SLANG_RAW("                    Ray.TMax,\n")
SLANG_RAW("                    __rayPayloadLocation(p));\n")
SLANG_RAW("        \n")
SLANG_RAW("                // Write the payload out\n")
SLANG_RAW("                Payload = p;\n")
SLANG_RAW("            }\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            {\n")
SLANG_RAW("                [__vulkanRayPayload]\n")
SLANG_RAW("                static payload_t p;\n")
SLANG_RAW("\n")
SLANG_RAW("                // Save the payload\n")
SLANG_RAW("                p = Payload;\n")
SLANG_RAW("\n")
SLANG_RAW("                let origin = Ray.Origin;\n")
SLANG_RAW("                let direction = Ray.Direction;\n")
SLANG_RAW("                let tmin = Ray.TMin;\n")
SLANG_RAW("                let tmax = Ray.TMax;\n")
SLANG_RAW("                spirv_asm {\n")
SLANG_RAW("                    OpHitObjectTraceRayNV\n")
SLANG_RAW("                        /**/ &__return_val\n")
SLANG_RAW("                        /**/ $AccelerationStructure\n")
SLANG_RAW("                        /**/ $RayFlags\n")
SLANG_RAW("                        /**/ $InstanceInclusionMask\n")
SLANG_RAW("                        /**/ $RayContributionToHitGroupIndex\n")
SLANG_RAW("                        /**/ $MultiplierForGeometryContributionToHitGroupIndex\n")
SLANG_RAW("                        /**/ $MissShaderIndex\n")
SLANG_RAW("                        /**/ $origin\n")
SLANG_RAW("                        /**/ $tmin\n")
SLANG_RAW("                        /**/ $direction\n")
SLANG_RAW("                        /**/ $tmax\n")
SLANG_RAW("                        /**/ &p;\n")
SLANG_RAW("                };\n")
SLANG_RAW("\n")
SLANG_RAW("                // Write the payload out\n")
SLANG_RAW("                Payload = p;\n")
SLANG_RAW("            }\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("        /// Executes motion ray traversal (including anyhit and intersection shaders) like TraceRay, but returns the\n")
SLANG_RAW("        /// resulting hit information as a HitObject and does not trigger closesthit or miss shaders.\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    static HitObject TraceMotionRay<payload_t>( \n")
SLANG_RAW("        RaytracingAccelerationStructure AccelerationStructure, \n")
SLANG_RAW("        uint RayFlags, \n")
SLANG_RAW("        uint InstanceInclusionMask, \n")
SLANG_RAW("        uint RayContributionToHitGroupIndex, \n")
SLANG_RAW("        uint MultiplierForGeometryContributionToHitGroupIndex, \n")
SLANG_RAW("        uint MissShaderIndex, \n")
SLANG_RAW("        RayDesc Ray,\n")
SLANG_RAW("        float CurrentTime,\n")
SLANG_RAW("        inout payload_t Payload)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case hlsl:\n")
SLANG_RAW("            __intrinsic_asm \"TraceMotionRay\";\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("            {\n")
SLANG_RAW("                [__vulkanRayPayload]\n")
SLANG_RAW("                static payload_t p;\n")
SLANG_RAW("\n")
SLANG_RAW("                // Save the payload\n")
SLANG_RAW("                p = Payload;\n")
SLANG_RAW("\n")
SLANG_RAW("                __glslTraceMotionRay(\n")
SLANG_RAW("                    __return_val,\n")
SLANG_RAW("                    AccelerationStructure,\n")
SLANG_RAW("                    RayFlags,                                           // Assumes D3D/VK have some RayFlags values\n")
SLANG_RAW("                    InstanceInclusionMask,                              // cullMask\n")
SLANG_RAW("                    RayContributionToHitGroupIndex,                     // sbtRecordOffset\n")
SLANG_RAW("                    MultiplierForGeometryContributionToHitGroupIndex,   // sbtRecordStride\n")
SLANG_RAW("                    MissShaderIndex,\n")
SLANG_RAW("                    Ray.Origin,\n")
SLANG_RAW("                    Ray.TMin,\n")
SLANG_RAW("                    Ray.Direction, \n")
SLANG_RAW("                    Ray.TMax,\n")
SLANG_RAW("                    CurrentTime,\n")
SLANG_RAW("                    __rayPayloadLocation(p));\n")
SLANG_RAW("        \n")
SLANG_RAW("                // Write the payload out\n")
SLANG_RAW("                Payload = p;\n")
SLANG_RAW("            }\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            {\n")
SLANG_RAW("                [__vulkanRayPayload]\n")
SLANG_RAW("                static payload_t p;\n")
SLANG_RAW("\n")
SLANG_RAW("                // Save the payload\n")
SLANG_RAW("                p = Payload;\n")
SLANG_RAW("\n")
SLANG_RAW("                let origin = Ray.Origin;\n")
SLANG_RAW("                let direction = Ray.Direction;\n")
SLANG_RAW("                let tmin = Ray.TMin;\n")
SLANG_RAW("                let tmax = Ray.TMax;\n")
SLANG_RAW("                spirv_asm {\n")
SLANG_RAW("                    OpCapability RayTracingMotionBlurNV;\n")
SLANG_RAW("                    OpExtension \"SPV_NV_ray_tracing_motion_blur\";\n")
SLANG_RAW("                    OpHitObjectTraceRayMotionNV\n")
SLANG_RAW("                        /**/ &__return_val\n")
SLANG_RAW("                        /**/ $AccelerationStructure\n")
SLANG_RAW("                        /**/ $RayFlags\n")
SLANG_RAW("                        /**/ $InstanceInclusionMask\n")
SLANG_RAW("                        /**/ $RayContributionToHitGroupIndex\n")
SLANG_RAW("                        /**/ $MultiplierForGeometryContributionToHitGroupIndex\n")
SLANG_RAW("                        /**/ $MissShaderIndex\n")
SLANG_RAW("                        /**/ $origin\n")
SLANG_RAW("                        /**/ $tmin\n")
SLANG_RAW("                        /**/ $direction\n")
SLANG_RAW("                        /**/ $tmax\n")
SLANG_RAW("                        /**/ $CurrentTime\n")
SLANG_RAW("                        /**/ &p;\n")
SLANG_RAW("                };\n")
SLANG_RAW("        \n")
SLANG_RAW("                // Write the payload out\n")
SLANG_RAW("                Payload = p;\n")
SLANG_RAW("            }\n")
SLANG_RAW("        }\n")
SLANG_RAW("        \n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("        /// Creates a HitObject representing a hit based on values explicitly passed as arguments, without\n")
SLANG_RAW("        /// tracing a ray. The primitive specified by AccelerationStructure, InstanceIndex, GeometryIndex,\n")
SLANG_RAW("        /// and PrimitiveIndex must exist. The shader table index is computed using the formula used with\n")
SLANG_RAW("        /// TraceRay. The computed index must reference a valid hit group record in the shader table. The\n")
SLANG_RAW("        /// Attributes parameter must either be an attribute struct, such as\n")
SLANG_RAW("        /// BuiltInTriangleIntersectionAttributes, or another HitObject to copy the attributes from.\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    static HitObject MakeHit<attr_t>(\n")
SLANG_RAW("        RaytracingAccelerationStructure AccelerationStructure,\n")
SLANG_RAW("        uint InstanceIndex,\n")
SLANG_RAW("        uint GeometryIndex,\n")
SLANG_RAW("        uint PrimitiveIndex,\n")
SLANG_RAW("        uint HitKind,\n")
SLANG_RAW("        uint RayContributionToHitGroupIndex,\n")
SLANG_RAW("        uint MultiplierForGeometryContributionToHitGroupIndex,\n")
SLANG_RAW("        RayDesc Ray,\n")
SLANG_RAW("        attr_t attributes)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case hlsl:\n")
SLANG_RAW("            HitObject hitObj;\n")
SLANG_RAW("            __hlslMakeHit(\n")
SLANG_RAW("                AccelerationStructure, \n")
SLANG_RAW("                InstanceIndex,\n")
SLANG_RAW("                GeometryIndex,\n")
SLANG_RAW("                PrimitiveIndex,\n")
SLANG_RAW("                HitKind,\n")
SLANG_RAW("                RayContributionToHitGroupIndex,\n")
SLANG_RAW("                MultiplierForGeometryContributionToHitGroupIndex,\n")
SLANG_RAW("                Ray,\n")
SLANG_RAW("                attributes,\n")
SLANG_RAW("                hitObj);\n")
SLANG_RAW("            return hitObj;\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("            {\n")
SLANG_RAW("                // Save the attributes\n")
SLANG_RAW("                __ref attr_t attr = __hitObjectAttributes<attr_t>();\n")
SLANG_RAW("\n")
SLANG_RAW("                attr = attributes;\n")
SLANG_RAW("\n")
SLANG_RAW("                __glslMakeHit(\n")
SLANG_RAW("                    __return_val,\n")
SLANG_RAW("                    AccelerationStructure,\n")
SLANG_RAW("                    InstanceIndex,\n")
SLANG_RAW("                    PrimitiveIndex,\n")
SLANG_RAW("                    GeometryIndex,\n")
SLANG_RAW("                    HitKind,\n")
SLANG_RAW("                    RayContributionToHitGroupIndex,                         /// sbtRecordOffset?\n")
SLANG_RAW("                    MultiplierForGeometryContributionToHitGroupIndex,       /// sbtRecordStride?\n")
SLANG_RAW("                    Ray.Origin,\n")
SLANG_RAW("                    Ray.TMin,\n")
SLANG_RAW("                    Ray.Direction, \n")
SLANG_RAW("                    Ray.TMax,\n")
SLANG_RAW("                    __hitObjectAttributesLocation(__hitObjectAttributes<attr_t>()));\n")
SLANG_RAW("            }\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            {\n")
SLANG_RAW("                // Save the attributes\n")
SLANG_RAW("                Ptr<attr_t> attr = __allocHitObjectAttributes<attr_t>();\n")
SLANG_RAW("\n")
SLANG_RAW("                *attr = attributes;\n")
SLANG_RAW("\n")
SLANG_RAW("                let origin = Ray.Origin;\n")
SLANG_RAW("                let direction = Ray.Direction;\n")
SLANG_RAW("                let tmin = Ray.TMin;\n")
SLANG_RAW("                let tmax = Ray.TMax;\n")
SLANG_RAW("                spirv_asm {\n")
SLANG_RAW("                    OpHitObjectRecordHitNV\n")
SLANG_RAW("                        /**/ &__return_val\n")
SLANG_RAW("                        /**/ $AccelerationStructure\n")
SLANG_RAW("                        /**/ $InstanceIndex\n")
SLANG_RAW("                        /**/ $PrimitiveIndex\n")
SLANG_RAW("                        /**/ $GeometryIndex\n")
SLANG_RAW("                        /**/ $HitKind\n")
SLANG_RAW("                        /**/ $RayContributionToHitGroupIndex\n")
SLANG_RAW("                        /**/ $MultiplierForGeometryContributionToHitGroupIndex\n")
SLANG_RAW("                        /**/ $origin\n")
SLANG_RAW("                        /**/ $tmin\n")
SLANG_RAW("                        /**/ $direction\n")
SLANG_RAW("                        /**/ $tmax\n")
SLANG_RAW("                        /**/ $attr;\n")
SLANG_RAW("                };\n")
SLANG_RAW("            }\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("        /// See MakeHit but handles Motion \n")
SLANG_RAW("        /// Currently only supported on VK\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    static HitObject MakeMotionHit<attr_t>( \n")
SLANG_RAW("        RaytracingAccelerationStructure AccelerationStructure, \n")
SLANG_RAW("        uint InstanceIndex, \n")
SLANG_RAW("        uint GeometryIndex, \n")
SLANG_RAW("        uint PrimitiveIndex, \n")
SLANG_RAW("        uint HitKind, \n")
SLANG_RAW("        uint RayContributionToHitGroupIndex, \n")
SLANG_RAW("        uint MultiplierForGeometryContributionToHitGroupIndex, \n")
SLANG_RAW("        RayDesc Ray,\n")
SLANG_RAW("        float CurrentTime,\n")
SLANG_RAW("        attr_t attributes)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \"MakeMotionHit\";\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("        {\n")
SLANG_RAW("            // Save the attributes\n")
SLANG_RAW("            __ref attr_t attr = __hitObjectAttributes<attr_t>();\n")
SLANG_RAW("\n")
SLANG_RAW("            attr = attributes;\n")
SLANG_RAW("\n")
SLANG_RAW("            __glslMakeMotionHit(\n")
SLANG_RAW("                __return_val,\n")
SLANG_RAW("                AccelerationStructure,\n")
SLANG_RAW("                InstanceIndex,\n")
SLANG_RAW("                PrimitiveIndex,\n")
SLANG_RAW("                GeometryIndex,\n")
SLANG_RAW("                HitKind,\n")
SLANG_RAW("                RayContributionToHitGroupIndex,                         /// sbtRecordOffset?\n")
SLANG_RAW("                MultiplierForGeometryContributionToHitGroupIndex,       /// sbtRecordStride?\n")
SLANG_RAW("                Ray.Origin,\n")
SLANG_RAW("                Ray.TMin,\n")
SLANG_RAW("                Ray.Direction, \n")
SLANG_RAW("                Ray.TMax,\n")
SLANG_RAW("                CurrentTime,\n")
SLANG_RAW("                __hitObjectAttributesLocation(__hitObjectAttributes<attr_t>()));\n")
SLANG_RAW("        }\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("        {\n")
SLANG_RAW("            // Save the attributes\n")
SLANG_RAW("            Ptr<attr_t> attr = __allocHitObjectAttributes<attr_t>();\n")
SLANG_RAW("\n")
SLANG_RAW("            *attr = attributes;\n")
SLANG_RAW("\n")
SLANG_RAW("            let origin = Ray.Origin;\n")
SLANG_RAW("            let direction = Ray.Direction;\n")
SLANG_RAW("            let tmin = Ray.TMin;\n")
SLANG_RAW("            let tmax = Ray.TMax;\n")
SLANG_RAW("            spirv_asm {\n")
SLANG_RAW("                OpCapability RayTracingMotionBlurNV;\n")
SLANG_RAW("                OpExtension \"SPV_NV_ray_tracing_motion_blur\";\n")
SLANG_RAW("                OpHitObjectRecordHitMotionNV\n")
SLANG_RAW("                    /**/ &__return_val\n")
SLANG_RAW("                    /**/ $AccelerationStructure\n")
SLANG_RAW("                    /**/ $InstanceIndex\n")
SLANG_RAW("                    /**/ $PrimitiveIndex\n")
SLANG_RAW("                    /**/ $GeometryIndex\n")
SLANG_RAW("                    /**/ $HitKind\n")
SLANG_RAW("                    /**/ $RayContributionToHitGroupIndex\n")
SLANG_RAW("                    /**/ $MultiplierForGeometryContributionToHitGroupIndex\n")
SLANG_RAW("                    /**/ $origin\n")
SLANG_RAW("                    /**/ $tmin\n")
SLANG_RAW("                    /**/ $direction\n")
SLANG_RAW("                    /**/ $tmax\n")
SLANG_RAW("                    /**/ $CurrentTime\n")
SLANG_RAW("                    /**/ $attr;\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("        /// Creates a HitObject representing a hit based on values explicitly passed as arguments, without\n")
SLANG_RAW("        /// tracing a ray. The primitive specified by AccelerationStructure, InstanceIndex, GeometryIndex,\n")
SLANG_RAW("        /// and PrimitiveIndex must exist. The shader table index is explicitly provided as an argument\n")
SLANG_RAW("        /// instead of being computed from the indexing formula used in TraceRay. The provided index must\n")
SLANG_RAW("        /// reference a valid hit group record in the shader table. The Attributes parameter must either be an\n")
SLANG_RAW("        /// attribute struct, such as BuiltInTriangleIntersectionAttributes, or another HitObject to copy the\n")
SLANG_RAW("        /// attributes from.\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    static HitObject MakeHit<attr_t>(\n")
SLANG_RAW("        uint HitGroupRecordIndex,\n")
SLANG_RAW("        RaytracingAccelerationStructure AccelerationStructure,\n")
SLANG_RAW("        uint InstanceIndex,\n")
SLANG_RAW("        uint GeometryIndex,\n")
SLANG_RAW("        uint PrimitiveIndex,\n")
SLANG_RAW("        uint HitKind,\n")
SLANG_RAW("        RayDesc Ray,\n")
SLANG_RAW("        attr_t attributes)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case hlsl:\n")
SLANG_RAW("            HitObject hitObj;\n")
SLANG_RAW("            __hlslMakeHitWithRecordIndex(\n")
SLANG_RAW("                HitGroupRecordIndex, \n")
SLANG_RAW("                AccelerationStructure, \n")
SLANG_RAW("                InstanceIndex,\n")
SLANG_RAW("                GeometryIndex,\n")
SLANG_RAW("                PrimitiveIndex,\n")
SLANG_RAW("                HitKind,\n")
SLANG_RAW("                Ray,\n")
SLANG_RAW("                attributes,\n")
SLANG_RAW("                hitObj);\n")
SLANG_RAW("            return hitObj;\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("        {\n")
SLANG_RAW("            // Save the attributes\n")
SLANG_RAW("            __ref attr_t attr = __hitObjectAttributes<attr_t>();\n")
SLANG_RAW("            attr = attributes;\n")
SLANG_RAW("\n")
SLANG_RAW("            __glslMakeHitWithIndex(\n")
SLANG_RAW("                __return_val,\n")
SLANG_RAW("                AccelerationStructure, \n")
SLANG_RAW("                InstanceIndex,              ///? Same as instanceid ?\n")
SLANG_RAW("                GeometryIndex, \n")
SLANG_RAW("                PrimitiveIndex,\n")
SLANG_RAW("                HitKind,                    /// Assuming HitKinds are compatible\n")
SLANG_RAW("                HitGroupRecordIndex,        /// sbtRecordIndex\n")
SLANG_RAW("                Ray.Origin,\n")
SLANG_RAW("                Ray.TMin,\n")
SLANG_RAW("                Ray.Direction, \n")
SLANG_RAW("                Ray.TMax,\n")
SLANG_RAW("                __hitObjectAttributesLocation(__hitObjectAttributes<attr_t>()));\n")
SLANG_RAW("        }\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("        {\n")
SLANG_RAW("            // Save the attributes\n")
SLANG_RAW("            Ptr<attr_t> attr = __allocHitObjectAttributes<attr_t>();\n")
SLANG_RAW("            *attr = attributes;\n")
SLANG_RAW("            let origin = Ray.Origin;\n")
SLANG_RAW("            let direction = Ray.Direction;\n")
SLANG_RAW("            let tmin = Ray.TMin;\n")
SLANG_RAW("            let tmax = Ray.TMax;\n")
SLANG_RAW("            spirv_asm {\n")
SLANG_RAW("                OpHitObjectRecordHitWithIndexNV\n")
SLANG_RAW("                    /**/ &__return_val\n")
SLANG_RAW("                    /**/ $AccelerationStructure\n")
SLANG_RAW("                    /**/ $InstanceIndex\n")
SLANG_RAW("                    /**/ $PrimitiveIndex\n")
SLANG_RAW("                    /**/ $GeometryIndex\n")
SLANG_RAW("                    /**/ $HitKind\n")
SLANG_RAW("                    /**/ $HitGroupRecordIndex\n")
SLANG_RAW("                    /**/ $origin\n")
SLANG_RAW("                    /**/ $tmin\n")
SLANG_RAW("                    /**/ $direction\n")
SLANG_RAW("                    /**/ $tmax\n")
SLANG_RAW("                    /**/ $attr;\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("        /// See MakeHit but handles Motion \n")
SLANG_RAW("        /// Currently only supported on VK\n")
SLANG_RAW("\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    static HitObject MakeMotionHit<attr_t>( \n")
SLANG_RAW("        uint HitGroupRecordIndex, \n")
SLANG_RAW("        RaytracingAccelerationStructure AccelerationStructure, \n")
SLANG_RAW("        uint InstanceIndex, \n")
SLANG_RAW("        uint GeometryIndex, \n")
SLANG_RAW("        uint PrimitiveIndex, \n")
SLANG_RAW("        uint HitKind, \n")
SLANG_RAW("        RayDesc Ray, \n")
SLANG_RAW("        float CurrentTime,\n")
SLANG_RAW("        attr_t attributes)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("        {\n")
SLANG_RAW("            // Save the attributes\n")
SLANG_RAW("            __ref attr_t attr = __hitObjectAttributes<attr_t>();\n")
SLANG_RAW("            attr = attributes;\n")
SLANG_RAW("\n")
SLANG_RAW("            __glslMakeMotionHitWithIndex(\n")
SLANG_RAW("                __return_val,\n")
SLANG_RAW("                AccelerationStructure, \n")
SLANG_RAW("                InstanceIndex,              ///? Same as instanceid ?\n")
SLANG_RAW("                GeometryIndex, \n")
SLANG_RAW("                PrimitiveIndex,\n")
SLANG_RAW("                HitKind,                    /// Assuming HitKinds are compatible\n")
SLANG_RAW("                HitGroupRecordIndex,        /// sbtRecordIndex\n")
SLANG_RAW("                Ray.Origin,\n")
SLANG_RAW("                Ray.TMin,\n")
SLANG_RAW("                Ray.Direction, \n")
SLANG_RAW("                Ray.TMax,\n")
SLANG_RAW("                CurrentTime,\n")
SLANG_RAW("                __hitObjectAttributesLocation(__hitObjectAttributes<attr_t>()));\n")
SLANG_RAW("        }\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("        {\n")
SLANG_RAW("            // Save the attributes\n")
SLANG_RAW("            Ptr<attr_t> attr = __allocHitObjectAttributes<attr_t>();\n")
SLANG_RAW("            *attr = attributes;\n")
SLANG_RAW("            let origin = Ray.Origin;\n")
SLANG_RAW("            let direction = Ray.Direction;\n")
SLANG_RAW("            let tmin = Ray.TMin;\n")
SLANG_RAW("            let tmax = Ray.TMax;\n")
SLANG_RAW("            spirv_asm {\n")
SLANG_RAW("                OpCapability RayTracingMotionBlurNV;\n")
SLANG_RAW("                OpExtension \"SPV_NV_ray_tracing_motion_blur\";\n")
SLANG_RAW("                OpHitObjectRecordHitWithIndexMotionNV\n")
SLANG_RAW("                    /**/ &__return_val\n")
SLANG_RAW("                    /**/ $AccelerationStructure\n")
SLANG_RAW("                    /**/ $InstanceIndex\n")
SLANG_RAW("                    /**/ $PrimitiveIndex\n")
SLANG_RAW("                    /**/ $GeometryIndex\n")
SLANG_RAW("                    /**/ $HitKind\n")
SLANG_RAW("                    /**/ $HitGroupRecordIndex\n")
SLANG_RAW("                    /**/ $origin\n")
SLANG_RAW("                    /**/ $tmin\n")
SLANG_RAW("                    /**/ $direction\n")
SLANG_RAW("                    /**/ $tmax\n")
SLANG_RAW("                    /**/ $CurrentTime\n")
SLANG_RAW("                    /**/ $attr;\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("        /// Creates a HitObject representing a miss based on values explicitly passed as arguments, without\n")
SLANG_RAW("        /// tracing a ray. The provided shader table index must reference a valid miss record in the shader\n")
SLANG_RAW("        /// table.\n")
SLANG_RAW("    [__requiresNVAPI]\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    static HitObject MakeMiss( \n")
SLANG_RAW("        uint MissShaderIndex, \n")
SLANG_RAW("        RayDesc Ray)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \"($2=NvMakeMiss($0,$1))\";\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("            __glslMakeMiss(__return_val, MissShaderIndex, Ray.Origin, Ray.TMin, Ray.Direction, Ray.TMax);\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            {\n")
SLANG_RAW("                let origin = Ray.Origin;\n")
SLANG_RAW("                let direction = Ray.Direction;\n")
SLANG_RAW("                let tmin = Ray.TMin;\n")
SLANG_RAW("                let tmax = Ray.TMax;\n")
SLANG_RAW("                spirv_asm {\n")
SLANG_RAW("                    OpHitObjectRecordMissNV\n")
SLANG_RAW("                        /**/ &__return_val\n")
SLANG_RAW("                        /**/ $MissShaderIndex\n")
SLANG_RAW("                        /**/ $origin\n")
SLANG_RAW("                        /**/ $tmin\n")
SLANG_RAW("                        /**/ $direction\n")
SLANG_RAW("                        /**/ $tmax;\n")
SLANG_RAW("                };\n")
SLANG_RAW("            }\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("        /// See MakeMiss but handles Motion \n")
SLANG_RAW("        /// Currently only supported on VK\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    __specialized_for_target(glsl)\n")
SLANG_RAW("    static HitObject MakeMotionMiss( \n")
SLANG_RAW("        uint MissShaderIndex, \n")
SLANG_RAW("        RayDesc Ray,\n")
SLANG_RAW("        float CurrentTime)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \"($3=NvMakeMotionMiss($0,$1,$2))\";\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("            __glslMakeMotionMiss(__return_val, MissShaderIndex, Ray.Origin, Ray.TMin, Ray.Direction, Ray.TMax, CurrentTime);\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            {\n")
SLANG_RAW("                let origin = Ray.Origin;\n")
SLANG_RAW("                let direction = Ray.Direction;\n")
SLANG_RAW("                let tmin = Ray.TMin;\n")
SLANG_RAW("                let tmax = Ray.TMax;\n")
SLANG_RAW("                spirv_asm {\n")
SLANG_RAW("                    OpCapability RayTracingMotionBlurNV;\n")
SLANG_RAW("                    OpExtension \"SPV_NV_ray_tracing_motion_blur\";\n")
SLANG_RAW("                    OpHitObjectRecordMissMotionNV\n")
SLANG_RAW("                        /**/ &__return_val\n")
SLANG_RAW("                        /**/ $MissShaderIndex\n")
SLANG_RAW("                        /**/ $origin\n")
SLANG_RAW("                        /**/ $tmin\n")
SLANG_RAW("                        /**/ $direction\n")
SLANG_RAW("                        /**/ $tmax\n")
SLANG_RAW("                        /**/ $CurrentTime;\n")
SLANG_RAW("                };\n")
SLANG_RAW("            }\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("        /// Creates a HitObject representing 429496726642949671684294967196NOP429496726642949671684294967197 (no operation) which is neither a hit nor a miss. Invoking a\n")
SLANG_RAW("        /// NOP hit object using HitObject::Invoke has no effect. Reordering by hit objects using\n")
SLANG_RAW("        /// ReorderThread will group NOP hit objects together. This can be useful in some reordering\n")
SLANG_RAW("        /// scenarios where future control flow for some threads is known to process neither a hit nor a\n")
SLANG_RAW("        /// miss.\n")
SLANG_RAW("    [__requiresNVAPI]\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    static HitObject MakeNop()\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case hlsl:\n")
SLANG_RAW("            __intrinsic_asm \"($0 = NvMakeNop())\";\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("            __glslMakeNop(__return_val);\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            spirv_asm {\n")
SLANG_RAW("                OpHitObjectRecordEmptyNV\n")
SLANG_RAW("                    /**/ &__return_val;\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("        /// Invokes closesthit or miss shading for the specified hit object. In case of a NOP HitObject, no\n")
SLANG_RAW("        /// shader is invoked.\n")
SLANG_RAW("    [__requiresNVAPI]\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    static void Invoke<payload_t>(\n")
SLANG_RAW("        RaytracingAccelerationStructure AccelerationStructure,\n")
SLANG_RAW("        HitObject HitOrMiss,\n")
SLANG_RAW("        inout payload_t Payload)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \"NvInvokeHitObject\";\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("            {\n")
SLANG_RAW("                [__vulkanRayPayload]\n")
SLANG_RAW("                static payload_t p;\n")
SLANG_RAW("\n")
SLANG_RAW("                // Save the payload\n")
SLANG_RAW("                p = Payload;\n")
SLANG_RAW("\n")
SLANG_RAW("                __glslInvoke(HitOrMiss, __rayPayloadLocation(p));\n")
SLANG_RAW("\n")
SLANG_RAW("                // Write payload result\n")
SLANG_RAW("                Payload = p;\n")
SLANG_RAW("            }\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            {\n")
SLANG_RAW("                [__vulkanRayPayload]\n")
SLANG_RAW("                static payload_t p;\n")
SLANG_RAW("\n")
SLANG_RAW("                // Save the payload\n")
SLANG_RAW("                p = Payload;\n")
SLANG_RAW("\n")
SLANG_RAW("                spirv_asm {\n")
SLANG_RAW("                    OpHitObjectExecuteShaderNV\n")
SLANG_RAW("                        /**/ &HitOrMiss\n")
SLANG_RAW("                        /**/ &p;\n")
SLANG_RAW("                };\n")
SLANG_RAW("\n")
SLANG_RAW("                // Write payload result\n")
SLANG_RAW("                Payload = p;\n")
SLANG_RAW("            }\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("        /// Returns true if the HitObject encodes a miss, otherwise returns false.\n")
SLANG_RAW("    [__requiresNVAPI]\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    __glsl_extension(GL_EXT_ray_tracing)\n")
SLANG_RAW("    bool IsMiss()\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".IsMiss\";\n")
SLANG_RAW("        case glsl: __intrinsic_asm \"hitObjectIsMissNV($0)\";\n")
SLANG_RAW("        case spirv: return spirv_asm {\n")
SLANG_RAW("                result:$$bool = OpHitObjectIsMissNV &this;\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("        /// Returns true if the HitObject encodes a hit, otherwise returns false.\n")
SLANG_RAW("    [__requiresNVAPI]\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    __glsl_extension(GL_EXT_ray_tracing)\n")
SLANG_RAW("    bool IsHit()\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".IsHit\";\n")
SLANG_RAW("        case glsl: __intrinsic_asm \"hitObjectIsHitNV($0)\";\n")
SLANG_RAW("        case spirv: return spirv_asm {\n")
SLANG_RAW("                result:$$bool = OpHitObjectIsHitNV &this;\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("        /// Returns true if the HitObject encodes a nop, otherwise returns false.\n")
SLANG_RAW("    [__requiresNVAPI]\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    __glsl_extension(GL_EXT_ray_tracing)\n")
SLANG_RAW("    bool IsNop()\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".IsNop\";\n")
SLANG_RAW("        case glsl: __intrinsic_asm \"hitObjectIsEmptyNV($0)\";\n")
SLANG_RAW("        case spirv: return spirv_asm {\n")
SLANG_RAW("                result:$$bool = OpHitObjectIsEmptyNV &this;\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("        /// Queries ray properties from HitObject. Valid if the hit object represents a hit or a miss.\n")
SLANG_RAW("    [__requiresNVAPI]\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    __target_intrinsic(hlsl)\n")
SLANG_RAW("    RayDesc GetRayDesc()\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case hlsl:\n")
SLANG_RAW("            __intrinsic_asm \".GetRayDesc\";\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("            {\n")
SLANG_RAW("                RayDesc ray = { __glslGetRayWorldOrigin(), __glslGetTMin(), __glslGetRayWorldDirection(), __glslGetTMax() };\n")
SLANG_RAW("                return ray;\n")
SLANG_RAW("            }\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            return spirv_asm {\n")
SLANG_RAW("                %origin:$$float3 = OpHitObjectGetWorldRayOriginNV &this;\n")
SLANG_RAW("                %tmin:$$float = OpHitObjectGetRayTMinNV &this;\n")
SLANG_RAW("                %direction:$$float3 = OpHitObjectGetWorldRayDirectionNV &this;\n")
SLANG_RAW("                %tmax:$$float = OpHitObjectGetRayTMaxNV &this;\n")
SLANG_RAW("                result:$$RayDesc = OpCompositeConstruct %origin %tmin %direction %tmax;\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("        /// Queries shader table index from HitObject. Valid if the hit object represents a hit or a miss.\n")
SLANG_RAW("    [__requiresNVAPI]\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    __glsl_extension(GL_EXT_ray_tracing)\n")
SLANG_RAW("    uint GetShaderTableIndex()\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".GetShaderTableIndex\";\n")
SLANG_RAW("        case glsl: __intrinsic_asm \"hitObjectGetShaderBindingTableRecordIndexNV($0)\";\n")
SLANG_RAW("        case spirv: return spirv_asm {\n")
SLANG_RAW("                result:$$uint = OpHitObjectGetShaderBindingTableRecordIndexNV &this;\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("        /// Returns the instance index of a hit. Valid if the hit object represents a hit.\n")
SLANG_RAW("    [__requiresNVAPI]\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    __glsl_extension(GL_EXT_ray_tracing)\n")
SLANG_RAW("    uint GetInstanceIndex()\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".GetInstanceIndex\";\n")
SLANG_RAW("        case glsl: __intrinsic_asm \"hitObjectGetInstanceIdNV($0)\";\n")
SLANG_RAW("        case spirv: return spirv_asm {\n")
SLANG_RAW("                result:$$uint = OpHitObjectGetInstanceIdNV &this;\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("        /// Returns the instance ID of a hit. Valid if the hit object represents a hit.\n")
SLANG_RAW("    [__requiresNVAPI]\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    __glsl_extension(GL_EXT_ray_tracing)\n")
SLANG_RAW("    uint GetInstanceID()\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".GetInstanceID\";\n")
SLANG_RAW("        case glsl: __intrinsic_asm \"hitObjectGetInstanceCustomIndexNV($0)\";\n")
SLANG_RAW("        case spirv: return spirv_asm {\n")
SLANG_RAW("                result:$$uint = OpHitObjectGetInstanceCustomIndexNV &this;\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("        /// Returns the geometry index of a hit. Valid if the hit object represents a hit.\n")
SLANG_RAW("    [__requiresNVAPI]\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    __glsl_extension(GL_EXT_ray_tracing)\n")
SLANG_RAW("    uint GetGeometryIndex()\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".GetGeometryIndex\";\n")
SLANG_RAW("        case glsl: __intrinsic_asm \"hitObjectGetGeometryIndexNV($0)\";\n")
SLANG_RAW("        case spirv: return spirv_asm {\n")
SLANG_RAW("                result:$$uint = OpHitObjectGetGeometryIndexNV &this;\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("        /// Returns the primitive index of a hit. Valid if the hit object represents a hit.\n")
SLANG_RAW("    [__requiresNVAPI]\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    __glsl_extension(GL_EXT_ray_tracing)\n")
SLANG_RAW("    uint GetPrimitiveIndex()\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".GetPrimitiveIndex\";\n")
SLANG_RAW("        case glsl: __intrinsic_asm \"hitObjectGetPrimitiveIndexNV($0)\";\n")
SLANG_RAW("        case spirv: return spirv_asm {\n")
SLANG_RAW("                result:$$uint = OpHitObjectGetPrimitiveIndexNV &this;\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("        /// Returns the hit kind. Valid if the hit object represents a hit.\n")
SLANG_RAW("    [__requiresNVAPI]\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    __glsl_extension(GL_EXT_ray_tracing)\n")
SLANG_RAW("    uint GetHitKind()\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".GetHitKind\";\n")
SLANG_RAW("        case glsl: __intrinsic_asm \"hitObjectGetHitKindNV($0)\";\n")
SLANG_RAW("        case spirv: return spirv_asm {\n")
SLANG_RAW("                result:$$uint = OpHitObjectGetHitKindNV &this;\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__requiresNVAPI]\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    __glsl_extension(GL_EXT_ray_tracing)\n")
SLANG_RAW("    float4x3 GetWorldToObject()\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".GetWorldToObject\";\n")
SLANG_RAW("        case glsl: __intrinsic_asm \"hitObjectGetWorldToObjectNV($0)\";\n")
SLANG_RAW("        case spirv: return spirv_asm {\n")
SLANG_RAW("                result:$$float4x3 = OpHitObjectGetWorldToObjectNV &this;\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__requiresNVAPI]\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    __glsl_extension(GL_EXT_ray_tracing)\n")
SLANG_RAW("    float4x3 GetObjectToWorld()\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case hlsl: __intrinsic_asm \".GetObjectToWorld\";\n")
SLANG_RAW("        case glsl: __intrinsic_asm \"hitObjectGetObjectToWorldNV($0)\";\n")
SLANG_RAW("        case spirv: return spirv_asm {\n")
SLANG_RAW("                result:$$float4x3 = OpHitObjectGetObjectToWorldNV &this;\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("        /// Returns the attributes of a hit. Valid if the hit object represents a hit or a miss.\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    attr_t GetAttributes<attr_t>()\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case hlsl:\n")
SLANG_RAW("            {\n")
SLANG_RAW("                attr_t v;\n")
SLANG_RAW("                __hlslGetAttributesFromHitObject(v);\n")
SLANG_RAW("                return v;\n")
SLANG_RAW("            }\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("            {\n")
SLANG_RAW("                // Work out the location\n")
SLANG_RAW("                int attributeLocation = __hitObjectAttributesLocation(__hitObjectAttributes<attr_t>());\n")
SLANG_RAW("\n")
SLANG_RAW("                // Load the attributes from the location\n")
SLANG_RAW("                __glslGetAttributes(attributeLocation);\n")
SLANG_RAW("\n")
SLANG_RAW("                // Return the attributes\n")
SLANG_RAW("                return __hitObjectAttributes<attr_t>();\n")
SLANG_RAW("            }\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            {\n")
SLANG_RAW("                Ptr<attr_t> attr = __allocHitObjectAttributes<attr_t>();\n")
SLANG_RAW("                spirv_asm {\n")
SLANG_RAW("                    OpHitObjectGetAttributesNV &this $attr;\n")
SLANG_RAW("                };\n")
SLANG_RAW("                return *attr;\n")
SLANG_RAW("            }\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("        /// Loads a root constant from the local root table referenced by the hit object. Valid if the hit object\n")
SLANG_RAW("        /// represents a hit or a miss. RootConstantOffsetInBytes must be a multiple of 4.\n")
SLANG_RAW("    __target_intrinsic(hlsl)\n")
SLANG_RAW("    [__requiresNVAPI]\n")
SLANG_RAW("    uint LoadLocalRootTableConstant(uint RootConstantOffsetInBytes);\n")
SLANG_RAW("\n")
SLANG_RAW("    /// \n")
SLANG_RAW("    /// !!!! Internal NVAPI HLSL impl. Not part of interface! !!!!!!!!!!!!\n")
SLANG_RAW("    /// \n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(hlsl, \"NvGetAttributesFromHitObject($0, $1)\")\n")
SLANG_RAW("    [__requiresNVAPI]\n")
SLANG_RAW("    void __hlslGetAttributesFromHitObject<T>(out T t);\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(hlsl, \"NvMakeHitWithRecordIndex\")\n")
SLANG_RAW("    [__requiresNVAPI]\n")
SLANG_RAW("    static void __hlslMakeHitWithRecordIndex<attr_t>(\n")
SLANG_RAW("        uint HitGroupRecordIndex, \n")
SLANG_RAW("        RaytracingAccelerationStructure AccelerationStructure, \n")
SLANG_RAW("        uint InstanceIndex, \n")
SLANG_RAW("        uint GeometryIndex, \n")
SLANG_RAW("        uint PrimitiveIndex, \n")
SLANG_RAW("        uint HitKind, \n")
SLANG_RAW("        RayDesc Ray, \n")
SLANG_RAW("        attr_t attributes, \n")
SLANG_RAW("        out HitObject hitObj);\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(hlsl, \"NvMakeHit\")\n")
SLANG_RAW("    [__requiresNVAPI]\n")
SLANG_RAW("    static void __hlslMakeHit<attr_t>(RaytracingAccelerationStructure AccelerationStructure, \n")
SLANG_RAW("        uint InstanceIndex, \n")
SLANG_RAW("        uint GeometryIndex, \n")
SLANG_RAW("        uint PrimitiveIndex, \n")
SLANG_RAW("        uint HitKind, \n")
SLANG_RAW("        uint RayContributionToHitGroupIndex, \n")
SLANG_RAW("        uint MultiplierForGeometryContributionToHitGroupIndex, \n")
SLANG_RAW("        RayDesc Ray, \n")
SLANG_RAW("        attr_t attributes, \n")
SLANG_RAW("        out HitObject hitObj);\n")
SLANG_RAW("\n")
SLANG_RAW("    __target_intrinsic(hlsl, \"NvTraceRayHitObject\")\n")
SLANG_RAW("    [__requiresNVAPI]\n")
SLANG_RAW("    static void __hlslTraceRay<payload_t>( \n")
SLANG_RAW("        RaytracingAccelerationStructure AccelerationStructure, \n")
SLANG_RAW("        uint RayFlags, \n")
SLANG_RAW("        uint InstanceInclusionMask, \n")
SLANG_RAW("        uint RayContributionToHitGroupIndex, \n")
SLANG_RAW("        uint MultiplierForGeometryContributionToHitGroupIndex, \n")
SLANG_RAW("        uint MissShaderIndex, \n")
SLANG_RAW("        RayDesc Ray, \n")
SLANG_RAW("        inout payload_t Payload,\n")
SLANG_RAW("        out HitObject hitObj);\n")
SLANG_RAW("\n")
SLANG_RAW("    /// \n")
SLANG_RAW("    /// !!!! Internal GLSL GL_NV_shader_invocation_reorder impl. Not part of interface! !!!!!!!!!!!!\n")
SLANG_RAW("    /// \n")
SLANG_RAW("\n")
SLANG_RAW("    __glsl_extension(GL_NV_shader_invocation_reorder)\n")
SLANG_RAW("    __glsl_extension(GL_EXT_ray_tracing)\n")
SLANG_RAW("    __glsl_version(460)\n")
SLANG_RAW("    __target_intrinsic(glsl, \"hitObjectRecordMissNV\")\n")
SLANG_RAW("    static void __glslMakeMiss(\n")
SLANG_RAW("        out HitObject hitObj,\n")
SLANG_RAW("        uint MissShaderIndex,\n")
SLANG_RAW("        float3 Origin,\n")
SLANG_RAW("        float TMin,\n")
SLANG_RAW("        float3 Direction,\n")
SLANG_RAW("        float TMax);\n")
SLANG_RAW("\n")
SLANG_RAW("    // \"void hitObjectRecordMissNV(hitObjectNV, uint, vec3, float, vec3, float);\"\n")
SLANG_RAW("    __glsl_extension(GL_NV_shader_invocation_reorder)\n")
SLANG_RAW("    __glsl_extension(GL_EXT_ray_tracing)\n")
SLANG_RAW("    __glsl_extension(GL_NV_ray_tracing_motion_blur)\n")
SLANG_RAW("    __glsl_version(460)\n")
SLANG_RAW("    __target_intrinsic(glsl, \"hitObjectRecordMissMotionNV\")\n")
SLANG_RAW("    static void __glslMakeMotionMiss(\n")
SLANG_RAW("        out HitObject hitObj,\n")
SLANG_RAW("        uint MissShaderIndex,\n")
SLANG_RAW("        float3 Origin,\n")
SLANG_RAW("        float TMin,\n")
SLANG_RAW("        float3 Direction,\n")
SLANG_RAW("        float TMax, \n")
SLANG_RAW("        float CurrentTime);\n")
SLANG_RAW("\n")
SLANG_RAW("    __glsl_extension(GL_NV_shader_invocation_reorder)\n")
SLANG_RAW("    __glsl_extension(GL_EXT_ray_tracing)\n")
SLANG_RAW("    __target_intrinsic(glsl, \"hitObjectRecordEmptyNV\")\n")
SLANG_RAW("    static void __glslMakeNop(out HitObject hitObj);\n")
SLANG_RAW("\n")
SLANG_RAW("    __glsl_extension(GL_NV_shader_invocation_reorder)\n")
SLANG_RAW("    __target_intrinsic(glsl, \"hitObjectGetObjectRayDirectionNV($0)\")\n")
SLANG_RAW("    float3 __glslGetRayDirection();\n")
SLANG_RAW("\n")
SLANG_RAW("    __glsl_extension(GL_NV_shader_invocation_reorder)\n")
SLANG_RAW("    __target_intrinsic(glsl, \"hitObjectGetWorldRayDirectionNV($0)\")\n")
SLANG_RAW("    float3 __glslGetRayWorldDirection();\n")
SLANG_RAW("\n")
SLANG_RAW("    __glsl_extension(GL_NV_shader_invocation_reorder)\n")
SLANG_RAW("    __target_intrinsic(glsl, \"hitObjectGetWorldRayOriginNV($0)\")\n")
SLANG_RAW("    float3 __glslGetRayWorldOrigin();\n")
SLANG_RAW("\n")
SLANG_RAW("    __glsl_extension(GL_NV_shader_invocation_reorder)\n")
SLANG_RAW("    __target_intrinsic(glsl, \"hitObjectGetRayTMaxNV($0)\")\n")
SLANG_RAW("    float __glslGetTMax();\n")
SLANG_RAW("\n")
SLANG_RAW("    __glsl_extension(GL_NV_shader_invocation_reorder)\n")
SLANG_RAW("    __target_intrinsic(glsl, \"hitObjectGetRayTMinNV($0)\")\n")
SLANG_RAW("    float __glslGetTMin();\n")
SLANG_RAW("\n")
SLANG_RAW("    // \"void hitObjectRecordHitWithIndexNV(hitObjectNV, accelerationStructureEXT,int,int,int,uint,uint,vec3,float,vec3,float,int);\"\n")
SLANG_RAW("    __glsl_extension(GL_NV_shader_invocation_reorder)\n")
SLANG_RAW("    __glsl_extension(GL_EXT_ray_tracing)\n")
SLANG_RAW("    __glsl_version(460)\n")
SLANG_RAW("    __target_intrinsic(glsl, \"hitObjectRecordHitWithIndexNV\")\n")
SLANG_RAW("    static void __glslMakeHitWithIndex(\n")
SLANG_RAW("        out HitObject hitObj,\n")
SLANG_RAW("        RaytracingAccelerationStructure accelerationStructure,\n")
SLANG_RAW("        int instanceid,\n")
SLANG_RAW("        int primitiveid,\n")
SLANG_RAW("        int geometryindex,\n")
SLANG_RAW("        uint hitKind,\n")
SLANG_RAW("        uint sbtRecordIndex,\n")
SLANG_RAW("        float3 origin,\n")
SLANG_RAW("        float Tmin,\n")
SLANG_RAW("        float3 direction,\n")
SLANG_RAW("        float Tmax,\n")
SLANG_RAW("        int attributeLocation);\n")
SLANG_RAW("\n")
SLANG_RAW("    //  \"void hitObjectRecordHitWithIndexMotionNV(hitObjectNV, accelerationStructureEXT,int,int,int,uint,uint,vec3,float,vec3,float,float,int);\"\n")
SLANG_RAW("    __glsl_extension(GL_NV_shader_invocation_reorder)\n")
SLANG_RAW("    __glsl_extension(GL_EXT_ray_tracing)\n")
SLANG_RAW("    __glsl_extension(GL_NV_ray_tracing_motion_blur)\n")
SLANG_RAW("    __target_intrinsic(glsl, \"hitObjectRecordHitWithIndexMotionNV\")\n")
SLANG_RAW("    static void __glslMakeMotionHitWithIndex(\n")
SLANG_RAW("        out HitObject hitObj,\n")
SLANG_RAW("        RaytracingAccelerationStructure accelerationStructure,\n")
SLANG_RAW("        int instanceid,\n")
SLANG_RAW("        int primitiveid,\n")
SLANG_RAW("        int geometryindex,\n")
SLANG_RAW("        uint hitKind,\n")
SLANG_RAW("        uint sbtRecordIndex,\n")
SLANG_RAW("        float3 origin,\n")
SLANG_RAW("        float Tmin,\n")
SLANG_RAW("        float3 direction,\n")
SLANG_RAW("        float Tmax,\n")
SLANG_RAW("        float CurrentTime,\n")
SLANG_RAW("        int attributeLocation);\n")
SLANG_RAW("\n")
SLANG_RAW("    // \"void hitObjectRecordHitNV(hitObjectNV,accelerationStructureEXT,int,int,int,uint,uint,uint,vec3,float,vec3,float,int);\"\n")
SLANG_RAW("    __glsl_extension(GL_EXT_ray_tracing)\n")
SLANG_RAW("    __glsl_extension(GL_NV_shader_invocation_reorder)\n")
SLANG_RAW("    __target_intrinsic(glsl, \"hitObjectRecordHitNV\")\n")
SLANG_RAW("    static void __glslMakeHit(\n")
SLANG_RAW("        out HitObject hitObj,\n")
SLANG_RAW("        RaytracingAccelerationStructure accelerationStructure,\n")
SLANG_RAW("        int instanceid,\n")
SLANG_RAW("        int primitiveid,\n")
SLANG_RAW("        int geometryindex,\n")
SLANG_RAW("        uint hitKind,\n")
SLANG_RAW("        uint sbtRecordOffset,\n")
SLANG_RAW("        uint sbtRecordStride,\n")
SLANG_RAW("        float3 origin,\n")
SLANG_RAW("        float Tmin,\n")
SLANG_RAW("        float3 direction,\n")
SLANG_RAW("        float Tmax,\n")
SLANG_RAW("        int attributeLocation);\n")
SLANG_RAW("\n")
SLANG_RAW("        // \"void hitObjectRecordHitMotionNV(hitObjectNV,accelerationStructureEXT,int,int,int,uint,uint,uint,vec3,float,vec3,float,float,int);\"\n")
SLANG_RAW("    __glsl_extension(GL_EXT_ray_tracing)\n")
SLANG_RAW("    __glsl_extension(GL_NV_shader_invocation_reorder)\n")
SLANG_RAW("    __glsl_extension(GL_NV_ray_tracing_motion_blur)\n")
SLANG_RAW("    __target_intrinsic(glsl, \"hitObjectRecordHitMotionNV\")\n")
SLANG_RAW("    static void __glslMakeMotionHit(\n")
SLANG_RAW("        out HitObject hitObj,\n")
SLANG_RAW("        RaytracingAccelerationStructure accelerationStructure,\n")
SLANG_RAW("        int instanceid,\n")
SLANG_RAW("        int primitiveid,\n")
SLANG_RAW("        int geometryindex,\n")
SLANG_RAW("        uint hitKind,\n")
SLANG_RAW("        uint sbtRecordOffset,\n")
SLANG_RAW("        uint sbtRecordStride,\n")
SLANG_RAW("        float3 origin,\n")
SLANG_RAW("        float Tmin,\n")
SLANG_RAW("        float3 direction,\n")
SLANG_RAW("        float Tmax,\n")
SLANG_RAW("        float CurrentTime,\n")
SLANG_RAW("        int attributeLocation);\n")
SLANG_RAW("\n")
SLANG_RAW("    \n")
SLANG_RAW("    __glsl_extension(GL_EXT_ray_tracing)\n")
SLANG_RAW("    __glsl_extension(GL_NV_shader_invocation_reorder)\n")
SLANG_RAW("    __target_intrinsic(glsl, \"hitObjectGetAttributesNV($0, $1)\")\n")
SLANG_RAW("    void __glslGetAttributes(int attributeLocation);\n")
SLANG_RAW("\n")
SLANG_RAW("    __glsl_extension(GL_EXT_ray_tracing)\n")
SLANG_RAW("    __glsl_extension(GL_NV_shader_invocation_reorder)\n")
SLANG_RAW("    __target_intrinsic(glsl, \"hitObjectTraceRayNV\")\n")
SLANG_RAW("    static void __glslTraceRay(\n")
SLANG_RAW("        out HitObject hitObject,\n")
SLANG_RAW("        RaytracingAccelerationStructure accelerationStructure,\n")
SLANG_RAW("        uint rayFlags,\n")
SLANG_RAW("        uint cullMask,\n")
SLANG_RAW("        uint sbtRecordOffset,\n")
SLANG_RAW("        uint sbtRecordStride,\n")
SLANG_RAW("        uint missIndex,\n")
SLANG_RAW("        float3 origin,\n")
SLANG_RAW("        float Tmin,\n")
SLANG_RAW("        float3 direction,\n")
SLANG_RAW("        float Tmax,\n")
SLANG_RAW("        int payload);\n")
SLANG_RAW("\n")
SLANG_RAW("    __glsl_extension(GL_EXT_ray_tracing)\n")
SLANG_RAW("    __glsl_extension(GL_NV_shader_invocation_reorder)\n")
SLANG_RAW("    __glsl_extension(GL_NV_ray_tracing_motion_blur)\n")
SLANG_RAW("    __target_intrinsic(glsl, \"hitObjectTraceRayMotionNV\")\n")
SLANG_RAW("    static void __glslTraceMotionRay(\n")
SLANG_RAW("        out HitObject hitObject,\n")
SLANG_RAW("        RaytracingAccelerationStructure accelerationStructure,\n")
SLANG_RAW("        uint rayFlags,\n")
SLANG_RAW("        uint cullMask,\n")
SLANG_RAW("        uint sbtRecordOffset,\n")
SLANG_RAW("        uint sbtRecordStride,\n")
SLANG_RAW("        uint missIndex,\n")
SLANG_RAW("        float3 origin,\n")
SLANG_RAW("        float Tmin,\n")
SLANG_RAW("        float3 direction,\n")
SLANG_RAW("        float Tmax,\n")
SLANG_RAW("        float currentTime,\n")
SLANG_RAW("        int payload);\n")
SLANG_RAW("\n")
SLANG_RAW("    __glsl_extension(GL_EXT_ray_tracing)\n")
SLANG_RAW("    __glsl_extension(GL_NV_shader_invocation_reorder)\n")
SLANG_RAW("    __target_intrinsic(glsl, \"hitObjectExecuteShaderNV\")\n")
SLANG_RAW("    static void __glslInvoke(\n")
SLANG_RAW("        HitObject hitObj,\n")
SLANG_RAW("        int payload);\n")
SLANG_RAW("};\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Reorders threads based on a coherence hint value. NumCoherenceHintBits indicates how many of\n")
SLANG_RAW("    /// the least significant bits of CoherenceHint should be considered during reordering (max: 16).\n")
SLANG_RAW("    /// Applications should set this to the lowest value required to represent all possible values in\n")
SLANG_RAW("    /// CoherenceHint. For best performance, all threads should provide the same value for\n")
SLANG_RAW("    /// NumCoherenceHintBits.\n")
SLANG_RAW("    /// Where possible, reordering will also attempt to retain locality in the thread429496726642949671684294967193s launch indices\n")
SLANG_RAW("    /// (DispatchRaysIndex in DXR).\n")
SLANG_RAW("[__requiresNVAPI]\n")
SLANG_RAW("__glsl_extension(GL_NV_shader_invocation_reorder)\n")
SLANG_RAW("__glsl_extension(GL_EXT_ray_tracing)\n")
SLANG_RAW("void ReorderThread( uint CoherenceHint, uint NumCoherenceHintBitsFromLSB )\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"NvReorderThread\";\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"reorderThreadNV\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        spirv_asm {\n")
SLANG_RAW("            OpCapability ShaderInvocationReorderNV;\n")
SLANG_RAW("            OpExtension \"SPV_NV_shader_invocation_reorder\";\n")
SLANG_RAW("            OpReorderThreadWithHintNV $CoherenceHint $NumCoherenceHintBitsFromLSB;\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Reorders threads based on a hit object, optionally extended by a coherence hint value. Coherence\n")
SLANG_RAW("    /// hints behave as described in the generic variant of ReorderThread. The maximum number of\n")
SLANG_RAW("    /// coherence hint bits in this variant of ReorderThread is 8. If no coherence hint is desired, set\n")
SLANG_RAW("    /// NumCoherenceHitBits to zero.\n")
SLANG_RAW("    /// Reordering will consider information in the HitObject and coherence hint with the following\n")
SLANG_RAW("    /// priority:\n")
SLANG_RAW("    ///\n")
SLANG_RAW("    /// 1. Shader ID stored in the HitObject\n")
SLANG_RAW("    /// 2. Coherence hint, with the most significant hint bit having highest priority\n")
SLANG_RAW("    /// 3. Spatial information stored in the HitObject\n")
SLANG_RAW("    ///\n")
SLANG_RAW("    /// That is, ReorderThread will first attempt to group threads whose HitObject references the\n")
SLANG_RAW("    /// same shader ID. (Miss shaders and NOP HitObjects are grouped separately). Within each of these\n")
SLANG_RAW("    /// groups, it will attempt to order threads by the value of their coherence hints. And within ranges\n")
SLANG_RAW("    /// of equal coherence hints, it will attempt to maximize locality in 3D space of the ray hit (if any).\n")
SLANG_RAW("[__requiresNVAPI]\n")
SLANG_RAW("__glsl_extension(GL_NV_shader_invocation_reorder)\n")
SLANG_RAW("__glsl_extension(GL_EXT_ray_tracing)\n")
SLANG_RAW("void ReorderThread( HitObject HitOrMiss, uint CoherenceHint, uint NumCoherenceHintBitsFromLSB )\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"NvReorderThread\";\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"reorderThreadNV\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        spirv_asm {\n")
SLANG_RAW("            OpReorderThreadWithHitObjectNV &HitOrMiss $CoherenceHint $NumCoherenceHintBitsFromLSB;\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Is equivalent to\n")
SLANG_RAW("    /// ```\n")
SLANG_RAW("    /// void ReorderThread( HitObject HitOrMiss, uint CoherenceHint, uint NumCoherenceHintBitsFromLSB );\n")
SLANG_RAW("    /// ```\n")
SLANG_RAW("    /// With CoherenceHint and NumCoherenceHintBitsFromLSB as 0, meaning they are ignored.\n")
SLANG_RAW("[__requiresNVAPI]\n")
SLANG_RAW("__glsl_extension(GL_NV_shader_invocation_reorder)\n")
SLANG_RAW("void ReorderThread( HitObject HitOrMiss )\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \"NvReorderThread\";\n")
SLANG_RAW("    case glsl: __intrinsic_asm \"reorderThreadNV\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        spirv_asm {\n")
SLANG_RAW("            OpReorderThreadWithHitObjectNV &HitOrMiss;\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("///\n")
SLANG_RAW("/// DebugBreak support \n")
SLANG_RAW("///\n")
SLANG_RAW("/// There doesn't appear to be an equivalent for debugBreak for HLSL\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(hlsl, \"/* debugBreak() not currently supported for HLSL */\")\n")
SLANG_RAW("__target_intrinsic(cuda,\"__brkpt()\")\n")
SLANG_RAW("__target_intrinsic(cpp, \"SLANG_BREAKPOINT(0)\")\n")
SLANG_RAW("void debugBreak();\n")
SLANG_RAW("\n")
SLANG_RAW("__specialized_for_target(glsl)\n")
SLANG_RAW("[[vk::spirv_instruction(1, \"NonSemantic.DebugBreak\")]]\n")
SLANG_RAW("void debugBreak();\n")
SLANG_RAW("\n")
SLANG_RAW("// \n")
SLANG_RAW("// Realtime Clock support\n")
SLANG_RAW("//\n")
SLANG_RAW("\n")
SLANG_RAW("// https://github.com/KhronosGroup/GLSL/blob/master/extensions/ext/GL_EXT_shader_realtime_clock.txt\n")
SLANG_RAW("\n")
SLANG_RAW("[__requiresNVAPI]\n")
SLANG_RAW("__glsl_extension(GL_EXT_shader_realtime_clock)\n")
SLANG_RAW("uint getRealtimeClockLow()\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        __intrinsic_asm \"NvGetSpecial( NV_SPECIALOP_GLOBAL_TIMER_LO)\";\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        return getRealtimeClock().x;\n")
SLANG_RAW("    case cuda:\n")
SLANG_RAW("        __intrinsic_asm \"clock\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return getRealtimeClock().x;\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(cuda, \"clock64\")\n")
SLANG_RAW("int64_t __cudaGetRealtimeClock();\n")
SLANG_RAW("\n")
SLANG_RAW("[__requiresNVAPI]\n")
SLANG_RAW("__glsl_extension(GL_EXT_shader_realtime_clock)\n")
SLANG_RAW("uint2 getRealtimeClock()\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        __intrinsic_asm \"uint2(NvGetSpecial(NV_SPECIALOP_GLOBAL_TIMER_LO), NvGetSpecial( NV_SPECIALOP_GLOBAL_TIMER_HI))\";\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"clockRealtime2x32EXT()\";\n")
SLANG_RAW("    case cuda:\n")
SLANG_RAW("        int64_t ticks = __cudaGetRealtimeClock();\n")
SLANG_RAW("        return uint2(uint(ticks), uint(uint64_t(ticks) >> 32));\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm\n")
SLANG_RAW("        {\n")
SLANG_RAW("            OpCapability ShaderClockKHR;\n")
SLANG_RAW("            OpExtension \"SPV_KHR_shader_clock\";\n")
SLANG_RAW("            result : $$uint2 = OpReadClockKHR Device\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// \n")
SLANG_RAW("// CUDA specific \n")
SLANG_RAW("// \n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(cuda, \"(threadIdx)\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("uint3 cudaThreadIdx();\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(cuda, \"(blockIdx)\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("uint3 cudaBlockIdx();\n")
SLANG_RAW("\n")
SLANG_RAW("__target_intrinsic(cuda, \"(blockDim)\")\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("uint3 cudaBlockDim();\n")
SLANG_RAW("\n")
SLANG_RAW("//\n")
SLANG_RAW("// Workgroup cooperation\n")
SLANG_RAW("//\n")
SLANG_RAW("\n")
SLANG_RAW("//\n")
SLANG_RAW("// `saturated_cooperation(c, f, s, u)` will call `f(s, u)` if not all lanes in the\n")
SLANG_RAW("// workgroup are currently executing. however if all lanes are saturated, then\n")
SLANG_RAW("// for each unique `s` across all the active lanes `c(s, u)` is called. The\n")
SLANG_RAW("// return value is the one corresponding to the input `s` from this lane.\n")
SLANG_RAW("//\n")
SLANG_RAW("// Adjacent calls to saturated_cooperation are subject to fusion, i.e.\n")
SLANG_RAW("//      saturated_cooperation(c1, f1, s, u1);\n")
SLANG_RAW("//      saturated_cooperation(c2, f2, s, u2);\n")
SLANG_RAW("// will be transformed to:\n")
SLANG_RAW("//      saturated_cooperation(c1c2, f1f2, s, u1u2);\n")
SLANG_RAW("// where\n")
SLANG_RAW("//      c1c2 is a function which calls c1(s, u1) and then c2(s, u2);\n")
SLANG_RAW("//      f1f2 is a function which calls f1(s, u1) and then f2(s, u2);\n")
SLANG_RAW("//\n")
SLANG_RAW("// When the input differs, calls are fused\n")
SLANG_RAW("//      saturated_cooperation(c1, f1, s1, u1);\n")
SLANG_RAW("//      saturated_cooperation(c2, f2, s2, u2);\n")
SLANG_RAW("// will be transformed to:\n")
SLANG_RAW("//      saturated_cooperation(c1c2, f1f2, s1s2, u1u2);\n")
SLANG_RAW("// where\n")
SLANG_RAW("//      s1s2 is a tuple of s1 and s2\n")
SLANG_RAW("//      c1c2 is a function which calls c1(s1, u1) and then c2(s2, u2);\n")
SLANG_RAW("//      f1f2 is a function which calls f1(s1, u1) and then f2(s2, u2);\n")
SLANG_RAW("// Note that in this case, we will make a call to c1c2 for every unique pair\n")
SLANG_RAW("// s1s2 across all lanes\n")
SLANG_RAW("//\n")
SLANG_RAW("// (This fusion takes place in the fuse-satcoop pass, and as such any changes to\n")
SLANG_RAW("// the signature or behavior of this function should be adjusted for there).\n")
SLANG_RAW("//\n")
SLANG_RAW("[KnownBuiltin(\"saturated_cooperation\")]\n")
SLANG_RAW("func saturated_cooperation<A : __BuiltinType, B, C>(\n")
SLANG_RAW("    cooperate : functype (A, B) -> C,\n")
SLANG_RAW("    fallback : functype (A, B) -> C,\n")
SLANG_RAW("    A input,\n")
SLANG_RAW("    B otherArg)\n")
SLANG_RAW("    -> C\n")
SLANG_RAW("{\n")
SLANG_RAW("    return saturated_cooperation_using(cooperate, fallback, __WaveMatchBuitin<A>, __WaveReadLaneAtBuiltin<A>, input, otherArg);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// These two functions are a temporary (circa May 2023) workaround to the fact\n")
SLANG_RAW("// that we can't deduce which overload to pass to saturated_cooperation_using\n")
SLANG_RAW("// in the call above\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("func __WaveMatchBuitin<T : __BuiltinType>(T t) -> uint4\n")
SLANG_RAW("{\n")
SLANG_RAW("    return WaveMatch(t);\n")
SLANG_RAW("}\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("func __WaveReadLaneAtBuiltin<T : __BuiltinType>(T t, int i) -> T\n")
SLANG_RAW("{\n")
SLANG_RAW("    return WaveReadLaneAt(t, i);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("//\n")
SLANG_RAW("// saturated_cooperation, but you're able to specify manually the functions:\n")
SLANG_RAW("//\n")
SLANG_RAW("// waveMatch: a function to return a mask of lanes with the same input as this one\n")
SLANG_RAW("// broadcast: a function which returns the value passed into it on the specified lane\n")
SLANG_RAW("//\n")
SLANG_RAW("[KnownBuiltin(\"saturated_cooperation_using\")]\n")
SLANG_RAW("func saturated_cooperation_using<A, B, C>(\n")
SLANG_RAW("    cooperate : functype (A, B) -> C,\n")
SLANG_RAW("    fallback : functype (A, B) -> C,\n")
SLANG_RAW("    waveMatch : functype (A) -> uint4,\n")
SLANG_RAW("    broadcast : functype (A, int) -> A,\n")
SLANG_RAW("    A input,\n")
SLANG_RAW("    B otherArg)\n")
SLANG_RAW("    -> C\n")
SLANG_RAW("{\n")
SLANG_RAW("    const bool isWaveSaturated = WaveActiveCountBits(true) == WaveGetLaneCount();\n")
SLANG_RAW("    if(isWaveSaturated)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        let lanesWithSameInput = waveMatch(input).x;\n")
SLANG_RAW("        // Keep least significant lane in our set\n")
SLANG_RAW("        let ourRepresentative = lanesWithSameInput & -lanesWithSameInput;\n")
SLANG_RAW("        // The representative lanes for all lanes\n")
SLANG_RAW("        var allRepresentatives = WaveActiveBitOr(ourRepresentative);\n")
SLANG_RAW("\n")
SLANG_RAW("        C ret;\n")
SLANG_RAW("\n")
SLANG_RAW("        // Iterate over set bits in mask from low to high.\n")
SLANG_RAW("        // In each iteration the lowest bit is cleared.\n")
SLANG_RAW("        while(bool(allRepresentatives))\n")
SLANG_RAW("        {\n")
SLANG_RAW("            // Broadcast input across warp.\n")
SLANG_RAW("            let laneIdx = firstbitlow(allRepresentatives);\n")
SLANG_RAW("            let uniformInput = broadcast(input, int(laneIdx));\n")
SLANG_RAW("\n")
SLANG_RAW("            // All lanes perform some cooperative computation with dynamic\n")
SLANG_RAW("            // uniform input\n")
SLANG_RAW("            C c = cooperate(uniformInput, otherArg);\n")
SLANG_RAW("\n")
SLANG_RAW("            // Update our return value until it\n")
SLANG_RAW("            if(bool(allRepresentatives & ourRepresentative))\n")
SLANG_RAW("                ret = c;\n")
SLANG_RAW("\n")
SLANG_RAW("            // Clear the lowest bit\n")
SLANG_RAW("            allRepresentatives &= allRepresentatives - 1;\n")
SLANG_RAW("        }\n")
SLANG_RAW("\n")
SLANG_RAW("        return ret;\n")
SLANG_RAW("    }\n")
SLANG_RAW("    else\n")
SLANG_RAW("    {\n")
SLANG_RAW("        return fallback(input, otherArg);\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("\n")

// The NVAPI operations are defined to take the space/register
// indices of their texture and sampler parameters, rather than
// taking the texture/sampler objects directly.
//
// In order to support this approach, we need intrinsics that
// can magically fetch the binding information for a resource.
//
// TODO: These operations are kind of *screaming* for us to
// have a built-in `interface` that all of the opaque resource
// types conform to, so that we can define builtins that work
// for any resource type.
SLANG_RAW("#line 11767 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_GetRegisterSpace
)
SLANG_RAW(") uint __getRegisterSpace<T, Shape: __ITextureShape, let isArray:int, let isMS:int, let sampleCount:int, let access:int, let isShadow:int, let isCombined:int, let format:int>(__TextureImpl<T,Shape,isArray,isMS,sampleCount,access,isShadow,isCombined,format> texture);\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_GetRegisterSpace
)
SLANG_RAW(") uint __getRegisterSpace(SamplerState sampler);\n")
SLANG_RAW("\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_GetRegisterIndex
)
SLANG_RAW(") uint __getRegisterIndex<T, Shape: __ITextureShape, let isArray:int, let isMS:int, let sampleCount:int, let access:int, let isShadow:int, let isCombined:int, let format:int>(__TextureImpl<T,Shape,isArray,isMS,sampleCount,access,isShadow,isCombined,format> texture);\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_GetRegisterIndex
)
SLANG_RAW(") uint __getRegisterIndex(SamplerState sampler);\n")
SLANG_RAW("\n")
SLANG_RAW("\n")

//
// Texture Footprint Queries
//
// This section introduces the types and methods related
// to the `GL_NV_shader_texture_footprint` GLSL extension,
// and the matching NVAPI operations.
//
// Footprint queries are allowed on both 2D and 3D textures,
// and are structurally similar for the two, so we will
// use a meta-loop to deduplicate the code for the two
// cases.
//

// A footprint query yields a data structure
// that describes blocks of texels that
// conservatively cover the data that might
// be fetched in the query.
//
// A given sampling operation might access two
// mip levels of a texture when, e.g., trilinear
// filtering is on. A footprint query may ask for
// a footprint in either the coarse or fine level
// of the pair.
//
// We first define a `struct` type that closely maps
// to how a footprint is defined for each of the
// implementations we support, and then wrap that
// in a derived `struct` that includes the extra
// data that is returned by the GLSL API via the
// function reuslt.
//
SLANG_RAW("#line 11808 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("[__NoSideEffect]\n")
SLANG_RAW("[__requiresNVAPI]\n")
SLANG_RAW("vector<uint, ND> __textureFootprintGetAnchor<let ND:int>(__TextureFootprintData<ND> data, int nd)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        __intrinsic_asm \"NvFootprintExtractAnchorTileLoc$!1D($0)\";\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"$0.anchor\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            result:$$vector<uint,ND> = OpCompositeExtract $data 1;\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[__NoSideEffect]\n")
SLANG_RAW("[__requiresNVAPI]\n")
SLANG_RAW("vector<uint, ND> __textureFootprintGetOffset<let ND:int>(__TextureFootprintData<ND> data, int nd)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case hlsl:\n")
SLANG_RAW("        __intrinsic_asm \"NvFootprintExtractOffset$!1D($0)\";\n")
SLANG_RAW("    case glsl:\n")
SLANG_RAW("        __intrinsic_asm \"$0.offset\";\n")
SLANG_RAW("    case spirv:\n")
SLANG_RAW("        return spirv_asm {\n")
SLANG_RAW("            result:$$vector<uint,ND> = OpCompositeExtract $data 2;\n")
SLANG_RAW("        };\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_TextureFootprintType
)
SLANG_RAW(")\n")
SLANG_RAW("struct __TextureFootprintData<let ND:int>\n")
SLANG_RAW("{\n")
SLANG_RAW("    typealias Anchor        = vector<uint, ND>;\n")
SLANG_RAW("    typealias Offset        = vector<uint, ND>;\n")
SLANG_RAW("    typealias Mask          = uint2;\n")
SLANG_RAW("    typealias LOD           = uint;\n")
SLANG_RAW("    typealias Granularity   = uint;\n")
SLANG_RAW("\n")
SLANG_RAW("    property anchor : Anchor\n")
SLANG_RAW("    {\n")
SLANG_RAW("        [__NoSideEffect]\n")
SLANG_RAW("        [__requiresNVAPI]\n")
SLANG_RAW("        [ForceInline]\n")
SLANG_RAW("        get { return __textureFootprintGetAnchor(this, ND); }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    property offset : Offset\n")
SLANG_RAW("    {\n")
SLANG_RAW("        [__NoSideEffect]\n")
SLANG_RAW("        [__requiresNVAPI]\n")
SLANG_RAW("        [ForceInline]\n")
SLANG_RAW("        get { return __textureFootprintGetOffset(this, ND); }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    property mask : Mask\n")
SLANG_RAW("    {\n")
SLANG_RAW("        [__NoSideEffect]\n")
SLANG_RAW("        [__requiresNVAPI]\n")
SLANG_RAW("        get\n")
SLANG_RAW("        {\n")
SLANG_RAW("            __target_switch\n")
SLANG_RAW("            {\n")
SLANG_RAW("            case hlsl:\n")
SLANG_RAW("                __intrinsic_asm \"NvFootprintExtractBitmask\";\n")
SLANG_RAW("            case glsl:\n")
SLANG_RAW("                __intrinsic_asm \"$0.mask\";\n")
SLANG_RAW("            case spirv:\n")
SLANG_RAW("                return spirv_asm {\n")
SLANG_RAW("                    result:$$Mask = OpCompositeExtract $this 3;\n")
SLANG_RAW("                };\n")
SLANG_RAW("            }\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    property lod : LOD\n")
SLANG_RAW("    {\n")
SLANG_RAW("        [__NoSideEffect]\n")
SLANG_RAW("        [__requiresNVAPI]\n")
SLANG_RAW("        get\n")
SLANG_RAW("        {\n")
SLANG_RAW("            __target_switch\n")
SLANG_RAW("            {\n")
SLANG_RAW("            case hlsl:\n")
SLANG_RAW("                __intrinsic_asm \"NvFootprintExtractLOD\";\n")
SLANG_RAW("            case glsl:\n")
SLANG_RAW("                __intrinsic_asm \"$0.lod\";\n")
SLANG_RAW("            case spirv:\n")
SLANG_RAW("                return spirv_asm {\n")
SLANG_RAW("                    result:$$LOD = OpCompositeExtract $this 4;\n")
SLANG_RAW("                };\n")
SLANG_RAW("            }\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    property granularity : Granularity\n")
SLANG_RAW("    {\n")
SLANG_RAW("        [__NoSideEffect]\n")
SLANG_RAW("        [__requiresNVAPI]\n")
SLANG_RAW("        get\n")
SLANG_RAW("        {\n")
SLANG_RAW("            __target_switch\n")
SLANG_RAW("            {\n")
SLANG_RAW("            case hlsl:\n")
SLANG_RAW("                __intrinsic_asm \"NvFootprintExtractReturnGran\";\n")
SLANG_RAW("            case glsl:\n")
SLANG_RAW("                __intrinsic_asm \"$0.granularity\";\n")
SLANG_RAW("            case spirv:\n")
SLANG_RAW("                return spirv_asm {\n")
SLANG_RAW("                    result:$$Granularity = OpCompositeExtract $this 5;\n")
SLANG_RAW("                };\n")
SLANG_RAW("            }\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("struct TextureFootprint<let ND:int> : __TextureFootprintData<ND>\n")
SLANG_RAW("{\n")
SLANG_RAW("    bool _isSingleLevel;\n")
SLANG_RAW("\n")
SLANG_RAW("    property isSingleLevel : bool\n")
SLANG_RAW("    {\n")
SLANG_RAW("        [__NoSideEffect]\n")
SLANG_RAW("        get\n")
SLANG_RAW("        {\n")
SLANG_RAW("            return _isSingleLevel;\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("typealias TextureFootprint2D = TextureFootprint<2>;\n")
SLANG_RAW("typealias TextureFootprint3D = TextureFootprint<3>;\n")
SLANG_RAW("\n")

// We define the new operations via an `extension`
// on the relevant texture type(s), rather than
// further clutter the original type declarations.
SLANG_RAW("#line 11951 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T, Shape: __ITextureShape, let sampleCount:int, let isShadow:int, let format:int>\n")
SLANG_RAW("extension __TextureImpl<T,Shape,0,0,sampleCount,0,isShadow,0,format>\n")
SLANG_RAW("{\n")

// We introduce a few convenience type aliases here,
// which both keep our declarations simpler and easier
// to understand, but which might *also* be useful to
// users of the stdlib, so that they can write things
// like `Texture2D.Footprint`, and also have auto-complete
// help them find such members.
//
// TODO: The `Coords` type really ought to be something
// defined on the base texture types, rather than via
// this `extension`.
SLANG_RAW("#line 11967 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("    typealias Coords = vector<float, Shape.dimensions>;\n")
SLANG_RAW("    typealias Footprint = TextureFootprint<Shape.dimensions>;\n")
SLANG_RAW("    typealias __FootprintData = __TextureFootprintData<Shape.dimensions>;\n")
SLANG_RAW("    typealias FootprintGranularity = Footprint.Granularity;\n")
SLANG_RAW("\n")

// For the GLSL extension, the choice between the
// coarse and fine level is modeled as a `bool`
// parameter to the query operation(s). We define
// the GLSL functions here as intrinsics, so that
// we can refer to them later in the definitions
// of our stdlib operaitons.
//
// Note: despite the GLSL extension defining the `granularity`
// member of the query result as having type `uint`, the
// function signatures all take `int` parameters for the
// granularity instead.
//
SLANG_RAW("#line 11986 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("    [__NoSideEffect]\n")
SLANG_RAW("    __glsl_version(450)\n")
SLANG_RAW("    __glsl_extension(GL_NV_shader_texture_footprint)\n")
SLANG_RAW("    bool __queryFootprintGLSL(\n")
SLANG_RAW("            SamplerState    sampler,\n")
SLANG_RAW("            Coords          coords,\n")
SLANG_RAW("            int             granularity,\n")
SLANG_RAW("            bool            useCoarseLevel,\n")
SLANG_RAW("            out __FootprintData footprint)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("            __intrinsic_asm \"textureFootprintNV($p, $*2)\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            return spirv_asm {\n")
SLANG_RAW("                OpCapability ImageFootprintNV;\n")
SLANG_RAW("                OpExtension \"SPV_NV_shader_image_footprint\";\n")
SLANG_RAW("                %sampledImage:__sampledImageType(this) = OpSampledImage $this $sampler;\n")
SLANG_RAW("                %resultVal:$$__FootprintData = OpImageSampleFootprintNV %sampledImage $coords $granularity $useCoarseLevel;\n")
SLANG_RAW("                OpStore &footprint %resultVal;\n")
SLANG_RAW("                result:$$bool = OpCompositeExtract %resultVal 0;\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__NoSideEffect]\n")
SLANG_RAW("    __glsl_version(450)\n")
SLANG_RAW("    __glsl_extension(GL_NV_shader_texture_footprint)\n")
SLANG_RAW("    bool __queryFootprintGLSL(\n")
SLANG_RAW("            SamplerState    sampler,\n")
SLANG_RAW("            Coords          coords,\n")
SLANG_RAW("            int             granularity,\n")
SLANG_RAW("            bool            useCoarseLevel,\n")
SLANG_RAW("            out __FootprintData footprint,\n")
SLANG_RAW("            float           bias)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("            __intrinsic_asm \"textureFootprintNV($p, $*2)\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            return spirv_asm {\n")
SLANG_RAW("                OpCapability ImageFootprintNV;\n")
SLANG_RAW("                OpExtension \"SPV_NV_shader_image_footprint\";\n")
SLANG_RAW("                %sampledImage:__sampledImageType(this) = OpSampledImage $this $sampler;\n")
SLANG_RAW("                %resultVal:$$__FootprintData = OpImageSampleFootprintNV %sampledImage $coords $granularity $useCoarseLevel Bias $bias;\n")
SLANG_RAW("                OpStore &footprint %resultVal;\n")
SLANG_RAW("                result:$$bool = OpCompositeExtract %resultVal 0;\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__NoSideEffect]\n")
SLANG_RAW("    __glsl_version(450)\n")
SLANG_RAW("    __glsl_extension(GL_NV_shader_texture_footprint)\n")
SLANG_RAW("    __glsl_extension(GL_ARB_sparse_texture_clamp)\n")
SLANG_RAW("    __target_intrinsic(glsl,\n")
SLANG_RAW("        \"textureFootprintClampNV($p, $*2)\")\n")
SLANG_RAW("    bool __queryFootprintClampGLSL(\n")
SLANG_RAW("            SamplerState    sampler,\n")
SLANG_RAW("            Coords          coords,\n")
SLANG_RAW("            float           lodClamp,\n")
SLANG_RAW("            int             granularity,\n")
SLANG_RAW("            bool            useCoarseLevel,\n")
SLANG_RAW("            out __FootprintData footprint)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("            __intrinsic_asm \"textureFootprintClampNV($p, $*2)\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            return spirv_asm {\n")
SLANG_RAW("                OpCapability ImageFootprintNV;\n")
SLANG_RAW("                OpCapability MinLod;\n")
SLANG_RAW("                OpExtension \"SPV_NV_shader_image_footprint\";\n")
SLANG_RAW("                %sampledImage:__sampledImageType(this) = OpSampledImage $this $sampler;\n")
SLANG_RAW("                %resultVal:$$__FootprintData = OpImageSampleFootprintNV %sampledImage $coords $granularity $useCoarseLevel MinLod $lodClamp;\n")
SLANG_RAW("                OpStore &footprint %resultVal;\n")
SLANG_RAW("                result:$$bool = OpCompositeExtract %resultVal 0;\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__NoSideEffect]\n")
SLANG_RAW("    __glsl_version(450)\n")
SLANG_RAW("    __glsl_extension(GL_NV_shader_texture_footprint)\n")
SLANG_RAW("    __glsl_extension(GL_ARB_sparse_texture_clamp)\n")
SLANG_RAW("    bool __queryFootprintClampGLSL(\n")
SLANG_RAW("            SamplerState    sampler,\n")
SLANG_RAW("            Coords          coords,\n")
SLANG_RAW("            float           lodClamp,\n")
SLANG_RAW("            int             granularity,\n")
SLANG_RAW("            bool            useCoarseLevel,\n")
SLANG_RAW("            out __FootprintData footprint,\n")
SLANG_RAW("            float           bias)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("            __intrinsic_asm \"textureFootprintClampNV($p, $*2)\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            return spirv_asm {\n")
SLANG_RAW("                OpCapability ImageFootprintNV;\n")
SLANG_RAW("                OpCapability MinLod;\n")
SLANG_RAW("                OpExtension \"SPV_NV_shader_image_footprint\";\n")
SLANG_RAW("                %sampledImage:__sampledImageType(this) = OpSampledImage $this $sampler;\n")
SLANG_RAW("                %resultVal:$$__FootprintData = OpImageSampleFootprintNV %sampledImage $coords $granularity $useCoarseLevel Bias|MinLod $bias $lodClamp;\n")
SLANG_RAW("                OpStore &footprint %resultVal;\n")
SLANG_RAW("                result:$$bool = OpCompositeExtract %resultVal 0;\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__NoSideEffect]\n")
SLANG_RAW("    __glsl_version(450)\n")
SLANG_RAW("    __glsl_extension(GL_NV_shader_texture_footprint)\n")
SLANG_RAW("    [__requiresNVAPI]\n")
SLANG_RAW("    bool __queryFootprintLodGLSL(\n")
SLANG_RAW("            SamplerState            sampler,\n")
SLANG_RAW("            Coords                  coords,\n")
SLANG_RAW("            float                   lod,\n")
SLANG_RAW("            int                     granularity,\n")
SLANG_RAW("            bool                    useCoarseLevel,\n")
SLANG_RAW("            out __FootprintData         footprint)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("            __intrinsic_asm \"textureFootprintLodNV($p, $*2)\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            return spirv_asm {\n")
SLANG_RAW("                OpCapability ImageFootprintNV;\n")
SLANG_RAW("                OpExtension \"SPV_NV_shader_image_footprint\";\n")
SLANG_RAW("                %sampledImage:__sampledImageType(this) = OpSampledImage $this $sampler;\n")
SLANG_RAW("                %resultVal:$$__FootprintData = OpImageSampleFootprintNV %sampledImage $coords $granularity $useCoarseLevel Lod $lod;\n")
SLANG_RAW("                OpStore &footprint %resultVal;\n")
SLANG_RAW("                result:$$bool = OpCompositeExtract %resultVal 0;\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("\n")

    // Texture sampling with gradient is only available for 2D textures.
SLANG_RAW("#line 12133 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("    [__NoSideEffect]\n")
SLANG_RAW("    __glsl_version(450)\n")
SLANG_RAW("    __glsl_extension(GL_NV_shader_texture_footprint)\n")
SLANG_RAW("    [__requiresNVAPI]\n")
SLANG_RAW("    bool __queryFootprintGradGLSL(\n")
SLANG_RAW("            SamplerState    sampler,\n")
SLANG_RAW("            Coords          coords,\n")
SLANG_RAW("            Coords          dx,\n")
SLANG_RAW("            Coords          dy,\n")
SLANG_RAW("            int             granularity,\n")
SLANG_RAW("            bool            useCoarseLevel,\n")
SLANG_RAW("            out __FootprintData footprint)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("            __intrinsic_asm \"textureFootprintGradNV($p, $*2)\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            return spirv_asm {\n")
SLANG_RAW("                OpCapability ImageFootprintNV;\n")
SLANG_RAW("                OpExtension \"SPV_NV_shader_image_footprint\";\n")
SLANG_RAW("                %sampledImage:__sampledImageType(this) = OpSampledImage $this $sampler;\n")
SLANG_RAW("                %resultVal:$$__FootprintData = OpImageSampleFootprintNV %sampledImage $coords $granularity $useCoarseLevel Grad $dx $dy;\n")
SLANG_RAW("                OpStore &footprint %resultVal;\n")
SLANG_RAW("                result:$$bool = OpCompositeExtract %resultVal 0;\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__NoSideEffect]\n")
SLANG_RAW("    __glsl_version(450)\n")
SLANG_RAW("    __glsl_extension(GL_NV_shader_texture_footprint)\n")
SLANG_RAW("    __glsl_extension(GL_ARB_sparse_texture_clamp)\n")
SLANG_RAW("    bool __queryFootprintGradClampGLSL(\n")
SLANG_RAW("            SamplerState    sampler,\n")
SLANG_RAW("            Coords          coords,\n")
SLANG_RAW("            Coords          dx,\n")
SLANG_RAW("            Coords          dy,\n")
SLANG_RAW("            float           lodClamp,\n")
SLANG_RAW("            int             granularity,\n")
SLANG_RAW("            bool            useCoarseLevel,\n")
SLANG_RAW("            out __FootprintData footprint)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("            __intrinsic_asm \"textureFootprintGradClampNV($p, $*2)\";\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            return spirv_asm {\n")
SLANG_RAW("                OpCapability ImageFootprintNV;\n")
SLANG_RAW("                OpCapability MinLod;\n")
SLANG_RAW("                OpExtension \"SPV_NV_shader_image_footprint\";\n")
SLANG_RAW("                %sampledImage:__sampledImageType(this) = OpSampledImage $this $sampler;\n")
SLANG_RAW("                %resultVal:$$__FootprintData = OpImageSampleFootprintNV %sampledImage $coords $granularity $useCoarseLevel Grad|MinLod $dx $dy $lodClamp;\n")
SLANG_RAW("                OpStore &footprint %resultVal;\n")
SLANG_RAW("                result:$$bool = OpCompositeExtract %resultVal 0;\n")
SLANG_RAW("            };\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")

    // End texture2D specific functions.
SLANG_RAW("#line 12195 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("\n")

// The NVAPI texture query operations encode the choice
// between coarse and fine levels as part of the function
// name, and so we are forced to match this convention
// if we want to provide a more portable API.
//
// TODO: We could conceivably define the functions to use
// a parameter for the coarse/fine choice, which is required
// to be `constexpr` for the HLSL/NVAPI target.
//
static const struct LevelChoice
{
char const* name;
char const* isCoarseVal;
} kLevelChoices[] =
{
    { "Coarse", "true" },
    { "Fine", "false" },
};
for(auto levelChoice : kLevelChoices)
{
    auto CoarseOrFine = levelChoice.name;
    auto isCoarseVal = levelChoice.isCoarseVal;

// We now go ahead and define the intrinsics provided by NVAPI,
// which have a very different signature from the GLSL ones.
//
// Note: the NVAPI functions also support an optional texel
// offset parameter. For now we are not including overloads
// with that parameter, since they have no equivalent in
// the GLSL extension.
//
SLANG_RAW("#line 12230 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("    [__NoSideEffect]\n")
SLANG_RAW("    [__requiresNVAPI]\n")
SLANG_RAW("    __target_intrinsic(hlsl,\n")
SLANG_RAW("        \"NvFootprint")
SLANG_SPLICE(CoarseOrFine
)
SLANG_RAW("($1, $2, $3, $4, NV_EXTN_TEXTURE_$!0D, $*5)\")\n")
SLANG_RAW("    static __FootprintData __queryFootprint")
SLANG_SPLICE(CoarseOrFine
)
SLANG_RAW("NVAPI(\n")
SLANG_RAW("        int                     nd,\n")
SLANG_RAW("        uint                    textureSpace,\n")
SLANG_RAW("        uint                    textureIndex,\n")
SLANG_RAW("        uint                    samplerSpace,\n")
SLANG_RAW("        uint                    samplerIndex,\n")
SLANG_RAW("        float3                  coords,\n")
SLANG_RAW("        FootprintGranularity    granularity, \n")
SLANG_RAW("        out uint                isSingleLod);\n")
SLANG_RAW("\n")
SLANG_RAW("    [__NoSideEffect]\n")
SLANG_RAW("    [__requiresNVAPI]\n")
SLANG_RAW("    __target_intrinsic(hlsl,\n")
SLANG_RAW("        \"NvFootprint")
SLANG_SPLICE(CoarseOrFine
)
SLANG_RAW("Bias($1, $2, $3, $4, NV_EXTN_TEXTURE_$!0D, $*5)\")\n")
SLANG_RAW("    static __FootprintData __queryFootprint")
SLANG_SPLICE(CoarseOrFine
)
SLANG_RAW("BiasNVAPI(\n")
SLANG_RAW("        int                     nd,\n")
SLANG_RAW("        uint                    textureSpace,\n")
SLANG_RAW("        uint                    textureIndex,\n")
SLANG_RAW("        uint                    samplerSpace,\n")
SLANG_RAW("        uint                    samplerIndex,\n")
SLANG_RAW("        float3                  coords,\n")
SLANG_RAW("        FootprintGranularity    granularity,\n")
SLANG_RAW("        float                   lodBias, \n")
SLANG_RAW("        out uint                isSingleLod);\n")
SLANG_RAW("\n")
SLANG_RAW("    [__NoSideEffect]\n")
SLANG_RAW("    [__requiresNVAPI]\n")
SLANG_RAW("    __target_intrinsic(hlsl,\n")
SLANG_RAW("        \"NvFootprint")
SLANG_SPLICE(CoarseOrFine
)
SLANG_RAW("Level($1, $2, $3, $4, NV_EXTN_TEXTURE_$!0D, $*5)\")\n")
SLANG_RAW("    static __FootprintData __queryFootprint")
SLANG_SPLICE(CoarseOrFine
)
SLANG_RAW("LevelNVAPI(\n")
SLANG_RAW("        int                     nd,\n")
SLANG_RAW("        uint                    textureSpace,\n")
SLANG_RAW("        uint                    textureIndex,\n")
SLANG_RAW("        uint                    samplerSpace,\n")
SLANG_RAW("        uint                    samplerIndex,\n")
SLANG_RAW("        float3                  coords,\n")
SLANG_RAW("        FootprintGranularity    granularity,\n")
SLANG_RAW("        float                   lod, \n")
SLANG_RAW("        out uint                isSingleLod);\n")
SLANG_RAW("\n")
SLANG_RAW("    [__NoSideEffect]\n")
SLANG_RAW("    [__requiresNVAPI]\n")
SLANG_RAW("    __target_intrinsic(hlsl,\n")
SLANG_RAW("        \"NvFootprint")
SLANG_SPLICE(CoarseOrFine
)
SLANG_RAW("Grad($1, $2, $3, $4, NV_EXTN_TEXTURE_$!0D, $*5)\")\n")
SLANG_RAW("    static __FootprintData __queryFootprint")
SLANG_SPLICE(CoarseOrFine
)
SLANG_RAW("GradNVAPI(\n")
SLANG_RAW("        int                     nd,\n")
SLANG_RAW("        uint                    textureSpace,\n")
SLANG_RAW("        uint                    textureIndex,\n")
SLANG_RAW("        uint                    samplerSpace,\n")
SLANG_RAW("        uint                    samplerIndex,\n")
SLANG_RAW("        float3                  coords,\n")
SLANG_RAW("        FootprintGranularity    granularity,\n")
SLANG_RAW("        float3                  dx,\n")
SLANG_RAW("        float3                  dy, \n")
SLANG_RAW("        out uint                isSingleLod);\n")
SLANG_RAW("\n")

// We now define the portable operations that will be officially
// supported by the standard library. For each operation, we
// need to provide both a version that maps to the GLSL extension,
// and a version that uses the NVAPI functions.
//
// Some function variations are only available with one extension
// or the other, so we try our best to only define them where
// each is available.
//
// Note that these functions cannot be marked as [ForceInline] for now
// because the texture resource may get removed after DCE, since the only
// use of those resources are done through __GetRegisterIndex/Space, which is
// replaced early with their binding slot in the compilation process.
// Not inlining these function is a quick way to make sure the texture always
// has live uses.
//
SLANG_RAW("#line 12309 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Query the footprint that would be accessed by a texture sampling operation.\n")
SLANG_RAW("    ///\n")
SLANG_RAW("    /// This operation queries the footprint that would be accessed\n")
SLANG_RAW("    /// by a comparable call to:\n")
SLANG_RAW("    ///\n")
SLANG_RAW("    ///     t.Sample(sampler, coords);\n")
SLANG_RAW("    ///\n")
SLANG_RAW("    [__NoSideEffect]\n")
SLANG_RAW("    Footprint queryFootprint")
SLANG_SPLICE(CoarseOrFine
)
SLANG_RAW("(\n")
SLANG_RAW("            FootprintGranularity    granularity,\n")
SLANG_RAW("            SamplerState            sampler,\n")
SLANG_RAW("            Coords                  coords)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            Footprint footprint;\n")
SLANG_RAW("            footprint._isSingleLevel = __queryFootprintGLSL(sampler, coords, granularity, ")
SLANG_SPLICE(isCoarseVal
)
SLANG_RAW(", footprint);\n")
SLANG_RAW("            return footprint;\n")
SLANG_RAW("\n")
SLANG_RAW("        case hlsl:\n")
SLANG_RAW("            uint isSingleLod = 0;\n")
SLANG_RAW("            Footprint footprint =  {__queryFootprint")
SLANG_SPLICE(CoarseOrFine
)
SLANG_RAW("NVAPI(\n")
SLANG_RAW("                Shape.dimensions,\n")
SLANG_RAW("                __getRegisterSpace(this), __getRegisterIndex(this),\n")
SLANG_RAW("                __getRegisterSpace(sampler), __getRegisterIndex(sampler),\n")
SLANG_RAW("                __vectorReshape<3>(coords), granularity, /* out */isSingleLod), false};\n")
SLANG_RAW("            footprint._isSingleLevel = (isSingleLod != 0);\n")
SLANG_RAW("            return footprint;\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Query the footprint that would be accessed by a texture sampling operation.\n")
SLANG_RAW("    ///\n")
SLANG_RAW("    /// This operation queries the footprint that would be accessed\n")
SLANG_RAW("    /// by a comparable call to:\n")
SLANG_RAW("    ///\n")
SLANG_RAW("    ///     t.SampleBias(sampler, coords, lodBias);\n")
SLANG_RAW("    ///\n")
SLANG_RAW("    [__NoSideEffect]\n")
SLANG_RAW("    Footprint queryFootprint")
SLANG_SPLICE(CoarseOrFine
)
SLANG_RAW("Bias(\n")
SLANG_RAW("            FootprintGranularity    granularity,\n")
SLANG_RAW("            SamplerState            sampler,\n")
SLANG_RAW("            Coords                  coords,\n")
SLANG_RAW("            float                   lodBias)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            Footprint footprint;\n")
SLANG_RAW("            footprint._isSingleLevel = __queryFootprintGLSL(sampler, coords, granularity, ")
SLANG_SPLICE(isCoarseVal
)
SLANG_RAW(", footprint, lodBias);\n")
SLANG_RAW("            return footprint;\n")
SLANG_RAW("        case hlsl:\n")
SLANG_RAW("            uint isSingleLod = 0;\n")
SLANG_RAW("            Footprint footprint = {__queryFootprint")
SLANG_SPLICE(CoarseOrFine
)
SLANG_RAW("BiasNVAPI(\n")
SLANG_RAW("                Shape.dimensions,\n")
SLANG_RAW("                __getRegisterSpace(this), __getRegisterIndex(this),\n")
SLANG_RAW("                __getRegisterSpace(sampler), __getRegisterIndex(sampler),\n")
SLANG_RAW("                __vectorReshape<3>(coords), granularity, lodBias, /* out */isSingleLod), false}; \n")
SLANG_RAW("            \n")
SLANG_RAW("            footprint._isSingleLevel = (isSingleLod != 0);\n")
SLANG_RAW("            return footprint;\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Query the footprint that would be accessed by a texture sampling operation.\n")
SLANG_RAW("    ///\n")
SLANG_RAW("    /// This operation queries the footprint that would be accessed\n")
SLANG_RAW("    /// by a comparable call to:\n")
SLANG_RAW("    ///\n")
SLANG_RAW("    ///     t.SampleClamp(sampler, coords, lodClamp);\n")
SLANG_RAW("    ///\n")
SLANG_RAW("    [__NoSideEffect]\n")
SLANG_RAW("    Footprint queryFootprint")
SLANG_SPLICE(CoarseOrFine
)
SLANG_RAW("Clamp(\n")
SLANG_RAW("            FootprintGranularity    granularity,\n")
SLANG_RAW("            SamplerState            sampler,\n")
SLANG_RAW("            Coords                  coords,\n")
SLANG_RAW("            float                   lodClamp)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            Footprint footprint;\n")
SLANG_RAW("            footprint._isSingleLevel = __queryFootprintClampGLSL(sampler, coords, lodClamp, granularity, ")
SLANG_SPLICE(isCoarseVal
)
SLANG_RAW(", footprint);\n")
SLANG_RAW("            return footprint;\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Query the footprint that would be accessed by a texture sampling operation.\n")
SLANG_RAW("    ///\n")
SLANG_RAW("    /// This operation queries the footprint that would be accessed\n")
SLANG_RAW("    /// by a comparable call to:\n")
SLANG_RAW("    ///\n")
SLANG_RAW("    ///     t.SampleBiasClamp(sampler, coords, lodBias, lodClamp);\n")
SLANG_RAW("    ///\n")
SLANG_RAW("    [__NoSideEffect]\n")
SLANG_RAW("    Footprint queryFootprint")
SLANG_SPLICE(CoarseOrFine
)
SLANG_RAW("BiasClamp(\n")
SLANG_RAW("            FootprintGranularity    granularity,\n")
SLANG_RAW("            SamplerState            sampler,\n")
SLANG_RAW("            Coords                  coords,\n")
SLANG_RAW("            float                   lodBias,\n")
SLANG_RAW("            float                   lodClamp)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            Footprint footprint;\n")
SLANG_RAW("            footprint._isSingleLevel = __queryFootprintClampGLSL(sampler, coords, lodClamp, granularity, ")
SLANG_SPLICE(isCoarseVal
)
SLANG_RAW(", footprint, lodBias);\n")
SLANG_RAW("            return footprint;\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Query the footprint that would be accessed by a texture sampling operation.\n")
SLANG_RAW("    ///\n")
SLANG_RAW("    /// This operation queries the footprint that would be accessed\n")
SLANG_RAW("    /// by a comparable call to:\n")
SLANG_RAW("    ///\n")
SLANG_RAW("    ///     t.SampleLevel(sampler, coords, lod);\n")
SLANG_RAW("    ///\n")
SLANG_RAW("    [__NoSideEffect]\n")
SLANG_RAW("    Footprint queryFootprint")
SLANG_SPLICE(CoarseOrFine
)
SLANG_RAW("Level(\n")
SLANG_RAW("            FootprintGranularity    granularity,\n")
SLANG_RAW("            SamplerState            sampler,\n")
SLANG_RAW("            Coords                  coords,\n")
SLANG_RAW("            float                   lod)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            Footprint footprint;\n")
SLANG_RAW("            footprint._isSingleLevel = __queryFootprintLodGLSL(sampler, coords, lod, granularity, ")
SLANG_SPLICE(isCoarseVal
)
SLANG_RAW(", footprint);\n")
SLANG_RAW("            return footprint;\n")
SLANG_RAW("        case hlsl:\n")
SLANG_RAW("            uint isSingleLod = 0;\n")
SLANG_RAW("            Footprint footprint = {__queryFootprint")
SLANG_SPLICE(CoarseOrFine
)
SLANG_RAW("LevelNVAPI(\n")
SLANG_RAW("                Shape.dimensions,\n")
SLANG_RAW("                __getRegisterSpace(this), __getRegisterIndex(this),\n")
SLANG_RAW("                __getRegisterSpace(sampler), __getRegisterIndex(sampler),\n")
SLANG_RAW("                __vectorReshape<3>(coords), granularity, lod, /* out */isSingleLod), false};\n")
SLANG_RAW("            \n")
SLANG_RAW("            footprint._isSingleLevel = (isSingleLod != 0);\n")
SLANG_RAW("            return footprint;\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")

    // TODO: Texture sampling with gradient is only available for 2D textures.
SLANG_RAW("#line 12463 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Query the footprint that would be accessed by a texture sampling operation.\n")
SLANG_RAW("    ///\n")
SLANG_RAW("    /// This operation queries the footprint that would be accessed\n")
SLANG_RAW("    /// by a comparable call to:\n")
SLANG_RAW("    ///\n")
SLANG_RAW("    ///     t.SampleGrad(sampler, coords, dx, dy);\n")
SLANG_RAW("    ///\n")
SLANG_RAW("    [__NoSideEffect] [ForceInline]\n")
SLANG_RAW("    Footprint queryFootprint")
SLANG_SPLICE(CoarseOrFine
)
SLANG_RAW("Grad(\n")
SLANG_RAW("            FootprintGranularity    granularity,\n")
SLANG_RAW("            SamplerState            sampler,\n")
SLANG_RAW("            Coords                  coords,\n")
SLANG_RAW("            Coords                  dx,\n")
SLANG_RAW("            Coords                  dy)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            Footprint footprint;\n")
SLANG_RAW("            footprint._isSingleLevel = __queryFootprintGradGLSL(sampler, coords, dx, dy, granularity, ")
SLANG_SPLICE(isCoarseVal
)
SLANG_RAW(", footprint);\n")
SLANG_RAW("            return footprint;\n")
SLANG_RAW("        case hlsl:\n")
SLANG_RAW("            uint isSingleLod = 0;\n")
SLANG_RAW("            Footprint footprint = {__queryFootprint")
SLANG_SPLICE(CoarseOrFine
)
SLANG_RAW("GradNVAPI(\n")
SLANG_RAW("                Shape.dimensions,\n")
SLANG_RAW("                __getRegisterSpace(this), __getRegisterIndex(this),\n")
SLANG_RAW("                __getRegisterSpace(sampler), __getRegisterIndex(sampler),\n")
SLANG_RAW("                __vectorReshape<3>(coords), granularity, __vectorReshape<3>(dx), __vectorReshape<3>(dy), /* out */isSingleLod), false};\n")
SLANG_RAW("\n")
SLANG_RAW("            footprint._isSingleLevel = (isSingleLod != 0);\n")
SLANG_RAW("            return footprint;\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Query the footprint that would be accessed by a texture sampling operation.\n")
SLANG_RAW("    ///\n")
SLANG_RAW("    /// This operation queries the footprint that would be accessed\n")
SLANG_RAW("    /// by a comparable call to:\n")
SLANG_RAW("    ///\n")
SLANG_RAW("    ///     t.SampleGradClamp(sampler, coords, dx, dy, lodClamp);\n")
SLANG_RAW("    ///\n")
SLANG_RAW("    [__NoSideEffect][ForceInline]\n")
SLANG_RAW("    Footprint queryFootprint")
SLANG_SPLICE(CoarseOrFine
)
SLANG_RAW("GradClamp(\n")
SLANG_RAW("            FootprintGranularity    granularity,\n")
SLANG_RAW("            SamplerState            sampler,\n")
SLANG_RAW("            Coords                  coords,\n")
SLANG_RAW("            Coords                  dx,\n")
SLANG_RAW("            Coords                  dy,\n")
SLANG_RAW("            float                   lodClamp)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case glsl:\n")
SLANG_RAW("        case spirv:\n")
SLANG_RAW("            Footprint footprint;\n")
SLANG_RAW("            footprint._isSingleLevel = __queryFootprintGradClampGLSL(sampler, coords, dx, dy, lodClamp, granularity, ")
SLANG_SPLICE(isCoarseVal
)
SLANG_RAW(", footprint);\n")
SLANG_RAW("            return footprint;\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")

    // TODO: end texture2D specific functions.
SLANG_RAW("#line 12528 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")

}
SLANG_RAW("#line 12532 \"hlsl.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("} // extension\n")
SLANG_RAW("\n")
SLANG_RAW("// Buffer Pointer\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T, let Alignment : int = 16>\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_HLSLConstBufferPointerType
)
SLANG_RAW(")\n")
SLANG_RAW("__glsl_extension(GL_EXT_buffer_reference)\n")
SLANG_RAW("__magic_type(ConstBufferPointerType)\n")
SLANG_RAW("struct ConstBufferPointer\n")
SLANG_RAW("{\n")
SLANG_RAW("    __glsl_version(450)\n")
SLANG_RAW("    __glsl_extension(GL_EXT_buffer_reference)\n")
SLANG_RAW("    __target_intrinsic(glsl, \"$0._data\")\n")
SLANG_RAW("    [__NoSideEffect]\n")
SLANG_RAW("    T get();\n")
SLANG_RAW("}\n")
