// This file is the single source of truth for all capabilities
// supported by the Slang language.
//
// This file will be parsed and processed by the slang-capability-generator
// tool during the build process to produce slang-generated-capability-defs.h
// and slang-generated-capability-defs-impl.h files that constitute the final
// C++ source of the compiler. New capabilties should be added by editing
// this file instead of the generated .h files.
//
// A capability atom represent a basic unit that characterizes a single code-gen target or
// a platform-specific API/feature, e.g. _GL_EXT_ray_tracing represents the GLSL ray tracing
// extension, and `glsl` represents the GLSL code gen target.
//
// A capability name is defined by a unique disjunction of conjunction of capability atoms.
// For example, `raytracing` is a name that expands to
// glsl + _GL_EXT_ray_tracing | spirv_1_4 + SPV_KHR_ray_tracing | hlsl + _sm_6_4
// which means it requires the `_GL_EXT_ray_tracing` extension when generating code for glsl,
// requires SPV_KHR_ray_tracing for spirv, and requires sm_6_4 when generating hlsl.
//
// There are three types of capability definitions:
// - `def`: this will introduce an new capability atom. If there is an inheritance clause,
//    the capability name will expand to all inherited atoms plus the newly introduced atom.
// - `abstract`: an abstract capability does not introduce an actual atom, but it defines
//   an implicit conflict group such that two capabilities inheriting the same abstract
//   capability cannot be satisfied simultaneously. When used in an expression, `abstract`
//   capability also expands into a disjunction (or) of all inherited capabilities.
// - `alias`: this defines an alias and does not introduce actual atoms.

// Several capabilities represent the target formats in which we generate code.
// Because we can only generate code in one format at a time, all of these are
// marked as conflicting with one another along the `TargetFormat` axis.
//
// Note: We are only including here the source code formats we initially generate
// code in and not the formats that code might be translated into "downstream."
// Trying to figure out how to integrate both kinds of formats into our capability
// system will be an interesting challenge (e.g., can we compile code for `hlsl+spirv`
// and for `glsl+spirv` or even just for `spirv`, and how should all of those impact
// overloading).
//
def textualTarget;

abstract target;
def hlsl : target + textualTarget;
def glsl : target + textualTarget;
def c : target + textualTarget;
def cpp : target + textualTarget;
def cuda : target + textualTarget;
def metal : target + textualTarget;

// We have multiple capabilities for the various SPIR-V versions,
// arranged so that they inherit from one another to represent which versions
// provide a super-set of the features of earlier ones (e.g., SPIR-V 1.4 is
// expressed as inheriting from SPIR-V 1.3).
//
def spirv_1_0 : target;
def spirv_1_1 : spirv_1_0;
def spirv_1_2 : spirv_1_1;
def spirv_1_3 : spirv_1_2;
def spirv_1_4 : spirv_1_3;
def spirv_1_5 : spirv_1_4;
def spirv_1_6 : spirv_1_5;
alias spirv = spirv_1_0;
alias spirv_latest = spirv_1_6;

alias any_target = hlsl | glsl | c | cpp | cuda | spirv;
alias any_textual_target = hlsl | glsl | c | cpp | cuda;
alias any_gfx_target = hlsl | glsl | spirv;
alias any_cpp_target = cpp | cuda;

alias cpp_cuda = cpp | cuda;
alias cpp_cuda_glsl_spirv = cpp | cuda | glsl | spirv;
alias cpp_cuda_glsl_hlsl = cpp | cuda | glsl | hlsl;
alias cpp_cuda_glsl_hlsl_spirv = cpp | cuda | glsl | hlsl | spirv_1_0;
alias cpp_cuda_glsl_hlsl_metal_spirv = cpp | cuda | glsl | hlsl | metal | spirv_1_0;
alias cpp_cuda_hlsl = cpp | cuda | hlsl;
alias cpp_glsl = cpp | glsl;
alias cpp_glsl_hlsl_spirv = cpp | glsl | hlsl | spirv_1_0;
alias cpp_hlsl = cpp | hlsl;
alias cuda_glsl_hlsl = cuda | glsl | hlsl;
alias cuda_glsl_hlsl_spirv = cuda | glsl | hlsl | spirv_1_0;
alias cuda_glsl_spirv = cuda | glsl | spirv;
alias cuda_hlsl = cuda | hlsl;
alias cuda_hlsl_spirv = cuda | hlsl | spirv;
alias glsl_hlsl_spirv = glsl | hlsl | spirv;
alias glsl_spirv = glsl | spirv;
alias hlsl_spirv = hlsl | spirv;

// Capabilities that stand for target spirv version for GLSL backend.
// These are not compilation targets.
def glsl_spirv_1_0 : glsl;
def glsl_spirv_1_1 : glsl_spirv_1_0;
def glsl_spirv_1_2 : glsl_spirv_1_1;
def glsl_spirv_1_3 : glsl_spirv_1_2;
def glsl_spirv_1_4 : glsl_spirv_1_3;
def glsl_spirv_1_5 : glsl_spirv_1_4;
def glsl_spirv_1_6 : glsl_spirv_1_5;

def metallib_2_3 : metal;
def metallib_2_4 : metallib_2_3;


abstract stage;
def vertex : stage;
def fragment : stage;
def compute : stage;
def hull : stage;
def domain : stage;
def geometry : stage;
def raygen : stage;
def intersection : stage;
def anyhit : stage;
def closesthit: stage;
def miss : stage;
def mesh : stage;
def amplification : stage;
def callable : stage;

// shader stage alias's
alias pixel = fragment;
alias raygeneration = raygen;
alias tesscontrol = hull;
alias tesseval = domain;
alias amplification_mesh = amplification | mesh;
alias raytracing_stages = raygen | intersection | anyhit | closesthit | miss | callable;
alias raytracing_stages_intersection = intersection;
alias raytracing_stages_raygen = raygen;
alias raytracing_stages_anyhit_closesthit = anyhit | closesthit;
alias raytracing_stages_raygen_closesthit_miss = raygen | closesthit | miss;
alias raytracing_stages_anyhit_closesthit_intersection = anyhit | closesthit | intersection;
alias raytracing_stages_anyhit_closesthit_intersection_miss = anyhit | closesthit | intersection | miss;
alias raytracing_stages_raygen_closesthit_miss_callable = raygen | closesthit | miss | callable;
alias shader_stages_compute_tesscontrol_tesseval = compute | tesscontrol | tesseval;
alias shader_stages_compute_fragment = compute | fragment;
alias shader_stages_compute_fragment_geometry_vertex = compute | fragment | geometry | vertex;
alias shader_stages_domain_hull = domain | hull;
alias raytracing_stages_fragment = raytracing_stages | fragment;
alias raytracing_stages_compute = raytracing_stages | compute;
alias raytracing_stages_compute_amplification_mesh = raytracing_stages_compute | amplification_mesh;
alias raytracing_stages_compute_fragment = raytracing_stages | shader_stages_compute_fragment;
alias raytracing_stages_compute_fragment_geometry_vertex = raytracing_stages | shader_stages_compute_fragment_geometry_vertex;

def _GLSL_130 : glsl;
def _GLSL_140 : _GLSL_130;
def _GLSL_150 : _GLSL_140;
def _GLSL_330 : _GLSL_150;
def _GLSL_400 : _GLSL_330;
def _GLSL_410 : _GLSL_400;
def _GLSL_420 : _GLSL_410;
def _GLSL_430 : _GLSL_420;
def _GLSL_440 : _GLSL_430;
def _GLSL_450 : _GLSL_440;
def _GLSL_460 : _GLSL_450;

def _sm_4_0 : hlsl;
def _sm_4_1 : _sm_4_0;
def _sm_5_0 : _sm_4_1;
def _sm_5_1 : _sm_5_0;
def _sm_6_0 : _sm_5_1;
def _sm_6_1 : _sm_6_0;
def _sm_6_2 : _sm_6_1;
def _sm_6_3 : _sm_6_2;
def _sm_6_4 : _sm_6_3;
def _sm_6_5 : _sm_6_4;
def _sm_6_6 : _sm_6_5;
def _sm_6_7 : _sm_6_6;

def hlsl_nvapi : hlsl;

def _cuda_sm_1_0 : cuda;
def _cuda_sm_2_0 : _cuda_sm_1_0;
def _cuda_sm_3_0 : _cuda_sm_2_0;
def _cuda_sm_3_5 : _cuda_sm_3_0;
def _cuda_sm_4_0 : _cuda_sm_3_5;
def _cuda_sm_5_0 : _cuda_sm_4_0;
def _cuda_sm_6_0 : _cuda_sm_5_0;
def _cuda_sm_7_0 : _cuda_sm_6_0;
def _cuda_sm_8_0 : _cuda_sm_7_0;
def _cuda_sm_9_0 : _cuda_sm_8_0;

// SPIRV extensions.

def SOURCE_EXT_GL_NV_compute_shader_derivatives : spirv_1_0;

def SPV_EXT_fragment_shader_interlock : spirv_1_0;
def SPV_KHR_fragment_shader_barycentric : spirv_1_0;
def SPV_EXT_fragment_fully_covered : spirv_1_0;
def SPV_EXT_descriptor_indexing : spirv_1_0;
def SPV_EXT_shader_atomic_float_add : spirv_1_0;
def SPV_EXT_shader_atomic_float16_add : SPV_EXT_shader_atomic_float_add;
def SPV_EXT_shader_atomic_float_min_max : spirv_1_0;
def SPV_KHR_non_semantic_info : spirv_1_0;
def SPV_NV_shader_subgroup_partitioned : spirv_1_0;
def SPV_NV_ray_tracing_motion_blur : spirv_1_0;
def SPV_EXT_mesh_shader : spirv_1_4;
def SPV_KHR_ray_tracing : spirv_1_4;
def SPV_KHR_ray_query : spirv_1_0;
def SPV_KHR_ray_tracing_position_fetch : SPV_KHR_ray_tracing + SPV_KHR_ray_query;
def SPV_NV_shader_invocation_reorder : spirv_1_5 + SPV_KHR_ray_tracing;
def SPV_KHR_shader_clock : spirv_1_0;
def SPV_NV_shader_image_footprint : spirv_1_0;
def SPV_GOOGLE_user_type : spirv_1_0;
def SPV_NV_compute_shader_derivatives : spirv_1_0;

// SPIRV Capabilities.

def spvAtomicFloat32AddEXT : SPV_EXT_shader_atomic_float_add;
def spvAtomicFloat16AddEXT : SPV_EXT_shader_atomic_float16_add;
def spvInt64Atomics : spirv_1_0;
def spvAtomicFloat32MinMaxEXT : SPV_EXT_shader_atomic_float_min_max;
def spvAtomicFloat16MinMaxEXT : SPV_EXT_shader_atomic_float_min_max;
def spvDerivativeControl : spirv_1_0;
def spvImageQuery : spirv_1_0;
def spvImageGatherExtended : spirv_1_0;
def spvImageFootprintNV : SPV_NV_shader_image_footprint;
def spvMinLod : spirv_1_0;
def spvFragmentShaderPixelInterlockEXT : SPV_EXT_fragment_shader_interlock;
def spvFragmentBarycentricKHR : SPV_KHR_fragment_shader_barycentric;
def spvFragmentFullyCoveredEXT : SPV_EXT_fragment_fully_covered;
def spvGroupNonUniformBallot : spirv_1_3;
def spvGroupNonUniformShuffle : spirv_1_3;
def spvGroupNonUniformArithmetic : spirv_1_3;
def spvGroupNonUniformQuad : spirv_1_3;
def spvGroupNonUniformVote : spirv_1_3;
def spvGroupNonUniformPartitionedNV : spirv_1_3 + SPV_NV_shader_subgroup_partitioned;
def spvRayTracingMotionBlurNV : SPV_NV_ray_tracing_motion_blur;
def spvMeshShadingEXT : SPV_EXT_mesh_shader;
def spvRayTracingKHR : SPV_KHR_ray_tracing;
def spvRayTracingPositionFetchKHR : SPV_KHR_ray_tracing_position_fetch;
def spvRayQueryKHR : SPV_KHR_ray_query;
def spvRayQueryPositionFetchKHR : SPV_KHR_ray_tracing_position_fetch;
def spvShaderInvocationReorderNV : SPV_NV_shader_invocation_reorder;
def spvShaderClockKHR : SPV_KHR_shader_clock;
def spvShaderNonUniform : spirv_1_5;

// The following capabilities all pertain to how ray tracing shaders are translated
// to GLSL, where there are two different extensions that can provide the core
// functionality of `TraceRay` and the related operations.
//
// The two extensions are expressed as distinct capabilities that both are marked
// as conflicting on the `RayTracingExtension` axis, so that a compilation target
// cannot have both enabled at once.
//
// The `_GL_EXT_ray_tracing` extension should be favored, so it has a rank of `1`
// instead of `0`, which means that when comparing overloads that require these
// extensions, the `EXT` extension will be favored over the `NV` extension, if
// all other factors are equal.
//

def _GL_ARB_derivative_control : glsl;
def _GL_ARB_fragment_shader_interlock : glsl;
def _GL_ARB_gpu_shader5 : glsl;
def _GL_ARB_shader_image_size : glsl;
def _GL_ARB_shader_texture_image_samples : glsl;
def _GL_ARB_sparse_texture_clamp : glsl;
def _GL_EXT_texture_query_lod : glsl;
def _GL_ARB_texture_query_levels : glsl;
def _GL_ARB_texture_cube_map : glsl;
def _GL_ARB_texture_gather : glsl;
def _GL_EXT_buffer_reference : glsl;
def _GL_EXT_buffer_reference_uvec2 : glsl;
def _GL_EXT_debug_printf : glsl;
def _GL_EXT_fragment_shader_barycentric : glsl;
def _GL_EXT_mesh_shader : glsl;
def _GL_EXT_nonuniform_qualifier : glsl;
def _GL_EXT_ray_query : glsl_spirv_1_4;
def _GL_EXT_ray_tracing : glsl_spirv_1_4;
def _GL_EXT_ray_tracing_position_fetch : glsl_spirv_1_4;
def _GL_EXT_samplerless_texture_functions : glsl;
def _GL_EXT_shader_atomic_float : glsl;
def _GL_EXT_shader_atomic_float2 : glsl;
def _GL_EXT_shader_atomic_int64 : glsl;
def _GL_EXT_shader_atomic_float_min_max : glsl;
def _GL_EXT_shader_explicit_arithmetic_types_int64 : glsl;
def _GL_EXT_shader_image_load_store : glsl;
def _GL_EXT_shader_realtime_clock : glsl;
def _GL_EXT_texture_shadow_lod : glsl;
def _GL_KHR_memory_scope_semantics : glsl;
def _GL_KHR_shader_subgroup_arithmetic : glsl;
def _GL_KHR_shader_subgroup_basic : glsl;
def _GL_KHR_shader_subgroup_ballot : glsl;
def _GL_KHR_shader_subgroup_quad : glsl;
def _GL_KHR_shader_subgroup_shuffle : glsl;
def _GL_KHR_shader_subgroup_shuffle_relative : glsl;
def _GL_KHR_shader_subgroup_shuffle_clustered : glsl;
def _GL_KHR_shader_subgroup_vote : glsl;
def _GL_NV_compute_shader_derivatives : glsl;
def _GL_NV_shader_subgroup_partitioned : glsl;
def _GL_NV_ray_tracing_motion_blur : glsl_spirv_1_4;
def _GL_NV_shader_atomic_fp16_vector : glsl;
def _GL_NV_shader_invocation_reorder : glsl_spirv_1_4;
def _GL_NV_shader_texture_footprint : glsl;
def _GL_NV_gpu_shader5 : _GL_ARB_gpu_shader5;
alias _GL_NV_fragment_shader_barycentric = _GL_EXT_fragment_shader_barycentric;
alias _GL_NV_ray_tracing = _GL_EXT_ray_tracing;

// GLSL extension and SPV extension associations.
alias GL_ARB_derivative_control = _GL_ARB_derivative_control | spvDerivativeControl;
alias GL_ARB_fragment_shader_interlock = _GL_ARB_fragment_shader_interlock | spvFragmentShaderPixelInterlockEXT;
alias GL_ARB_gpu_shader5 = _GL_ARB_gpu_shader5 | spirv_1_0;
alias GL_ARB_sparse_texture_clamp = _GL_ARB_fragment_shader_interlock | spirv_1_0;
alias GL_EXT_texture_query_lod = _GL_EXT_texture_query_lod | spvImageQuery;
alias GL_ARB_texture_query_levels = _GL_ARB_texture_query_levels |spvImageQuery;
alias GL_ARB_texture_cube_map = _GL_ARB_texture_cube_map | spirv_1_0;
alias GL_ARB_texture_gather = _GL_ARB_texture_gather | spirv_1_0;
alias GL_EXT_buffer_reference = _GL_ARB_fragment_shader_interlock | spirv_1_5;
alias GL_EXT_buffer_reference_uvec2 = _GL_EXT_buffer_reference_uvec2 | spirv_1_0;
alias GL_EXT_debug_printf = _GL_EXT_debug_printf | SPV_KHR_non_semantic_info;
alias GL_EXT_fragment_shader_barycentric = _GL_EXT_fragment_shader_barycentric | spvFragmentBarycentricKHR;
alias GL_EXT_mesh_shader = _GL_EXT_mesh_shader | spvMeshShadingEXT;
alias GL_EXT_nonuniform_qualifier = _GL_EXT_nonuniform_qualifier | spvShaderNonUniform;
alias GL_EXT_ray_query = _GL_EXT_ray_query | spvRayTracingKHR + spvRayQueryKHR;
alias GL_EXT_ray_tracing = _GL_EXT_ray_tracing | spvRayTracingKHR + spvRayQueryKHR;
alias GL_EXT_ray_tracing_position_fetch = _GL_EXT_ray_tracing_position_fetch | spvRayTracingPositionFetchKHR + spvRayQueryPositionFetchKHR;
alias GL_EXT_samplerless_texture_functions = _GL_EXT_samplerless_texture_functions | spirv_1_0;
alias GL_EXT_shader_atomic_float = _GL_EXT_shader_atomic_float | spvAtomicFloat32AddEXT + spvAtomicFloat32MinMaxEXT;
alias GL_EXT_shader_atomic_float2 = _GL_EXT_shader_atomic_float2 | spvAtomicFloat32AddEXT + spvAtomicFloat32MinMaxEXT + spvAtomicFloat16AddEXT + spvAtomicFloat16MinMaxEXT;
alias GL_EXT_shader_atomic_int64 = _GL_EXT_shader_atomic_int64 | spvInt64Atomics;
alias GL_EXT_shader_atomic_float_min_max = _GL_EXT_shader_atomic_float_min_max | spvAtomicFloat32MinMaxEXT + spvAtomicFloat16MinMaxEXT;
alias GL_EXT_shader_explicit_arithmetic_types_int64 = _GL_EXT_shader_explicit_arithmetic_types_int64 | spirv_1_0;
alias GL_EXT_shader_image_load_store = _GL_EXT_shader_image_load_store | spirv_1_0;
alias GL_EXT_shader_realtime_clock = _GL_EXT_shader_realtime_clock | spvShaderClockKHR;
alias GL_EXT_texture_shadow_lod = _GL_EXT_texture_shadow_lod + _GLSL_400 | spirv_1_0;
alias GL_KHR_memory_scope_semantics = _GL_KHR_memory_scope_semantics | spirv_1_0;
alias GL_KHR_shader_subgroup_arithmetic = _GL_KHR_shader_subgroup_arithmetic | spvGroupNonUniformArithmetic;
alias GL_KHR_shader_subgroup_basic = _GL_KHR_shader_subgroup_basic | spvGroupNonUniformBallot;
alias GL_KHR_shader_subgroup_ballot = _GL_KHR_shader_subgroup_ballot | spvGroupNonUniformBallot;
alias GL_KHR_shader_subgroup_clustered = _GL_KHR_shader_subgroup_shuffle_clustered | spvGroupNonUniformShuffle;
alias GL_KHR_shader_subgroup_shuffle = _GL_KHR_shader_subgroup_shuffle | spvGroupNonUniformShuffle;
alias GL_KHR_shader_subgroup_shuffle_relative = _GL_KHR_shader_subgroup_shuffle_relative | spvGroupNonUniformShuffle;
alias GL_KHR_shader_subgroup_vote = _GL_KHR_shader_subgroup_vote | spvGroupNonUniformVote;
alias GL_KHR_shader_subgroup_quad = _GL_KHR_shader_subgroup_quad | spvGroupNonUniformQuad;
alias GL_NV_compute_shader_derivatives = _GL_NV_compute_shader_derivatives | SOURCE_EXT_GL_NV_compute_shader_derivatives | SPV_NV_compute_shader_derivatives | _sm_6_6;
alias GL_ARB_shader_image_size = _GL_ARB_shader_image_size | spvImageQuery;
alias GL_ARB_shader_texture_image_samples = _GL_ARB_shader_texture_image_samples | spvImageQuery;
alias GL_NV_shader_atomic_fp16_vector = _GL_NV_shader_atomic_fp16_vector + _GL_NV_gpu_shader5 | spirv_1_0;
alias GL_NV_shader_subgroup_partitioned = _GL_NV_shader_subgroup_partitioned | spvGroupNonUniformPartitionedNV;
alias GL_NV_ray_tracing_motion_blur = _GL_NV_ray_tracing_motion_blur | spvRayTracingMotionBlurNV;
alias GL_NV_shader_invocation_reorder = _GL_NV_shader_invocation_reorder + _GL_EXT_buffer_reference_uvec2 | spvShaderInvocationReorderNV;
alias GL_NV_shader_texture_footprint = _GL_NV_shader_texture_footprint | spvImageFootprintNV;

alias GL_NV_fragment_shader_barycentric = GL_EXT_fragment_shader_barycentric;
alias GL_NV_ray_tracing = GL_EXT_ray_tracing;

// Define feature names

alias nvapi = hlsl_nvapi;
alias raytracing = GL_EXT_ray_tracing | _sm_6_5 | cuda;
alias ser = raytracing + GL_NV_shader_invocation_reorder | raytracing + hlsl_nvapi | cuda;
alias motionblur = GL_NV_ray_tracing_motion_blur | _sm_6_5 + hlsl_nvapi | cuda;
alias rayquery = GL_EXT_ray_query | _sm_6_5;
alias raytracing_motionblur =  raytracing + motionblur | cuda;
alias ser_motion = ser + motionblur;
alias shaderclock = GL_EXT_shader_realtime_clock | hlsl_nvapi | cpp | cuda;
alias meshshading_internal = spvMeshShadingEXT + _sm_6_5 + _GL_EXT_mesh_shader;
alias meshshading = amplification + meshshading_internal | mesh + meshshading_internal;
alias fragmentshaderinterlock = _GL_ARB_fragment_shader_interlock | hlsl_nvapi | spvFragmentShaderPixelInterlockEXT;
alias atomic64 = GL_EXT_shader_atomic_int64 | _sm_6_6 | cpp | cuda;
alias atomicfloat = GL_EXT_shader_atomic_float | _sm_6_0 + hlsl_nvapi | cpp | cuda;
alias atomicfloat2 = GL_EXT_shader_atomic_float2 | _sm_6_6 + hlsl_nvapi | cpp | cuda;
alias groupnonuniform = GL_KHR_shader_subgroup_ballot + GL_KHR_shader_subgroup_shuffle
                          + GL_KHR_shader_subgroup_arithmetic + GL_KHR_shader_subgroup_quad + GL_KHR_shader_subgroup_vote
                        | _sm_6_0 | cuda;
alias fragmentshaderbarycentric = GL_EXT_fragment_shader_barycentric | _sm_6_1;
alias shadermemorycontrol = glsl | spirv_1_0 | _sm_5_0;
alias shadermemorycontrol_compute = raytracing_stages_compute + shadermemorycontrol;
alias subpass = fragment + any_gfx_target;
alias subgroup_basic = GL_KHR_shader_subgroup_basic | GL_KHR_shader_subgroup_basic + spirv_1_0 | _sm_6_0 | _cuda_sm_7_0;
alias subgroup_basic_ballot = GL_KHR_shader_subgroup_basic + GL_KHR_shader_subgroup_ballot | _sm_6_0 | _cuda_sm_7_0;
alias subgroup_vote = GL_KHR_shader_subgroup_vote | _sm_6_0 | _cuda_sm_7_0;
alias subgroup_arithmetic = GL_KHR_shader_subgroup_arithmetic | _sm_6_0 | _cuda_sm_7_0;
alias subgroup_ballot = GL_KHR_shader_subgroup_ballot | _sm_6_0 | _cuda_sm_7_0;
alias subgroup_shuffle = GL_KHR_shader_subgroup_shuffle | _sm_6_0 | _cuda_sm_7_0;
alias subgroup_shufflerelative = GL_KHR_shader_subgroup_shuffle_relative | _sm_6_0 | _cuda_sm_7_0;
alias subgroup_clustered = GL_KHR_shader_subgroup_clustered | _sm_6_0 | _cuda_sm_7_0;
alias subgroup_quad = GL_KHR_shader_subgroup_quad | _sm_6_0 | _cuda_sm_7_0;
alias subgroup_partitioned = GL_NV_shader_subgroup_partitioned | _sm_6_5;
alias shaderinvocationgroup = subgroup_vote;
alias waveprefix = _sm_6_5 | _cuda_sm_7_0 | GL_KHR_shader_subgroup_arithmetic;
alias bufferreference = GL_EXT_buffer_reference;
alias bufferreference_int64 = bufferreference + GL_EXT_shader_explicit_arithmetic_types_int64;

// Define what each HLSL shader model means on different targets.


alias sm_4_0 = _sm_4_0
             | glsl_spirv_1_0 + _GL_ARB_sparse_texture_clamp + _GL_EXT_samplerless_texture_functions
             | spirv_1_0 + spvImageQuery + spvImageGatherExtended + spvMinLod + SPV_GOOGLE_user_type
             | _cuda_sm_2_0
             | metal
             | cpp
             ;

alias sm_4_1 = _sm_4_1
             | glsl_spirv_1_0 + sm_4_0
             | spirv_1_0 + sm_4_0
             | _cuda_sm_6_0
             | metal
             | cpp
             ;

alias sm_5_0 = _sm_5_0 
             | glsl_spirv_1_0 + sm_4_1 + _GL_KHR_memory_scope_semantics
             | spirv_1_0 + sm_4_1 + spvDerivativeControl + spvFragmentFullyCoveredEXT
             | _cuda_sm_9_0
             | metal
             | cpp
             ;

alias sm_5_1 = _sm_5_1 
             | glsl_spirv_1_0 + sm_5_0 + _GL_ARB_gpu_shader5 + _GL_EXT_nonuniform_qualifier
             | spirv_1_0 + sm_5_0 + spvShaderNonUniform
             | _cuda_sm_9_0
             | metal
             | cpp
             ;

alias sm_6_0 = _sm_6_0 
             | glsl_spirv_1_3 + sm_5_1
                + groupnonuniform + atomicfloat
             | spirv_1_3 + sm_5_1
                + groupnonuniform + atomicfloat 
             | _cuda_sm_9_0 
             | metal
             | cpp
             ;

alias sm_6_1 = _sm_6_1 
             | glsl_spirv_1_3 + sm_6_0 + fragmentshaderbarycentric 
             | spirv_1_3 + sm_6_0 + fragmentshaderbarycentric 
             | _cuda_sm_9_0
             | metal
             | cpp
             ;

alias sm_6_2 = _sm_6_2
             | glsl_spirv_1_3 + sm_6_1
             | spirv_1_3 + sm_6_1
             | _cuda_sm_9_0
             | metal
             | cpp
             ;

alias sm_6_3 = _sm_6_3 
             | glsl_spirv_1_4 + sm_6_2 + _GL_EXT_ray_tracing
             | spirv_1_4 + sm_6_2 + SPV_KHR_ray_tracing
             | _cuda_sm_9_0
             | metal
             | cpp
             ;

alias sm_6_4 = _sm_6_4
             | glsl_spirv_1_4 + sm_6_3
             | spirv_1_4 + sm_6_3
             | _cuda_sm_9_0
             | metal
             | cpp
             ;

alias sm_6_5 = _sm_6_5
             | glsl_spirv_1_4 + sm_6_4 + raytracing + meshshading
             | spirv_1_4 + sm_6_4 + raytracing + meshshading
             | _cuda_sm_9_0
             | metal
             | cpp
             ;

alias sm_6_6 = _sm_6_6
             | glsl_spirv_1_5 + sm_6_5
                + GL_EXT_shader_atomic_int64 + atomicfloat2
             | spirv_1_5 + sm_6_5
                + GL_EXT_shader_atomic_int64 + atomicfloat2
                + SPV_EXT_descriptor_indexing
             | _cuda_sm_9_0
             | metal
             | cpp
             ;

alias sm_6_7 = _sm_6_7
             | glsl_spirv_1_5 + sm_6_6
             | spirv_1_5 + sm_6_6
             | _cuda_sm_9_0
             | metal
             | cpp
             ;
// Profiles

alias GLSL_130 = _GLSL_130
               | _sm_4_0
               | _cuda_sm_2_0
               | spirv_1_0
               | metal
               | cpp
               ;
alias GLSL_140 = _GLSL_140
               | _sm_4_1
               | _cuda_sm_2_0
               | spirv_1_0
                | metal
               | cpp
               ;
alias GLSL_150 = _GLSL_150
               | _sm_4_1
               | _cuda_sm_2_0
               | spirv_1_0
               | metal
               | cpp
               ;
alias GLSL_330 = _GLSL_330
               | _sm_5_0
               | _cuda_sm_6_0
               | spirv_1_0
               | metal
               | cpp
               ;
alias GLSL_400 = _GLSL_400
               | _sm_5_1
               | _cuda_sm_6_0
               | spirv_1_3
               | metal
               | cpp
               ;
alias GLSL_410 = _GLSL_410
               | _sm_5_1
               | _cuda_sm_6_0
               | spirv_1_3
               | metal
               | cpp
               ;
alias GLSL_420 = _GLSL_420
               | _sm_5_1
               | _cuda_sm_6_0
               | spirv_1_3
               | metal
               | cpp
               ;
alias GLSL_430 = _GLSL_430
               | _sm_5_1
               | _cuda_sm_6_0
               | spirv_1_3
               | metal
               | cpp
               ;
alias GLSL_440 = _GLSL_440
               | _sm_6_0
               | _cuda_sm_6_0
               | spirv_1_5
               | metal
               | cpp
               ;
alias GLSL_450 = _GLSL_450
               | _sm_6_0
               | _cuda_sm_6_0
               | spirv_1_5
               | metal
               | cpp
               ;
alias GLSL_460 = _GLSL_460
               | _sm_6_6
               | _cuda_sm_6_0
               | spirv_1_5
               | metal
               | cpp
               ;

alias GLSL_410_SPIRV_1_0 = _GLSL_410 + GLSL_400 | GLSL_400;
alias GLSL_420_SPIRV_1_0 = _GLSL_420 + GLSL_410_SPIRV_1_0 | GLSL_410_SPIRV_1_0;
alias GLSL_430_SPIRV_1_0 = _GLSL_430 + GLSL_420_SPIRV_1_0 | GLSL_420_SPIRV_1_0;

alias DX_4_0 = sm_4_0;
alias DX_4_1 = sm_4_1;
alias DX_5_0 = sm_5_0;
alias DX_5_1 = sm_5_1;
alias DX_6_0 = sm_6_0;
alias DX_6_1 = sm_6_1;
alias DX_6_2 = sm_6_2;
alias DX_6_3 = sm_6_3;
alias DX_6_4 = sm_6_4;
alias DX_6_5 = sm_6_5;
alias DX_6_6 = sm_6_6;
alias DX_6_7 = sm_6_7;


alias METAL_2_3 = metallib_2_3;
alias METAL_2_4 = metallib_2_4;

alias sm_2_0_GLSL_140 = sm_4_0 | glsl | spirv_1_0 | cuda | cpp;
alias sm_2_0_GLSL_400 = sm_4_0 | glsl | spirv_1_0 | cuda | cpp;
alias appendstructuredbuffer = sm_5_0 + raytracing_stages_compute_fragment;
alias atomic_hlsl = _sm_4_0;
alias atomic_hlsl_nvapi = _sm_4_0 + hlsl_nvapi;
alias atomic_hlsl_sm_6_6 = _sm_6_6;
alias byteaddressbuffer = sm_4_0;
alias byteaddressbuffer_rw = sm_4_0 + raytracing_stages_compute_fragment;
alias consumestructuredbuffer = sm_5_0 + raytracing_stages_compute_fragment;
alias fragmentprocessing = fragment + _sm_5_0
                         | fragment + glsl_spirv
                         | raytracing_stages_compute_amplification_mesh + GL_NV_compute_shader_derivatives
                         ;
alias fragmentprocessing_derivativecontrol = fragment + _sm_5_0
                                           | fragment + GL_ARB_derivative_control
                                           | raytracing_stages_compute_amplification_mesh + GL_NV_compute_shader_derivatives
                                           ;
alias getattributeatvertex = fragment + _sm_6_1 | fragment + GL_EXT_fragment_shader_barycentric;
alias memorybarrier_compute = raytracing_stages_compute + sm_5_0;
alias structuredbuffer = sm_4_0;
alias structuredbuffer_rw = sm_4_0 + raytracing_stages_compute_fragment;
alias texture_sm_4_1 = sm_4_1 + _GLSL_150 | sm_4_1;
alias texture_sm_4_1_samplerless = texture_sm_4_1 + GL_EXT_samplerless_texture_functions;
alias texture_sm_4_1_compute_fragment = cpp + texture_sm_4_1
                              | cuda + texture_sm_4_1
                              | glsl + texture_sm_4_1
                              | hlsl + texture_sm_4_1 + raytracing_stages_compute_fragment
                              | spirv_1_0 + texture_sm_4_1
                              ;
// supposedly works on compute but docs say nothing, so for now keep as compute_fragment
alias texture_sm_4_1_fragment = cpp + texture_sm_4_1
                              | cuda + texture_sm_4_1
                              | glsl + texture_sm_4_1
                              | hlsl + texture_sm_4_1 + raytracing_stages_compute_fragment
                              | spirv_1_0 + texture_sm_4_1
                              ;
alias texture_sm_4_1_clamp_fragment = texture_sm_4_1_fragment + GL_ARB_sparse_texture_clamp;
alias texture_sm_4_1_vertex_fragment_geometry = cpp + texture_sm_4_1
                                              | cuda + texture_sm_4_1
                                              | glsl + texture_sm_4_1
                                              | hlsl + texture_sm_4_1 + raytracing_stages_compute_fragment_geometry_vertex
                                              | spirv_1_0 + texture_sm_4_1
                                              ;
alias texture_gather = texture_sm_4_1_vertex_fragment_geometry + GL_ARB_texture_gather;
alias image_samples = texture_sm_4_1_compute_fragment + GL_ARB_shader_texture_image_samples;
alias image_size = texture_sm_4_1_compute_fragment + GL_ARB_shader_image_size;
alias texture_size = texture_sm_4_1 + GL_ARB_shader_image_size;
alias texture_querylod = texture_sm_4_1 + GL_EXT_texture_query_lod;
alias texture_querylevels = texture_sm_4_1 + GL_ARB_texture_query_levels;
alias texture_shadowlod = texture_sm_4_1 + GL_EXT_texture_shadow_lod
                        | texture_sm_4_1;
alias texture_shadowlod_cube = texture_shadowlod | texture_shadowlod + GL_ARB_texture_cube_map;
alias texture_cube = texture_sm_4_1 + GL_ARB_texture_cube_map | texture_sm_4_1;
alias texture_querylevels_cube = texture_querylevels + GL_ARB_texture_cube_map | texture_querylevels;

alias atomic_glsl_float1 = GL_EXT_shader_atomic_float;
alias atomic_glsl_float2 = GL_EXT_shader_atomic_float2;
alias atomic_glsl_halfvec = GL_NV_shader_atomic_fp16_vector;
alias atomic_glsl = GLSL_430_SPIRV_1_0;
alias atomic_glsl_int64 = atomic_glsl + GL_EXT_shader_atomic_int64;
alias GLSL_430_SPIRV_1_0_compute = GLSL_430_SPIRV_1_0 + compute;
alias image_loadstore = GL_EXT_shader_image_load_store + GLSL_420;
alias nonuniformqualifier = sm_5_1;
alias printf = GL_EXT_debug_printf | _sm_4_0 | _cuda_sm_2_0 | cpp;
alias texturefootprint = GL_NV_shader_texture_footprint + GLSL_450 | hlsl_nvapi + _sm_4_0;
alias texturefootprintclamp = texturefootprint + GL_ARB_sparse_texture_clamp;

alias shader5_sm_4_0 = GL_ARB_gpu_shader5 | sm_4_0;
alias shader5_sm_5_0 = GL_ARB_gpu_shader5 | sm_5_0;

alias atomic_glsl_hlsl_cuda = atomic_glsl | _sm_5_0 | _cuda_sm_2_0;
alias atomic_glsl_hlsl_cuda_float1 = atomic_glsl_float1 | atomic_hlsl_nvapi | _cuda_sm_2_0;
alias atomic_glsl_hlsl_cuda_float2 = atomic_glsl_float2 | atomic_hlsl_nvapi | _cuda_sm_2_0;
alias atomic_glsl_hlsl_cuda2_int64 = atomic_glsl_int64 | atomic_hlsl_nvapi | _cuda_sm_2_0;
alias atomic_glsl_hlsl_cuda5_int64 = atomic_glsl_int64 | atomic_hlsl_nvapi | _cuda_sm_6_0;
alias atomic_glsl_hlsl_cuda6_int64 = atomic_glsl_int64 | atomic_hlsl_nvapi | _cuda_sm_6_0;
alias atomic_glsl_hlsl_cuda9_int64 = atomic_glsl_int64 | atomic_hlsl_nvapi | _cuda_sm_9_0;

alias breakpoint = GL_EXT_debug_printf | hlsl | _cuda_sm_8_0 | cpp;

alias rayobject = raytracing | rayquery;
alias raytracing_allstages = raytracing_stages + raytracing;
alias raytracing_anyhit = anyhit + raytracing;
alias raytracing_intersection = raytracing_stages_intersection + raytracing;
alias raytracing_anyhit_closesthit = raytracing_stages_anyhit_closesthit + raytracing;
alias raytracing_anyhit_closesthit_intersection = raytracing_stages_anyhit_closesthit_intersection + raytracing;
alias raytracing_raygen_closesthit_miss = raytracing_stages_raygen_closesthit_miss + raytracing;
alias raytracing_anyhit_closesthit_intersection_miss = raytracing_stages_anyhit_closesthit_intersection_miss + raytracing;
alias raytracing_raygen_closesthit_miss_callable = raytracing_stages_raygen_closesthit_miss_callable + raytracing;
alias raytracing_position = raytracing + GL_EXT_ray_tracing_position_fetch + anyhit + closesthit;
alias raytracing_motionblur_anyhit_closesthit_intersection_miss = raytracing_stages_anyhit_closesthit_intersection_miss + raytracing_motionblur;
alias raytracing_motionblur_raygen_closesthit_miss = raytracing_stages_raygen_closesthit_miss + raytracing_motionblur;
alias rayquery_position = rayquery + GL_EXT_ray_tracing_position_fetch;
alias ser_raygen = raytracing_stages_raygen + ser;
alias ser_raygen_closesthit_miss = raytracing_stages_raygen_closesthit_miss + ser;
alias ser_any_closesthit_intersection_miss = raytracing_stages_anyhit_closesthit_intersection_miss + ser;
alias ser_anyhit_closesthit_intersection = raytracing_stages_anyhit_closesthit_intersection + ser;
alias ser_anyhit_closesthit = raytracing_stages_anyhit_closesthit + ser;
alias ser_motion_raygen_closesthit_miss = raytracing_stages_raygen_closesthit_miss + ser_motion;
alias ser_motion_raygen = raytracing_stages_raygen + ser_motion;

alias all = _sm_6_7 + hlsl_nvapi
          | glsl_spirv_1_5 + sm_6_7
             + ser + shaderclock + texturefootprint + fragmentshaderinterlock + _GL_NV_shader_subgroup_partitioned
             + _GL_NV_ray_tracing_motion_blur + _GL_NV_shader_texture_footprint
          | spirv_1_5 + sm_6_7
             + ser + shaderclock + texturefootprint + fragmentshaderinterlock + spvGroupNonUniformPartitionedNV
             + spvRayTracingMotionBlurNV + spvRayTracingMotionBlurNV;
