SLANG_RAW("public module core;\n")
SLANG_RAW("\n")
SLANG_RAW("// Slang `core` library\n")
SLANG_RAW("\n")
SLANG_RAW("// Aliases for base types\n")
SLANG_RAW("/// @category scalar_types Scalar types\n")
SLANG_RAW("typedef half float16_t;\n")
SLANG_RAW("/// @category scalar_types\n")
SLANG_RAW("typedef float float32_t;\n")
SLANG_RAW("/// @category scalar_types\n")
SLANG_RAW("typedef double float64_t;\n")
SLANG_RAW("\n")
SLANG_RAW("/// @category scalar_types\n")
SLANG_RAW("typedef int int32_t;\n")
SLANG_RAW("\n")
SLANG_RAW("/// @category scalar_types\n")
SLANG_RAW("typedef uint uint32_t;\n")
SLANG_RAW("\n")
SLANG_RAW("/// @category scalar_types\n")
SLANG_RAW("typedef uintptr_t size_t;\n")
SLANG_RAW("/// @category scalar_types\n")
SLANG_RAW("typedef uintptr_t usize_t;\n")
SLANG_RAW("/// @category scalar_types\n")
SLANG_RAW("typedef intptr_t ssize_t;\n")
SLANG_RAW("\n")
SLANG_RAW("// Modifier for variables that must resolve to compile-time constants\n")
SLANG_RAW("// as part of translation.\n")
SLANG_RAW("syntax constexpr : ConstExprModifier;\n")
SLANG_RAW("\n")
SLANG_RAW("// Modifier for variables that should have writes be made\n")
SLANG_RAW("// visible at the global-memory scope\n")
SLANG_RAW("syntax globallycoherent : GloballyCoherentModifier;\n")
SLANG_RAW("\n")
SLANG_RAW("/// Modifier to disable inteprolation and force per-vertex passing of a varying attribute.\n")
SLANG_RAW("///\n")
SLANG_RAW("/// When a varying attribute passed to the fragment shader is marked `pervertex`, it will\n")
SLANG_RAW("/// not be interpolated during rasterization (similar to `nointerpolate` attributes).\n")
SLANG_RAW("/// Unlike a plain `nointerpolate` attribute, this modifier indicates that the attribute\n")
SLANG_RAW("/// should *only* be acccessed through the `GetAttributeAtVertex()` operation, so access its\n")
SLANG_RAW("/// distinct per-vertex values.\n")
SLANG_RAW("///\n")
SLANG_RAW("syntax pervertex : PerVertexModifier;\n")
SLANG_RAW("\n")
SLANG_RAW("/// Modifier to indicate a buffer or texture element type is\n")
SLANG_RAW("/// backed by data in an unsigned normalized format.\n")
SLANG_RAW("///\n")
SLANG_RAW("/// The `unorm` modifier is only valid on `float` and `vector`s\n")
SLANG_RAW("/// with `float` elements.\n")
SLANG_RAW("///\n")
SLANG_RAW("/// This modifier does not affect the semantics of any variable,\n")
SLANG_RAW("/// parameter, or field that uses it. The semantics of a `float`\n")
SLANG_RAW("/// or vector are the same with or without `unorm`.\n")
SLANG_RAW("///\n")
SLANG_RAW("/// The `unorm` modifier can be used for the element type of a\n")
SLANG_RAW("/// buffer or texture, to indicate that the data that is bound\n")
SLANG_RAW("/// to that buffer or texture is in a matching normalized format.\n")
SLANG_RAW("/// Some platforms may require a `unorm` qualifier for such buffers\n")
SLANG_RAW("/// and textures, and others may operate correctly without it.\n")
SLANG_RAW("///\n")
SLANG_RAW("syntax unorm : UNormModifier;\n")
SLANG_RAW("\n")
SLANG_RAW("/// Modifier to indicate a buffer or texture element type is\n")
SLANG_RAW("/// backed by data in an signed normalized format.\n")
SLANG_RAW("///\n")
SLANG_RAW("/// The `snorm` modifier is only valid on `float` and `vector`s\n")
SLANG_RAW("/// with `float` elements.\n")
SLANG_RAW("///\n")
SLANG_RAW("/// This modifier does not affect the semantics of any variable,\n")
SLANG_RAW("/// parameter, or field that uses it. The semantics of a `float`\n")
SLANG_RAW("/// or vector are the same with or without `snorm`.\n")
SLANG_RAW("///\n")
SLANG_RAW("/// The `snorm` modifier can be used for the element type of a\n")
SLANG_RAW("/// buffer or texture, to indicate that the data that is bound\n")
SLANG_RAW("/// to that buffer or texture is in a matching normalized format.\n")
SLANG_RAW("/// Some platforms may require a `unorm` qualifier for such buffers\n")
SLANG_RAW("/// and textures, and others may operate correctly without it.\n")
SLANG_RAW("///\n")
SLANG_RAW("syntax snorm : SNormModifier;\n")
SLANG_RAW("\n")
SLANG_RAW("/// Modifier to indicate that a function name should not be mangled\n")
SLANG_RAW("/// by the Slang compiler.\n")
SLANG_RAW("///\n")
SLANG_RAW("/// The `__extern_cpp` modifier makes a symbol to have unmangled\n")
SLANG_RAW("/// name in source/output C++ code.\n")
SLANG_RAW("///\n")
SLANG_RAW("syntax __extern_cpp : ExternCppModifier;\n")
SLANG_RAW("\n")
SLANG_RAW("/// Represents types that can be initialized with a default constructor.\n")
SLANG_RAW("__magic_type(DefaultInitializableType)\n")
SLANG_RAW("interface IDefaultInitializable\n")
SLANG_RAW("{\n")
SLANG_RAW("    __builtin_requirement(")
SLANG_SPLICE( (int)BuiltinRequirementKind::DefaultInitializableConstructor
)
SLANG_RAW(")\n")
SLANG_RAW("    __init();\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("/// Represents types that can be compared.\n")
SLANG_RAW("/// Implemented by all builtin integer and floating point scalar or vector types.\n")
SLANG_RAW("interface IComparable\n")
SLANG_RAW("{\n")
SLANG_RAW("    /// Returns true if two values of the conforming type are equal.\n")
SLANG_RAW("    __builtin_requirement(")
SLANG_SPLICE( (int)BuiltinRequirementKind::Equals
)
SLANG_RAW(")\n")
SLANG_RAW("    bool equals(This other);\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Returns true if `this` is less than `other`.\n")
SLANG_RAW("    __builtin_requirement(")
SLANG_SPLICE( (int)BuiltinRequirementKind::LessThan
)
SLANG_RAW(")\n")
SLANG_RAW("    bool lessThan(This other);\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Returns true if `this` is less than or equal to `other`.\n")
SLANG_RAW("    __builtin_requirement(")
SLANG_SPLICE( (int)BuiltinRequirementKind::LessThanOrEquals
)
SLANG_RAW(")\n")
SLANG_RAW("    bool lessThanOrEquals(This other);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("/// Represents types that has a defined range of values.\n")
SLANG_RAW("/// Implemented by all builtin integer and floating point types.\n")
SLANG_RAW("interface IRangedValue\n")
SLANG_RAW("{\n")
SLANG_RAW("    /// The maximum value that an instance of the type can hold.\n")
SLANG_RAW("    /// This is a constant value specific to the type.\n")
SLANG_RAW("    static const This maxValue;\n")
SLANG_RAW("\n")
SLANG_RAW("    /// The minimum value that an instance of the type can hold.\n")
SLANG_RAW("    /// This is a constant value specific to the type.\n")
SLANG_RAW("    static const This minValue;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__attributeTarget(DeclBase)\n")
SLANG_RAW("attribute_syntax [TreatAsDifferentiable] : TreatAsDifferentiableAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// Represents types that provide arithmetic operations.\n")
SLANG_RAW("interface IArithmetic : IComparable\n")
SLANG_RAW("{\n")
SLANG_RAW("    /// Adds two values of the conforming type.\n")
SLANG_RAW("    /// @param other The value to add to `this`.\n")
SLANG_RAW("    /// @return The sum of `this` and `other`.\n")
SLANG_RAW("    This add(This other);\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Subtracts one value of the conforming type from another.\n")
SLANG_RAW("    /// @param other The value to subtract from `this`.\n")
SLANG_RAW("    /// @return The difference of `this` and `other`.\n")
SLANG_RAW("    This sub(This other);\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Multiplies two values of the conforming type.\n")
SLANG_RAW("    /// @param other The value to multiply with `this`.\n")
SLANG_RAW("    /// @return The product of `this` and `other`.\n")
SLANG_RAW("    This mul(This other);\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Divides one value of the conforming type by another.\n")
SLANG_RAW("    /// @param other The value by which to divide `this`.\n")
SLANG_RAW("    /// @return The quotient of `this` divided by `other`.\n")
SLANG_RAW("    This div(This other);\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Computes the remainder of division of one value of the conforming type by another.\n")
SLANG_RAW("    /// @param other The divisor used to divide `this`.\n")
SLANG_RAW("    /// @return The remainder of `this` divided by `other`.\n")
SLANG_RAW("    This mod(This other);\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Negates a value of the conforming type.\n")
SLANG_RAW("    /// @return The negation of `this`.\n")
SLANG_RAW("    This neg();\n")
SLANG_RAW("\n")
SLANG_RAW("    __init(int val);\n")
SLANG_RAW("\n")
SLANG_RAW("        /// Initialize from the same type.\n")
SLANG_RAW("    __init(This value);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("/// Represents types that provide logical operations.\n")
SLANG_RAW("interface ILogical : IComparable\n")
SLANG_RAW("{\n")
SLANG_RAW("    /// Shifts the bits of this value to the left by the specified number of positions.\n")
SLANG_RAW("    __builtin_requirement(")
SLANG_SPLICE( (int)BuiltinRequirementKind::Shl
)
SLANG_RAW(" )\n")
SLANG_RAW("    This shl(int value);\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Shifts the bits of this value to the right by the specified number of positions.\n")
SLANG_RAW("    __builtin_requirement(")
SLANG_SPLICE( (int)BuiltinRequirementKind::Shr
)
SLANG_RAW(" )\n")
SLANG_RAW("    This shr(int value);\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Performs a bitwise AND operation on this value with another value of the same type.\n")
SLANG_RAW("    __builtin_requirement(")
SLANG_SPLICE( (int)BuiltinRequirementKind::BitAnd
)
SLANG_RAW(" )\n")
SLANG_RAW("    This bitAnd(This other);\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Performs a bitwise OR operation on this value with another value of the same type.\n")
SLANG_RAW("    __builtin_requirement(")
SLANG_SPLICE( (int)BuiltinRequirementKind::BitOr
)
SLANG_RAW(" )\n")
SLANG_RAW("    This bitOr(This other);\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Performs a bitwise XOR operation on this value with another value of the same type.\n")
SLANG_RAW("    __builtin_requirement(")
SLANG_SPLICE( (int)BuiltinRequirementKind::BitXor
)
SLANG_RAW(" )\n")
SLANG_RAW("    This bitXor(This other);\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Performs a bitwise NOT operation on this value, flipping all bits.\n")
SLANG_RAW("    __builtin_requirement(")
SLANG_SPLICE( (int)BuiltinRequirementKind::BitNot
)
SLANG_RAW(" )\n")
SLANG_RAW("    This bitNot();\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Performs a logical AND operation on this value with another value of the same type.\n")
SLANG_RAW("    __builtin_requirement(")
SLANG_SPLICE( (int)BuiltinRequirementKind::And
)
SLANG_RAW(" )\n")
SLANG_RAW("    This and(This other);\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Performs a logical OR operation on this value with another value of the same type.\n")
SLANG_RAW("    __builtin_requirement(")
SLANG_SPLICE( (int)BuiltinRequirementKind::Or
)
SLANG_RAW(" )\n")
SLANG_RAW("    This or(This other);\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Performs a logical NOT operation on this value, returning the logical negation.\n")
SLANG_RAW("    __builtin_requirement(")
SLANG_SPLICE( (int)BuiltinRequirementKind::Not
)
SLANG_RAW(" )\n")
SLANG_RAW("    This not();\n")
SLANG_RAW("\n")
SLANG_RAW("    __builtin_requirement(")
SLANG_SPLICE( (int)BuiltinRequirementKind::InitLogicalFromInt
)
SLANG_RAW(" )\n")
SLANG_RAW("    __init(int val);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("/// Represents a type that can be used for integer arithmetic operations.\n")
SLANG_RAW("/// \n")
SLANG_RAW("/// Implemented by builtin scalar types: `int`, `uint`, `int64_t`, `uint64_t`, `int8_t`, `uint8_t`, `int16_t`, `uint16_t`.\n")
SLANG_RAW("///\n")
SLANG_RAW("/// Also implemented by `vector<T, N>` where `T` is one of the above scalar types.\n")
SLANG_RAW("///\n")
SLANG_RAW("/// @remarks This interface can be used to define generic functions that work with integer-like types. See example below.\n")
SLANG_RAW("/// @example The following code defines a generic function that computes `a*b+1`, where `a`, `b` can be any integer scalar or vector types.\n")
SLANG_RAW("/// ```csharp\n")
SLANG_RAW("/// T compute<T:IInteger>(T a, T b)\n")
SLANG_RAW("/// {\n")
SLANG_RAW("///     return a * b + T(1);\n")
SLANG_RAW("/// }\n")
SLANG_RAW("/// \n")
SLANG_RAW("/// RWStructuredBuffer<int> outputBuffer;\n")
SLANG_RAW("/// \n")
SLANG_RAW("/// [numthreads(1,1,1)]\n")
SLANG_RAW("/// void test()\n")
SLANG_RAW("/// {\n")
SLANG_RAW("///     int a = 2;\n")
SLANG_RAW("///     int b = 3;\n")
SLANG_RAW("///     outputBuffer[0] = compute(a, b); // result = 2*3 + 1 = 7\n")
SLANG_RAW("/// \n")
SLANG_RAW("///     int16_t2 a2 = int16_t2(2, 3);\n")
SLANG_RAW("///     int16_t2 b2 = int16_t2(4, 5);\n")
SLANG_RAW("///     // result2 = int16_t2(2*4 + 1, 3*5 + 1) = int16_t2(9, 16)\n")
SLANG_RAW("///     int16_t2 result2 = compute<int16_t2>(a2, b2);\n")
SLANG_RAW("///     outputBuffer[1] = result2.x;\n")
SLANG_RAW("/// }\n")
SLANG_RAW("/// ```\n")
SLANG_RAW("///\n")
SLANG_RAW("interface IInteger : IArithmetic, ILogical\n")
SLANG_RAW("{\n")
SLANG_RAW("    /// Converts the value of the current instance to an `int`.\n")
SLANG_RAW("    /// @return The converted `int` value.\n")
SLANG_RAW("    int toInt();\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Converts the value of the current instance to an `int64_t`.\n")
SLANG_RAW("    /// @return The converted `int64_t` value.\n")
SLANG_RAW("    int64_t toInt64();\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Converts the value of the current instance to an `uint`.\n")
SLANG_RAW("    /// @return The converted `uint` value.\n")
SLANG_RAW("    uint toUInt();\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Converts the value of the current instance to an `uint64_t`.\n")
SLANG_RAW("    /// @return The converted `uint64_t` value.\n")
SLANG_RAW("    uint64_t toUInt64();\n")
SLANG_RAW("\n")
SLANG_RAW("    __init(int val);\n")
SLANG_RAW("    __init(int64_t val);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("/// Represents a type that can be used for floating point arithmetic operations.\n")
SLANG_RAW("/// \n")
SLANG_RAW("/// Implemented by builtin scalar types: `float`, `half`, `double`.\n")
SLANG_RAW("///\n")
SLANG_RAW("/// Also implemented by `vector<T, N>` where `T` is one of the above scalar types.\n")
SLANG_RAW("///\n")
SLANG_RAW("/// @remarks This interface can be used to define generic functions that work with floating-point-like types. See example below.\n")
SLANG_RAW("/// @example The following code defines a generic function that computes `a*b+1`, where `a`, `b` can be any floating point scalar or vector types.\n")
SLANG_RAW("/// ```csharp\n")
SLANG_RAW("/// T compute<T:IFloat>(T a, T b)\n")
SLANG_RAW("/// {\n")
SLANG_RAW("///     return a * b + T(1.0f);\n")
SLANG_RAW("/// }\n")
SLANG_RAW("/// \n")
SLANG_RAW("/// RWStructuredBuffer<float> outputBuffer;\n")
SLANG_RAW("/// \n")
SLANG_RAW("/// [numthreads(1,1,1)]\n")
SLANG_RAW("/// void test()\n")
SLANG_RAW("/// {\n")
SLANG_RAW("///     float a = 2.0;\n")
SLANG_RAW("///     float b = 3.0;\n")
SLANG_RAW("///     outputBuffer[0] = compute(a, b); // result = 2.0*3.0 + 1.0 = 7.0\n")
SLANG_RAW("/// \n")
SLANG_RAW("///     half2 a2 = half2(2.0h, 3.0h);\n")
SLANG_RAW("///     half2 b2 = half2(4.0h, 5.0h);\n")
SLANG_RAW("///     // result2 = half2(2*4 + 1, 3*5 + 1) = half2(9, 16)\n")
SLANG_RAW("///     half2 result2 = compute(a2, b2);\n")
SLANG_RAW("///     outputBuffer[1] = result2.x;\n")
SLANG_RAW("/// }\n")
SLANG_RAW("/// ```\n")
SLANG_RAW("///\n")
SLANG_RAW("interface IFloat : IArithmetic, IDifferentiable\n")
SLANG_RAW("{\n")
SLANG_RAW("    /// Initializes a value of the conforming type form a `float`.\n")
SLANG_RAW("    [TreatAsDifferentiable]\n")
SLANG_RAW("    __init(float value);\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Converts a value of the conforming type into a `float`.\n")
SLANG_RAW("    [TreatAsDifferentiable]\n")
SLANG_RAW("    float toFloat();\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Computes the arithmetic sum of two values of the conforming type.\n")
SLANG_RAW("    [TreatAsDifferentiable]\n")
SLANG_RAW("    This add(This other);\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Computes the arithmetic subtraction from values of the conforming type.\n")
SLANG_RAW("    [TreatAsDifferentiable]\n")
SLANG_RAW("    This sub(This other);\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Computes the arithmetic multiplication from values of the conforming type.\n")
SLANG_RAW("    [TreatAsDifferentiable]\n")
SLANG_RAW("    This mul(This other);\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Computes the arithmetic division from values of the conforming type.\n")
SLANG_RAW("    [TreatAsDifferentiable]\n")
SLANG_RAW("    This div(This other);\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Computes the arithmetic remainder from values of the conforming type.\n")
SLANG_RAW("    [TreatAsDifferentiable]\n")
SLANG_RAW("    This mod(This other);\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Computes the arithmetic negation of the conforming type.\n")
SLANG_RAW("    [TreatAsDifferentiable]\n")
SLANG_RAW("    This neg();\n")
SLANG_RAW("\n")
SLANG_RAW("    [TreatAsDifferentiable]\n")
SLANG_RAW("    __init(This value);\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Multiplies a value of the conforming type by a floating point scale factor..\n")
SLANG_RAW("    [TreatAsDifferentiable]\n")
SLANG_RAW("    This scale<T:__BuiltinFloatingPointType>(T scale);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("/// A type that can be used as an operand for builtins\n")
SLANG_RAW("[sealed]\n")
SLANG_RAW("[builtin]\n")
SLANG_RAW("interface __BuiltinType \n")
SLANG_RAW("{\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("/// A type that can be used for arithmetic operations. For defining generic functions that work with builtin scalar arithmetic types only.\n")
SLANG_RAW("/// Builtin types implementing this interface: `int`, `uint`, `int64_t`, `uint64_t`, `int8_t`, `uint8_t`, `int16_t`, `uint16_t`, `float`, `half`, `double`.\n")
SLANG_RAW("/// To define generic functions that work with both scalar and vector types, use `IInteger` or `IFloat` instead.\n")
SLANG_RAW("[sealed]\n")
SLANG_RAW("[builtin]\n")
SLANG_RAW("interface __BuiltinArithmeticType : __BuiltinType, IArithmetic\n")
SLANG_RAW("{\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("/// A type that can be used for logical/bitwise operations. For defining generic functions that work with builtin scalar logical types only.\n")
SLANG_RAW("/// Builtin types implementing this interface: `bool`, `int8_t`, `uint8_t`, `int16_t`, `uint16_t`, `int`, `uint`, `int64_t`, `uint64_t`.\n")
SLANG_RAW("[sealed]\n")
SLANG_RAW("[builtin]\n")
SLANG_RAW("interface __BuiltinLogicalType : __BuiltinType, ILogical\n")
SLANG_RAW("{\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("/// Represents builtin types that logically have a sign (positive/negative/zero).\n")
SLANG_RAW("[sealed]\n")
SLANG_RAW("[builtin]\n")
SLANG_RAW("interface __BuiltinSignedArithmeticType : __BuiltinArithmeticType {}\n")
SLANG_RAW("\n")
SLANG_RAW("/// Represents builtin types that can represent integers.\n")
SLANG_RAW("[sealed]\n")
SLANG_RAW("[builtin]\n")
SLANG_RAW("interface __BuiltinIntegerType : __BuiltinArithmeticType, IInteger\n")
SLANG_RAW("{}\n")
SLANG_RAW("\n")
SLANG_RAW("/// Represents a `int` or `uint` type.\n")
SLANG_RAW("[sealed]\n")
SLANG_RAW("[builtin]\n")
SLANG_RAW("interface __BuiltinInt32Type : __BuiltinIntegerType\n")
SLANG_RAW("{}\n")
SLANG_RAW("\n")
SLANG_RAW("/// Represents a `int64_t` or `uint64_t` type.\n")
SLANG_RAW("[sealed]\n")
SLANG_RAW("[builtin]\n")
SLANG_RAW("interface __BuiltinInt64Type : __BuiltinIntegerType\n")
SLANG_RAW("{}\n")
SLANG_RAW("\n")
SLANG_RAW("/// Represents builtin types that can represent a real number.\n")
SLANG_RAW("[sealed]\n")
SLANG_RAW("[builtin]\n")
SLANG_RAW("interface __BuiltinRealType : __BuiltinSignedArithmeticType {}\n")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("__attributeTarget(AggTypeDecl)\n")
SLANG_RAW("attribute_syntax [__NonCopyableType] : NonCopyableTypeAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("__attributeTarget(FunctionDeclBase)\n")
SLANG_RAW("attribute_syntax [__NoSideEffect] : NoSideEffectAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// Marks a function as being differentiable in forward-mode.\n")
SLANG_RAW("///\n")
SLANG_RAW("/// See the user guide [section on forward-mode differentiation](https://shader-slang.org/slang/user-guide/autodiff.html#invoking-auto-diff-in-slang) for more\n")
SLANG_RAW("///\n")
SLANG_RAW("/// If used on a function that has a definition (i.e. a function body),Slang will use\n")
SLANG_RAW("/// automatic-differentiation to generate a forward-mode derivative of this function,\n")
SLANG_RAW("/// unless an implementation is provided by the user via `[ForwardDerivative(fn)]`\n")
SLANG_RAW("///\n")
SLANG_RAW("/// If used on an interface requirement, the signature of the requirement is modified to\n")
SLANG_RAW("/// include forward-differentiability. Any satisfying method must also be forward-differentiable,\n")
SLANG_RAW("/// or provide an appropriate derivative implementation.\n")
SLANG_RAW("/// See the user guide [section on auto-diff for interfaces](https://shader-slang.org/slang/user-guide/autodiff.html##using-auto-diff-with-interface-requirements-and-interface-types) for more \n")
SLANG_RAW("/// \n")
SLANG_RAW("__attributeTarget(FunctionDeclBase)\n")
SLANG_RAW("attribute_syntax [ForwardDifferentiable] : ForwardDifferentiableAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// Marks a function as being differentiable for backward-mode auto-diff.\n")
SLANG_RAW("/// Note that in the current implementation, this implies that the method\n")
SLANG_RAW("/// is also forward differentiable.\n")
SLANG_RAW("/// \n")
SLANG_RAW("/// This attribute is equivalent to using `[Differentiable]`\n")
SLANG_RAW("///\n")
SLANG_RAW("__attributeTarget(FunctionDeclBase)\n")
SLANG_RAW("attribute_syntax [BackwardDifferentiable(order:int = 0)] : BackwardDifferentiableAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// Marks a function as being differentiable for both\n")
SLANG_RAW("/// forward and backward mode auto-diff.\n")
SLANG_RAW("///\n")
SLANG_RAW("/// This attribute is equivalent to using `[Differentiable]`\n")
SLANG_RAW("///\n")
SLANG_RAW("/// See the user guide [section on auto-diff invocation](https://shader-slang.org/slang/user-guide/autodiff.html#invoking-auto-diff-in-slang) for more.\n")
SLANG_RAW("///\n")
SLANG_RAW("/// If used on a function that has a definition (i.e. a function body), Slang will use\n")
SLANG_RAW("/// automatic-differentiation to generate the derivative implementations for this function,\n")
SLANG_RAW("/// unless an implementation is provided by the user via `[ForwardDerivative(fn)]` and/or `[BackwardDerivative(fn)]`\n")
SLANG_RAW("///\n")
SLANG_RAW("/// If used on an interface requirement, the signature of the requirement is modified to\n")
SLANG_RAW("/// include differentiability. Any satisfying method must also be differentiable,\n")
SLANG_RAW("/// or provide appropriate derivative implementations.\n")
SLANG_RAW("/// See the user guide [section on auto-diff for interfaces](https://shader-slang.org/slang/user-guide/autodiff.html##using-auto-diff-with-interface-requirements-and-interface-types) for more\n")
SLANG_RAW("///\n")
SLANG_RAW("__attributeTarget(FunctionDeclBase)\n")
SLANG_RAW("attribute_syntax [Differentiable(order:int = 0)] : BackwardDifferentiableAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_RequirePrelude
)
SLANG_RAW(")\n")
SLANG_RAW("void __requirePrelude(constexpr String preludeText);\n")
SLANG_RAW("\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_RequireTargetExtension
)
SLANG_RAW(")\n")
SLANG_RAW("void __requireTargetExtension(constexpr String preludeText);\n")
SLANG_RAW("\n")
SLANG_RAW("/// @experimetal\n")
SLANG_RAW("/// Perform a compile-time condition check and emit a compile-time error if the condition is false.\n")
SLANG_RAW("/// @param condition The compile-time condition to check.\n")
SLANG_RAW("/// @param errorMessage The error message to emit if the condition is false.\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_StaticAssert
)
SLANG_RAW(")\n")
SLANG_RAW("void static_assert(constexpr bool condition, NativeString errorMessage);\n")
SLANG_RAW("\n")
SLANG_RAW("/// Represents a 'value' type that is differentiable for the purposes of automatic differentiation.\n")
SLANG_RAW("///\n")
SLANG_RAW("/// See the auto-diff user guide section for an introduction to \n")
SLANG_RAW("/// differentiable value types (https://shader-slang.org/slang/user-guide/autodiff.html#differentiable-value-types)\n")
SLANG_RAW("///\n")
SLANG_RAW("/// #### Builtin Differentiable Value Types\n")
SLANG_RAW("/// The following built-in types are differentiable: \n")
SLANG_RAW("/// - Scalars: `float`, `double` and `half`.\n")
SLANG_RAW("/// - Vector/Matrix: `vector` and `matrix` of `float`, `double` and `half` types.\n")
SLANG_RAW("/// - Arrays: `T[n]` is differentiable if `T` is differentiable.\n")
SLANG_RAW("/// - Tuples: `Tuple<each T>` is differentiable if `T` is differentiable. \n")
SLANG_RAW("/// \n")
SLANG_RAW("/// The `IDifferentiable` interface requires the following definitions (which can be auto-generated by the compiler for most scenarios)\n")
SLANG_RAW("/// ```csharp\n")
SLANG_RAW("/// interface IDifferentiable\n")
SLANG_RAW("/// {\n")
SLANG_RAW("///     associatedtype Differential : IDifferentiable\n")
SLANG_RAW("///         where Differential.Differential == Differential;\n")
SLANG_RAW("/// \n")
SLANG_RAW("///     static Differential dzero();\n")
SLANG_RAW("/// \n")
SLANG_RAW("///     static Differential dadd(Differential, Differential);\n")
SLANG_RAW("/// }\n")
SLANG_RAW("/// ```\n")
SLANG_RAW("/// \n")
SLANG_RAW("/// As defined by the `IDifferentiable` interface, a differentiable type must have a \n")
SLANG_RAW("/// `Differential` associated type that stores the derivative of the value. \n")
SLANG_RAW("/// A further requirement is that the type of the second-order derivative must be the same \n")
SLANG_RAW("/// `Differential` type. In another words, given a type `T`, `T.Differential` can be different \n")
SLANG_RAW("/// from `T`, but `T.Differential.Differential` must equal to `T.Differential`.\n")
SLANG_RAW("///\n")
SLANG_RAW("/// In addition, a differentiable type must define the `zero` value of its derivative, \n")
SLANG_RAW("/// and how to add two derivative values together. These function are used during reverse-mode \n")
SLANG_RAW("/// auto-diff, to initialize and accumulate derivatives of the given type.\n")
SLANG_RAW("///\n")
SLANG_RAW("/// #### Automatic Fulfillment of `IDifferentiable` Requirements\n")
SLANG_RAW("/// Assume the user has defined the following type:\n")
SLANG_RAW("///\n")
SLANG_RAW("/// ```csharp\n")
SLANG_RAW("/// struct MyRay\n")
SLANG_RAW("/// {\n")
SLANG_RAW("///     float3 origin;\n")
SLANG_RAW("///     float3 dir;\n")
SLANG_RAW("///     int nonDifferentiablePayload;\n")
SLANG_RAW("/// }\n")
SLANG_RAW("/// ```\n")
SLANG_RAW("///\n")
SLANG_RAW("/// The type can be made differentiable by adding `IDifferentiable` conformance:\n")
SLANG_RAW("/// ```csharp\n")
SLANG_RAW("/// struct MyRay : IDifferentiable\n")
SLANG_RAW("/// {\n")
SLANG_RAW("///     float3 origin;\n")
SLANG_RAW("///     float3 dir;\n")
SLANG_RAW("///     int nonDifferentiablePayload;\n")
SLANG_RAW("/// }\n")
SLANG_RAW("/// ```\n")
SLANG_RAW("///\n")
SLANG_RAW("/// Note that this code does not provide any explicit implementation of the `IDifferentiable` requirements. In this case the compiler will automatically synthesize all the requirements. This should provide the desired behavior most of the time. The procedure for synthesizing the interface implementation is as follows:\n")
SLANG_RAW("/// 1. A new type is generated that stores the `Differential` of all differentiable fields. This new type itself will conform to the `IDifferentiable` interface, and it will be used to satisfy the `Differential` associated type requirement.\n")
SLANG_RAW("/// 2. Each differential field will be associated to its corresponding field in the newly synthesized `Differential` type.\n")
SLANG_RAW("/// 3. The `zero` value of the differential type is made from the `zero` value of each field in the differential type.\n")
SLANG_RAW("/// 4. The `dadd` method invokes the `dadd` operations for each field whose type conforms to `IDifferentiable`.\n")
SLANG_RAW("/// 5. If the synthesized `Differential` type contains exactly the same fields as the original type, and the type of each field is the same as the original field type, then the original type itself will be used as the `Differential` type instead of creating a new type to satisfy the `Differential` associated type requirement. This means that all the synthesized `Differential` type use itself to meet its own `IDifferentiable` requirements.\n")
SLANG_RAW("///\n")
SLANG_RAW("/// #### Manual fulfilment of `IDifferentiable` requirements\n")
SLANG_RAW("/// In rare cases where more control is desired, the user can manually provide the implementation. \n")
SLANG_RAW("/// To do so, we will first define the `Differential` type for `MyRay`, and use it to fulfill \n")
SLANG_RAW("/// the `Differential` requirement in `MyRay`:\n")
SLANG_RAW("/// ```csharp\n")
SLANG_RAW("/// struct MyRayDifferential\n")
SLANG_RAW("/// {\n")
SLANG_RAW("///     float3 d_origin;\n")
SLANG_RAW("///     float3 d_dir;\n")
SLANG_RAW("/// }\n")
SLANG_RAW("///\n")
SLANG_RAW("/// struct MyRay : IDifferentiable\n")
SLANG_RAW("/// {\n")
SLANG_RAW("///     // Specify that `MyRay.Differential` is `MyRayDifferential`.\n")
SLANG_RAW("///     typealias Differential = MyRayDifferential;\n")
SLANG_RAW("///\n")
SLANG_RAW("///     // Specify that the derivative for `origin` will be stored in `MayRayDifferential.d_origin`.\n")
SLANG_RAW("///     [DerivativeMember(MayRayDifferential.d_origin)]\n")
SLANG_RAW("///     float3 origin;\n")
SLANG_RAW("///\n")
SLANG_RAW("///     // Specify that the derivative for `dir` will be stored in `MayRayDifferential.d_dir`.\n")
SLANG_RAW("///     [DerivativeMember(MayRayDifferential.d_dir)]\n")
SLANG_RAW("///     float3 dir;\n")
SLANG_RAW("///\n")
SLANG_RAW("///     // This is a non-differentiable field so we don't put any attributes on it.\n")
SLANG_RAW("///     int nonDifferentiablePayload;\n")
SLANG_RAW("///\n")
SLANG_RAW("///     // Define zero derivative.\n")
SLANG_RAW("///     static MyRayDifferential dzero()\n")
SLANG_RAW("///     {\n")
SLANG_RAW("///         return {float3(0.0), float3(0.0)};\n")
SLANG_RAW("///     }\n")
SLANG_RAW("///\n")
SLANG_RAW("///     // Define the add operation of two derivatives.\n")
SLANG_RAW("///     static MyRayDifferential dadd(MyRayDifferential v1, MyRayDifferential v2)\n")
SLANG_RAW("///     {\n")
SLANG_RAW("///         MyRayDifferential result;\n")
SLANG_RAW("///         result.d_origin = v1.d_origin + v2.d_origin;\n")
SLANG_RAW("///         result.d_dir = v1.d_dir + v2.d_dir;\n")
SLANG_RAW("///         return result;\n")
SLANG_RAW("///     }\n")
SLANG_RAW("/// }\n")
SLANG_RAW("/// ```\n")
SLANG_RAW("/// \n")
SLANG_RAW("/// Note that for each struct field that is differentiable, we need to use the `[DerivativeMember]` attribute to associate it with the\n")
SLANG_RAW("/// corresponding field in the `Differential` type, so the compiler knows how to access the derivative for the field.\n")
SLANG_RAW("///\n")
SLANG_RAW("/// However, there is still a missing piece in the above code: we also need to make `MyRayDifferential` conform to `IDifferentiable` because it is required that the `Differential` of a type must itself be `Differential`. Again we can use automatic fulfillment by simply adding `IDifferentiable` conformance to `MyRayDifferential`:\n")
SLANG_RAW("/// ```csharp\n")
SLANG_RAW("/// struct MyRayDifferential : IDifferentiable\n")
SLANG_RAW("/// {\n")
SLANG_RAW("///     float3 d_origin;\n")
SLANG_RAW("///     float3 d_dir;\n")
SLANG_RAW("/// }\n")
SLANG_RAW("/// ```\n")
SLANG_RAW("/// In this case, since all fields in `MyRayDifferential` are differentiable, and the `Differential` of each field is the same as the original type of each field (i.e. `float3.Differential == float3` as defined in the core module), the compiler will automatically use the type itself as its own `Differential`, making `MyRayDifferential` suitable for use as `Differential` of `MyRay`.\n")
SLANG_RAW("///\n")
SLANG_RAW("/// We can also choose to manually implement `IDifferentiable` interface for `MyRayDifferential` as in the following code:\n")
SLANG_RAW("///\n")
SLANG_RAW("/// ```csharp\n")
SLANG_RAW("/// struct MyRayDifferential : IDifferentiable\n")
SLANG_RAW("/// {\n")
SLANG_RAW("///     typealias Differential = MyRayDifferential;\n")
SLANG_RAW("///\n")
SLANG_RAW("///    [DerivativeMember(MyRayDifferential.d_origin)]\n")
SLANG_RAW("///    float3 d_origin;\n")
SLANG_RAW("///\n")
SLANG_RAW("///    [DerivativeMember(MyRayDifferential.d_dir)]\n")
SLANG_RAW("///    float3 d_dir;\n")
SLANG_RAW("///\n")
SLANG_RAW("///    static MyRayDifferential dzero()\n")
SLANG_RAW("///    {\n")
SLANG_RAW("///        return {float3(0.0), float3(0.0)};\n")
SLANG_RAW("///    }\n")
SLANG_RAW("///\n")
SLANG_RAW("///    static MyRayDifferential dadd(MyRayDifferential v1, MyRayDifferential v2)\n")
SLANG_RAW("///    {\n")
SLANG_RAW("///        MyRayDifferential result;\n")
SLANG_RAW("///        result.d_origin = v1.d_origin + v2.d_origin;\n")
SLANG_RAW("///         result.d_dir = v1.d_dir + v2.d_dir;\n")
SLANG_RAW("///         return result;\n")
SLANG_RAW("///     }\n")
SLANG_RAW("/// }\n")
SLANG_RAW("/// ```\n")
SLANG_RAW("/// In this specific case, the automatically generated `IDifferentiable` \n")
SLANG_RAW("/// implementation will be exactly the same as the manually written code listed above.\n")
SLANG_RAW("///\n")
SLANG_RAW("/// \n")
SLANG_RAW("__magic_type(DifferentiableType)\n")
SLANG_RAW("[KnownBuiltin(\"IDifferentiable\")]\n")
SLANG_RAW("interface IDifferentiable\n")
SLANG_RAW("{\n")
SLANG_RAW("    // Note: the compiler implementation requires the `Differential` associated type to be defined\n")
SLANG_RAW("    // before anything else.\n")
SLANG_RAW("\n")
SLANG_RAW("    __builtin_requirement(")
SLANG_SPLICE( (int)BuiltinRequirementKind::DifferentialType
)
SLANG_RAW(" )\n")
SLANG_RAW("    associatedtype Differential : IDifferentiable;\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Returns a zero-initialized value of the differential type.\n")
SLANG_RAW("    __builtin_requirement(")
SLANG_SPLICE( (int)BuiltinRequirementKind::DZeroFunc
)
SLANG_RAW(" )\n")
SLANG_RAW("    static Differential dzero();\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Adds two differential values and returns the result.\n")
SLANG_RAW("    __builtin_requirement(")
SLANG_SPLICE( (int)BuiltinRequirementKind::DAddFunc
)
SLANG_RAW(" )\n")
SLANG_RAW("    static Differential dadd(Differential, Differential);\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Multiplies a scalar value of a built-in real type with a differential value and returns the result.\n")
SLANG_RAW("    __builtin_requirement(")
SLANG_SPLICE( (int)BuiltinRequirementKind::DMulFunc
)
SLANG_RAW(" )\n")
SLANG_RAW("    __generic<T : __BuiltinRealType>\n")
SLANG_RAW("    static Differential dmul(T, Differential);\n")
SLANG_RAW("};\n")
SLANG_RAW("\n")
SLANG_RAW("/// @experimental\n")
SLANG_RAW("///\n")
SLANG_RAW("/// The `IDifferentiablePtrType` interface requires the following definitions.\n")
SLANG_RAW("///\n")
SLANG_RAW("/// ```csharp\n")
SLANG_RAW("/// interface IDifferentiablePtrType\n")
SLANG_RAW("/// {\n")
SLANG_RAW("///     associatedtype Differential : IDifferentiablePtrType\n")
SLANG_RAW("///         where Differential.Differential == Differential;\n")
SLANG_RAW("/// }\n")
SLANG_RAW("/// ```\n")
SLANG_RAW("///\n")
SLANG_RAW("/// Types that conform to this interface can be used with `DifferentialPtrPair<T>`\n")
SLANG_RAW("/// to pass the derivative components to calls to `fwd_diff(fn)` or `bwd_diff(fn)`\n")
SLANG_RAW("///\n")
SLANG_RAW("/// See the auto-diff user guide for more details (https://shader-slang.org/slang/user-guide/autodiff.html#differentiable-ptr-types)\n")
SLANG_RAW("///\n")
SLANG_RAW("/// @remarks Support for this interface is still experimental and subject to change.\n")
SLANG_RAW("///\n")
SLANG_RAW("__magic_type(DifferentiablePtrType)\n")
SLANG_RAW("[KnownBuiltin(\"IDifferentiablePtr\")]\n")
SLANG_RAW("interface IDifferentiablePtrType\n")
SLANG_RAW("{\n")
SLANG_RAW("    __builtin_requirement(")
SLANG_SPLICE( (int)BuiltinRequirementKind::DifferentialPtrType
)
SLANG_RAW(" )\n")
SLANG_RAW("    associatedtype Differential : IDifferentiablePtrType;\n")
SLANG_RAW("};\n")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("/// `DifferentialPair<T>` is a built-in type that carries both the original and derivative value of a term. \n")
SLANG_RAW("/// It is defined as follows:\n")
SLANG_RAW("/// ```csharp\n")
SLANG_RAW("/// struct DifferentialPair<T : IDifferentiable> : IDifferentiable\n")
SLANG_RAW("/// {\n")
SLANG_RAW("///     typealias Differential = DifferentialPair<T.Differential>;\n")
SLANG_RAW("///     property T p {get;}\n")
SLANG_RAW("///     property T.Differential d {get;}\n")
SLANG_RAW("///     static Differential dzero();\n")
SLANG_RAW("///     static Differential dadd(Differential a, Differential b);\n")
SLANG_RAW("/// }\n")
SLANG_RAW("/// ```\n")
SLANG_RAW("/// \n")
SLANG_RAW("/// Differential pairs can be created via constructor or through the `diffPair()` operation \n")
SLANG_RAW("/// ```csharp\n")
SLANG_RAW("/// DifferentialPair<float> dpa = DifferentialPair<float>(1.0f, 2.0f);\n")
SLANG_RAW("/// DifferentialPair<float> dpa = diffPair(1.0f, 2.0f);\n")
SLANG_RAW("/// ```\n")
SLANG_RAW("/// Note that derivative pairs are used to pass derivatives into and out of auto-diff functions.\n")
SLANG_RAW("/// See documentation on `fwd_diff` and `bwd_diff` operators for more information.\n")
SLANG_RAW("///\n")
SLANG_RAW("__generic<T : IDifferentiable>\n")
SLANG_RAW("__magic_type(DifferentialPairType)\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_DifferentialPairUserCodeType
)
SLANG_RAW(")\n")
SLANG_RAW("struct DifferentialPair : IDifferentiable\n")
SLANG_RAW("{\n")
SLANG_RAW("    typedef DifferentialPair<T.Differential> Differential;\n")
SLANG_RAW("    typedef T.Differential DifferentialElementType;\n")
SLANG_RAW("\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_MakeDifferentialPairUserCode
)
SLANG_RAW(")\n")
SLANG_RAW("    __init(T _primal, T.Differential _differential);\n")
SLANG_RAW("\n")
SLANG_RAW("    property p : T\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __intrinsic_op(")
SLANG_SPLICE(kIROp_DifferentialPairGetPrimalUserCode
)
SLANG_RAW(")\n")
SLANG_RAW("        get;\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    property v : T\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __intrinsic_op(")
SLANG_SPLICE(kIROp_DifferentialPairGetPrimalUserCode
)
SLANG_RAW(")\n")
SLANG_RAW("        get;\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    property d : T.Differential\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __intrinsic_op(")
SLANG_SPLICE(kIROp_DifferentialPairGetDifferentialUserCode
)
SLANG_RAW(")\n")
SLANG_RAW("        get;\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__unsafeForceInlineEarly]\n")
SLANG_RAW("    T.Differential getDifferential()\n")
SLANG_RAW("    {\n")
SLANG_RAW("        return d;\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__unsafeForceInlineEarly]\n")
SLANG_RAW("    T getPrimal()\n")
SLANG_RAW("    {\n")
SLANG_RAW("        return p;\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__unsafeForceInlineEarly]\n")
SLANG_RAW("    static Differential dzero()\n")
SLANG_RAW("    {\n")
SLANG_RAW("        return Differential(T.dzero(), T.Differential.dzero());\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__unsafeForceInlineEarly]\n")
SLANG_RAW("    static Differential dadd(Differential a, Differential b)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        return Differential(\n")
SLANG_RAW("            T.dadd(\n")
SLANG_RAW("                a.p,\n")
SLANG_RAW("                b.p\n")
SLANG_RAW("            ),\n")
SLANG_RAW("            T.Differential.dadd(a.d, b.d));\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    __generic<U : __BuiltinRealType>\n")
SLANG_RAW("    [__unsafeForceInlineEarly]\n")
SLANG_RAW("    static Differential dmul(U a, Differential b)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        return Differential(\n")
SLANG_RAW("            T.dmul<U>(a, b.p),\n")
SLANG_RAW("            T.Differential.dmul<U>(a, b.d));\n")
SLANG_RAW("    }\n")
SLANG_RAW("};\n")
SLANG_RAW("\n")
SLANG_RAW("/// @experimental\n")
SLANG_RAW("/// `DifferentialPtrPair<T>` is a built-in type that carries both the original and differential of a \n")
SLANG_RAW("/// pointer-like object. \n")
SLANG_RAW("/// `T` must conform to `IDifferentiablePtrType`\n")
SLANG_RAW("/// \n")
SLANG_RAW("/// It is defined as follows:\n")
SLANG_RAW("/// ```csharp\n")
SLANG_RAW("/// struct DifferentialPtrPair<T : IDifferentiablePtrType> : IDifferentiablePtrType\n")
SLANG_RAW("/// {\n")
SLANG_RAW("///     typealias Differential = DifferentialPtrPair<T.Differential>;\n")
SLANG_RAW("///     property T p {get;}\n")
SLANG_RAW("///     property T.Differential d {get;}\n")
SLANG_RAW("/// }\n")
SLANG_RAW("/// ```\n")
SLANG_RAW("/// @remarks\n")
SLANG_RAW("/// Differential ptr pairs can be created via constructor.\n")
SLANG_RAW("/// ```csharp\n")
SLANG_RAW("/// struct DPtrFloat : IDifferentialPtrType \n")
SLANG_RAW("/// { \n")
SLANG_RAW("///     typealias Differential = DPtrFloat;\n")
SLANG_RAW("///     float* ptr;\n")
SLANG_RAW("/// };\n")
SLANG_RAW("/// \n")
SLANG_RAW("/// DifferentialPtrPair<DPtrFloat> dpa = \n")
SLANG_RAW("///            DifferentialPtrPair<float>({&outputBuffer[0]}, {&outputBuffer[1]});\n")
SLANG_RAW("/// ```\n")
SLANG_RAW("/// Note that derivative ptr pairs are used to pass derivatives into and out of auto-diff functions.\n")
SLANG_RAW("/// See documentation on `fwd_diff` and `bwd_diff` operators for more information.\n")
SLANG_RAW("///\n")
SLANG_RAW("/// \n")
SLANG_RAW("__generic<T : IDifferentiablePtrType>\n")
SLANG_RAW("__magic_type(DifferentialPtrPairType)\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_DifferentialPtrPairType
)
SLANG_RAW(")\n")
SLANG_RAW("struct DifferentialPtrPair : IDifferentiablePtrType\n")
SLANG_RAW("{\n")
SLANG_RAW("    typedef DifferentialPtrPair<T.Differential> Differential;\n")
SLANG_RAW("    typedef T.Differential DifferentialElementType;\n")
SLANG_RAW("\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_MakeDifferentialPtrPair
)
SLANG_RAW(")\n")
SLANG_RAW("    __init(T _primal, T.Differential _differential);\n")
SLANG_RAW("\n")
SLANG_RAW("    property p : T\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __intrinsic_op(")
SLANG_SPLICE(kIROp_DifferentialPtrPairGetPrimal
)
SLANG_RAW(")\n")
SLANG_RAW("        get;\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    property v : T\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __intrinsic_op(")
SLANG_SPLICE(kIROp_DifferentialPtrPairGetPrimal
)
SLANG_RAW(")\n")
SLANG_RAW("        get;\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    property d : T.Differential\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __intrinsic_op(")
SLANG_SPLICE(kIROp_DifferentialPtrPairGetDifferential
)
SLANG_RAW(")\n")
SLANG_RAW("        get;\n")
SLANG_RAW("    }\n")
SLANG_RAW("};\n")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("/// Represents builtin floating point scalar types.\n")
SLANG_RAW("/// To define generic functions that work with both scalar and vector types, use `IFloat` instead.\n")
SLANG_RAW("///\n")
SLANG_RAW("/// Implemented by `float`, `half` and `double` types.\n")
SLANG_RAW("[sealed]\n")
SLANG_RAW("[builtin]\n")
SLANG_RAW("[TreatAsDifferentiable]\n")
SLANG_RAW("interface __BuiltinFloatingPointType : __BuiltinRealType, IFloat\n")
SLANG_RAW("{\n")
SLANG_RAW("        /// Get the value of the mathematical constant pi in this type.\n")
SLANG_RAW("    [Differentiable]\n")
SLANG_RAW("    static This getPi();\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("//@ hidden:\n")
SLANG_RAW("\n")
SLANG_RAW("// A type resulting from an `enum` declaration.\n")
SLANG_RAW("[builtin]\n")
SLANG_RAW("__magic_type(EnumTypeType)\n")
SLANG_RAW("interface __EnumType : ILogical\n")
SLANG_RAW("{\n")
SLANG_RAW("    // The type of tags for this `enum`\n")
SLANG_RAW("    //\n")
SLANG_RAW("    // Note: using `__Tag` instead of `Tag` to avoid any\n")
SLANG_RAW("    // conflict if a user had an `enum` case called `Tag`\n")
SLANG_RAW("    associatedtype __Tag : __BuiltinIntegerType;\n")
SLANG_RAW("\n")
SLANG_RAW("    __builtin_requirement(")
SLANG_SPLICE( (int)BuiltinRequirementKind::InitLogicalFromInt
)
SLANG_RAW(" )\n")
SLANG_RAW("    __init(__Tag value);\n")
SLANG_RAW("};\n")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("//@public:\n")
SLANG_RAW("\n")
SLANG_RAW("/// Represents types that provide a subscript operator so that they can be used like an immutable array.\n")
SLANG_RAW("/// @param T The element type returned by the subscript operator.\n")
SLANG_RAW("/// @remarks This interface is implemented by `Array`, `vector`, `matrix`, `StructuredBuffer` and `RWStructuredBuffer` types.\n")
SLANG_RAW("/// @example The follow example shows how to define a generic function that computes the sum of all elements in an array-like type.\n")
SLANG_RAW("/// ```csharp\n")
SLANG_RAW("/// T sum<T:IFloat, U:IArray<T>>(U array)\n")
SLANG_RAW("/// {\n")
SLANG_RAW("///     T result = T(0);\n")
SLANG_RAW("///     for (int i = 0; i < array.getCount(); i++)\n")
SLANG_RAW("///     {\n")
SLANG_RAW("///         result = result + array[i];\n")
SLANG_RAW("///     }\n")
SLANG_RAW("///     return result;\n")
SLANG_RAW("/// }\n")
SLANG_RAW("/// \n")
SLANG_RAW("/// RWStructuredBuffer<float> outputBuffer;\n")
SLANG_RAW("/// \n")
SLANG_RAW("/// [numthreads(1, 1, 1)]\n")
SLANG_RAW("/// void computeMain(int3 dispatchThreadID : SV_DispatchThreadID)\n")
SLANG_RAW("/// {\n")
SLANG_RAW("///     float arr[3] = { 1.0, 2.0, 3.0 };\n")
SLANG_RAW("///     float4 v = float4(1.0, 2.0, 3.0, 4.0);\n")
SLANG_RAW("///     float2x2 m = float2x2(1.0, 2.0, 3.0, 4.0);\n")
SLANG_RAW("///\n")
SLANG_RAW("///     outputBuffer[0] = sum(arr);  // 6.0\n")
SLANG_RAW("///\n")
SLANG_RAW("///     // treat `v` as array of `float`.\n")
SLANG_RAW("///     outputBuffer[1] = sum(v);    // 10.0\n")
SLANG_RAW("///\n")
SLANG_RAW("///     // treat `m` as array of `float2`.\n")
SLANG_RAW("///     float2 innerSum = sum(m); \n")
SLANG_RAW("///     outputBuffer[2] = sum(innerSum); // 10.0\n")
SLANG_RAW("/// }\n")
SLANG_RAW("/// ```\n")
SLANG_RAW("interface IArray<T>\n")
SLANG_RAW("{\n")
SLANG_RAW("    /// Returns the number of elements in the conforming type.\n")
SLANG_RAW("    int getCount();\n")
SLANG_RAW("\n")
SLANG_RAW("    /// The subscript operator to be provided by a conforming type.\n")
SLANG_RAW("    __subscript(int index) -> T\n")
SLANG_RAW("    {\n")
SLANG_RAW("        get;\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("/// Represents types that provide a subscript operator so that they can be used like a mutable array.\n")
SLANG_RAW("/// @param T The element type returned by the subscript operator.\n")
SLANG_RAW("/// @remarks This interface is implemented by `Array`, `vector`, `matrix`, `StructuredBuffer` and `RWStructuredBuffer` types.\n")
SLANG_RAW("/// @example The follow example shows how to define a generic function uses the `IRWArray` interface to mutate an array-like value.\n")
SLANG_RAW("/// ```csharp\n")
SLANG_RAW("/// void writeToArray<U, T : IRWArray<U>>(inout T array, int index, U value) { array[index] = value; }\n")
SLANG_RAW("/// void writeToBuffer<U, T : IRWArray<U>>(T array, int index, U value) { array[index] = value; }\n")
SLANG_RAW("/// U readFromArray<U, T:IArray<U>>(T array, int index) { return array[index]; }\n")
SLANG_RAW("/// \n")
SLANG_RAW("/// //TEST_INPUT:ubuffer(data=[0 0 0 0], stride=4):out,name=outputBuffer\n")
SLANG_RAW("/// RWStructuredBuffer<float> outputBuffer;\n")
SLANG_RAW("/// \n")
SLANG_RAW("/// [numthreads(1, 1, 1)]\n")
SLANG_RAW("/// void computeMain(int3 dispatchThreadID: SV_DispatchThreadID)\n")
SLANG_RAW("/// {\n")
SLANG_RAW("///     float arr[3] = { 1.0, 2.0, 3.0 };\n")
SLANG_RAW("///     float4 v = float4(1.0, 2.0, 3.0, 4.0);\n")
SLANG_RAW("///     float2x2 m = float2x2(1.0, 2.0, 3.0, 4.0);\n")
SLANG_RAW("/// \n")
SLANG_RAW("///     // treat `outputBuffer` as a mutable array of `float`.\n")
SLANG_RAW("///     writeToBuffer(outputBuffer, 0, 1.0f);\n")
SLANG_RAW("/// \n")
SLANG_RAW("///     // treat `arr` as a mutable array of `float`.\n")
SLANG_RAW("///     writeToArray(arr, 0, 4.0f);\n")
SLANG_RAW("///     outputBuffer[1] = readFromArray(arr, 0); // 4.0\n")
SLANG_RAW("/// \n")
SLANG_RAW("///     // treat `v` as a mutable array of `float`.\n")
SLANG_RAW("///     writeToArray(v, 3, 3.0f);\n")
SLANG_RAW("///     outputBuffer[2] = readFromArray(v, 3);  // 3.0\n")
SLANG_RAW("/// \n")
SLANG_RAW("///     // treat `m` as a mutable array of `float2`.\n")
SLANG_RAW("///     writeToArray(m, 1, float2(10.0f, 20.0f));\n")
SLANG_RAW("///     outputBuffer[3] = readFromArray(m, 1).x + readFromArray(m, 1).y; // 30.0\n")
SLANG_RAW("/// \n")
SLANG_RAW("///     writeToBuffer(outputBuffer, 0, readFromArray(outputBuffer, 0));\n")
SLANG_RAW("/// }\n")
SLANG_RAW("/// ```\n")
SLANG_RAW("interface IRWArray<T> : IArray<T>\n")
SLANG_RAW("{\n")
SLANG_RAW("    /// The subscript operator to be provided by a conforming type. Provides both a `get` and a `set` accessor.\n")
SLANG_RAW("    __subscript(int index)->T\n")
SLANG_RAW("    {\n")
SLANG_RAW("        get;\n")
SLANG_RAW("        set;\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// The \"comma operator\" is effectively just a generic function that returns its second\n")
SLANG_RAW("// argument. The left-to-right evaluation order guaranteed by Slang then ensures that\n")
SLANG_RAW("// `left` is evaluated before `right`.\n")
SLANG_RAW("//\n")
SLANG_RAW("//@hidden:\n")
SLANG_RAW("__generic<T,U>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("U operator,(T left, U right)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return right;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// The ternary `?:` operator does not short-circuit in HLSL, and Slang no longer\n")
SLANG_RAW("// follow that definition for the scalar condition overload, so this declaration just serves\n")
SLANG_RAW("// for type-checking purpose only.\n")
SLANG_RAW("\n")
SLANG_RAW("//@hidden:\n")
SLANG_RAW("__generic<T> __intrinsic_op(select) T operator?: (bool condition, T ifTrue, T ifFalse);\n")
SLANG_RAW("\n")
SLANG_RAW("//@hidden:\n")
SLANG_RAW("__generic<T, let N : int> __intrinsic_op(select) vector<T,N> operator?:(vector<bool,N> condition, vector<T,N> ifTrue, vector<T,N> ifFalse);\n")
SLANG_RAW("\n")
SLANG_RAW("// Users are advised to use `select` instead if non-short-circuiting behavior is intended.\n")
SLANG_RAW("//@public:\n")
SLANG_RAW("__generic<T> __intrinsic_op(select) T select(bool condition, T ifTrue, T ifFalse);\n")
SLANG_RAW("__generic<T, let N : int> __intrinsic_op(select) vector<T,N> select(vector<bool,N> condition, vector<T,N> ifTrue, vector<T,N> ifFalse);\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("__generic<T> Optional<T> select(bool condition, __none_t ifTrue, T ifFalse)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return select(condition, Optional<T>(none), Optional<T>(ifFalse));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("__generic<T> Optional<T> select(bool condition, T ifTrue, __none_t ifFalse)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return select(condition, Optional<T>(ifTrue), Optional<T>(none));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// Allow real-number types to be cast into each other\n")
SLANG_RAW("//@hidden:\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_FloatCast
)
SLANG_RAW(")\n")
SLANG_RAW("    T __realCast<T : __BuiltinRealType, U : __BuiltinRealType>(U val);\n")
SLANG_RAW("//@hidden:\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_CastIntToFloat
)
SLANG_RAW(")\n")
SLANG_RAW("T __realCast<T : __BuiltinRealType, U : __BuiltinIntegerType>(U val);\n")
SLANG_RAW("//@hidden:\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_IntCast
)
SLANG_RAW(")\n")
SLANG_RAW("T __intCast<T : __BuiltinType, U : __BuiltinType>(U val);\n")
SLANG_RAW("\n")
SLANG_RAW("//@hidden:\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_CastIntToFloat
)
SLANG_RAW(")\n")
SLANG_RAW("T __castIntToFloat<T:__BuiltinType, U:__BuiltinType>(U v);\n")
SLANG_RAW("\n")
SLANG_RAW("//@hidden:\n")

// We are going to use code generation to produce the
// declarations for all of our base types.
static const int kBaseTypeCount = sizeof(kBaseTypes) / sizeof(kBaseTypes[0]);
for (int tt = 0; tt < kBaseTypeCount; ++tt)
{
SLANG_RAW("#line 995 \"core.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("__builtin_type(")
SLANG_SPLICE(int(kBaseTypes[tt].tag)
)
SLANG_RAW(")\n")
SLANG_RAW("struct ")
SLANG_SPLICE(kBaseTypes[tt].name
)
SLANG_RAW("\n")
SLANG_RAW("    : __BuiltinType\n")
SLANG_RAW("\n")

    switch (kBaseTypes[tt].tag)
    {
    case BaseType::Half:
    case BaseType::Float:
    case BaseType::Double:
SLANG_RAW("#line 1007 \"core.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("    ,  __BuiltinFloatingPointType\n")
SLANG_RAW("    ,  __BuiltinRealType\n")
SLANG_RAW("    ,  __BuiltinSignedArithmeticType\n")
SLANG_RAW("    ,  __BuiltinArithmeticType\n")

        break;
    case BaseType::Int8:
    case BaseType::Int16:
    case BaseType::Int:
    case BaseType::Int64:
    case BaseType::IntPtr:
SLANG_RAW("#line 1019 \"core.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("    ,  __BuiltinSignedArithmeticType\n")

        ; // fall through
    case BaseType::UInt8:
    case BaseType::UInt16:
    case BaseType::UInt:
    case BaseType::UInt64:
    case BaseType::UIntPtr:
SLANG_RAW("#line 1028 \"core.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("    ,  __BuiltinArithmeticType\n")
SLANG_RAW("    ,  __BuiltinIntegerType\n")

    if (kBaseTypes[tt].tag == BaseType::Int || kBaseTypes[tt].tag == BaseType::UInt)
SLANG_RAW("#line 1033 \"core.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("    ,  __BuiltinInt32Type\n")

    if (kBaseTypes[tt].tag == BaseType::Int64 || kBaseTypes[tt].tag == BaseType::UInt64)
SLANG_RAW("#line 1037 \"core.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("    ,  __BuiltinInt64Type\n")

        ; // fall through
    case BaseType::Bool:
SLANG_RAW("#line 1042 \"core.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("    ,  __BuiltinLogicalType\n")

        break;

    default:
        break;
    }
SLANG_RAW("#line 1050 \"core.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("{\n")

    // Declare initializers to convert from various other types
    for (int ss = 0; ss < kBaseTypeCount; ++ss)
    {
        // Don't allow conversion to or from `void`
        if (kBaseTypes[tt].tag == BaseType::Void)
            continue;
        if (kBaseTypes[ss].tag == BaseType::Void)
            continue;

        // We need to emit a modifier so that the semantic-checking
        // layer will know it can use these operations for implicit
        // conversion.
        ConversionCost conversionCost = getBaseTypeConversionCost(
            kBaseTypes[tt],
            kBaseTypes[ss]);

        IROp intrinsicOpCode = getBaseTypeConversionOp(
            kBaseTypes[tt],
            kBaseTypes[ss]);

        BuiltinConversionKind builtinConversionKind = kBuiltinConversion_Unknown;
        if (kBaseTypes[tt].tag == BaseType::Double &&
            kBaseTypes[ss].tag == BaseType::Float)
            builtinConversionKind = kBuiltinConversion_FloatToDouble;

        const char* attrib = "";
        if ((kBaseTypes[tt].flags & kBaseTypes[ss].flags & FLOAT_MASK) != 0)
            attrib = "[TreatAsDifferentiable]";
SLANG_RAW("#line 1081 \"core.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("    ")
SLANG_SPLICE(attrib
)
SLANG_RAW("\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(intrinsicOpCode
)
SLANG_RAW(")\n")
SLANG_RAW("    __implicit_conversion(")
SLANG_SPLICE(conversionCost
)
SLANG_RAW(", ")
SLANG_SPLICE(builtinConversionKind
)
SLANG_RAW(")\n")
SLANG_RAW("    __init(")
SLANG_SPLICE(kBaseTypes[ss].name
)
SLANG_RAW(" value);\n")
SLANG_RAW("\n")

    }

    // Integer type implementations.
    switch (kBaseTypes[tt].tag)
    {
    case BaseType::Bool:
SLANG_RAW("#line 1094 \"core.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("        [__unsafeForceInlineEarly] __intrinsic_op(")
SLANG_SPLICE(kIROp_Eql
)
SLANG_RAW(") bool equals(This other);\n")
SLANG_RAW("        [__unsafeForceInlineEarly] __intrinsic_op(")
SLANG_SPLICE(kIROp_Less
)
SLANG_RAW(") bool lessThan(This other);\n")
SLANG_RAW("        [__unsafeForceInlineEarly] __intrinsic_op(")
SLANG_SPLICE(kIROp_Leq
)
SLANG_RAW(") bool lessThanOrEquals(This other);\n")
SLANG_RAW("        [__unsafeForceInlineEarly] This shl(int other) { return __intCast<This>(__shl(__intCast<int>(this), other)); }\n")
SLANG_RAW("        [__unsafeForceInlineEarly] This shr(int other) { return __intCast<This>(__shr(__intCast<int>(this), other)); }\n")
SLANG_RAW("        [__unsafeForceInlineEarly] This bitAnd(This other) { return __intCast<This>(__and(__intCast<int>(this), __intCast<int>(other))); }\n")
SLANG_RAW("        [__unsafeForceInlineEarly] This bitOr(This other) { return __intCast<This>(__or(__intCast<int>(this), __intCast<int>(other))); }\n")
SLANG_RAW("        [__unsafeForceInlineEarly] __intrinsic_op(")
SLANG_SPLICE(kIROp_And
)
SLANG_RAW(") This and(This other);\n")
SLANG_RAW("        [__unsafeForceInlineEarly] __intrinsic_op(")
SLANG_SPLICE(kIROp_Or
)
SLANG_RAW(") This or(This other);\n")
SLANG_RAW("        [__unsafeForceInlineEarly] This bitXor(This other)  { return __intCast<This>(__xor(__intCast<int>(this), __intCast<int>(other))); }\n")
SLANG_RAW("        [__unsafeForceInlineEarly] This bitNot()  { return __intCast<This>(__not(__intCast<int>(this))); }\n")
SLANG_RAW("        [__unsafeForceInlineEarly] __intrinsic_op(")
SLANG_SPLICE(kIROp_Not
)
SLANG_RAW(") This not();\n")

        break;
    case BaseType::UInt8:
    case BaseType::UInt16:
    case BaseType::UInt:
    case BaseType::UInt64:
    case BaseType::Int8:
    case BaseType::Int16:
    case BaseType::Int:
    case BaseType::Int64:
    case BaseType::IntPtr:
    case BaseType::UIntPtr:
SLANG_RAW("#line 1119 \"core.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("        // If this is a basic integer type, then define explicit\n")
SLANG_RAW("        // initializers that take a value of an `enum` type.\n")
SLANG_RAW("        //\n")
SLANG_RAW("        // TODO: This should actually be restricted, so that this\n")
SLANG_RAW("        // only applies `where T.__Tag == Self`, but we don't have\n")
SLANG_RAW("        // the needed features in our type system to implement\n")
SLANG_RAW("        // that constraint right now.\n")
SLANG_RAW("        //\n")
SLANG_RAW("        __generic<T:__EnumType>\n")
SLANG_RAW("        __intrinsic_op(")
SLANG_SPLICE(kIROp_IntCast
)
SLANG_RAW(")\n")
SLANG_RAW("        __init(T value);\n")
SLANG_RAW("\n")
SLANG_RAW("        // Implementation of the `IInteger` interface.\n")
SLANG_RAW("        __intrinsic_op(")
SLANG_SPLICE(kIROp_Less
)
SLANG_RAW(") bool lessThan(This other);\n")
SLANG_RAW("        __intrinsic_op(")
SLANG_SPLICE(kIROp_Leq
)
SLANG_RAW(")  bool lessThanOrEquals(This other);\n")
SLANG_RAW("        __intrinsic_op(")
SLANG_SPLICE(kIROp_Eql
)
SLANG_RAW(")  bool equals(This other);\n")
SLANG_RAW("        __intrinsic_op(")
SLANG_SPLICE(kIROp_Add
)
SLANG_RAW(")  This add(This other);\n")
SLANG_RAW("        __intrinsic_op(")
SLANG_SPLICE(kIROp_Sub
)
SLANG_RAW(")  This sub(This other);\n")
SLANG_RAW("        __intrinsic_op(")
SLANG_SPLICE(kIROp_Mul
)
SLANG_RAW(")  This mul(This other);\n")
SLANG_RAW("        __intrinsic_op(")
SLANG_SPLICE(kIROp_Div
)
SLANG_RAW(")  This div(This other);\n")
SLANG_RAW("        __intrinsic_op(")
SLANG_SPLICE(kIROp_IRem
)
SLANG_RAW(") This mod(This other);\n")
SLANG_RAW("        __intrinsic_op(")
SLANG_SPLICE(kIROp_Neg
)
SLANG_RAW(")  This neg();\n")
SLANG_RAW("        __intrinsic_op(")
SLANG_SPLICE(kIROp_Lsh
)
SLANG_RAW(") This shl(int other);\n")
SLANG_RAW("        __intrinsic_op(")
SLANG_SPLICE(kIROp_Rsh
)
SLANG_RAW(") This shr(int other);\n")
SLANG_RAW("        __intrinsic_op(")
SLANG_SPLICE(kIROp_BitAnd
)
SLANG_RAW(") This bitAnd(This other);\n")
SLANG_RAW("        __intrinsic_op(")
SLANG_SPLICE(kIROp_BitOr
)
SLANG_RAW(") This bitOr(This other);\n")
SLANG_RAW("        [__unsafeForceInlineEarly] This and(This other) {return __intCast<This>(and(__intCast<bool>(this), __intCast<bool>(other))); }\n")
SLANG_RAW("        [__unsafeForceInlineEarly] This or(This other) {return __intCast<This>(__intCast<bool>(this) || __intCast<bool>(other)); }\n")
SLANG_RAW("        __intrinsic_op(")
SLANG_SPLICE(kIROp_BitXor
)
SLANG_RAW(") This bitXor(This other);\n")
SLANG_RAW("        __intrinsic_op(")
SLANG_SPLICE(kIROp_BitNot
)
SLANG_RAW(") This bitNot();\n")
SLANG_RAW("        [__unsafeForceInlineEarly] This not() {return __intCast<This>(!__intCast<bool>(this)); }\n")
SLANG_RAW("        __intrinsic_op(")
SLANG_SPLICE(kIROp_IntCast
)
SLANG_RAW(") int toInt();\n")
SLANG_RAW("        __intrinsic_op(")
SLANG_SPLICE(kIROp_IntCast
)
SLANG_RAW(") int64_t toInt64();\n")
SLANG_RAW("        __intrinsic_op(")
SLANG_SPLICE(kIROp_IntCast
)
SLANG_RAW(") uint toUInt();\n")
SLANG_RAW("        __intrinsic_op(")
SLANG_SPLICE(kIROp_IntCast
)
SLANG_RAW(") uint64_t toUInt64();\n")

        break;

    default:
        break;
    }

    // If this is a floating-point type, then we need to
    // implement the `IFloat` interface, which defines the basic `getPi()`
    // function that is used to implement generic versions of `degrees()` and
    // `radians()`.
    //
    switch (kBaseTypes[tt].tag)
    {
    default:
        break;
    case BaseType::Half:
    case BaseType::Float:
    case BaseType::Double:
SLANG_RAW("#line 1174 \"core.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("        [Differentiable]\n")
SLANG_RAW("        static ")
SLANG_SPLICE(kBaseTypes[tt].name
)
SLANG_RAW(" getPi() { return ")
SLANG_SPLICE(kBaseTypes[tt].name
)
SLANG_RAW("(3.14159265358979323846264338328); }\n")
SLANG_RAW("\n")
SLANG_RAW("         __intrinsic_op(")
SLANG_SPLICE(kIROp_Less
)
SLANG_RAW(") bool lessThan(This other);\n")
SLANG_RAW("         __intrinsic_op(")
SLANG_SPLICE(kIROp_Leq
)
SLANG_RAW(")  bool lessThanOrEquals(This other);\n")
SLANG_RAW("         __intrinsic_op(")
SLANG_SPLICE(kIROp_Eql
)
SLANG_RAW(")  bool equals(This other);\n")
SLANG_RAW("         __intrinsic_op(")
SLANG_SPLICE(kIROp_Add
)
SLANG_RAW(")  This add(This other);\n")
SLANG_RAW("         __intrinsic_op(")
SLANG_SPLICE(kIROp_Sub
)
SLANG_RAW(")  This sub(This other);\n")
SLANG_RAW("         __intrinsic_op(")
SLANG_SPLICE(kIROp_Mul
)
SLANG_RAW(")  This mul(This other);\n")
SLANG_RAW("         __intrinsic_op(")
SLANG_SPLICE(kIROp_Div
)
SLANG_RAW(")  This div(This other);\n")
SLANG_RAW("         __intrinsic_op(")
SLANG_SPLICE(kIROp_FRem
)
SLANG_RAW(") This mod(This other);\n")
SLANG_RAW("         __intrinsic_op(")
SLANG_SPLICE(kIROp_Neg
)
SLANG_RAW(")  This neg();\n")
SLANG_RAW("         __intrinsic_op(")
SLANG_SPLICE(kIROp_FloatCast
)
SLANG_RAW(") float toFloat();\n")
SLANG_RAW("         __intrinsic_op(")
SLANG_SPLICE(kIROp_Mul
)
SLANG_RAW(") This scale<T:__BuiltinFloatingPointType>(T s) { return __mul(this, __realCast<This>(s)); }\n")
SLANG_RAW("        typedef ")
SLANG_SPLICE(kBaseTypes[tt].name
)
SLANG_RAW(" Differential;\n")
SLANG_RAW("    \n")
SLANG_RAW("        [__unsafeForceInlineEarly]\n")
SLANG_RAW("        [BackwardDifferentiable]\n")
SLANG_RAW("        static Differential dzero()\n")
SLANG_RAW("        {\n")
SLANG_RAW("            return Differential(0);\n")
SLANG_RAW("        }\n")
SLANG_RAW("\n")
SLANG_RAW("        [__unsafeForceInlineEarly]\n")
SLANG_RAW("        [BackwardDifferentiable]\n")
SLANG_RAW("        static Differential dadd(Differential a, Differential b)\n")
SLANG_RAW("        {\n")
SLANG_RAW("            return a + b;\n")
SLANG_RAW("        }\n")
SLANG_RAW("        \n")
SLANG_RAW("        __generic<U : __BuiltinRealType>\n")
SLANG_RAW("        [__unsafeForceInlineEarly]\n")
SLANG_RAW("        [BackwardDifferentiable]\n")
SLANG_RAW("        static Differential dmul(U a, Differential b)\n")
SLANG_RAW("        {\n")
SLANG_RAW("            return __realCast<Differential, U>(a) * b;\n")
SLANG_RAW("        }\n")

        break;
    }

    // If this is the `void` type, then we want to allow
    // explicit conversion to it from any other type, using
    // `(void) someExpression`.
    //
    if( kBaseTypes[tt].tag == BaseType::Void )
    {
SLANG_RAW("#line 1222 \"core.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("        __generic<T>\n")
SLANG_RAW("        [__readNone]\n")
SLANG_RAW("        __intrinsic_op(")
SLANG_SPLICE(kIROp_CastToVoid
)
SLANG_RAW(")\n")
SLANG_RAW("        __init(T value)\n")
SLANG_RAW("        {}\n")

    }

SLANG_RAW("#line 1231 \"core.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")

}

// Declare built-in pointer type
// (eventually we can have the traditional syntax sugar for this)
SLANG_RAW("#line 1240 \"core.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("//@hidden:\n")
SLANG_RAW("__magic_type(NullPtrType)\n")
SLANG_RAW("struct NullPtr\n")
SLANG_RAW("{\n")
SLANG_RAW("};\n")
SLANG_RAW("\n")
SLANG_RAW("//@hidden:\n")
SLANG_RAW("__magic_type(NoneType)\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_VoidType
)
SLANG_RAW(")\n")
SLANG_RAW("struct __none_t\n")
SLANG_RAW("{\n")
SLANG_RAW("};\n")
SLANG_RAW("\n")
SLANG_RAW("//@public:\n")
SLANG_RAW("/// Represents a pointer type.\n")
SLANG_RAW("/// @param T The type of the value pointed to.\n")
SLANG_RAW("/// @remarks `T* val` is equivalent to `Ptr<T> val`.\n")
SLANG_RAW("__generic<T, let addrSpace : uint64_t = ")
SLANG_SPLICE( (uint64_t)AddressSpace::UserPointer
)
SLANG_RAW("ULL>\n")
SLANG_RAW("__magic_type(PtrType)\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_PtrType
)
SLANG_RAW(")\n")
SLANG_RAW("struct Ptr\n")
SLANG_RAW("{\n")
SLANG_RAW("    __generic<U>\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_BitCast
)
SLANG_RAW(")\n")
SLANG_RAW("    __init(Ptr<U, addrSpace> ptr);\n")
SLANG_RAW("\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_CastIntToPtr
)
SLANG_RAW(")\n")
SLANG_RAW("    __init(uint64_t val);\n")
SLANG_RAW("\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_CastIntToPtr
)
SLANG_RAW(")\n")
SLANG_RAW("    __init(int64_t val);\n")
SLANG_RAW("\n")
SLANG_RAW("    __generic<TInt : __BuiltinIntegerType>\n")
SLANG_RAW("    __subscript(TInt index) -> T\n")
SLANG_RAW("    {\n")
SLANG_RAW("        // If a 'Ptr[index]' is referred to by a '__ref', call 'kIROp_GetOffsetPtr(index)'\n")
SLANG_RAW("        __intrinsic_op(")
SLANG_SPLICE(kIROp_GetOffsetPtr
)
SLANG_RAW(")\n")
SLANG_RAW("        [nonmutating]\n")
SLANG_RAW("        ref;\n")
SLANG_RAW("    }\n")
SLANG_RAW("};\n")
SLANG_RAW("\n")
SLANG_RAW("//@hidden:\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_AlignedAttr
)
SLANG_RAW(")\n")
SLANG_RAW("void __align_attr(int alignment);\n")
SLANG_RAW("\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_Load
)
SLANG_RAW(")\n")
SLANG_RAW("T __load_aligned<T, U>(T* ptr, U alignmentAttr);\n")
SLANG_RAW("\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_Store
)
SLANG_RAW(")\n")
SLANG_RAW("void __store_aligned<T, U>(T* ptr, T value, U alignmentAttr);\n")
SLANG_RAW("\n")
SLANG_RAW("//@public:\n")
SLANG_RAW("\n")
SLANG_RAW("/// Load a value from a pointer with a known alignment.\n")
SLANG_RAW("/// Aligned loads are more efficient than unaligned loads on some platforms.\n")
SLANG_RAW("/// @param alignment The alignment of the load operation.\n")
SLANG_RAW("/// @param ptr The pointer to load from.\n")
SLANG_RAW("/// @return The value loaded from the pointer.\n")
SLANG_RAW("/// @remarks When targeting SPIRV, this function maps to an `OpLoad` instruction with the `Aligned` memory operand.\n")
SLANG_RAW("/// The functions maps to normal load operation on other targets.\n")
SLANG_RAW("///\n")
SLANG_RAW("[__NoSideEffect]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("T loadAligned<int alignment, T>(T* ptr)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return __load_aligned(ptr, __align_attr(alignment));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("/// Store a value to a pointer with a known alignment.\n")
SLANG_RAW("/// Aligned stores are more efficient than unaligned stores on some platforms.\n")
SLANG_RAW("/// @param alignment The alignment of the store operation.\n")
SLANG_RAW("/// @param ptr The pointer to store value to.\n")
SLANG_RAW("/// @param value The value to store.\n")
SLANG_RAW("/// @remarks When targeting SPIRV, this function maps to an `OpStore` instruction with the `Aligned` memory operand.\n")
SLANG_RAW("/// The functions maps to normal store operation on other targets.\n")
SLANG_RAW("///\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("void storeAligned<int alignment, T>(T* ptr, T value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __store_aligned(ptr, value, __align_attr(alignment));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("//@hidden:\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_Load
)
SLANG_RAW(")\n")
SLANG_RAW("T __load<T, let addrSpace : uint64_t>(Ptr<T, addrSpace> ptr);\n")
SLANG_RAW("\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_Store
)
SLANG_RAW(")\n")
SLANG_RAW("void __store<T, let addrSpace : uint64_t>(Ptr<T, addrSpace> ptr, T val);\n")
SLANG_RAW("\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_GetElementPtr
)
SLANG_RAW(")\n")
SLANG_RAW("Ptr<T, addrSpace> __getElementPtr<T, let addrSpace : uint64_t, TIndex : __BuiltinIntegerType>(Ptr<T, addrSpace> ptr, TIndex index);\n")
SLANG_RAW("\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_GetOffsetPtr
)
SLANG_RAW(")\n")
SLANG_RAW("Ptr<T, addrSpace> __getOffsetPtr<T, let addrSpace : uint64_t, TIndex : __BuiltinIntegerType>(Ptr<T, addrSpace> ptr, TIndex index);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T, let addrSpace : uint64_t>\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_Less
)
SLANG_RAW(")\n")
SLANG_RAW("bool operator <(Ptr<T, addrSpace> p1, Ptr<T, addrSpace> p2);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T, let addrSpace : uint64_t>\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_Leq
)
SLANG_RAW(")\n")
SLANG_RAW("bool operator <=(Ptr<T, addrSpace> p1, Ptr<T, addrSpace> p2);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T, let addrSpace : uint64_t>\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_Greater
)
SLANG_RAW(")\n")
SLANG_RAW("bool operator>(Ptr<T, addrSpace> p1, Ptr<T, addrSpace> p2);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T, let addrSpace : uint64_t>\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_Geq
)
SLANG_RAW(")\n")
SLANG_RAW("bool operator >=(Ptr<T, addrSpace> p1, Ptr<T, addrSpace> p2);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T, let addrSpace : uint64_t>\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_Neq
)
SLANG_RAW(")\n")
SLANG_RAW("bool operator !=(Ptr<T, addrSpace> p1, Ptr<T, addrSpace> p2);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T, let addrSpace : uint64_t>\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_Eql
)
SLANG_RAW(")\n")
SLANG_RAW("bool operator ==(Ptr<T, addrSpace> p1, Ptr<T, addrSpace> p2);\n")
SLANG_RAW("\n")
SLANG_RAW("//@public:\n")
SLANG_RAW("extension bool : IRangedValue\n")
SLANG_RAW("{\n")
SLANG_RAW("    __generic<T, let addrSpace : uint64_t>\n")
SLANG_RAW("    __implicit_conversion(")
SLANG_SPLICE(kConversionCost_PtrToBool
)
SLANG_RAW(")\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_CastPtrToBool
)
SLANG_RAW(")\n")
SLANG_RAW("    __init(Ptr<T, addrSpace> ptr);\n")
SLANG_RAW("\n")
SLANG_RAW("    __generic<T : __EnumType>\n")
SLANG_RAW("    __implicit_conversion(")
SLANG_SPLICE(kConversionCost_IntegerTruncate
)
SLANG_RAW(")\n")
SLANG_RAW("    [__unsafeForceInlineEarly]\n")
SLANG_RAW("    __init(T v)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        return __slang_noop_cast<T.__Tag>(v) != __intCast<T.__Tag>(0);\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    static const bool maxValue = true;\n")
SLANG_RAW("    static const bool minValue = false;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("extension uint64_t : IRangedValue\n")
SLANG_RAW("{\n")
SLANG_RAW("    __generic<T, let addrSpace : uint64_t>\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_CastPtrToInt
)
SLANG_RAW(")\n")
SLANG_RAW("    __init(Ptr<T, addrSpace> ptr);\n")
SLANG_RAW("\n")
SLANG_RAW("    static const uint64_t maxValue = 0xFFFFFFFFFFFFFFFFULL;\n")
SLANG_RAW("    static const uint64_t minValue = 0;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("extension int64_t : IRangedValue\n")
SLANG_RAW("{\n")
SLANG_RAW("    __generic<T, let addrSpace : uint64_t>\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_CastPtrToInt
)
SLANG_RAW(")\n")
SLANG_RAW("    __init(Ptr<T, addrSpace> ptr);\n")
SLANG_RAW("\n")
SLANG_RAW("    static const int64_t maxValue =  0x7FFFFFFFFFFFFFFFLL;\n")
SLANG_RAW("    static const int64_t minValue = -0x8000000000000000LL;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("extension intptr_t : IRangedValue\n")
SLANG_RAW("{\n")
SLANG_RAW("    __generic<T, let addrSpace : uint64_t>\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_CastPtrToInt
)
SLANG_RAW(")\n")
SLANG_RAW("    __init(Ptr<T, addrSpace> ptr);\n")
SLANG_RAW("    static const intptr_t maxValue = ")
SLANG_SPLICE(SLANG_PROCESSOR_X86_64?"0x7FFFFFFFFFFFFFFFz":"0x7FFFFFFFz"
)
SLANG_RAW(";\n")
SLANG_RAW("    static const intptr_t minValue = ")
SLANG_SPLICE(SLANG_PROCESSOR_X86_64?"0x8000000000000000z":"0x80000000z"
)
SLANG_RAW(";\n")
SLANG_RAW("    static const int size = ")
SLANG_SPLICE(SLANG_PROCESSOR_X86_64?"8":"4"
)
SLANG_RAW(";\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("extension uintptr_t : IRangedValue\n")
SLANG_RAW("{\n")
SLANG_RAW("    __generic<T, let addrSpace : uint64_t>\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_CastPtrToInt
)
SLANG_RAW(")\n")
SLANG_RAW("    __init(Ptr<T, addrSpace> ptr);\n")
SLANG_RAW("    static const uintptr_t maxValue = ")
SLANG_SPLICE(SLANG_PROCESSOR_X86_64?"0xFFFFFFFFFFFFFFFFz":"0xFFFFFFFFz"
)
SLANG_RAW(";\n")
SLANG_RAW("    static const uintptr_t minValue = 0z;\n")
SLANG_RAW("    static const int size = ")
SLANG_SPLICE(SLANG_PROCESSOR_X86_64?"8":"4"
)
SLANG_RAW(";\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("//@hidden:\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("__magic_type(OutType)\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_OutType
)
SLANG_RAW(")\n")
SLANG_RAW("struct Out\n")
SLANG_RAW("{};\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("__magic_type(InOutType)\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_InOutType
)
SLANG_RAW(")\n")
SLANG_RAW("struct InOut\n")
SLANG_RAW("{};\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("__magic_type(RefType)\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_RefType
)
SLANG_RAW(")\n")
SLANG_RAW("struct Ref\n")
SLANG_RAW("{};\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("__magic_type(ConstRefType)\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_ConstRefType
)
SLANG_RAW(")\n")
SLANG_RAW("struct ConstRef\n")
SLANG_RAW("{};\n")
SLANG_RAW("\n")
SLANG_RAW("typealias __Addr<T> = Ptr<T, ")
SLANG_SPLICE( (uint64_t)AddressSpace::Generic
)
SLANG_RAW("ULL>;\n")
SLANG_RAW("\n")
SLANG_RAW("//@public:\n")
SLANG_RAW("\n")
SLANG_RAW("/// `Optional<T>` is a type with one extra value than `T`, this extra value is\n")
SLANG_RAW("/// used to represent a \"missing\" or \"invalid\" `T`. This extra value is called\n")
SLANG_RAW("/// `none`. \n")
SLANG_RAW("///\n")
SLANG_RAW("/// `none` can be compared against with the operators `==` or `!=`.\n")
SLANG_RAW("///\n")
SLANG_RAW("/// An `Optional<T>` value can also be implicitly or explicitly constructed from\n")
SLANG_RAW("/// a value of type `T`\n")
SLANG_RAW("///\n")
SLANG_RAW("/// `Optional<T>` values can be deconstructed with `if(let myT = myOptionalT) ...` \n")
SLANG_RAW("/// where this branch will only be taken if `myOptionalT` contains a value\n")
SLANG_RAW("/// of type `T` (to be put into scope as `myT`).\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("__magic_type(OptionalType)\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_OptionalType
)
SLANG_RAW(")\n")
SLANG_RAW("struct Optional\n")
SLANG_RAW("{\n")
SLANG_RAW("    /// Return `true` iff this `Optional` contains a value of type `T`\n")
SLANG_RAW("    property bool hasValue\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __intrinsic_op(")
SLANG_SPLICE(kIROp_OptionalHasValue
)
SLANG_RAW(")\n")
SLANG_RAW("        get;\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    /// If this `Optional` contains a value of type `T` return that.\n")
SLANG_RAW("    property T value\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __intrinsic_op(")
SLANG_SPLICE(kIROp_GetOptionalValue
)
SLANG_RAW(")\n")
SLANG_RAW("        get;\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    __implicit_conversion(")
SLANG_SPLICE(kConversionCost_ValToOptional
)
SLANG_RAW(")\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_MakeOptionalValue
)
SLANG_RAW(")\n")
SLANG_RAW("    __init(T val);\n")
SLANG_RAW("};\n")
SLANG_RAW("\n")
SLANG_RAW("//@hidden:\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("bool operator==(Optional<T> val, __none_t noneVal)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return !val.hasValue;\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("bool operator!=(Optional<T> val, __none_t noneVal)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return val.hasValue;\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("bool operator==(__none_t noneVal, Optional<T> val)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return !val.hasValue;\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("bool operator!=(__none_t noneVal, Optional<T> val)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return val.hasValue;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("//@public:\n")
SLANG_RAW("\n")
SLANG_RAW("/// A variadic generic storing the product of several types.\n")
SLANG_RAW("///\n")
SLANG_RAW("/// The member names of individual values are `_0`, `_1`, `_2`, ...\n")
SLANG_RAW("///\n")
SLANG_RAW("/// New tuples can also be constructed by swizzling an existing tuple with the\n")
SLANG_RAW("/// concatenation of these names, for example `x._2_1_0` will return the first\n")
SLANG_RAW("/// three members of the tuple `x` in reverse order.\n")
SLANG_RAW("///\n")
SLANG_RAW("/// When all tuple elements conform to `IComparable` tuples can themselves be\n")
SLANG_RAW("/// compared according to a lexicographic ordering.\n")
SLANG_RAW("///\n")
SLANG_RAW("/// The number of elements in a tuple is given by the `countof` function.\n")
SLANG_RAW("__generic<each T>\n")
SLANG_RAW("__magic_type(TupleType)\n")
SLANG_RAW("struct Tuple\n")
SLANG_RAW("{\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_MakeTuple
)
SLANG_RAW(")\n")
SLANG_RAW("    __init(expand each T);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("/// Construct a tuple from several values in order\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_MakeTuple
)
SLANG_RAW(")\n")
SLANG_RAW("Tuple<T> makeTuple<each T>(T v);\n")
SLANG_RAW("\n")
SLANG_RAW("/// Return a tuple containing the values of both input tuples in order\n")
SLANG_RAW("Tuple<T, U> concat<each T, each U>(Tuple<T> t, Tuple<U> u)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return makeTuple(expand each t, expand each u);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("//@hidden:\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("bool __assign(inout bool v, bool newVal)\n")
SLANG_RAW("{\n")
SLANG_RAW("    v = newVal;\n")
SLANG_RAW("    return newVal;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("void __tupleLessKernel<T : IComparable>(inout bool result, inout bool exit, T a, T b)\n")
SLANG_RAW("{\n")
SLANG_RAW("    if (!exit)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        if (a.lessThan(b))\n")
SLANG_RAW("        {\n")
SLANG_RAW("            result = true;\n")
SLANG_RAW("            exit = true;\n")
SLANG_RAW("        }\n")
SLANG_RAW("        else if (!a.equals(b))\n")
SLANG_RAW("        {\n")
SLANG_RAW("            exit = true;\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("void __tupleGreaterKernel<T : IComparable>(inout bool result, inout bool exit, T a, T b)\n")
SLANG_RAW("{\n")
SLANG_RAW("    if (!exit)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        if (!a.lessThanOrEquals(b))\n")
SLANG_RAW("        {\n")
SLANG_RAW("            result = true;\n")
SLANG_RAW("            exit = true;\n")
SLANG_RAW("        }\n")
SLANG_RAW("        else if (!a.equals(b))\n")
SLANG_RAW("        {\n")
SLANG_RAW("            exit = true;\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("//@public:\n")
SLANG_RAW("__generic<each T : IComparable>\n")
SLANG_RAW("extension Tuple<T> : IComparable\n")
SLANG_RAW("{\n")
SLANG_RAW("    bool lessThan(Tuple<T> other)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        bool result = false;\n")
SLANG_RAW("        bool exit = false;\n")
SLANG_RAW("        expand __tupleLessKernel(result, exit, each this, each other);\n")
SLANG_RAW("        return result;\n")
SLANG_RAW("    }\n")
SLANG_RAW("    bool lessThanOrEquals(Tuple<T> other)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        bool result = false;\n")
SLANG_RAW("        bool exit = false;\n")
SLANG_RAW("        expand __tupleGreaterKernel(result, exit, each this, each other);\n")
SLANG_RAW("        return !result;\n")
SLANG_RAW("    }\n")
SLANG_RAW("    bool equals(Tuple<T> other)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        bool result = true;\n")
SLANG_RAW("        expand result && __assign(result, result && (each this).equals(each other));\n")
SLANG_RAW("        return result;\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("/// Represents an interface for a mutating function that can take multiple parameters.\n")
SLANG_RAW("/// The function allows to modify the state of the object it belongs to.\n")
SLANG_RAW("interface IMutatingFunc<TR, each TP>\n")
SLANG_RAW("{\n")
SLANG_RAW("    /// Defines a mutating function that takes multiple parameters and returns a result of type `TR`.\n")
SLANG_RAW("    /// This function can modify the state of the object it is called on.\n")
SLANG_RAW("    [mutating]\n")
SLANG_RAW("    TR operator()(expand each TP p);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("/// Represents an interface for a function that can take multiple parameters.\n")
SLANG_RAW("/// This interface inherits from `IMutatingFunc` but is used for non-mutating functions.\n")
SLANG_RAW("interface IFunc<TR, each TP> : IMutatingFunc<TR, expand each TP>\n")
SLANG_RAW("{\n")
SLANG_RAW("    /// Defines a non-mutating function that takes multiple parameters and returns a result of type `TR`.\n")
SLANG_RAW("    TR operator()(expand each TP p);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("/// Represents an interface for a mutating function that can take multiple differentiable parameters.\n")
SLANG_RAW("/// The function allows to modify the state of the object it belongs to and supports differentiation.\n")
SLANG_RAW("interface IDifferentiableMutatingFunc<TR : IDifferentiable, each TP : IDifferentiable> : IMutatingFunc<TR, expand each TP>\n")
SLANG_RAW("{\n")
SLANG_RAW("    /// Defines a mutating function that takes multiple differentiable parameters and returns a differentiable result of type `TR`.\n")
SLANG_RAW("    /// This function can modify the state of the object it is called on and supports automatic differentiation.\n")
SLANG_RAW("    [Differentiable]\n")
SLANG_RAW("    [mutating]\n")
SLANG_RAW("    TR operator()(expand each TP p);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("/// Represents an interface for a function that can take multiple differentiable parameters and supports differentiation.\n")
SLANG_RAW("/// This interface inherits from both `IFunc` and `IDifferentiableMutatingFunc` but is used for non-mutating differentiable functions.\n")
SLANG_RAW("interface IDifferentiableFunc<TR : IDifferentiable, each TP : IDifferentiable> : IFunc<TR, expand each TP>, IDifferentiableMutatingFunc<TR, expand each TP>\n")
SLANG_RAW("{\n")
SLANG_RAW("    /// Defines a non-mutating function that takes multiple differentiable parameters and returns a differentiable result of type `TR`.\n")
SLANG_RAW("    /// This function supports automatic differentiation.\n")
SLANG_RAW("    [Differentiable]\n")
SLANG_RAW("    TR operator()(expand each TP p);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("//@hidden:\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("__magic_type(NativeRefType)\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_NativePtrType
)
SLANG_RAW(")\n")
SLANG_RAW("struct NativeRef\n")
SLANG_RAW("{\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_GetNativePtr
)
SLANG_RAW(")\n")
SLANG_RAW("    __init(T val);\n")
SLANG_RAW("};\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_ManagedPtrAttach
)
SLANG_RAW(")\n")
SLANG_RAW("void __managed_ptr_attach(__ref T val, NativeRef<T> nativeVal);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("T __attachToNativeRef(NativeRef<T> nativeVal)\n")
SLANG_RAW("{\n")
SLANG_RAW("    T result;\n")
SLANG_RAW("    __managed_ptr_attach(result, nativeVal);\n")
SLANG_RAW("    return result;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("//@public:\n")
SLANG_RAW("\n")
SLANG_RAW("/// Represents a string.\n")
SLANG_RAW("/// This type can only be used on the CPU target.\n")
SLANG_RAW("__magic_type(StringType)\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_StringType
)
SLANG_RAW(")\n")
SLANG_RAW("struct String\n")
SLANG_RAW("{\n")
SLANG_RAW("    [require(cpp)]\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_MakeString
)
SLANG_RAW(")\n")
SLANG_RAW("    __init(int val);\n")
SLANG_RAW("\n")
SLANG_RAW("    [require(cpp)]\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_MakeString
)
SLANG_RAW(")\n")
SLANG_RAW("    __init(uint val);\n")
SLANG_RAW("\n")
SLANG_RAW("    [require(cpp)]\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_MakeString
)
SLANG_RAW(")\n")
SLANG_RAW("    __init(int64_t val);\n")
SLANG_RAW("\n")
SLANG_RAW("    [require(cpp)]\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_MakeString
)
SLANG_RAW(")\n")
SLANG_RAW("    __init(uint64_t val);\n")
SLANG_RAW("\n")
SLANG_RAW("    [require(cpp)]\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_MakeString
)
SLANG_RAW(")\n")
SLANG_RAW("    __init(float val);\n")
SLANG_RAW("\n")
SLANG_RAW("    [require(cpp)]\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_MakeString
)
SLANG_RAW(")\n")
SLANG_RAW("    __init(double val);\n")
SLANG_RAW("\n")
SLANG_RAW("    [require(cpp)]\n")
SLANG_RAW("    __implicit_conversion(")
SLANG_SPLICE(kConversionCost_None
)
SLANG_RAW(")\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_MakeString
)
SLANG_RAW(")\n")
SLANG_RAW("    __init(NativeString value);\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Returns the length of the string.\n")
SLANG_RAW("    [require(cpp)]\n")
SLANG_RAW("    int64_t getLength();\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Returns the length of the string.\n")
SLANG_RAW("    property int length\n")
SLANG_RAW("    {\n")
SLANG_RAW("        get { return (int)getLength(); }\n")
SLANG_RAW("    }\n")
SLANG_RAW("};\n")
SLANG_RAW("\n")
SLANG_RAW("/// @category misc_types\n")
SLANG_RAW("typedef String string;\n")
SLANG_RAW("\n")
SLANG_RAW("/// @category misc_types\n")
SLANG_RAW("__magic_type(NativeStringType)\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_NativeStringType
)
SLANG_RAW(")\n")
SLANG_RAW("struct NativeString\n")
SLANG_RAW("{\n")
SLANG_RAW("    [require(cpp)]\n")
SLANG_RAW("    int getLength()\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case cpp: __intrinsic_asm \"int(strlen($0))\";\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [require(cpp)]\n")
SLANG_RAW("    Ptr<void> getBuffer()\n")
SLANG_RAW("    {\n")
SLANG_RAW("        __target_switch\n")
SLANG_RAW("        {\n")
SLANG_RAW("        case cpp: __intrinsic_asm \"(void*)((const char*)($0))\";\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    property int length { [__unsafeForceInlineEarly] get{return getLength();} }\n")
SLANG_RAW("\n")
SLANG_RAW("    __implicit_conversion(")
SLANG_SPLICE(kConversionCost_None
)
SLANG_RAW(")\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_getNativeStr
)
SLANG_RAW(")\n")
SLANG_RAW("    __init(String value);\n")
SLANG_RAW("\n")
SLANG_RAW("    __init() { this = NativeString(\"\"); }\n")
SLANG_RAW("};\n")
SLANG_RAW("\n")
SLANG_RAW("extension Ptr<void>\n")
SLANG_RAW("{\n")
SLANG_RAW("    __implicit_conversion(")
SLANG_SPLICE(kConversionCost_PtrToVoidPtr
)
SLANG_RAW(")\n")
SLANG_RAW("    [__unsafeForceInlineEarly]\n")
SLANG_RAW("    __init(NativeString nativeStr) { this = nativeStr.getBuffer(); }\n")
SLANG_RAW("\n")
SLANG_RAW("    __generic<T, let addrSpace : uint64_t>\n")
SLANG_RAW("    __intrinsic_op(0)\n")
SLANG_RAW("    __implicit_conversion(")
SLANG_SPLICE(kConversionCost_PtrToVoidPtr
)
SLANG_RAW(")\n")
SLANG_RAW("    __init(Ptr<T, addrSpace> ptr);\n")
SLANG_RAW("\n")
SLANG_RAW("    __generic<T>\n")
SLANG_RAW("    __intrinsic_op(0)\n")
SLANG_RAW("    __implicit_conversion(")
SLANG_SPLICE(kConversionCost_PtrToVoidPtr
)
SLANG_RAW(")\n")
SLANG_RAW("    __init(NativeRef<T> ptr);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("//@hidden:\n")
SLANG_RAW("__magic_type(DynamicType)\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_DynamicType
)
SLANG_RAW(")\n")
SLANG_RAW("struct __Dynamic\n")
SLANG_RAW("{};\n")
SLANG_RAW("\n")
SLANG_RAW("//@public:\n")
SLANG_RAW("\n")
SLANG_RAW("extension half : IRangedValue\n")
SLANG_RAW("{\n")
SLANG_RAW("    static const half maxValue = half(65504);\n")
SLANG_RAW("    static const half minValue = half(-65504);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("extension float : IRangedValue\n")
SLANG_RAW("{\n")
SLANG_RAW("    static const float maxValue = 340282346638528859811704183484516925440.0f;\n")
SLANG_RAW("    static const float minValue = -340282346638528859811704183484516925440.0f;\n")
SLANG_RAW("\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("extension double : IRangedValue\n")
SLANG_RAW("{\n")
SLANG_RAW("    static const double maxValue = bit_cast<double>(0x7fefffffffffffffULL);\n")
SLANG_RAW("    static const double minValue = bit_cast<double>(0xffefffffffffffffULL);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("extension int : IRangedValue\n")
SLANG_RAW("{\n")
SLANG_RAW("    static const int maxValue = 2147483647;\n")
SLANG_RAW("    static const int minValue = -2147483648;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("extension uint : IRangedValue\n")
SLANG_RAW("{\n")
SLANG_RAW("    static const uint maxValue = 4294967295;\n")
SLANG_RAW("    static const uint minValue = 0;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("extension int8_t : IRangedValue\n")
SLANG_RAW("{\n")
SLANG_RAW("    static const int8_t maxValue = 127;\n")
SLANG_RAW("    static const int8_t minValue = -128;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("extension uint8_t : IRangedValue\n")
SLANG_RAW("{\n")
SLANG_RAW("    static const uint8_t maxValue = 255;\n")
SLANG_RAW("    static const uint8_t minValue = 0;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("extension uint16_t : IRangedValue\n")
SLANG_RAW("{\n")
SLANG_RAW("    static const uint16_t maxValue = 65535;\n")
SLANG_RAW("    static const uint16_t minValue = 0;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("extension int16_t : IRangedValue\n")
SLANG_RAW("{\n")
SLANG_RAW("    static const int16_t maxValue = 32767;\n")
SLANG_RAW("    static const int16_t minValue = -32768;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T, let N:int>\n")
SLANG_RAW("__magic_type(ArrayExpressionType)\n")
SLANG_RAW("struct Array : IRWArray<T>\n")
SLANG_RAW("{\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_GetArrayLength
)
SLANG_RAW(")\n")
SLANG_RAW("    int getCount();\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("/// @category math_types Math types\n")
SLANG_RAW("/// An `N` component vector with elements of type `T`.\n")
SLANG_RAW("__generic<T = float, let N : int = 4>\n")
SLANG_RAW("__magic_type(VectorExpressionType)\n")
SLANG_RAW("struct vector : IRWArray<T>\n")
SLANG_RAW("{\n")
SLANG_RAW("        /// The element type of the vector\n")
SLANG_RAW("    typedef T Element;\n")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("        /// Initialize a vector where all elements have the same scalar `value`.\n")
SLANG_RAW("    [TreatAsDifferentiable]\n")
SLANG_RAW("    __implicit_conversion(")
SLANG_SPLICE(kConversionCost_ScalarToVector
)
SLANG_RAW(")\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_MakeVectorFromScalar
)
SLANG_RAW(")\n")
SLANG_RAW("    __init(T value);\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Initialize a vector from a value of the same type\n")
SLANG_RAW("    // TODO: we should revise semantic checking so this kind of \"identity\" conversion is not required\n")
SLANG_RAW("    __intrinsic_op(0)\n")
SLANG_RAW("    [TreatAsDifferentiable]\n")
SLANG_RAW("    __init(vector<T,N> value);\n")
SLANG_RAW("\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    int getCount() { return N; }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("//@hidden:\n")
SLANG_RAW("static const int kRowMajorMatrixLayout = ")
SLANG_SPLICE(SLANG_MATRIX_LAYOUT_ROW_MAJOR
)
SLANG_RAW(";\n")
SLANG_RAW("static const int kColumnMajorMatrixLayout = ")
SLANG_SPLICE(SLANG_MATRIX_LAYOUT_COLUMN_MAJOR
)
SLANG_RAW(";\n")
SLANG_RAW("\n")
SLANG_RAW("//@public:\n")
SLANG_RAW("/// A matrix with `R` rows and `C` columns, with elements of type `T`.\n")
SLANG_RAW("/// @category math_types Math types\n")
SLANG_RAW("__generic<T = float, let R : int = 4, let C : int = 4, let L : int = ")
SLANG_SPLICE(SLANG_MATRIX_LAYOUT_MODE_UNKNOWN
)
SLANG_RAW(">\n")
SLANG_RAW("__magic_type(MatrixExpressionType)\n")
SLANG_RAW("struct matrix : IRWArray<vector<T,C>>\n")
SLANG_RAW("{\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_MakeMatrixFromScalar
)
SLANG_RAW(")\n")
SLANG_RAW("    __implicit_conversion(")
SLANG_SPLICE(kConversionCost_ScalarToMatrix
)
SLANG_RAW(")\n")
SLANG_RAW("    [TreatAsDifferentiable]\n")
SLANG_RAW("    __init(T val);\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Initialize a vector from a value of the same type\n")
SLANG_RAW("    // TODO: we should revise semantic checking so this kind of \"identity\" conversion is not required\n")
SLANG_RAW("    __intrinsic_op(0)\n")
SLANG_RAW("    [TreatAsDifferentiable]\n")
SLANG_RAW("    __init(This value);\n")
SLANG_RAW("\n")
SLANG_RAW("    [ForceInline]\n")
SLANG_RAW("    int getCount() { return R; }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("//@hidden:\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_Eql
)
SLANG_RAW(")\n")
SLANG_RAW("vector<bool, N> __vectorEql<T, let N : int>(vector<T, N> left, vector<T, N> right);\n")
SLANG_RAW("\n")
SLANG_RAW("//@public:\n")
SLANG_RAW("__generic<T:__BuiltinIntegerType, let N : int>\n")
SLANG_RAW("extension vector<T,N> : IInteger\n")
SLANG_RAW("{\n")
SLANG_RAW("    [__unsafeForceInlineEarly] bool lessThan(This other) { return this[0] < other[0]; }\n")
SLANG_RAW("    [__unsafeForceInlineEarly] bool lessThanOrEquals(This other) { return this[0] <= other[0]; }\n")
SLANG_RAW("    [__unsafeForceInlineEarly] bool equals(This other) { return all(__vectorEql(this, other)); }\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_Add
)
SLANG_RAW(") This add(This other);\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_Sub
)
SLANG_RAW(") This sub(This other);\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_Mul
)
SLANG_RAW(") This mul(This other);\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_Div
)
SLANG_RAW(") This div(This other);\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_FRem
)
SLANG_RAW(") This mod(This other);\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_Neg
)
SLANG_RAW(") This neg();\n")
SLANG_RAW("\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_Lsh
)
SLANG_RAW(")\n")
SLANG_RAW("    This shl(int value);\n")
SLANG_RAW("\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_Rsh
)
SLANG_RAW(")\n")
SLANG_RAW("    This shr(int value);\n")
SLANG_RAW("\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_BitAnd
)
SLANG_RAW(")\n")
SLANG_RAW("    This bitAnd(This other);\n")
SLANG_RAW("\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_BitOr
)
SLANG_RAW(")\n")
SLANG_RAW("    This bitOr(This other);\n")
SLANG_RAW("\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_BitXor
)
SLANG_RAW(")\n")
SLANG_RAW("    This bitXor(This other);\n")
SLANG_RAW("\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_BitNot
)
SLANG_RAW(")\n")
SLANG_RAW("    This bitNot();\n")
SLANG_RAW("\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_And
)
SLANG_RAW(")\n")
SLANG_RAW("    This and(This other);\n")
SLANG_RAW("\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_Or
)
SLANG_RAW(")\n")
SLANG_RAW("    This or(This other);\n")
SLANG_RAW("\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_Not
)
SLANG_RAW(")\n")
SLANG_RAW("    This not();\n")
SLANG_RAW("\n")
SLANG_RAW("    [__unsafeForceInlineEarly] int toInt() { return __intCast<int>(this[0]); }\n")
SLANG_RAW("    [__unsafeForceInlineEarly] int64_t toInt64() { return __intCast<int64_t>(this[0]); }\n")
SLANG_RAW("    [__unsafeForceInlineEarly] uint toUInt() { return __intCast<uint>(this[0]); }\n")
SLANG_RAW("    [__unsafeForceInlineEarly] uint64_t toUInt64() { return __intCast<uint64_t>(this[0]); }\n")
SLANG_RAW("    [OverloadRank(-1)]\n")
SLANG_RAW("    [__unsafeForceInlineEarly] __init(int v) { this = vector<T,N>(T(v)); }\n")
SLANG_RAW("    [OverloadRank(-1)]\n")
SLANG_RAW("    [__unsafeForceInlineEarly] __init(int64_t v) { this = vector<T,N>(T(v)); }\n")
SLANG_RAW("\n")
SLANG_RAW("    [OverloadRank(-1)]\n")
SLANG_RAW("    __implicit_conversion(")
SLANG_SPLICE(kConversionCost_Default
)
SLANG_RAW(")\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_CastFloatToInt
)
SLANG_RAW(")\n")
SLANG_RAW("    __generic<U:__BuiltinFloatingPointType>\n")
SLANG_RAW("    __init(vector<U, N> other);\n")
SLANG_RAW("\n")
SLANG_RAW("    [OverloadRank(-1)]\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_IntCast
)
SLANG_RAW(")\n")
SLANG_RAW("    __generic<U:__BuiltinIntegerType>\n")
SLANG_RAW("    __init(vector<U, N> other);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinFloatingPointType, let N : int>\n")
SLANG_RAW("extension vector<T,N> : IFloat\n")
SLANG_RAW("{\n")
SLANG_RAW("    [__unsafeForceInlineEarly] bool lessThan(This other) { return this[0] < other[0]; }\n")
SLANG_RAW("    [__unsafeForceInlineEarly] bool lessThanOrEquals(This other) { return this[0] <= other[0]; }\n")
SLANG_RAW("    [__unsafeForceInlineEarly] bool equals(This other) { return all(__vectorEql(this, other)); }\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_Add
)
SLANG_RAW(") This add(This other);\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_Sub
)
SLANG_RAW(") This sub(This other);\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_Mul
)
SLANG_RAW(") This mul(This other);\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_Div
)
SLANG_RAW(") This div(This other);\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_FRem
)
SLANG_RAW(") This mod(This other);\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_Neg
)
SLANG_RAW(") This neg();\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_Mul
)
SLANG_RAW(") This scale<T1:__BuiltinFloatingPointType>(T1 s);\n")
SLANG_RAW("    [__unsafeForceInlineEarly] float toFloat() { return __realCast<float>(this[0]); }\n")
SLANG_RAW("\n")
SLANG_RAW("    [OverloadRank(-1)]\n")
SLANG_RAW("    __implicit_conversion(")
SLANG_SPLICE(kConversionCost_Default
)
SLANG_RAW(")\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_FloatCast
)
SLANG_RAW(")\n")
SLANG_RAW("    __generic<U:__BuiltinFloatingPointType>\n")
SLANG_RAW("    __init(vector<U, N> other);\n")
SLANG_RAW("\n")
SLANG_RAW("    [OverloadRank(-1)]\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_CastIntToFloat
)
SLANG_RAW(")\n")
SLANG_RAW("    __generic<U:__BuiltinIntegerType>\n")
SLANG_RAW("    __init(vector<U, N> other);\n")
SLANG_RAW("\n")
SLANG_RAW("    [OverloadRank(-1)]\n")
SLANG_RAW("    [__unsafeForceInlineEarly] __init(int v) { this = vector<T,N>(T(v)); }\n")
SLANG_RAW("    [OverloadRank(-1)]\n")
SLANG_RAW("    [__unsafeForceInlineEarly] __init(float v) { this = vector<T,N>(T(v)); }\n")
SLANG_RAW("\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_Add
)
SLANG_RAW(")\n")
SLANG_RAW("T __internal_add<T>(T a, T b);\n")
SLANG_RAW("\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_Mul
)
SLANG_RAW(")\n")
SLANG_RAW("T __internal_mul<T, U>(U a, T b);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:IDifferentiable, let N : int>\n")
SLANG_RAW("extension vector<T,N> : IDifferentiable\n")
SLANG_RAW("{\n")
SLANG_RAW("    // IDifferentiable\n")
SLANG_RAW("    typedef vector<T, N> Differential;\n")
SLANG_RAW("\n")
SLANG_RAW("    [__unsafeForceInlineEarly]\n")
SLANG_RAW("    [BackwardDifferentiable]\n")
SLANG_RAW("    static Differential dzero()\n")
SLANG_RAW("    {\n")
SLANG_RAW("        return Differential(__slang_noop_cast<T>(T.dzero()));\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__unsafeForceInlineEarly]\n")
SLANG_RAW("    [BackwardDifferentiable]\n")
SLANG_RAW("    static Differential dadd(Differential a, Differential b)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        return __internal_add(a, b);\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    __generic<U : __BuiltinRealType>\n")
SLANG_RAW("    [__unsafeForceInlineEarly]\n")
SLANG_RAW("    [BackwardDifferentiable]\n")
SLANG_RAW("    static Differential dmul(U a, Differential b)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        return __internal_mul(__realCast<float>(a), b);\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:__BuiltinFloatingPointType, let N : int, let M : int, let L : int>\n")
SLANG_RAW("extension matrix<T,N,M,L> : IFloat\n")
SLANG_RAW("{\n")
SLANG_RAW("    [TreatAsDifferentiable][__unsafeForceInlineEarly] bool lessThan(This other) { return this < other; }\n")
SLANG_RAW("    [TreatAsDifferentiable][__unsafeForceInlineEarly] bool lessThanOrEquals(This other) { return this <= other; }\n")
SLANG_RAW("    [TreatAsDifferentiable][__unsafeForceInlineEarly] bool equals(This other) { return all(this == other); }\n")
SLANG_RAW("    [TreatAsDifferentiable] __intrinsic_op(")
SLANG_SPLICE(kIROp_Add
)
SLANG_RAW(") This add(This other);\n")
SLANG_RAW("    [TreatAsDifferentiable] __intrinsic_op(")
SLANG_SPLICE(kIROp_Sub
)
SLANG_RAW(") This sub(This other);\n")
SLANG_RAW("    [TreatAsDifferentiable] __intrinsic_op(")
SLANG_SPLICE(kIROp_Mul
)
SLANG_RAW(")This mul(This other);\n")
SLANG_RAW("    [TreatAsDifferentiable] __intrinsic_op(")
SLANG_SPLICE(kIROp_Div
)
SLANG_RAW(") This div(This other);\n")
SLANG_RAW("    [TreatAsDifferentiable] __intrinsic_op(")
SLANG_SPLICE(kIROp_FRem
)
SLANG_RAW(") This mod(This other);\n")
SLANG_RAW("    [TreatAsDifferentiable] __intrinsic_op(")
SLANG_SPLICE(kIROp_Neg
)
SLANG_RAW(") This neg();\n")
SLANG_RAW("    [TreatAsDifferentiable] __intrinsic_op(")
SLANG_SPLICE(kIROp_Mul
)
SLANG_RAW(") This scale<T1:__BuiltinFloatingPointType>(T1 s);\n")
SLANG_RAW("    [TreatAsDifferentiable][__unsafeForceInlineEarly] This scale<T1:__BuiltinFloatingPointType>(T1 s);\n")
SLANG_RAW("    [TreatAsDifferentiable][__unsafeForceInlineEarly] float toFloat() { return __realCast<float>(this[0][0]); }\n")
SLANG_RAW("\n")
SLANG_RAW("    [OverloadRank(-1)]\n")
SLANG_RAW("    [TreatAsDifferentiable]\n")
SLANG_RAW("    [__unsafeForceInlineEarly]\n")
SLANG_RAW("    __implicit_conversion(")
SLANG_SPLICE(kConversionCost_ScalarIntegerToFloatMatrix
)
SLANG_RAW(")\n")
SLANG_RAW("    __init(int v) { this = matrix<T,N,M>(T(v)); }\n")
SLANG_RAW("\n")
SLANG_RAW("    [OverloadRank(-1)]\n")
SLANG_RAW("    [TreatAsDifferentiable]\n")
SLANG_RAW("    [__unsafeForceInlineEarly]\n")
SLANG_RAW("    __implicit_conversion(")
SLANG_SPLICE(kConversionCost_ScalarToMatrix
)
SLANG_RAW(")\n")
SLANG_RAW("    __init(float v) { this = matrix<T,N,M>(T(v)); }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T:IDifferentiable, let N : int, let M : int, let L : int>\n")
SLANG_RAW("extension matrix<T,N,M,L> : IDifferentiable\n")
SLANG_RAW("{\n")
SLANG_RAW("    // IDifferentiable.\n")
SLANG_RAW("    typedef matrix<T, N,M,L> Differential;\n")
SLANG_RAW("\n")
SLANG_RAW("    [__unsafeForceInlineEarly]\n")
SLANG_RAW("    [BackwardDifferentiable]\n")
SLANG_RAW("    static Differential dzero()\n")
SLANG_RAW("    {\n")
SLANG_RAW("        return matrix<T, N,M,L>(__slang_noop_cast<T>(T.dzero()));\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    [__unsafeForceInlineEarly]\n")
SLANG_RAW("    [BackwardDifferentiable]\n")
SLANG_RAW("    static Differential dadd(Differential a, Differential b)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        return __internal_add(a, b);\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    __generic<U : __BuiltinRealType>\n")
SLANG_RAW("    [__unsafeForceInlineEarly]\n")
SLANG_RAW("    [BackwardDifferentiable]\n")
SLANG_RAW("    static Differential dmul(U a, Differential b)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        return __internal_mul(__realCast<float>(a), b);\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<let R : int, let C : int, let L : int>\n")
SLANG_RAW("extension matrix<int16_t,R,C,L>\n")
SLANG_RAW("{\n")
SLANG_RAW("    typealias T = int16_t;\n")
SLANG_RAW("    __implicit_conversion(")
SLANG_SPLICE(kConversionCost_IntegerTruncate
)
SLANG_RAW(")\n")
SLANG_RAW("    __init(int value) { this = matrix<T,R,C,L>(T(value)); }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("//@hidden:\n")
SLANG_RAW("__intrinsic_op(makeVector)\n")
SLANG_RAW("__generic<T, let N:int>\n")
SLANG_RAW("vector<T,N*2> __makeVector(vector<T,N> vec1, vector<T,N> vec2);\n")
SLANG_RAW("\n")
SLANG_RAW("//@public:\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("extension vector<T, 4>\n")
SLANG_RAW("{\n")
SLANG_RAW("    __generic<let L : int>\n")
SLANG_RAW("    [__unsafeForceInlineEarly]\n")
SLANG_RAW("    __init(matrix<T, 2, 2, L> value)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        this = __makeVector(value[0], value[1]);\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T, let L : int>\n")
SLANG_RAW("extension matrix<T, 2, 2, L>\n")
SLANG_RAW("{\n")
SLANG_RAW("    [__unsafeForceInlineEarly]\n")
SLANG_RAW("    __init(vector<T, 4> value)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        this[0] = value.xy;\n")
SLANG_RAW("        this[1] = value.zw;\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("//@hidden:\n")

static const struct {
    char const* name;
    char const* glslPrefix;
} kTypes[] =
{
    {"half",        "f16"},
    {"float",       ""},
    {"double",      "d"},

    {"float16_t",   "f16"},
    {"float32_t",   "f32"},
    {"float64_t",   "f64"},

    {"int8_t",      "i8"},
    {"int16_t",     "i16"},
    {"int32_t",     "i32"},
    {"int",         "i"},
    {"int64_t",     "i64"},

    {"uint8_t",     "u8"},
    {"uint16_t",    "u16"},
    {"uint32_t",    "u32"},
    {"uint",        "u"},
    {"uint64_t",    "u64"},

    {"bool",        "b"},
};

static const int kTypeCount = sizeof(kTypes) / sizeof(kTypes[0]);

for (int tt = 0; tt < kTypeCount; ++tt)
{
    // Declare HLSL vector types
    for (int ii = 1; ii <= 4; ++ii)
    {
        sb << "typedef vector<" << kTypes[tt].name << "," << ii << "> " << kTypes[tt].name << ii << ";\n";
    }

    // Declare HLSL matrix types
    for (int rr = 1; rr <= 4; ++rr)
    for (int cc = 1; cc <= 4; ++cc)
    {
        sb << "typedef matrix<" << kTypes[tt].name << "," << rr << "," << cc << "> " << kTypes[tt].name << rr << "x" << cc << ";\n";
    }
}

sb << "\n\n";
sb << "// Cast from vector<T,1> to T, which is a scalar type\n";

for (int tt = 0; tt < kBaseTypeCount; ++tt)
{
    if(kBaseTypes[tt].tag == BaseType::Void) continue;

    const char* tname = kBaseTypes[tt].name;

    sb << "extension " << tname << "\n";
    sb << "{\n";
    sb << "    __implicit_conversion(" << kConversionCost_OneVectorToScalar << ")\n";
    sb << "    __init(vector<" << tname << ",1> v) { this = v[0]; }\n";
    sb << "}\n";
}

// Declare additional built-in generic types
SLANG_RAW("#line 2190 \"core.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("//@ public:\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T, L:IBufferDataLayout = DefaultDataLayout>\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_ConstantBufferType
)
SLANG_RAW(")\n")
SLANG_RAW("__magic_type(ConstantBufferType)\n")
SLANG_RAW("struct ConstantBuffer {}\n")
SLANG_RAW("\n")
SLANG_RAW("///@category texture_types\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_TextureBufferType
)
SLANG_RAW(")\n")
SLANG_RAW("__magic_type(TextureBufferType)\n")
SLANG_RAW("struct TextureBuffer {}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_ParameterBlockType
)
SLANG_RAW(")\n")
SLANG_RAW("__magic_type(ParameterBlockType)\n")
SLANG_RAW("struct ParameterBlock {}\n")
SLANG_RAW("\n")
SLANG_RAW("/// @category stage_io\n")
SLANG_RAW("__generic<T, let MAX_VERTS : uint>\n")
SLANG_RAW("__magic_type(VerticesType)\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_VerticesType
)
SLANG_RAW(")\n")
SLANG_RAW("[__NonCopyableType]\n")
SLANG_RAW("struct OutputVertices\n")
SLANG_RAW("{\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_MetalSetVertex
)
SLANG_RAW(")\n")
SLANG_RAW("    static void _metalSetVertex(uint index, T val);\n")
SLANG_RAW("\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_MeshOutputSet
)
SLANG_RAW(")\n")
SLANG_RAW("    static void _setVertex(This v, uint index, T val);\n")
SLANG_RAW("\n")
SLANG_RAW("    __subscript(uint index) -> T\n")
SLANG_RAW("    {\n")
SLANG_RAW("        // TODO: Make sure this remains write only, we can't do this with just\n")
SLANG_RAW("        // a 'set' operation as it's legal to only write to part of the output\n")
SLANG_RAW("        // buffer, or part of the output buffer at a time.\n")
SLANG_RAW("\n")
SLANG_RAW("        [mutating]\n")
SLANG_RAW("        [require(glsl_hlsl_metal_spirv, meshshading)]\n")
SLANG_RAW("        set\n")
SLANG_RAW("        {\n")
SLANG_RAW("            __target_switch\n")
SLANG_RAW("            {\n")
SLANG_RAW("            case metal: _metalSetVertex(index, newValue);\n")
SLANG_RAW("            case glsl: _setVertex(this, index, newValue);\n")
SLANG_RAW("            case hlsl: _setVertex(this, index, newValue);\n")
SLANG_RAW("            case spirv: _setVertex(this, index, newValue);\n")
SLANG_RAW("            }\n")
SLANG_RAW("        }\n")
SLANG_RAW("        \n")
SLANG_RAW("        //\n")
SLANG_RAW("        // If a 'OutputVertices[index]' is referred to by a '__ref', call 'kIROp_MeshOutputRef(index)'\n")
SLANG_RAW("        [require(glsl_hlsl_spirv, meshshading)]\n")
SLANG_RAW("        __intrinsic_op(")
SLANG_SPLICE(kIROp_MeshOutputRef
)
SLANG_RAW(")\n")
SLANG_RAW("        ref;\n")
SLANG_RAW("    }\n")
SLANG_RAW("};\n")
SLANG_RAW("\n")
SLANG_RAW("/// @category stage_io\n")
SLANG_RAW("__generic<T, let MAX_PRIMITIVES : uint>\n")
SLANG_RAW("__magic_type(IndicesType)\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_IndicesType
)
SLANG_RAW(")\n")
SLANG_RAW("[__NonCopyableType]\n")
SLANG_RAW("struct OutputIndices\n")
SLANG_RAW("{\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_MetalSetIndices
)
SLANG_RAW(")\n")
SLANG_RAW("    static void __metalSetIndices(uint index, T val);\n")
SLANG_RAW("\n")
SLANG_RAW("    // for some reason only here in the indices array it uses the return value as an actual\n")
SLANG_RAW("    // operand, while the others use the value of the instruction (the return value) to access\n")
SLANG_RAW("    // the type of the vertex, as when using the ref there is no third operand\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_MeshOutputSet
)
SLANG_RAW(")\n")
SLANG_RAW("    static void __setIndices(This v, uint index, T val);\n")
SLANG_RAW("\n")
SLANG_RAW("    __subscript(uint index) -> T\n")
SLANG_RAW("    {\n")
SLANG_RAW("        [mutating]\n")
SLANG_RAW("        [require(glsl_hlsl_metal_spirv, meshshading)]\n")
SLANG_RAW("        set\n")
SLANG_RAW("        {\n")
SLANG_RAW("            __target_switch\n")
SLANG_RAW("            {\n")
SLANG_RAW("            case metal: __metalSetIndices(index, newValue);\n")
SLANG_RAW("            case glsl: __setIndices(this, index, newValue);\n")
SLANG_RAW("            case hlsl: __setIndices(this, index, newValue);\n")
SLANG_RAW("            case spirv: __setIndices(this, index, newValue);\n")
SLANG_RAW("            }\n")
SLANG_RAW("        }\n")
SLANG_RAW("    }\n")
SLANG_RAW("};\n")
SLANG_RAW("\n")
SLANG_RAW("/// @category stage_io\n")
SLANG_RAW("__generic<T, let MAX_PRIMITIVES : uint>\n")
SLANG_RAW("__magic_type(PrimitivesType)\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_PrimitivesType
)
SLANG_RAW(")\n")
SLANG_RAW("[__NonCopyableType]\n")
SLANG_RAW("struct OutputPrimitives\n")
SLANG_RAW("{\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_MetalSetPrimitive
)
SLANG_RAW(")\n")
SLANG_RAW("    static void __metalSetPrimitive(uint index, T val);\n")
SLANG_RAW("\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_MeshOutputSet
)
SLANG_RAW(")\n")
SLANG_RAW("    static void __setPrimitive(This v, uint index, T val);\n")
SLANG_RAW("\n")
SLANG_RAW("    __subscript(uint index)->T\n")
SLANG_RAW("    {\n")
SLANG_RAW("        [mutating]\n")
SLANG_RAW("        [require(glsl_hlsl_metal_spirv, meshshading)]\n")
SLANG_RAW("        set\n")
SLANG_RAW("        {\n")
SLANG_RAW("            __target_switch\n")
SLANG_RAW("            {\n")
SLANG_RAW("            case metal: __metalSetPrimitive(index, newValue);\n")
SLANG_RAW("            case glsl: __setPrimitive(this, index, newValue);\n")
SLANG_RAW("            case hlsl: __setPrimitive(this, index, newValue);\n")
SLANG_RAW("            case spirv: __setPrimitive(this, index, newValue);\n")
SLANG_RAW("            }\n")
SLANG_RAW("        }\n")
SLANG_RAW("\n")
SLANG_RAW("        // If a 'OutputPrimitives[index]' is referred to by a '__ref', call 'kIROp_MeshOutputRef(index)'\n")
SLANG_RAW("        [require(glsl_hlsl_spirv, meshshading)]\n")
SLANG_RAW("        __intrinsic_op(")
SLANG_SPLICE(kIROp_MeshOutputRef
)
SLANG_RAW(")\n")
SLANG_RAW("        ref;\n")
SLANG_RAW("    }\n")
SLANG_RAW("};\n")
SLANG_RAW("\n")
SLANG_RAW("//@ public:\n")
SLANG_RAW("\n")
SLANG_RAW("// Need to add constructors to the types above\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T> __extension vector<T, 2>\n")
SLANG_RAW("{\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_MakeVector
)
SLANG_RAW(")\n")
SLANG_RAW("    __init(T x, T y);\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T> __extension vector<T, 3>\n")
SLANG_RAW("{\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_MakeVector
)
SLANG_RAW(")\n")
SLANG_RAW("    __init(T x, T y, T z);\n")
SLANG_RAW("\n")
SLANG_RAW("    [__unsafeForceInlineEarly]\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_MakeVector
)
SLANG_RAW(")\n")
SLANG_RAW("    __init(vector<T,2> xy, T z);\n")
SLANG_RAW("\n")
SLANG_RAW("    [__unsafeForceInlineEarly]\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_MakeVector
)
SLANG_RAW(")\n")
SLANG_RAW("    __init(T x, vector<T,2> yz);\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T> __extension vector<T, 4>\n")
SLANG_RAW("{\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_MakeVector
)
SLANG_RAW(")\n")
SLANG_RAW("    __init(T x, T y, T z, T w);\n")
SLANG_RAW("\n")
SLANG_RAW("    [__unsafeForceInlineEarly]\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_MakeVector
)
SLANG_RAW(")\n")
SLANG_RAW("    __init(vector<T,2> xy, T z, T w);\n")
SLANG_RAW("\n")
SLANG_RAW("    [__unsafeForceInlineEarly]\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_MakeVector
)
SLANG_RAW(")\n")
SLANG_RAW("    __init(T x, vector<T,2> yz, T w);\n")
SLANG_RAW("\n")
SLANG_RAW("    [__unsafeForceInlineEarly]\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_MakeVector
)
SLANG_RAW(")\n")
SLANG_RAW("    __init(T x, T y, vector<T,2> zw);\n")
SLANG_RAW("\n")
SLANG_RAW("    [__unsafeForceInlineEarly]\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_MakeVector
)
SLANG_RAW(")\n")
SLANG_RAW("    __init(vector<T,2> xy, vector<T,2> zw);\n")
SLANG_RAW("\n")
SLANG_RAW("    [__unsafeForceInlineEarly]\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_MakeVector
)
SLANG_RAW(")\n")
SLANG_RAW("    __init(vector<T,3> xyz, T w);\n")
SLANG_RAW("\n")
SLANG_RAW("    [__unsafeForceInlineEarly]\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_MakeVector
)
SLANG_RAW(")\n")
SLANG_RAW("    __init(T x, vector<T,3> yzw);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")



for( int R = 1; R <= 4; ++R )
for( int C = 1; C <= 4; ++C )
{
    sb << "__generic<T, let L:int> __extension matrix<T, " << R << "," << C << ", L>\n{\n";

    // initialize from R*C scalars
    if (R == 1 || C == 1)
        sb << "[require(hlsl)]\n";
    sb << "__intrinsic_op(" << int(kIROp_MakeMatrix) << ") __init(";
    for( int ii = 0; ii < R; ++ii )
    for( int jj = 0; jj < C; ++jj )
    {
        if ((ii+jj) != 0) sb << ", ";
        sb << "T m" << ii << jj;
    }
    sb << ");\n";

    // Initialize from R C-vectors
    if (R == 1 || C == 1)
        sb << "[require(hlsl)]\n";
    sb << "__intrinsic_op(" << int(kIROp_MakeMatrix) << ") __init(";
    for (int ii = 0; ii < R; ++ii)
    {
        if(ii != 0) sb << ", ";
        sb << "vector<T," << C << "> row" << ii;
    }
    sb << ");\n";

    // initialize from a matrix of larger size
    for(int rr = R; rr <= 4; ++rr)
    for( int cc = C; cc <= 4; ++cc )
    {
        if(rr == R && cc == C) continue;
        if (R == 1 || C == 1)
            sb << "[require(hlsl)]\n";
        sb << "__intrinsic_op(" << int(kIROp_MatrixReshape) << ") __init(matrix<T," << rr << "," << cc << ", L> value);\n";
    }

    // Initialize from matrix and vector
    if (R > 2)
    {
        sb << "__init(matrix<T," << (R - 1) << "," << C << "> m, vector<T," << C << "> row" << (R - 1) << ") ";
        sb << "{ this = This(";
        for (int ii = 0; ii < R - 1; ++ii)
        {
            sb << "m[" << ii << "], ";
        }
        sb << "row" << (R - 1) << "); }\n";
    }

    sb << "}\n";
}

SLANG_RAW("#line 2426 \"core.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("//@hidden:\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_BuiltinCast
)
SLANG_RAW(")\n")
SLANG_RAW("internal T __builtin_cast<T, U>(U u);\n")
SLANG_RAW("\n")
SLANG_RAW("// If T is implicitly convertible to U, then vector<T,N> is implicitly convertible to vector<U,N>.\n")
SLANG_RAW("__generic<ToType, let N : int> extension vector<ToType,N>\n")
SLANG_RAW("{\n")
SLANG_RAW("    __implicit_conversion(constraint)\n")
SLANG_RAW("    __intrinsic_op(BuiltinCast)\n")
SLANG_RAW("    __init<FromType>(vector<FromType,N> value) where ToType(FromType) implicit;\n")
SLANG_RAW("\n")
SLANG_RAW("    __implicit_conversion(constraint+)\n")
SLANG_RAW("    [__unsafeForceInlineEarly]\n")
SLANG_RAW("    [__readNone]\n")
SLANG_RAW("    [TreatAsDifferentiable]\n")
SLANG_RAW("    __init<FromType>(FromType value) where ToType(FromType) implicit\n")
SLANG_RAW("    {\n")
SLANG_RAW("        this = __builtin_cast<vector<ToType,N>>(vector<FromType,N>(value));\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// If T is implicitly convertible to U, then matrix<T,R,C,L> is implicitly convertible to matrix<U,R,C,L>.\n")
SLANG_RAW("__generic<ToType, let R : int, let C : int, let L : int> extension matrix<ToType,R,C,L>\n")
SLANG_RAW("{\n")
SLANG_RAW("    __implicit_conversion(constraint)\n")
SLANG_RAW("    __intrinsic_op(BuiltinCast)\n")
SLANG_RAW("    __init<FromType>(matrix<FromType,R,C,L> value) where ToType(FromType) implicit;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("//@ hidden:\n")
SLANG_RAW("__generic<T, U>\n")
SLANG_RAW("__intrinsic_op(0)\n")
SLANG_RAW("T __slang_noop_cast(U u);\n")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("//@ public:\n")
SLANG_RAW("\n")
SLANG_RAW("/// Sampling state for filtered texture fetches.\n")
SLANG_RAW("/// @category sampler_types Sampler types\n")
SLANG_RAW("__magic_type(SamplerStateType, ")
SLANG_SPLICE(int(SamplerStateFlavor::SamplerState)
)
SLANG_RAW(")\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_SamplerStateType
)
SLANG_RAW(")\n")
SLANG_RAW("struct SamplerState\n")
SLANG_RAW("{\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("/// Sampling state for filtered texture fetches that include a comparison operation before filtering.\n")
SLANG_RAW("/// @category sampler_types\n")
SLANG_RAW("__magic_type(SamplerStateType, ")
SLANG_SPLICE(int(SamplerStateFlavor::SamplerComparisonState)
)
SLANG_RAW(")\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_SamplerComparisonStateType
)
SLANG_RAW(")\n")
SLANG_RAW("struct SamplerComparisonState\n")
SLANG_RAW("{\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("//@ hidden:\n")
SLANG_RAW("\n")


for (auto op : intrinsicUnaryOps)
{
    for (auto type : kBaseTypes)
    {
        if ((type.flags & op.flags) == 0)
            continue;

        char const* resultType = type.name;
        if (op.flags & BOOL_RESULT) resultType = "bool";

        // scalar version
        sb << "__prefix __intrinsic_op(" << int(op.opCode) << ") " << resultType << " operator" << op.opName << "(" << type.name << " value);\n";
        sb << "__intrinsic_op(" << int(op.opCode) << ") " << resultType << " __" << op.funcName << "(" << type.name << " value);\n";

        // vector version
        sb << "__generic<let N : int> ";
        sb << "__prefix __intrinsic_op(" << int(op.opCode) << ") vector<" << resultType << ",N> operator" << op.opName << "(" << "vector<" << type.name << ",N> value);\n";

        // matrix version
        sb << "__generic<let N : int, let M : int> ";
        sb << "__prefix __intrinsic_op(" << int(op.opCode) << ") matrix<" << resultType << ",N,M> operator" << op.opName << "(" <<  "matrix<" << type.name << ",N,M> value);\n";
    }

    // Synthesize generic versions
    if(op.interface)
    {
        char const* resultType = "T";
        if (op.flags & BOOL_RESULT) resultType = "bool";
        
        // scalar version
        sb << "__generic<T : " << op.interface << ">\n";
        sb << "[OverloadRank(10)]";
        sb << "__prefix __intrinsic_op(" << int(op.opCode) << ") " << resultType << " operator" << op.opName << "(" << "T value);\n";

        // vector version
        sb << "__generic<T : " << op.interface << ", let N : int> ";
        sb << "[OverloadRank(10)]";
        sb << "__prefix __intrinsic_op(" << int(op.opCode) << ") vector<" << resultType << ",N> operator" << op.opName << "(vector<T,N> value);\n";

        // matrix version
        sb << "__generic<T : " << op.interface << ", let N : int, let M : int> ";
        sb << "[OverloadRank(10)]";
        sb << "__prefix __intrinsic_op(" << int(op.opCode) << ") matrix<" << resultType << ",N,M> operator" << op.opName << "(matrix<T,N,M> value);\n";
    }
}

SLANG_RAW("#line 2531 \"core.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T, let addrSpace : uint64_t>\n")
SLANG_RAW("__intrinsic_op(0)\n")
SLANG_RAW("[require(cpp_cuda_spirv)]\n")
SLANG_RAW("__prefix Ref<T> operator*(Ptr<T, addrSpace> value);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("__intrinsic_op(0)\n")
SLANG_RAW("[require(cpp_cuda_spirv)]\n")
SLANG_RAW("__prefix Ptr<T, ")
SLANG_SPLICE( (uint64_t)AddressSpace::UserPointer
)
SLANG_RAW("ULL> operator&(__ref T value);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("__intrinsic_op(0)\n")
SLANG_RAW("[require(cpp_cuda_spirv)]\n")
SLANG_RAW("__Addr<T> __get_addr( __ref T value);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T, let addrSpace : uint64_t>\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_GetOffsetPtr
)
SLANG_RAW(")\n")
SLANG_RAW("Ptr<T, addrSpace> operator+(Ptr<T, addrSpace> value, int64_t offset);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T, let addrSpace : uint64_t>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("Ptr<T, addrSpace> operator -(Ptr<T, addrSpace> value, int64_t offset)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return __getOffsetPtr(value, -offset);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : IArithmetic>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("__prefix T operator+(T value)\n")
SLANG_RAW("{ return value; }\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("__prefix vector<T,N> operator+(vector<T,N> value)\n")
SLANG_RAW("{ return value; }\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let R : int, let C : int>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("__prefix matrix<T,R,C> operator+(matrix<T,R,C> value)\n")
SLANG_RAW("{ return value; }\n")
SLANG_RAW("\n")


static const struct IncDecOpInfo
{
    char const* name;
    char const* binOp;
} kIncDecOps[] =
{
    { "++", "+" },
    { "--", "-" },
};
static const struct IncDecOpFixity
{
    char const* qual;
    char const* bodyPrefix;
    char const* returnVal;
} kIncDecFixities[] =
{
    { "__prefix", "", "value" },
    { "__postfix", " let result = value;", "result" },
};
for(auto op : kIncDecOps)
for(auto fixity : kIncDecFixities)
{
SLANG_RAW("#line 2598 \"core.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_SPLICE(fixity.qual
)
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("T operator")
SLANG_SPLICE(op.name
)
SLANG_RAW("( in out T value)\n")
SLANG_RAW("{ ")
SLANG_SPLICE(fixity.bodyPrefix
)
SLANG_RAW(" value = value ")
SLANG_SPLICE(op.binOp
)
SLANG_RAW(" __builtin_cast<T>(1); return ")
SLANG_SPLICE(fixity.returnVal
)
SLANG_RAW("; }\n")
SLANG_RAW("\n")
SLANG_SPLICE(fixity.qual
)
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let N : int>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("vector<T,N> operator")
SLANG_SPLICE(op.name
)
SLANG_RAW("(in out vector<T,N> value)\n")
SLANG_RAW("{")
SLANG_SPLICE(fixity.bodyPrefix
)
SLANG_RAW(" value = value ")
SLANG_SPLICE(op.binOp
)
SLANG_RAW(" __builtin_cast<T>(1); return ")
SLANG_SPLICE(fixity.returnVal
)
SLANG_RAW("; }\n")
SLANG_RAW("\n")
SLANG_SPLICE(fixity.qual
)
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __BuiltinArithmeticType, let R : int, let C : int, let L : int>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("matrix<T,R,C> operator")
SLANG_SPLICE(op.name
)
SLANG_RAW("(in out matrix<T,R,C,L> value)\n")
SLANG_RAW("{")
SLANG_SPLICE(fixity.bodyPrefix
)
SLANG_RAW(" value = value ")
SLANG_SPLICE(op.binOp
)
SLANG_RAW(" __builtin_cast<T>(1); return ")
SLANG_SPLICE(fixity.returnVal
)
SLANG_RAW("; }\n")
SLANG_RAW("\n")
SLANG_SPLICE(fixity.qual
)
SLANG_RAW("\n")
SLANG_RAW("__generic<T, let addrSpace : uint64_t>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("Ptr<T, addrSpace> operator")
SLANG_SPLICE(op.name
)
SLANG_RAW("(in out Ptr<T, addrSpace> value)\n")
SLANG_RAW("{")
SLANG_SPLICE(fixity.bodyPrefix
)
SLANG_RAW(" value = value ")
SLANG_SPLICE(op.binOp
)
SLANG_RAW(" 1; return ")
SLANG_SPLICE(fixity.returnVal
)
SLANG_RAW("; }\n")
SLANG_RAW("\n")

}

for (auto op : intrinsicBinaryOps)
{
    for (auto type : kBaseTypes)
    {
        if ((type.flags & op.flags) == 0)
            continue;

        char const* leftType = type.name;
        char const* rightType = leftType;
        char const* resultType = leftType;

        if (op.flags & BOOL_RESULT) resultType = "bool";

        // TODO: We should handle a `SHIFT` flag on the op
        // by changing `rightType` to `int` in order to
        // account for the fact that the shift amount should
        // always have a fixed type independent of the LHS.
        //
        // (It is unclear why this change hadn't been made
        // already, so it is possible that such a change
        // breaks overload resolution or other parts of
        // the compiler)

        // scalar version
        sb << "__intrinsic_op(" << int(op.opCode) << ") " << resultType << " operator" << op.opName << "(" << leftType << " left, " << rightType << " right);\n";
        sb << "__intrinsic_op(" << int(op.opCode) << ") " << resultType << " __" << op.funcName << "(" << leftType << " left, " << rightType << " right);\n";

        // vector version
        sb << "__generic<let N : int> ";
        sb << "__intrinsic_op(" << int(op.opCode) << ") vector<" << resultType << ",N> operator" << op.opName << "(vector<" << leftType << ",N> left, vector<" << rightType << ",N> right);\n";

        // matrix version
        sb << "__generic<let N : int, let M : int> ";
        sb << "__intrinsic_op(" << int(op.opCode) << ") matrix<" << resultType << ",N,M> operator" << op.opName << "(matrix<" << leftType << ",N,M> left, matrix<" << rightType << ",N,M> right);\n";

        // We currently synthesize addiitonal overloads
        // for the case where one or the other operand
        // is a scalar. This choice serves a few purposes:
        //
        // 1. It avoids introducing scalar-to-vector or
        // scalar-to-matrix promotions before the operator,
        // which might allow some back ends to produce
        // more optimal code.
        //
        // 2. It avoids concerns about making overload resolution
        // and the inference rules for `N` and `M` able to
        // handle the mixed vector/scalar or matrix/scalar case.
        //
        // 3. Having explicit overloads for the matrix/scalar cases
        // here means that we do *not* need to support a general
        // implicit conversion from scalars to matrices, unless
        // we decide we want to.
        //
        // Note: Case (2) of the motivation shouldn't really apply
        // any more, because we end up having to support similar
        // inteference for built-in binary math functions where
        // vectors and scalars might be combined (and where defining
        // additional overloads to cover all the combinations doesn't
        // seem practical or desirable).
        //
        // TODO: We should consider whether dropping these extra
        // overloads is possible and worth it. The optimization
        // concern (1) could possibly be addressed in specific
        // back-ends. The issue (3) about not wanting to support
        // implicit scalar-to-matrix conversion may be moot if
        // we end up needing to support mixed scalar/matrix input
        // for builtin in non-operator functions anyway.

        // scalar-vector and scalar-matrix
        sb << "__generic<let N : int> ";
        sb << "__intrinsic_op(" << int(op.opCode) << ") vector<" << resultType << ",N> operator" << op.opName << "(" << leftType << " left, vector<" << rightType << ",N> right);\n";

        sb << "__generic<let N : int, let M : int> ";
        sb << "__intrinsic_op(" << int(op.opCode) << ") matrix<" << resultType << ",N,M> operator" << op.opName << "(" << leftType << " left, matrix<" << rightType << ",N,M> right);\n";

        // vector-scalar and matrix-scalar
        sb << "__generic<let N : int> ";
        sb << "__intrinsic_op(" << int(op.opCode) << ") vector<" << resultType << ",N> operator" << op.opName << "(vector<" << leftType << ",N> left, " << rightType << " right);\n";

        sb << "__generic<let N : int, let M : int> ";
        sb << "__intrinsic_op(" << int(op.opCode) << ") matrix<" << resultType << ",N,M> operator" << op.opName << "(matrix<" << leftType << ",N,M> left, " << rightType << " right);\n";
    }

    // Synthesize generic versions
    if(op.interface)
    {
        char const* leftType = "T";
        char const* rightType = leftType;
        char const* resultType = leftType;

        if (op.flags & BOOL_RESULT) resultType = "bool";
        // TODO: handle `SHIFT`

        // scalar version
        sb << "__generic<T : " << op.interface << ">\n";
        sb << "[OverloadRank(10)]";
        sb << "__intrinsic_op(" << int(op.opCode) << ") " << resultType << " operator" << op.opName << "(" << leftType << " left, " << rightType << " right);\n";

        // vector version
        sb << "__generic<T : " << op.interface << ", let N : int> ";
        sb << "[OverloadRank(10)]";
        sb << "__intrinsic_op(" << int(op.opCode) << ") vector<" << resultType << ",N> operator" << op.opName << "(vector<" << leftType << ",N> left, vector<" << rightType << ",N> right);\n";

        // matrix version
        sb << "__generic<T : " << op.interface << ", let N : int, let M : int> ";
        sb << "[OverloadRank(10)]";
        sb << "__intrinsic_op(" << int(op.opCode) << ") matrix<" << resultType << ",N,M> operator" << op.opName << "(matrix<" << leftType << ",N,M> left, matrix<" << rightType << ",N,M> right);\n";

        // scalar-vector and scalar-matrix
        sb << "__generic<T : " << op.interface << ", let N : int> ";
        sb << "[OverloadRank(10)]";
        sb << "__intrinsic_op(" << int(op.opCode) << ") vector<" << resultType << ",N> operator" << op.opName << "(" << leftType << " left, vector<" << rightType << ",N> right);\n";

        sb << "__generic<T : " << op.interface << ", let N : int, let M : int> ";
        sb << "[OverloadRank(10)]";
        sb << "__intrinsic_op(" << int(op.opCode) << ") matrix<" << resultType << ",N,M> operator" << op.opName << "(" <<  leftType << " left, matrix<" << rightType << ",N,M> right);\n";

        // vector-scalar and matrix-scalar
        sb << "__generic<T : " << op.interface << ", let N : int> ";
        sb << "[OverloadRank(10)]";
        sb << "__intrinsic_op(" << int(op.opCode) << ") vector<" << resultType << ",N> operator" << op.opName << "(vector<" << leftType << ",N> left, " << rightType << " right);\n";

        sb << "__generic<T : " << op.interface << ", let N : int, let M : int> ";
        sb << "[OverloadRank(10)]";
        sb << "__intrinsic_op(" << int(op.opCode) << ") matrix<" << resultType << ",N,M> operator" << op.opName << "(matrix<" << leftType << ",N,M> left, " << rightType << " right);\n";
    }
}

// We will declare the shift operations entirely as generics
// rather than try to handle all the pairings of left-hand
// and right-hand side types.
//
static const struct ShiftOpInfo
{
    char const* name;
    char const* funcName;
    int op;
} kShiftOps[] =
{
    { "<<", "shl", kIROp_Lsh },
    { ">>", "shr", kIROp_Rsh },
};
for(auto info : kShiftOps) {
SLANG_RAW("#line 2770 \"core.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<L: __BuiltinIntegerType, R: __BuiltinIntegerType>\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(info.op
)
SLANG_RAW(")\n")
SLANG_RAW("L operator")
SLANG_SPLICE(info.name
)
SLANG_RAW("(L left, R right);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<L: __BuiltinIntegerType, R: __BuiltinIntegerType>\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(info.op
)
SLANG_RAW(")\n")
SLANG_RAW("L __")
SLANG_SPLICE(info.funcName
)
SLANG_RAW("(L left, R right);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<L: __BuiltinIntegerType, R: __BuiltinIntegerType>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("L operator")
SLANG_SPLICE(info.name
)
SLANG_RAW("=(in out L left, R right)\n")
SLANG_RAW("{\n")
SLANG_RAW("    left = left ")
SLANG_SPLICE(info.name
)
SLANG_RAW(" right;\n")
SLANG_RAW("    return left;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<L: __BuiltinIntegerType, R: __BuiltinIntegerType, let N : int>\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(info.op
)
SLANG_RAW(")\n")
SLANG_RAW("vector<L,N> operator")
SLANG_SPLICE(info.name
)
SLANG_RAW("(vector<L,N> left, vector<R,N> right);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<L: __BuiltinIntegerType, R: __BuiltinIntegerType, let N : int>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("vector<L,N> operator")
SLANG_SPLICE(info.name
)
SLANG_RAW("=(in out vector<L,N> left, vector<R,N> right)\n")
SLANG_RAW("{\n")
SLANG_RAW("    left = left ")
SLANG_SPLICE(info.name
)
SLANG_RAW(" right;\n")
SLANG_RAW("    return left;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<L: __BuiltinIntegerType, R: __BuiltinIntegerType, let N : int, let M : int>\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(info.op
)
SLANG_RAW(")\n")
SLANG_RAW("matrix<L,N,M> operator")
SLANG_SPLICE(info.name
)
SLANG_RAW("(matrix<L,N,M> left, matrix<R,N,M> right);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<L: __BuiltinIntegerType, R: __BuiltinIntegerType, let N : int, let M : int, let Layout : int>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("matrix<L, N, M> operator")
SLANG_SPLICE(info.name
)
SLANG_RAW("=(in out matrix<L, N, M, Layout> left, matrix<R, N, M> right)\n")
SLANG_RAW("{\n")
SLANG_RAW("    left = left ")
SLANG_SPLICE(info.name
)
SLANG_RAW(" right;\n")
SLANG_RAW("    return left;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<L: __BuiltinIntegerType, R: __BuiltinIntegerType, let N : int>\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(info.op
)
SLANG_RAW(")\n")
SLANG_RAW("vector<L,N> operator")
SLANG_SPLICE(info.name
)
SLANG_RAW("(L left, vector<R,N> right);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<L: __BuiltinIntegerType, R: __BuiltinIntegerType, let N : int, let M : int>\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(info.op
)
SLANG_RAW(")\n")
SLANG_RAW("matrix<L,N,M> operator")
SLANG_SPLICE(info.name
)
SLANG_RAW("(L left, matrix<R,N,M> right);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<L: __BuiltinIntegerType, R: __BuiltinIntegerType, let N : int>\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(info.op
)
SLANG_RAW(")\n")
SLANG_RAW("vector<L,N> operator")
SLANG_SPLICE(info.name
)
SLANG_RAW("(vector<L,N> left, R right);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<L: __BuiltinIntegerType, R: __BuiltinIntegerType, let N : int>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("vector<L, N> operator")
SLANG_SPLICE(info.name
)
SLANG_RAW("=(in out vector<L, N> left, R right)\n")
SLANG_RAW("{\n")
SLANG_RAW("    left = left ")
SLANG_SPLICE(info.name
)
SLANG_RAW(" right;\n")
SLANG_RAW("    return left;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<L: __BuiltinIntegerType, R: __BuiltinIntegerType, let N : int, let M : int>\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(info.op
)
SLANG_RAW(")\n")
SLANG_RAW("matrix<L,N,M> operator")
SLANG_SPLICE(info.name
)
SLANG_RAW("(matrix<L,N,M> left, R right);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<L: __BuiltinIntegerType, R: __BuiltinIntegerType, let N : int, let M : int, let Layout : int>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("matrix<L,N,M> operator")
SLANG_SPLICE(info.name
)
SLANG_RAW("=(in out matrix<L,N,M, Layout> left, R right)\n")
SLANG_RAW("{\n")
SLANG_RAW("    left = left ")
SLANG_SPLICE(info.name
)
SLANG_RAW(" right;\n")
SLANG_RAW("    return left;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")

}

    static const struct CompoundBinaryOpInfo
    {
        char const* name;
        char const* interface;
    } kCompoundBinaryOps[] =
    {
        { "+",  "__BuiltinArithmeticType" },
        { "-",  "__BuiltinArithmeticType" },
        { "*",  "__BuiltinArithmeticType" },
        { "/",  "__BuiltinArithmeticType" },
        { "%",  "__BuiltinIntegerType" },
        { "%",  "__BuiltinFloatingPointType" },
        { "&",  "__BuiltinLogicalType" },
        { "|",  "__BuiltinLogicalType" },
        { "^",  "__BuiltinLogicalType" },
    };
    for( auto op : kCompoundBinaryOps )
    {
    
SLANG_RAW("#line 2865 \"core.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("    __generic<T : ")
SLANG_SPLICE(op.interface
)
SLANG_RAW(">\n")
SLANG_RAW("    [__unsafeForceInlineEarly]\n")
SLANG_RAW("    T operator")
SLANG_SPLICE(op.name
)
SLANG_RAW("=(in out T left, T right)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        left = left ")
SLANG_SPLICE(op.name
)
SLANG_RAW(" right;\n")
SLANG_RAW("        return left;\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    __generic<T : ")
SLANG_SPLICE(op.interface
)
SLANG_RAW(", let N : int>\n")
SLANG_RAW("    [__unsafeForceInlineEarly]\n")
SLANG_RAW("    vector<T,N> operator")
SLANG_SPLICE(op.name
)
SLANG_RAW("=(in out vector<T,N> left, vector<T,N> right)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        left = left ")
SLANG_SPLICE(op.name
)
SLANG_RAW(" right;\n")
SLANG_RAW("        return left;\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    __generic<T : ")
SLANG_SPLICE(op.interface
)
SLANG_RAW(", let N : int>\n")
SLANG_RAW("    [__unsafeForceInlineEarly]\n")
SLANG_RAW("    vector<T,N> operator")
SLANG_SPLICE(op.name
)
SLANG_RAW("=(in out vector<T,N> left, T right)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        left = left ")
SLANG_SPLICE(op.name
)
SLANG_RAW(" right;\n")
SLANG_RAW("        return left;\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    __generic<T : ")
SLANG_SPLICE(op.interface
)
SLANG_RAW(", let R : int, let C : int, let Layout : int>\n")
SLANG_RAW("    [__unsafeForceInlineEarly]\n")
SLANG_RAW("    matrix<T,R,C> operator")
SLANG_SPLICE(op.name
)
SLANG_RAW("=(in out matrix<T,R,C,Layout> left, matrix<T,R,C> right)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        left = left ")
SLANG_SPLICE(op.name
)
SLANG_RAW(" right;\n")
SLANG_RAW("        return left;\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")
SLANG_RAW("    __generic<T : ")
SLANG_SPLICE(op.interface
)
SLANG_RAW(", let R : int, let C : int, let Layout : int>\n")
SLANG_RAW("    [__unsafeForceInlineEarly]\n")
SLANG_RAW("    matrix<T,R,C> operator")
SLANG_SPLICE(op.name
)
SLANG_RAW("=(in out matrix<T,R,C, Layout> left, T right)\n")
SLANG_RAW("    {\n")
SLANG_RAW("        left = left ")
SLANG_SPLICE(op.name
)
SLANG_RAW(" right;\n")
SLANG_RAW("        return left;\n")
SLANG_RAW("    }\n")
SLANG_RAW("\n")

    }

SLANG_RAW("#line 2910 \"core.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("//@ public:\n")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("/// Bit cast between types. `T` and `U` must have the same size.\n")
SLANG_RAW("/// They can be any scalar, vector, matrix, struct or array types.\n")
SLANG_RAW("/// @category conversion\n")
SLANG_RAW("__generic<T, U>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_BitCast
)
SLANG_RAW(")\n")
SLANG_RAW("T bit_cast(U value);\n")
SLANG_RAW("\n")
SLANG_RAW("// Create Existential object\n")
SLANG_RAW("__generic<T, U>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_CreateExistentialObject
)
SLANG_RAW(")\n")
SLANG_RAW("T createDynamicObject(uint typeId, U value);\n")
SLANG_RAW("\n")
SLANG_RAW("/// Reinterpret type `U` as type `T`. `T` and `U` \n")
SLANG_RAW("/// can be any scalar, vector, matrix, struct or array types.\n")
SLANG_RAW("/// @category conversion\n")
SLANG_RAW("__generic<T, U>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_Reinterpret
)
SLANG_RAW(")\n")
SLANG_RAW("T reinterpret(U value);\n")
SLANG_RAW("\n")
SLANG_RAW("/// `bitfieldInsert` inserts the bits least significant bits of `insert` into base at `offset` offset.\n")
SLANG_RAW("/// The returned value will have bits [offset, offset + bits + 1] taken from [0, bits - 1] of `insert`\n")
SLANG_RAW("/// and all other bits taken directly from the corresponding bits of `base`.\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_BitfieldInsert
)
SLANG_RAW(")\n")
SLANG_RAW("T bitfieldInsert(T base, T insert, uint offset, uint bits);\n")
SLANG_RAW("\n")
SLANG_RAW("/// `bitfieldExtract` extracts a subset of the bits of `value` and\n")
SLANG_RAW("/// returns it in the least significant bits of the result. The range of bits extracted is [offset, offset + bits - 1].\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_BitfieldExtract
)
SLANG_RAW(")\n")
SLANG_RAW("T bitfieldExtract(T value, uint offset, uint bits);\n")
SLANG_RAW("\n")
SLANG_RAW("/// Use an otherwise unused value\n")
SLANG_RAW("/// This can be used to silence the warning about returning before initializing an out paramter.\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_Unmodified
)
SLANG_RAW(")\n")
SLANG_RAW("void unused(inout T){}\n")
SLANG_RAW("\n")
SLANG_RAW("// This can be used to silence the warning about not writing to an inout parameter.\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_Unmodified
)
SLANG_RAW(")\n")
SLANG_RAW("void unmodified(out T){}\n")
SLANG_RAW("\n")
SLANG_RAW("// Specialized function\n")
SLANG_RAW("\n")
SLANG_RAW("/// Given a string returns an integer hash of that string.\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_GetStringHash
)
SLANG_RAW(")\n")
SLANG_RAW("int getStringHash(String string);\n")
SLANG_RAW("\n")
SLANG_RAW("/// Use will produce a syntax error in downstream compiler\n")
SLANG_RAW("/// Useful for testing diagnostics around compilation errors of downstream compiler\n")
SLANG_RAW("/// It 'returns' an int so can be used in expressions without the front end complaining.\n")
SLANG_RAW("[require(cpp_cuda_glsl_hlsl)]\n")
SLANG_RAW("int __SyntaxError()\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case cpp: __intrinsic_asm \" @ \";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \" @ \";\n")
SLANG_RAW("    case glsl: __intrinsic_asm \" @ \";\n")
SLANG_RAW("    case hlsl: __intrinsic_asm \" @ \";\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("//@ hidden:\n")
SLANG_RAW("\n")
SLANG_RAW("/// For downstream compilers that allow sizeof/alignof/offsetof\n")
SLANG_RAW("/// Can't be called in the C/C++ style. Need to use __size_of<some_type>() as opposed to sizeof(some_type).\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[require(cpp_cuda)]\n")
SLANG_RAW("int __sizeOf()\n")
SLANG_RAW("{\n")
SLANG_RAW("    __intrinsic_asm \"sizeof($[0])\", T;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[require(cpp_cuda)]\n")
SLANG_RAW("int __sizeOf(T v)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case cpp: __intrinsic_asm \"sizeof($T0)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"sizeof($T0)\";\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[require(cpp_cuda)]\n")
SLANG_RAW("int __alignOf()\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case cuda :\n")
SLANG_RAW("    case cpp :\n")
SLANG_RAW("        __intrinsic_asm \"SLANG_ALIGN_OF($[0])\", T;\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[require(cpp_cuda)]\n")
SLANG_RAW("int __alignOf(T v)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case cpp: __intrinsic_asm \"SLANG_ALIGN_OF($T0)\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"SLANG_ALIGN_OF($T0)\";\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// It would be nice to have offsetof equivalent, but it's not clear how that would work in terms of the Slang language.\n")
SLANG_RAW("// Here we allow calculating the offset of a field in bytes from an *instance* of the type.\n")
SLANG_RAW("__generic<T,F>\n")
SLANG_RAW("[__readNone]\n")
SLANG_RAW("[require(cpp_cuda)]\n")
SLANG_RAW("int __offsetOf(in T t, in F field)\n")
SLANG_RAW("{\n")
SLANG_RAW("    __target_switch\n")
SLANG_RAW("    {\n")
SLANG_RAW("    case cpp: __intrinsic_asm \"int(((char*)&($1)) - ((char*)&($0))\";\n")
SLANG_RAW("    case cuda: __intrinsic_asm \"int(((char*)&($1)) - ((char*)&($0)))\";\n")
SLANG_RAW("    }\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("/// Mark beginning of \"interlocked\" operations in a fragment shader.\n")
SLANG_RAW("[require(glsl_spirv, GL_ARB_fragment_shader_interlock, fragment)]\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_BeginFragmentShaderInterlock
)
SLANG_RAW(")\n")
SLANG_RAW("void beginInvocationInterlock();\n")
SLANG_RAW("\n")
SLANG_RAW("/// Mark end of \"interlocked\" operations in a fragment shader.\n")
SLANG_RAW("[require(glsl_spirv, GL_ARB_fragment_shader_interlock, fragment)]\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_EndFragmentShaderInterlock
)
SLANG_RAW(")\n")
SLANG_RAW("void endInvocationInterlock();\n")
SLANG_RAW("\n")
SLANG_RAW("// Operators to apply to `enum` types\n")
SLANG_RAW("\n")
SLANG_RAW("//@ hidden:\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<E : __EnumType>\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_Eql
)
SLANG_RAW(")\n")
SLANG_RAW("bool operator==(E left, E right);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<E : __EnumType>\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_Neq
)
SLANG_RAW(")\n")
SLANG_RAW("bool operator!=(E left, E right);\n")
SLANG_RAW("\n")
SLANG_RAW("//@ hidden:\n")
SLANG_RAW("\n")
SLANG_RAW("// public interfaces for generic arithmetic types.\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : IComparable>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("[OverloadRank(-10)]\n")
SLANG_RAW("bool operator<(T v0, T v1)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return v0.lessThan(v1);\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : IComparable>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("[OverloadRank(-10)]\n")
SLANG_RAW("bool operator>(T v0, T v1)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return v1.lessThan(v0);\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : IComparable>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("[OverloadRank(-10)]\n")
SLANG_RAW("bool operator ==(T v0, T v1)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return v0.equals(v1);\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : IComparable>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("[OverloadRank(-10)]\n")
SLANG_RAW("bool operator >=(T v0, T v1)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return v1.lessThanOrEquals(v0);\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : IComparable>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("[OverloadRank(-10)]\n")
SLANG_RAW("bool operator <=(T v0, T v1)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return v0.lessThanOrEquals(v1);\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : IComparable>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("[OverloadRank(-10)]\n")
SLANG_RAW("bool operator !=(T v0, T v1)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return !v0.equals(v1);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")

const char* arithmeticInterfaces[] = {"IArithmetic", "IFloat"};
const char* attribs[] = {"", "[TreatAsDifferentiable]"};
for (Index i = 0; i < 2; i++) {
    const auto interfaceName = arithmeticInterfaces[i];
    const auto attrib = attribs[i];
    Index overloadRank = i - 3;
SLANG_RAW("#line 3129 \"core.meta.slang\"")
SLANG_RAW("\n")
SLANG_SPLICE(attrib
)
SLANG_RAW("\n")
SLANG_RAW("__generic<T : ")
SLANG_SPLICE(interfaceName
)
SLANG_RAW(">\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("[OverloadRank(")
SLANG_SPLICE(overloadRank
)
SLANG_RAW(")]\n")
SLANG_RAW("T operator +(T v0, T v1)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return v0.add(v1);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_SPLICE(attrib
)
SLANG_RAW("\n")
SLANG_RAW("__generic<T : ")
SLANG_SPLICE(interfaceName
)
SLANG_RAW(">\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("[OverloadRank(")
SLANG_SPLICE(overloadRank
)
SLANG_RAW(")]\n")
SLANG_RAW("T operator -(T v0, T v1)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return v0.sub(v1);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_SPLICE(attrib
)
SLANG_RAW("\n")
SLANG_RAW("__generic<T : ")
SLANG_SPLICE(interfaceName
)
SLANG_RAW(">\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("[OverloadRank(")
SLANG_SPLICE(overloadRank
)
SLANG_RAW(")]\n")
SLANG_RAW("T operator *(T v0, T v1)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return v0.mul(v1);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_SPLICE(attrib
)
SLANG_RAW("\n")
SLANG_RAW("__generic<T : ")
SLANG_SPLICE(interfaceName
)
SLANG_RAW(">\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("[OverloadRank(")
SLANG_SPLICE(overloadRank
)
SLANG_RAW(")]\n")
SLANG_RAW("T operator /(T v0, T v1)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return v0.div(v1);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_SPLICE(attrib
)
SLANG_RAW("\n")
SLANG_RAW("__generic<T : ")
SLANG_SPLICE(interfaceName
)
SLANG_RAW(">\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("[OverloadRank(")
SLANG_SPLICE(overloadRank
)
SLANG_RAW(")]\n")
SLANG_RAW("T operator %(T v0, T v1)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return v0.mod(v1);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_SPLICE(attrib
)
SLANG_RAW("\n")
SLANG_RAW("__generic<T : ")
SLANG_SPLICE(interfaceName
)
SLANG_RAW(">\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("[OverloadRank(")
SLANG_SPLICE(overloadRank
)
SLANG_RAW(")]\n")
SLANG_RAW("__prefix T operator -(T v0)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return v0.neg();\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")

    } // foreach ["IArithmetic", "IFloat"]
SLANG_RAW("#line 3186 \"core.meta.slang\"")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : ILogical>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("[OverloadRank(-10)]\n")
SLANG_RAW("T operator &(T v0, T v1)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return v0.bitAnd(v1);\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : ILogical>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("[OverloadRank(-10)]\n")
SLANG_RAW("T operator &&(T v0, T v1)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return v0.and(v1);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("[OverloadRank(-10)]\n")
SLANG_RAW("bool and(bool v0, bool v1)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return __and(v0, v1);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("[OverloadRank(-10)]\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_And
)
SLANG_RAW(")\n")
SLANG_RAW("vector<bool, N> and<let N : int>(vector<bool, N> v0, vector<bool, N> v1);\n")
SLANG_RAW("\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("[OverloadRank(-10)]\n")
SLANG_RAW("vector<bool, N> and<let N : int>(bool b, vector<bool, N> v)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return and(vector<bool, N>(b), v);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("[OverloadRank(-10)]\n")
SLANG_RAW("vector<bool, N> and<let N : int>(vector<bool, N> v, bool b)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return and(v, vector<bool, N>(b));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("[OverloadRank(-10)]\n")
SLANG_RAW("bool or(bool v0, bool v1)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return __or(v0, v1);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("[OverloadRank(-10)]\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_Or
)
SLANG_RAW(")\n")
SLANG_RAW("vector<bool, N> or<let N : int>(vector<bool, N> v0, vector<bool, N> v1);\n")
SLANG_RAW("\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("[OverloadRank(-10)]\n")
SLANG_RAW("vector<bool, N> or<let N : int>(bool b, vector<bool, N> v)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return or(vector<bool, N>(b), v);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("[OverloadRank(-10)]\n")
SLANG_RAW("vector<bool, N> or<let N : int>(vector<bool, N> v, bool b)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return or(v, vector<bool, N>(b));\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : ILogical>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("[OverloadRank(-10)]\n")
SLANG_RAW("T operator |(T v0, T v1)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return v0.bitOr(v1);\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : ILogical>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("[OverloadRank(-10)]\n")
SLANG_RAW("T operator ||(T v0, T v1)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return v0.or(v1);\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : ILogical>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("[OverloadRank(-10)]\n")
SLANG_RAW("T operator ^(T v0, T v1)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return v0.bitXor(v1);\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : ILogical>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("[OverloadRank(-10)]\n")
SLANG_RAW("__prefix T operator ~(T v0)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return v0.bitNot();\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : ILogical>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("[OverloadRank(-10)]\n")
SLANG_RAW("__prefix T operator !(T v0)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return v0.not();\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("// The operator overloads defined above already allows Enum types to be used\n")
SLANG_RAW("// in logical operators, but we still provide overloads for __EnumTypes and map\n")
SLANG_RAW("// them directly to intrinsic op to allow constant propagation at AST level to\n")
SLANG_RAW("// work on enum types.\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __EnumType>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_BitAnd
)
SLANG_RAW(")\n")
SLANG_RAW("T operator &(T v0, T v1);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __EnumType>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_BitOr
)
SLANG_RAW(")\n")
SLANG_RAW("T operator |(T v0, T v1);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : __EnumType>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_BitNot
)
SLANG_RAW(")\n")
SLANG_RAW("__prefix T operator ~(T v0);\n")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("// IR level type traits.\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_undefined
)
SLANG_RAW(")\n")
SLANG_RAW("T __declVal();\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_DefaultConstruct
)
SLANG_RAW(")\n")
SLANG_RAW("T __default();\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T, U>\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_TypeEquals
)
SLANG_RAW(")\n")
SLANG_RAW("bool __type_equals_impl(T t, U u);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T, U>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("bool __type_equals(T t, U u)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return __type_equals_impl(__declVal<T>(), __declVal<U>());\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T, U>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("bool __type_equals()\n")
SLANG_RAW("{\n")
SLANG_RAW("    return __type_equals_impl(__declVal<T>(), __declVal<U>());\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_IsBool
)
SLANG_RAW(")\n")
SLANG_RAW("bool __isBool_impl(T t);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("bool __isBool()\n")
SLANG_RAW("{\n")
SLANG_RAW("    return __isBool_impl(__declVal<T>());\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_IsInt
)
SLANG_RAW(")\n")
SLANG_RAW("bool __isInt_impl(T t);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("bool __isInt()\n")
SLANG_RAW("{\n")
SLANG_RAW("    return __isInt_impl(__declVal<T>());\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_IsFloat
)
SLANG_RAW(")\n")
SLANG_RAW("bool __isFloat_impl(T t);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_IsHalf
)
SLANG_RAW(")\n")
SLANG_RAW("bool __isHalf_impl(T t);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("bool __isFloat()\n")
SLANG_RAW("{\n")
SLANG_RAW("    return __isFloat_impl(__declVal<T>());\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("bool __isHalf()\n")
SLANG_RAW("{\n")
SLANG_RAW("    return __isHalf_impl(__declVal<T>());\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_IsUnsignedInt
)
SLANG_RAW(")\n")
SLANG_RAW("bool __isUnsignedInt_impl(T t);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("bool __isUnsignedInt()\n")
SLANG_RAW("{\n")
SLANG_RAW("    return __isUnsignedInt_impl(__declVal<T>());\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_IsSignedInt
)
SLANG_RAW(")\n")
SLANG_RAW("bool __isSignedInt_impl(T t);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("bool __isSignedInt()\n")
SLANG_RAW("{\n")
SLANG_RAW("    return __isSignedInt_impl(__declVal<T>());\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_IsVector
)
SLANG_RAW(")\n")
SLANG_RAW("bool __isVector_impl(T t);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("bool __isVector()\n")
SLANG_RAW("{\n")
SLANG_RAW("    return __isVector_impl(__declVal<T>());\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_GetNaturalStride
)
SLANG_RAW(")\n")
SLANG_RAW("int __naturalStrideOf_impl(T v);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("int __naturalStrideOf()\n")
SLANG_RAW("{\n")
SLANG_RAW("    return __naturalStrideOf_impl(__declVal<T>());\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_AlignOf
)
SLANG_RAW(")\n")
SLANG_RAW("int __alignOf_intrinsic_impl<T>(T t);\n")
SLANG_RAW("\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("int __alignOf_intrinsic<T>()\n")
SLANG_RAW("{\n")
SLANG_RAW("    return __alignOf_intrinsic_impl<T>(__default<T>());\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("int32_t __elemToByteOffset<T>(int32_t elemOffset)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return elemOffset * __naturalStrideOf<T>();\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("[__unsafeForceInlineEarly]\n")
SLANG_RAW("int32_t __byteToElemOffset<T>(int32_t byteOffset)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return byteOffset / __naturalStrideOf<T>();\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_TreatAsDynamicUniform
)
SLANG_RAW(")\n")
SLANG_RAW("T asDynamicUniform<T>(T v);\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("__intrinsic_op( ")
SLANG_SPLICE(kIROp_GetLegalizedSPIRVGlobalParamAddr
)
SLANG_RAW(")\n")
SLANG_RAW("__Addr<T> __getLegalizedSPIRVGlobalParamAddr(T val);\n")
SLANG_RAW("\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_RequireComputeDerivative
)
SLANG_RAW(")\n")
SLANG_RAW("void __requireComputeDerivative();\n")
SLANG_RAW("\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_RequireMaximallyReconverges
)
SLANG_RAW(")\n")
SLANG_RAW("void __requireMaximallyReconverges();\n")
SLANG_RAW("\n")
SLANG_RAW("__intrinsic_op(")
SLANG_SPLICE(kIROp_RequireQuadDerivatives
)
SLANG_RAW(")\n")
SLANG_RAW("void __requireQuadDerivatives();\n")
SLANG_RAW("\n")
SLANG_RAW("//@ public:\n")
SLANG_RAW("/// @category misc_types \n")
SLANG_RAW("enum MemoryOrder\n")
SLANG_RAW("{\n")
SLANG_RAW("    /// No memory operation ordering constraints\n")
SLANG_RAW("    Relaxed = ")
SLANG_SPLICE(kIRMemoryOrder_Relaxed
)
SLANG_RAW(",\n")
SLANG_RAW("    /// Ensures that all subsequent memory operations in the same thread are not reordered before it\n")
SLANG_RAW("    Acquire = ")
SLANG_SPLICE(kIRMemoryOrder_Acquire
)
SLANG_RAW(",\n")
SLANG_RAW("    /// Ensures that all prior memory operations in the same thread are not reordered after it\n")
SLANG_RAW("    Release = ")
SLANG_SPLICE(kIRMemoryOrder_Release
)
SLANG_RAW(",\n")
SLANG_RAW("    /// Combines both acquire and release semantics\n")
SLANG_RAW("    AcquireRelease = ")
SLANG_SPLICE(kIRMemoryOrder_AcquireRelease
)
SLANG_RAW(",\n")
SLANG_RAW("    /// Provides the strongest ordering: total order exists between all SeqCst operations\n")
SLANG_RAW("    SeqCst = ")
SLANG_SPLICE(kIRMemoryOrder_SeqCst
)
SLANG_RAW(",\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("/// Represents types that can be used in any atomic operations.\n")
SLANG_RAW("/// Implemented by builtin scalar types: `int`, `uint`, `int64_t`, `uint64_t`, `int8_t`, `uint8_t`, `int16_t`, `uint16_t`, `float`, `double` and `half`.\n")
SLANG_RAW("[sealed] interface IAtomicable {}\n")
SLANG_RAW("\n")
SLANG_RAW("/// Represents types that can be used in atomic arithmetic operations.\n")
SLANG_RAW("/// Implemented by builtin scalar types: `int`, `uint`, `int64_t`, `uint64_t`, `int8_t`, `uint8_t`, `int16_t`, `uint16_t`, `float`, `double` and `half`.\n")
SLANG_RAW("[sealed] interface IArithmeticAtomicable : IAtomicable, IArithmetic {}\n")
SLANG_RAW("\n")
SLANG_RAW("/// Represents types that can be used in atomic bit operations.\n")
SLANG_RAW("/// Implemented by builtin scalar types: `int`, `uint`, `int64_t`, `uint64_t`, `int8_t`, `uint8_t`, `int16_t`, `uint16_t`.\n")
SLANG_RAW("[sealed] interface IBitAtomicable : IArithmeticAtomicable, IInteger {}\n")
SLANG_RAW("\n")
SLANG_RAW("extension int : IBitAtomicable {}\n")
SLANG_RAW("extension uint : IBitAtomicable {}\n")
SLANG_RAW("extension int64_t : IBitAtomicable {}\n")
SLANG_RAW("extension uint64_t : IBitAtomicable {}\n")
SLANG_RAW("extension double : IArithmeticAtomicable {}\n")
SLANG_RAW("extension float : IArithmeticAtomicable {}\n")
SLANG_RAW("extension half : IArithmeticAtomicable {}\n")
SLANG_RAW("\n")
SLANG_RAW("/// A wrapper for `IAtomicable` types to introduce atomic load and store\n")
SLANG_RAW("/// operations. Values of this type are to be stored in buffers or groupshared\n")
SLANG_RAW("/// memory.\n")
SLANG_RAW("///\n")
SLANG_RAW("/// All operations take a `MemoryOrder` parameter which influenced the\n")
SLANG_RAW("/// semantics of the performed operation\n")
SLANG_RAW("///\n")
SLANG_RAW("/// All operations take place at the device scope.\n")
SLANG_RAW("///\n")
SLANG_RAW("/// Operators `+=`, `-=`, `&=`, `|=`, `^=`, `++`, `--` are overloaded to\n")
SLANG_RAW("/// operate on `Atomic<T>`.\n")
SLANG_RAW("__magic_type(AtomicType)\n")
SLANG_RAW("__intrinsic_type(")
SLANG_SPLICE(kIROp_AtomicType
)
SLANG_RAW(")\n")
SLANG_RAW("[require(cuda_glsl_hlsl_metal_spirv_wgsl)]\n")
SLANG_RAW("struct Atomic<T : IAtomicable>\n")
SLANG_RAW("{\n")
SLANG_RAW("    /// Atomically load the stored `T` value\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_AtomicLoad
)
SLANG_RAW(")\n")
SLANG_RAW("    [__ref] T load(MemoryOrder order = MemoryOrder.Relaxed);\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Atomically store a new `T` value\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_AtomicStore
)
SLANG_RAW(")\n")
SLANG_RAW("    [__ref] void store(T newValue, MemoryOrder order = MemoryOrder.Relaxed);\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Atomically replace the stored `T` value with a new `T` value and return\n")
SLANG_RAW("    /// replaced value\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_AtomicExchange
)
SLANG_RAW(")\n")
SLANG_RAW("    [__ref] T exchange(T newValue, MemoryOrder order = MemoryOrder.Relaxed); // returns old value\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Atomically replace and return the stored `T` value with a new `T` value\n")
SLANG_RAW("    /// only if the stored value is equal to the specified comparison value.\n")
SLANG_RAW("    ///\n")
SLANG_RAW("    /// If the comparison value is equal to the stored value, then the\n")
SLANG_RAW("    /// `successOrder` `MemoryOrder` is used, otherwise the `failOrder`\n")
SLANG_RAW("    /// `MemoryOrder` is used. \n")
SLANG_RAW("    /// \n")
SLANG_RAW("    /// `successOrder` must be at least as strong as `failOrder`\n")
SLANG_RAW("    ///\n")
SLANG_RAW("    /// `failOrder` must not be `MemoryOrder.Release` or `MemoryOrder.AcquireRelease`\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_AtomicCompareExchange
)
SLANG_RAW(")\n")
SLANG_RAW("    [__ref] T compareExchange(\n")
SLANG_RAW("        T compareValue,\n")
SLANG_RAW("        T newValue,\n")
SLANG_RAW("        MemoryOrder successOrder = MemoryOrder.Relaxed,\n")
SLANG_RAW("        MemoryOrder failOrder = MemoryOrder.Relaxed);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("/// These additional members are only available when `T` conforms to `IArithmeticAtomicable`.\n")
SLANG_RAW("extension<T : IArithmeticAtomicable> Atomic<T>\n")
SLANG_RAW("{\n")
SLANG_RAW("    /// Atomically adds the given value to the stored value and returns the\n")
SLANG_RAW("    /// original stored value.\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_AtomicAdd
)
SLANG_RAW(")\n")
SLANG_RAW("    [__ref] T add(T value, MemoryOrder order = MemoryOrder.Relaxed);\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Atomically subtracts the given value from the stored value and returns\n")
SLANG_RAW("    /// the original stored value.\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_AtomicSub
)
SLANG_RAW(")\n")
SLANG_RAW("    [__ref] T sub(T value, MemoryOrder order = MemoryOrder.Relaxed);\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Atomically computes the maximum of the stored value and the given\n")
SLANG_RAW("    /// value, storing the result and returning the original stored value.\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_AtomicMax
)
SLANG_RAW(")\n")
SLANG_RAW("    [__ref] T max(T value, MemoryOrder order = MemoryOrder.Relaxed);\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Atomically computes the minimum of the stored value and the given\n")
SLANG_RAW("    /// value, storing the result and returning the original stored value.\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_AtomicMin
)
SLANG_RAW(")\n")
SLANG_RAW("    [__ref] T min(T value, MemoryOrder order = MemoryOrder.Relaxed);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("/// These additional members are only available when `T` conforms to `IBitAtomicable`.\n")
SLANG_RAW("extension<T : IBitAtomicable> Atomic<T>\n")
SLANG_RAW("{\n")
SLANG_RAW("    /// Atomically performs a bitwise AND operation between the stored value\n")
SLANG_RAW("    /// and the given value, storing the result and returning the original\n")
SLANG_RAW("    /// stored value.\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_AtomicAnd
)
SLANG_RAW(")\n")
SLANG_RAW("    [__ref] T and(T value, MemoryOrder order = MemoryOrder.Relaxed);\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Atomically performs a bitwise OR operation between the stored value and\n")
SLANG_RAW("    /// the given value, storing the result and returning the original stored\n")
SLANG_RAW("    /// value.\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_AtomicOr
)
SLANG_RAW(")\n")
SLANG_RAW("    [__ref] T or(T value, MemoryOrder order = MemoryOrder.Relaxed);\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Atomically performs a bitwise XOR operation between the stored value\n")
SLANG_RAW("    /// and the given value, storing the result and returning the original\n")
SLANG_RAW("    /// stored value.\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_AtomicXor
)
SLANG_RAW(")\n")
SLANG_RAW("    [__ref] T xor(T value, MemoryOrder order = MemoryOrder.Relaxed);\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Atomically increments the stored value and returns the original stored\n")
SLANG_RAW("    /// value.\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_AtomicInc
)
SLANG_RAW(")\n")
SLANG_RAW("    [__ref] T increment(MemoryOrder order = MemoryOrder.Relaxed);\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Atomically decrements the stored value and returns the original stored\n")
SLANG_RAW("    /// value.\n")
SLANG_RAW("    __intrinsic_op(")
SLANG_SPLICE(kIROp_AtomicDec
)
SLANG_RAW(")\n")
SLANG_RAW("    [__ref] T decrement(MemoryOrder order = MemoryOrder.Relaxed);\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("//@ hidden:\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : IArithmeticAtomicable>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("T operator +=(__ref Atomic<T> v, T value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return v.add(value) + value;\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : IArithmeticAtomicable>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("T operator -=(__ref Atomic<T> v, T value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return v.sub(value) - value;\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : IBitAtomicable>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("T operator &=(__ref Atomic<T> v, T value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return v.and(value) & value;\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : IBitAtomicable>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("T operator |=(__ref Atomic<T> v, T value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return v.or(value) | value;\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : IBitAtomicable>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("T operator ^=(__ref Atomic<T> v, T value)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return v.xor(value) ^ value;\n")
SLANG_RAW("}\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T : IBitAtomicable>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("__prefix T operator ++(__ref Atomic<T> v)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return v.increment() + T(1);\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : IBitAtomicable>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("__postfix T operator ++(__ref Atomic<T> v)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return v.increment();\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : IBitAtomicable>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("__prefix T operator --(__ref Atomic<T> v)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return v.decrement() - T(1);\n")
SLANG_RAW("}\n")
SLANG_RAW("__generic<T : IBitAtomicable>\n")
SLANG_RAW("[ForceInline]\n")
SLANG_RAW("__postfix T operator --(__ref Atomic<T> v)\n")
SLANG_RAW("{\n")
SLANG_RAW("    return v.decrement();\n")
SLANG_RAW("}\n")
SLANG_RAW("// Binding Attributes\n")
SLANG_RAW("\n")
SLANG_RAW("//@public:\n")
SLANG_RAW("\n")
SLANG_RAW("/// Declare the Vulkan binding location of a global shader variable.\n")
SLANG_RAW("/// @param binding The binding location.\n")
SLANG_RAW("/// @param set The descriptor set index of the binding.\n")
SLANG_RAW("__attributeTarget(DeclBase)\n")
SLANG_RAW("attribute_syntax [vk_binding(binding: int, set: int = 0)]\t\t\t: GLSLBindingAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// Declare the Vulkan binding location of a global shader variable.\n")
SLANG_RAW("/// @param binding The binding location.\n")
SLANG_RAW("/// @param set The descriptor set index of the binding.\n")
SLANG_RAW("__attributeTarget(DeclBase)\n")
SLANG_RAW("attribute_syntax [gl_binding(binding: int, set: int = 0)]\t\t\t: GLSLBindingAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("\n")
SLANG_RAW("/// Mark a global variable as a Vulkan shader record.\n")
SLANG_RAW("__attributeTarget(VarDeclBase)\n")
SLANG_RAW("attribute_syntax [vk_shader_record]\t\t\t                        : ShaderRecordAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// Mark a global variable as a Vulkan shader record.\n")
SLANG_RAW("__attributeTarget(VarDeclBase)\n")
SLANG_RAW("attribute_syntax [shader_record]\t\t\t                        : ShaderRecordAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// Mark a global variable as a Vulkan push constant.\n")
SLANG_RAW("__attributeTarget(VarDeclBase)\n")
SLANG_RAW("attribute_syntax [vk_push_constant]\t\t\t\t\t\t\t\t\t: PushConstantAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// Mark a global variable as a Vulkan push constant.\n")
SLANG_RAW("__attributeTarget(VarDeclBase)\n")
SLANG_RAW("attribute_syntax [push_constant]\t\t\t\t\t\t\t\t\t: PushConstantAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// Mark a global variable as a Vulkan specialization constant.\n")
SLANG_RAW("__attributeTarget(VarDeclBase)\n")
SLANG_RAW("attribute_syntax[vk_specialization_constant] : SpecializationConstantAttribute;\n")
SLANG_RAW("/// Mark a global variable as a Vulkan specialization constant.\n")
SLANG_RAW("__attributeTarget(VarDeclBase)\n")
SLANG_RAW("attribute_syntax[SpecializationConstant] : SpecializationConstantAttribute;\n")
SLANG_RAW("/// Mark a global variable as a Vulkan specialization constant.\n")
SLANG_RAW("/// @param location The index of the specialization constant.\n")
SLANG_RAW("__attributeTarget(VarDeclBase)\n")
SLANG_RAW("attribute_syntax[vk_constant_id(location: int)] : VkConstantIdAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// Declare the Vulkan location of a global variable.\n")
SLANG_RAW("__attributeTarget(VarDeclBase)\n")
SLANG_RAW("attribute_syntax [vk_location(location : int)] : GLSLLocationAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// Declare the Vulkan binding index of a global variable.\n")
SLANG_RAW("__attributeTarget(VarDeclBase)\n")
SLANG_RAW("attribute_syntax [vk_index(index : int)] : GLSLIndexAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// Declare offset for a struct field. Applies to all kinds of structs when targeting Vulkan.\n")
SLANG_RAW("/// Applies only to structs that are directly used as interface blocks (such as push constants and uniforms)\n")
SLANG_RAW("/// when targeting GLSL, as GLSL does not support the `offset` qualifier on regular structs.\n")
SLANG_RAW("/// This attribute has no effect on other targets.\n")
SLANG_RAW("__attributeTarget(VarDeclBase)\n")
SLANG_RAW("attribute_syntax [vk_offset(index: int)] : VkStructOffsetAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// @deprecated\n")
SLANG_RAW("/// Use `spirv_asm` instead for inline SPIR-V assembly.\n")
SLANG_RAW("__attributeTarget(FuncDecl)\n")
SLANG_RAW("attribute_syntax [vk_spirv_instruction(op : int, set : String = \"\")]     : SPIRVInstructionOpAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// Declare the Vulkan input attachment index of a global variable.\n")
SLANG_RAW("__attributeTarget(VarDeclBase)\n")
SLANG_RAW("attribute_syntax [vk_input_attachment_index(location : int)] : GLSLInputAttachmentIndexLayoutAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// @internal\n")
SLANG_RAW("__attributeTarget(FuncDecl)\n")
SLANG_RAW("attribute_syntax [spv_target_env_1_3] : SPIRVTargetEnv13Attribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// @internal\n")
SLANG_RAW("__attributeTarget(VarDeclBase)\n")
SLANG_RAW("attribute_syntax [disable_array_flattening] : DisableArrayFlatteningAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// Marks a enum type as an unscoped enum. The enum cases of an unscoped enum are not scoped within the enum type, and can be\n")
SLANG_RAW("/// referenced directly without the enum type name.\n")
SLANG_RAW("__attributeTarget(EnumDecl)\n")
SLANG_RAW("attribute_syntax [UnscopedEnum] : UnscopedEnumAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// Marks a enum type as a bit flag enum. Bit flag enums will have their enum cases assigned to powers of 2 instead of consecutive integers.\n")
SLANG_RAW("///\n")
SLANG_RAW("__attributeTarget(EnumDecl)\n")
SLANG_RAW("attribute_syntax[Flags] : FlagsAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("// Statement Attributes\n")
SLANG_RAW("\n")
SLANG_RAW("/// A hint to the downstream compiler to unroll the loop until the specified number of iterations reached.\n")
SLANG_RAW("/// This attribute does not affect Slang compiler's behavior.\n")
SLANG_RAW("/// To unroll a loop in the Slang compiler before emitting target code, use the `[ForceUnroll]` attribute.\n")
SLANG_RAW("__attributeTarget(LoopStmt)\n")
SLANG_RAW("attribute_syntax [unroll(count: int = 0)]   : UnrollAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// Instructs the Slang compiler to unroll the loop until the specified number of iterations before\n")
SLANG_RAW("/// emiting targett code.\n")
SLANG_RAW("/// @param count The maximun number of iterations to unroll the loop.\n")
SLANG_RAW("__attributeTarget(LoopStmt)\n")
SLANG_RAW("attribute_syntax [ForceUnroll(count: int = 0)]   : ForceUnrollAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// A hint to the downstream compiler to preserve a loop.\n")
SLANG_RAW("__attributeTarget(LoopStmt)\n")
SLANG_RAW("attribute_syntax [loop]                 : LoopAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// Used on loop statements as a hint to the downstream compiler to perform less aggressive optimization on the loop\n")
SLANG_RAW("/// in favor of faster compilation time.\n")
SLANG_RAW("/// This attribute has no effect on targets other than HLSL.\n")
SLANG_RAW("__attributeTarget(LoopStmt)\n")
SLANG_RAW("attribute_syntax [fastopt]              : FastOptAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// A hint to the downstream compiler that UAV conditions are allowed in the loop.\n")
SLANG_RAW("/// This attribute has no effect on targets other than HLSL.\n")
SLANG_RAW("/// @deprecated\n")
SLANG_RAW("__attributeTarget(LoopStmt)\n")
SLANG_RAW("attribute_syntax [allow_uav_condition]  : AllowUAVConditionAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("__attributeTarget(LoopStmt)\n")
SLANG_RAW("attribute_syntax [MaxIters(count)]      : MaxItersAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// A hint to the downstream compiler to flatten an if statement.\n")
SLANG_RAW("__attributeTarget(IfStmt)\n")
SLANG_RAW("attribute_syntax [flatten]              : FlattenAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// A hint to the downstream compiler to preserve the branching behavior of an if statement.\n")
SLANG_RAW("__attributeTarget(IfStmt)\n")
SLANG_RAW("__attributeTarget(SwitchStmt)\n")
SLANG_RAW("attribute_syntax [branch]               : BranchAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// A hint to the downstream compiler to preserve the `switch` statement as is.\n")
SLANG_RAW("/// This attribute has no effect on targets other than HLSL.\n")
SLANG_RAW("__attributeTarget(SwitchStmt)\n")
SLANG_RAW("attribute_syntax [forcecase]            : ForceCaseAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// A hint to the downstream compiler to translate the `switch` statement into subroutine calls.\n")
SLANG_RAW("/// This attribute has no effect on targets other than HLSL.\n")
SLANG_RAW("__attributeTarget(SwitchStmt)\n")
SLANG_RAW("attribute_syntax [call]                 : CallAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("// Entry-point Attributes\n")
SLANG_RAW("\n")
SLANG_RAW("// All Stages\n")
SLANG_RAW("\n")
SLANG_RAW("/// Marks a function as a shader entry point.\n")
SLANG_RAW("/// @param stage The stage of the shader. Must be one of \"vertex\", \"fragment\", \"compute\", \"geometry\", \"hull\", \"domain\", \"raygeneration\",\n")
SLANG_RAW("// \"intersection\", \"anyhit\", \"closesthit\", \"miss\", \"callable\", \"task\", \"mesh\".\n")
SLANG_RAW("__attributeTarget(FuncDecl)\n")
SLANG_RAW("attribute_syntax [shader(stage)]    : EntryPointAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// Marks a function as a shader entry point.\n")
SLANG_RAW("/// @param stage The stage of the shader. Must be one of \"vertex\", \"fragment\", \"compute\", \"geometry\", \"hull\", \"domain\", \"raygeneration\",\n")
SLANG_RAW("// \"intersection\", \"anyhit\", \"closesthit\", \"miss\", \"callable\", \"task\", \"mesh\".\n")
SLANG_RAW("__attributeTarget(FuncDecl)\n")
SLANG_RAW("attribute_syntax [Shader(stage)]    : EntryPointAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("// Hull Shader\n")
SLANG_RAW("/// Used on an hull shader entrypoint to declare the upperbound of the tessellation factor that the hull shader can return.\n")
SLANG_RAW("/// @param factor The maximum tessellation factor the hull shader can return.\n")
SLANG_RAW("__attributeTarget(FuncDecl)\n")
SLANG_RAW("attribute_syntax [maxtessfactor(factor: float)]     : MaxTessFactorAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// Used on an hull shader entrypoint to declare the number of control points the hull shader will produce per thread.\n")
SLANG_RAW("/// @param count The number of control points the hull shader will produce per thread.\n")
SLANG_RAW("/// @remarks The attribute indicates be the number of times the hull shader function will be executed.\n")
SLANG_RAW("__attributeTarget(FuncDecl)\n")
SLANG_RAW("attribute_syntax [outputcontrolpoints(count: int)]  : OutputControlPointsAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// Used on an hull shader entrypoint to declare the output primitive type of the tessellator.\n")
SLANG_RAW("/// @param topology The output primitive type, must be one of \"point\", \"line\", \"triangle_cw\", and \"triangle_ccw\".\n")
SLANG_RAW("__attributeTarget(FuncDecl)\n")
SLANG_RAW("attribute_syntax [outputtopology(topology)]         : OutputTopologyAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// Used on an hull shader entrypoint to specify the patch type used by the hull shader.\n")
SLANG_RAW("/// @param mode The patch type used by the hull shader. Valid values are \"tri\", \"quad\" and \"isoline\".\n")
SLANG_RAW("__attributeTarget(FuncDecl)\n")
SLANG_RAW("attribute_syntax [partitioning(mode)]               : PartitioningAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// Used on a hull shader entrypoint to specify the associated function that computes the patch constant data.\n")
SLANG_RAW("/// @param name The name of the function (in string literal) that computes the patch constant data.\n")
SLANG_RAW("__attributeTarget(FuncDecl)\n")
SLANG_RAW("attribute_syntax [patchconstantfunc(name)]          : PatchConstantFuncAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("// Hull/Domain Shader\n")
SLANG_RAW("\n")
SLANG_RAW("/// Used on an hull shader entrypoint to specify the patch type used by the hull shader.\n")
SLANG_RAW("/// @param patchType The patch type used by the hull shader. Valid values are \"tri\", \"quad\" and \"isoline\".\n")
SLANG_RAW("__attributeTarget(FuncDecl)\n")
SLANG_RAW("attribute_syntax [domain(patchType)]   : DomainAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("// Geometry Shader\n")
SLANG_RAW("\n")
SLANG_RAW("/// Used on a geometry shader entry point to specify the maximum number of vertices that the geometry shader can output.\n")
SLANG_RAW("/// @param count The maximum number of vertices that the geometry shader can output.\n")
SLANG_RAW("__attributeTarget(FuncDecl)\n")
SLANG_RAW("attribute_syntax [maxvertexcount(count: int)]   : MaxVertexCountAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// Used on a geometry shader entry point to specify the number of instances to execute for each input primitive.\n")
SLANG_RAW("/// @param count The number of instances to execute for each input primitive. \n")
SLANG_RAW("/// @remarks When using this attribute, a geometry shader can declare a parameter with `SV_GSInstanceID` semantic to get the instance index.\n")
SLANG_RAW("__attributeTarget(FuncDecl)\n")
SLANG_RAW("attribute_syntax [instance(count: int)]         : InstanceAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("// Fragment (\"Pixel\") Shader\n")
SLANG_RAW("/// Used on a fragment shader entry point to specify that early depth stencil testing can be enabled.\n")
SLANG_RAW("__attributeTarget(FuncDecl)\n")
SLANG_RAW("attribute_syntax [earlydepthstencil]    : EarlyDepthStencilAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("// Compute Shader\n")
SLANG_RAW("\n")
SLANG_RAW("/// Specifies the size of the thread group a compute shader.\n")
SLANG_RAW("/// @param x The number of threads in the x dimension of a thread group.\n")
SLANG_RAW("/// @param y The number of threads in the y dimension of a thread group.\n")
SLANG_RAW("/// @param z The number of threads in the z dimension of a thread group.\n")
SLANG_RAW("__attributeTarget(FuncDecl)\n")
SLANG_RAW("attribute_syntax [numthreads(x: int, y: int = 1, z: int = 1)]   : NumThreadsAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// Specifies the size of the thread group a compute shader.\n")
SLANG_RAW("/// @param x The number of threads in the x dimension of a thread group.\n")
SLANG_RAW("/// @param y The number of threads in the y dimension of a thread group.\n")
SLANG_RAW("/// @param z The number of threads in the z dimension of a thread group.\n")
SLANG_RAW("__attributeTarget(FuncDecl)\n")
SLANG_RAW("attribute_syntax [NumThreads(x: int, y: int = 1, z: int = 1)]   : NumThreadsAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// Indicate a compute shader entry point is only compatible with the specified wave size.\n")
SLANG_RAW("/// @param numLanes The wave size this shader entrypoint is compatible with. Must be one of 4, 8, 16, 32, 64, 128.\n")
SLANG_RAW("__attributeTarget(FuncDecl)\n")
SLANG_RAW("attribute_syntax [WaveSize(numLanes: int)]   : WaveSizeAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("//@hidden:\n")
SLANG_RAW("__attributeTarget(VarDeclBase)\n")
SLANG_RAW("attribute_syntax [__vulkanRayPayload(location : int = -1)] : VulkanRayPayloadAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("__attributeTarget(VarDeclBase)\n")
SLANG_RAW("attribute_syntax [__vulkanCallablePayload(location : int = -1)] : VulkanCallablePayloadAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("__attributeTarget(VarDeclBase)\n")
SLANG_RAW("attribute_syntax [__vulkanHitObjectAttributes(location : int = -1)] : VulkanHitObjectAttributesAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("__attributeTarget(VarDeclBase)\n")
SLANG_RAW("attribute_syntax [__vulkanHitAttributes] : VulkanHitAttributesAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("//@public:\n")
SLANG_RAW("/// Mark a function or a property or subscript accessor as mutating. A mutating function receives the implicit `this` parameter\n")
SLANG_RAW("/// as an `inout` parameter, so that mutations to members access from `this` argument will be visible to the caller.\n")
SLANG_RAW("///\n")
SLANG_RAW("/// @remarks\n")
SLANG_RAW("/// By default, Slang treats all member functions as non-mutating. For example, consider the following function:\n")
SLANG_RAW("/// ```csharp\n")
SLANG_RAW("/// struct S\n")
SLANG_RAW("/// {\n")
SLANG_RAW("///    int x;\n")
SLANG_RAW("///    void foo()\n")
SLANG_RAW("///    {\n")
SLANG_RAW("///       x = 1; // error: `x` is not an l-value.\n")
SLANG_RAW("///    }\n")
SLANG_RAW("/// }\n")
SLANG_RAW("///\n")
SLANG_RAW("/// ```\n")
SLANG_RAW("/// The line `x = 1` will lead to a compile time error because by-default, all member methods in Slang are non-mutating. To\n")
SLANG_RAW("/// allow `foo` to modify `x`, you can use `[mutating]` to mark the function as such:\n")
SLANG_RAW("/// ```csharp\n")
SLANG_RAW("/// struct S\n")
SLANG_RAW("/// {\n")
SLANG_RAW("///    int x;\n")
SLANG_RAW("///    [mutating]\n")
SLANG_RAW("///    void foo()\n")
SLANG_RAW("///    {\n")
SLANG_RAW("///       x = 1; // ok\n")
SLANG_RAW("///    }\n")
SLANG_RAW("/// }\n")
SLANG_RAW("/// ```\n")
SLANG_RAW("/// @see `[nonmutating]`.\n")
SLANG_RAW("///\n")
SLANG_RAW("__attributeTarget(FunctionDeclBase)\n")
SLANG_RAW("attribute_syntax [mutating] : MutatingAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// Marks a function or a property and subscript accessor as non-mutating. A non-mutating function receives the implicit `this` parameter\n")
SLANG_RAW("/// as an `in` parameter, so mutations to members accessed from `this` argument will be prohibited by the compiler.\n")
SLANG_RAW("/// @remarks\n")
SLANG_RAW("/// Member functions of a type are non-mutating by default, so this attribute is not necessary in most cases.\n")
SLANG_RAW("/// However, the `set` accessor of a property or subscript is mutating by default, and you can use `[nonmutating]` to mark it as non-mutating.\n")
SLANG_RAW("/// For example:\n")
SLANG_RAW("/// ```csharp\n")
SLANG_RAW("/// struct S\n")
SLANG_RAW("/// {\n")
SLANG_RAW("///    int* ptr_x;\n")
SLANG_RAW("///    property x : int\n")
SLANG_RAW("///    {\n")
SLANG_RAW("///      get { return *ptr_x; }\n")
SLANG_RAW("///\n")
SLANG_RAW("///      [nonmutating]\n")
SLANG_RAW("///      set { *ptr_x = value; }\n")
SLANG_RAW("///    }\n")
SLANG_RAW("/// }\n")
SLANG_RAW("/// uniform S s; // `s` is not mutable.\n")
SLANG_RAW("/// void test() { s.x = 1; } // OK, because the `set` accessor is non-mutating.\n")
SLANG_RAW("/// ```\n")
SLANG_RAW("/// In the above example, the property `x` reads and writes to a memory location pointed to by `ptr_x`. Therefore, the `set` accessor is not actually\n")
SLANG_RAW("/// modifying any field of `S`, and does not need to take `this` as an `inout` parameter. Using `[nonmutating]` here on the set accessor will allow\n")
SLANG_RAW("/// it to be called with a non-mutating value of `S`.\n")
SLANG_RAW("/// @see `[mutating]`.\n")
SLANG_RAW("///\n")
SLANG_RAW("__attributeTarget(AccessorDecl)\n")
SLANG_RAW("attribute_syntax [nonmutating] : NonmutatingAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// @internal\n")
SLANG_RAW("/// Marks a member function to make `this` argument passed by const reference.\n")
SLANG_RAW("__attributeTarget(FunctionDeclBase)\n")
SLANG_RAW("attribute_syntax [constref] : ConstRefAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// @internal\n")
SLANG_RAW("/// Marks a member function to make `this` argument passed by reference.\n")
SLANG_RAW("__attributeTarget(FunctionDeclBase)\n")
SLANG_RAW("attribute_syntax [__ref] : RefAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// @internal\n")
SLANG_RAW("/// Indicates that a function computes its result as a function of its arguments without loading/storing any memory or other state.\n")
SLANG_RAW("///\n")
SLANG_RAW("/// This is equivalent to the LLVM `readnone` function attribute.\n")
SLANG_RAW("__attributeTarget(FunctionDeclBase)\n")
SLANG_RAW("attribute_syntax [__readNone] : ReadNoneAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// Represents the applicable target for an attribute.\n")
SLANG_RAW("enum _AttributeTargets\n")
SLANG_RAW("{\n")
SLANG_RAW("    Struct = ")
SLANG_SPLICE( (int) UserDefinedAttributeTargets::Struct
)
SLANG_RAW(", /// Struct types.\n")
SLANG_RAW("    Var = ")
SLANG_SPLICE( (int) UserDefinedAttributeTargets::Var
)
SLANG_RAW(", /// Global and local variables and constants.\n")
SLANG_RAW("    Function = ")
SLANG_SPLICE( (int) UserDefinedAttributeTargets::Function
)
SLANG_RAW(", /// Functions or member functions.\n")
SLANG_RAW("    Param = ")
SLANG_SPLICE( (int) UserDefinedAttributeTargets::Param
)
SLANG_RAW(", /// Function parameters.\n")
SLANG_RAW("};\n")
SLANG_RAW("\n")
SLANG_RAW("/// Mark a struct type as a user defined attribute type.\n")
SLANG_RAW("/// @param target The type of declarations to which the attribute can be applied.\n")
SLANG_RAW("__attributeTarget(StructDecl)\n")
SLANG_RAW("attribute_syntax [__AttributeUsage(target : _AttributeTargets)] : AttributeUsageAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// Specify the storage format of a read-write texture. Can only be used on a texture typed struct field or global parameter.\n")
SLANG_RAW("/// @param format The storage format of the texture.\n")
SLANG_RAW("/// @see Please refer to `_Texture` for a complete list of allowed format strings.\n")
SLANG_RAW("__attributeTarget(VarDeclBase)\n")
SLANG_RAW("attribute_syntax [format(format : String)] : FormatAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// Specify the storage format of a read-write texture. Can only be used on a texture typed struct field or global parameter.\n")
SLANG_RAW("/// This is an alias of the `[format]` attribute.\n")
SLANG_RAW("/// @param format The storage format of the texture.\n")
SLANG_RAW("/// @see Please refer to `_Texture` for a complete list of allowed format strings.\n")
SLANG_RAW("__attributeTarget(VarDeclBase)\n")
SLANG_RAW("attribute_syntax [vk_image_format(format : String)] : FormatAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("__attributeTarget(Decl)\n")
SLANG_RAW("attribute_syntax [allow(diagnostic: String)] : AllowAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// Mark declaration to require a specific target capability.\n")
SLANG_RAW("/// @param capability The required capability.\n")
SLANG_RAW("__attributeTarget(Decl)\n")
SLANG_RAW("attribute_syntax [require(capability)] : RequireCapabilityAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("// Linking\n")
SLANG_RAW("__attributeTarget(Decl)\n")
SLANG_RAW("attribute_syntax [__extern] : ExternAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("__attributeTarget(FunctionDeclBase)\n")
SLANG_RAW("attribute_syntax [__unsafeForceInlineEarly] : UnsafeForceInlineEarlyAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// Perform inlining of the function at the call site during Slang compilation.\n")
SLANG_RAW("/// @remarks By default Slang does not inline user defined functions, and will preserve the function call hierarchy in the generated code.\n")
SLANG_RAW("/// Use this attribute on a function to force the Slang compiler to inline the function before emitting target code.\n")
SLANG_RAW("__attributeTarget(FunctionDeclBase)\n")
SLANG_RAW("attribute_syntax [ForceInline] : ForceInlineAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// @internal\n")
SLANG_RAW("/// Specify the overload rank of a function for overload resolution.\n")
SLANG_RAW("__attributeTarget(FunctionDeclBase)\n")
SLANG_RAW("attribute_syntax [OverloadRank] : OverloadRankAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// @experimental\n")
SLANG_RAW("/// Mark a function as imported from a DLL. Valid only on CPU host targets.\n")
SLANG_RAW("__attributeTarget(FuncDecl)\n")
SLANG_RAW("attribute_syntax [DllImport(modulePath: String)] : DllImportAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// @experimental\n")
SLANG_RAW("/// Mark a function to be exported as a DLL symbol. Valid only on CPU host targets.\n")
SLANG_RAW("__attributeTarget(FuncDecl)\n")
SLANG_RAW("attribute_syntax [DllExport] : DllExportAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// @experimental\n")
SLANG_RAW("/// Mark a function as a pytorch kernel entrypoint.\n")
SLANG_RAW("__attributeTarget(FuncDecl)\n")
SLANG_RAW("attribute_syntax [TorchEntryPoint] : TorchEntryPointAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// @experimental\n")
SLANG_RAW("/// Mark a function for export as a CUDA device function. Valid only on CUDA target.\n")
SLANG_RAW("__attributeTarget(FuncDecl)\n")
SLANG_RAW("attribute_syntax [CudaDeviceExport] : CudaDeviceExportAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// @experimental\n")
SLANG_RAW("/// Mark a function for export as a CUDA host function. Valid only on CUDA target.\n")
SLANG_RAW("__attributeTarget(FuncDecl)\n")
SLANG_RAW("attribute_syntax [CudaHost] : CudaHostAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// @experimental\n")
SLANG_RAW("/// Mark a function for export as a CUDA kernel function. Valid only on CUDA target.\n")
SLANG_RAW("__attributeTarget(FuncDecl)\n")
SLANG_RAW("attribute_syntax [CudaKernel] : CudaKernelAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// @experimental\n")
SLANG_RAW("/// Mark a function for export as a CUDA device function. Valid only on CUDA target.\n")
SLANG_RAW("__attributeTarget(FuncDecl)\n")
SLANG_RAW("attribute_syntax [CUDADeviceExport] : CudaDeviceExportAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// @experimental\n")
SLANG_RAW("/// Mark a function for export as a CUDA host function. Valid only on CUDA target.\n")
SLANG_RAW("__attributeTarget(FuncDecl)\n")
SLANG_RAW("attribute_syntax [CUDAHost] : CudaHostAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// @experimental\n")
SLANG_RAW("/// Mark a function for export as a CUDA kernel function. Valid only on CUDA target.\n")
SLANG_RAW("__attributeTarget(FuncDecl)\n")
SLANG_RAW("attribute_syntax [CUDAKernel] : CudaKernelAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// @experimental\n")
SLANG_RAW("/// Mark a function for automatic pytorch binding.\n")
SLANG_RAW("__attributeTarget(FuncDecl)\n")
SLANG_RAW("attribute_syntax [AutoPyBindCUDA] : AutoPyBindCudaAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// @experimental\n")
SLANG_RAW("/// Mark a type for export to slang-torch.\n")
SLANG_RAW("__attributeTarget(AggTypeDecl)\n")
SLANG_RAW("attribute_syntax [PyExport(name: String)] : PyExportAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// @experimental\n")
SLANG_RAW("/// Mark an interface as a COM interface. Valid only on CPU target.\n")
SLANG_RAW("/// @param guid The GUID of the COM interface.\n")
SLANG_RAW("__attributeTarget(InterfaceDecl)\n")
SLANG_RAW("attribute_syntax [COM(guid: String)] : ComInterfaceAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("// Inheritance Control\n")
SLANG_RAW("\n")
SLANG_RAW("/// @experimental\n")
SLANG_RAW("/// Mark a type as sealed, preventing it from being inherited from or implemented by types defined in other modules.\n")
SLANG_RAW("/// @see `[open]`.\n")
SLANG_RAW("__attributeTarget(AggTypeDecl)\n")
SLANG_RAW("attribute_syntax [sealed] : SealedAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// @experimental\n")
SLANG_RAW("/// Mark a type as open, allowing it from being inherited from or implemented by types defined in other modules.\n")
SLANG_RAW("/// This is the default behavior.\n")
SLANG_RAW("/// @see `[sealed]`.\n")
SLANG_RAW("__attributeTarget(AggTypeDecl)\n")
SLANG_RAW("attribute_syntax [open] : OpenAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// @experimental\n")
SLANG_RAW("/// Mark an interface type to allow dynmaic dispatch, and declare the maximum size in bytes that an implementation type\n")
SLANG_RAW("/// of the interface can have.\n")
SLANG_RAW("__attributeTarget(InterfaceDecl)\n")
SLANG_RAW("attribute_syntax [anyValueSize(size:int)] : AnyValueSizeAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// @experimental\n")
SLANG_RAW("/// Mark an interface type for specialization only. Such interface types cannot be used for dynamic dispatch.\n")
SLANG_RAW("__attributeTarget(InterfaceDecl)\n")
SLANG_RAW("attribute_syntax [Specialize] : SpecializeAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// @internal\n")
SLANG_RAW("/// Marks a declaration as a builtin declaration.\n")
SLANG_RAW("__attributeTarget(DeclBase)\n")
SLANG_RAW("attribute_syntax [builtin] : BuiltinAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("// @hidden:\n")
SLANG_RAW("__attributeTarget(DeclBase)\n")
SLANG_RAW("attribute_syntax[__AutoDiffBuiltin] : AutoDiffBuiltinAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("__attributeTarget(DeclBase)\n")
SLANG_RAW("attribute_syntax [__requiresNVAPI] : RequiresNVAPIAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("// @public:\n")
SLANG_RAW("\n")
SLANG_RAW("/// Mark a type to require a target specific prelude.\n")
SLANG_RAW("/// The prelude will be included in the generated code for the specified target if the resulting code uses\n")
SLANG_RAW("/// the marked type.\n")
SLANG_RAW("__attributeTarget(AggTypeDecl)\n")
SLANG_RAW("attribute_syntax[RequirePrelude(target, prelude:String)] : RequirePreludeAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("__attributeTarget(DeclBase)\n")
SLANG_RAW("attribute_syntax [__AlwaysFoldIntoUseSiteAttribute] : AlwaysFoldIntoUseSiteAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// Inform the downstream compiler to not inline the function.\n")
SLANG_RAW("__attributeTarget(FunctionDeclBase)\n")
SLANG_RAW("attribute_syntax [noinline] : NoInlineAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("__attributeTarget(StructDecl)\n")
SLANG_RAW("attribute_syntax [payload] : PayloadAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// Mark a declaration as deprecated.\n")
SLANG_RAW("/// @param message The diagnostic message to show when the declaration is used.\n")
SLANG_RAW("__attributeTarget(DeclBase)\n")
SLANG_RAW("attribute_syntax [deprecated(message: String)] : DeprecatedAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// Controls the behavior of the compiler when a differentiable function is detected to have side-effects.\n")
SLANG_RAW("/// @category misc_types\n")
SLANG_RAW("enum SideEffectBehavior\n")
SLANG_RAW("{\n")
SLANG_RAW("    /// Causes a warning if the method is detected to have side-effects\n")
SLANG_RAW("    Warn = 0,\n")
SLANG_RAW("\n")
SLANG_RAW("    /// Suppresses the warning\n")
SLANG_RAW("    Allow = 1\n")
SLANG_RAW("};\n")
SLANG_RAW("\n")
SLANG_RAW("/// Mark a differentiable function to prefer recomputation over checkpointing when a value computed in the primal pass is needed\n")
SLANG_RAW("/// during backward derivative propagation.\n")
SLANG_RAW("__attributeTarget(FunctionDeclBase)\n")
SLANG_RAW("attribute_syntax[PreferRecompute(behavior: SideEffectBehavior = SideEffectBehavior.Warn)] : PreferRecomputeAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// Mark a differentiable function to prefer checkpointing over recomputation when a value computed in the primal pass is needed\n")
SLANG_RAW("/// during backward derivative propagation.\n")
SLANG_RAW("__attributeTarget(FunctionDeclBase)\n")
SLANG_RAW("attribute_syntax [PreferCheckpoint] : PreferCheckpointAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("// @hidden:\n")
SLANG_RAW("__attributeTarget(DeclBase)\n")
SLANG_RAW("attribute_syntax [KnownBuiltin(name : String)] : KnownBuiltinAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("__attributeTarget(FunctionDeclBase)\n")
SLANG_RAW("attribute_syntax [__GLSLRequireShaderInputParameter(parameterNumber:int)] : GLSLRequireShaderInputParameterAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("__attributeTarget(FuncDecl)\n")
SLANG_RAW("attribute_syntax [noRefInline] : NoRefInlineAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("// @public:\n")
SLANG_RAW("\n")
SLANG_RAW("/// Mark a function's return value as non-uniform.\n")
SLANG_RAW("__attributeTarget(FunctionDeclBase)\n")
SLANG_RAW("attribute_syntax [NonUniformReturn] : NonDynamicUniformAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// Mark a compute shader entry point to allow it to use implicit derivatives.\n")
SLANG_RAW("/// @remarks This attributes causes Slang to emit `DerivativeGroupQuadsNV` execution mode when producing SPIR-V. The attribute has no\n")
SLANG_RAW("/// effect on other targets.\n")
SLANG_RAW("__attributeTarget(FuncDecl)\n")
SLANG_RAW("attribute_syntax [DerivativeGroupQuad] : DerivativeGroupQuadAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// Mark a compute shader entry point to allow it to use implicit derivatives.\n")
SLANG_RAW("/// @remarks This attributes causes Slang to emit `DerivativeGroupLinearNV` execution mode when producing SPIR-V. The attribute has no\n")
SLANG_RAW("/// effect on other targets.\n")
SLANG_RAW("__attributeTarget(FuncDecl)\n")
SLANG_RAW("attribute_syntax [DerivativeGroupLinear] : DerivativeGroupLinearAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// Emits `MaximallyReconvergesKHR` execution mode when producing SPIR-V.\n")
SLANG_RAW("/// This attribute has no effect on other targets.\n")
SLANG_RAW("__attributeTarget(FuncDecl)\n")
SLANG_RAW("attribute_syntax [MaximallyReconverges] : MaximallyReconvergesAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// Emits `QuadDerivativesKHR` execution mode when producing SPIR-V.\n")
SLANG_RAW("/// This attribute has no effect on other targets.\n")
SLANG_RAW("__attributeTarget(FuncDecl)\n")
SLANG_RAW("attribute_syntax [QuadDerivatives] : QuadDerivativesAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("/// Emits `RequireFullQuadsKHR` execution mode when producing SPIR-V.\n")
SLANG_RAW("/// This attribute has no effect on other targets.\n")
SLANG_RAW("__attributeTarget(FuncDecl)\n")
SLANG_RAW("attribute_syntax [RequireFullQuads] : RequireFullQuadsAttribute;\n")
SLANG_RAW("\n")
SLANG_RAW("__generic<T>\n")
SLANG_RAW("typealias NodePayloadPtr = Ptr<T, ")
SLANG_SPLICE( (uint64_t)AddressSpace::NodePayloadAMDX
)
SLANG_RAW(">;\n")
SLANG_RAW("\n")
SLANG_RAW("__attributeTarget(StructDecl)\n")
SLANG_RAW("attribute_syntax [raypayload] : RayPayloadAttribute;\n")
SLANG_RAW("\n")
