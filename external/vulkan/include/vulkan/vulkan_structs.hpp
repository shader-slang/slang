// Copyright 2015-2021 The Khronos Group Inc.
//
// SPDX-License-Identifier: Apache-2.0 OR MIT
//

// This header is generated from the Khronos Vulkan XML API Registry.

#ifndef VULKAN_STRUCTS_HPP
#define VULKAN_STRUCTS_HPP

namespace VULKAN_HPP_NAMESPACE
{
  struct AabbPositionsKHR
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR AabbPositionsKHR( float minX_ = {},
                                           float minY_ = {},
                                           float minZ_ = {},
                                           float maxX_ = {},
                                           float maxY_ = {},
                                           float maxZ_ = {} ) VULKAN_HPP_NOEXCEPT
      : minX( minX_ )
      , minY( minY_ )
      , minZ( minZ_ )
      , maxX( maxX_ )
      , maxY( maxY_ )
      , maxZ( maxZ_ )
    {}

    VULKAN_HPP_CONSTEXPR AabbPositionsKHR( AabbPositionsKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AabbPositionsKHR( VkAabbPositionsKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : AabbPositionsKHR( *reinterpret_cast<AabbPositionsKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 AabbPositionsKHR & operator=( AabbPositionsKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AabbPositionsKHR & operator=( VkAabbPositionsKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::AabbPositionsKHR const *>( &rhs );
      return *this;
    }

    AabbPositionsKHR & setMinX( float minX_ ) VULKAN_HPP_NOEXCEPT
    {
      minX = minX_;
      return *this;
    }

    AabbPositionsKHR & setMinY( float minY_ ) VULKAN_HPP_NOEXCEPT
    {
      minY = minY_;
      return *this;
    }

    AabbPositionsKHR & setMinZ( float minZ_ ) VULKAN_HPP_NOEXCEPT
    {
      minZ = minZ_;
      return *this;
    }

    AabbPositionsKHR & setMaxX( float maxX_ ) VULKAN_HPP_NOEXCEPT
    {
      maxX = maxX_;
      return *this;
    }

    AabbPositionsKHR & setMaxY( float maxY_ ) VULKAN_HPP_NOEXCEPT
    {
      maxY = maxY_;
      return *this;
    }

    AabbPositionsKHR & setMaxZ( float maxZ_ ) VULKAN_HPP_NOEXCEPT
    {
      maxZ = maxZ_;
      return *this;
    }

    operator VkAabbPositionsKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkAabbPositionsKHR *>( this );
    }

    operator VkAabbPositionsKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkAabbPositionsKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( AabbPositionsKHR const & ) const = default;
#else
    bool operator==( AabbPositionsKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( minX == rhs.minX ) && ( minY == rhs.minY ) && ( minZ == rhs.minZ ) && ( maxX == rhs.maxX ) &&
             ( maxY == rhs.maxY ) && ( maxZ == rhs.maxZ );
    }

    bool operator!=( AabbPositionsKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    float minX = {};
    float minY = {};
    float minZ = {};
    float maxX = {};
    float maxY = {};
    float maxZ = {};
  };
  static_assert( sizeof( AabbPositionsKHR ) == sizeof( VkAabbPositionsKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<AabbPositionsKHR>::value, "struct wrapper is not a standard layout!" );
  using AabbPositionsNV = AabbPositionsKHR;

  union DeviceOrHostAddressConstKHR
  {
    DeviceOrHostAddressConstKHR( VULKAN_HPP_NAMESPACE::DeviceOrHostAddressConstKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      memcpy( static_cast<void *>( this ), &rhs, sizeof( VULKAN_HPP_NAMESPACE::DeviceOrHostAddressConstKHR ) );
    }

    DeviceOrHostAddressConstKHR( VULKAN_HPP_NAMESPACE::DeviceAddress deviceAddress_ = {} )
      : deviceAddress( deviceAddress_ )
    {}

    DeviceOrHostAddressConstKHR( const void * hostAddress_ ) : hostAddress( hostAddress_ ) {}

    DeviceOrHostAddressConstKHR &
      setDeviceAddress( VULKAN_HPP_NAMESPACE::DeviceAddress deviceAddress_ ) VULKAN_HPP_NOEXCEPT
    {
      deviceAddress = deviceAddress_;
      return *this;
    }

    DeviceOrHostAddressConstKHR & setHostAddress( const void * hostAddress_ ) VULKAN_HPP_NOEXCEPT
    {
      hostAddress = hostAddress_;
      return *this;
    }

    VULKAN_HPP_NAMESPACE::DeviceOrHostAddressConstKHR &
      operator=( VULKAN_HPP_NAMESPACE::DeviceOrHostAddressConstKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      memcpy( static_cast<void *>( this ), &rhs, sizeof( VULKAN_HPP_NAMESPACE::DeviceOrHostAddressConstKHR ) );
      return *this;
    }

    operator VkDeviceOrHostAddressConstKHR const &() const
    {
      return *reinterpret_cast<const VkDeviceOrHostAddressConstKHR *>( this );
    }

    operator VkDeviceOrHostAddressConstKHR &()
    {
      return *reinterpret_cast<VkDeviceOrHostAddressConstKHR *>( this );
    }

#ifdef VULKAN_HPP_HAS_UNRESTRICTED_UNIONS
    VULKAN_HPP_NAMESPACE::DeviceAddress deviceAddress;
    const void *                        hostAddress;
#else
    VkDeviceAddress                                 deviceAddress;
    const void *                                    hostAddress;
#endif /*VULKAN_HPP_HAS_UNRESTRICTED_UNIONS*/
  };

  struct AccelerationStructureGeometryTrianglesDataKHR
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eAccelerationStructureGeometryTrianglesDataKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    AccelerationStructureGeometryTrianglesDataKHR(
      VULKAN_HPP_NAMESPACE::Format                      vertexFormat_  = VULKAN_HPP_NAMESPACE::Format::eUndefined,
      VULKAN_HPP_NAMESPACE::DeviceOrHostAddressConstKHR vertexData_    = {},
      VULKAN_HPP_NAMESPACE::DeviceSize                  vertexStride_  = {},
      uint32_t                                          maxVertex_     = {},
      VULKAN_HPP_NAMESPACE::IndexType                   indexType_     = VULKAN_HPP_NAMESPACE::IndexType::eUint16,
      VULKAN_HPP_NAMESPACE::DeviceOrHostAddressConstKHR indexData_     = {},
      VULKAN_HPP_NAMESPACE::DeviceOrHostAddressConstKHR transformData_ = {} ) VULKAN_HPP_NOEXCEPT
      : vertexFormat( vertexFormat_ )
      , vertexData( vertexData_ )
      , vertexStride( vertexStride_ )
      , maxVertex( maxVertex_ )
      , indexType( indexType_ )
      , indexData( indexData_ )
      , transformData( transformData_ )
    {}

    AccelerationStructureGeometryTrianglesDataKHR( AccelerationStructureGeometryTrianglesDataKHR const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    AccelerationStructureGeometryTrianglesDataKHR( VkAccelerationStructureGeometryTrianglesDataKHR const & rhs )
      VULKAN_HPP_NOEXCEPT
      : AccelerationStructureGeometryTrianglesDataKHR(
          *reinterpret_cast<AccelerationStructureGeometryTrianglesDataKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    AccelerationStructureGeometryTrianglesDataKHR &
      operator=( AccelerationStructureGeometryTrianglesDataKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AccelerationStructureGeometryTrianglesDataKHR &
      operator=( VkAccelerationStructureGeometryTrianglesDataKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::AccelerationStructureGeometryTrianglesDataKHR const *>( &rhs );
      return *this;
    }

    AccelerationStructureGeometryTrianglesDataKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    AccelerationStructureGeometryTrianglesDataKHR &
      setVertexFormat( VULKAN_HPP_NAMESPACE::Format vertexFormat_ ) VULKAN_HPP_NOEXCEPT
    {
      vertexFormat = vertexFormat_;
      return *this;
    }

    AccelerationStructureGeometryTrianglesDataKHR &
      setVertexData( VULKAN_HPP_NAMESPACE::DeviceOrHostAddressConstKHR const & vertexData_ ) VULKAN_HPP_NOEXCEPT
    {
      vertexData = vertexData_;
      return *this;
    }

    AccelerationStructureGeometryTrianglesDataKHR &
      setVertexStride( VULKAN_HPP_NAMESPACE::DeviceSize vertexStride_ ) VULKAN_HPP_NOEXCEPT
    {
      vertexStride = vertexStride_;
      return *this;
    }

    AccelerationStructureGeometryTrianglesDataKHR & setMaxVertex( uint32_t maxVertex_ ) VULKAN_HPP_NOEXCEPT
    {
      maxVertex = maxVertex_;
      return *this;
    }

    AccelerationStructureGeometryTrianglesDataKHR &
      setIndexType( VULKAN_HPP_NAMESPACE::IndexType indexType_ ) VULKAN_HPP_NOEXCEPT
    {
      indexType = indexType_;
      return *this;
    }

    AccelerationStructureGeometryTrianglesDataKHR &
      setIndexData( VULKAN_HPP_NAMESPACE::DeviceOrHostAddressConstKHR const & indexData_ ) VULKAN_HPP_NOEXCEPT
    {
      indexData = indexData_;
      return *this;
    }

    AccelerationStructureGeometryTrianglesDataKHR &
      setTransformData( VULKAN_HPP_NAMESPACE::DeviceOrHostAddressConstKHR const & transformData_ ) VULKAN_HPP_NOEXCEPT
    {
      transformData = transformData_;
      return *this;
    }

    operator VkAccelerationStructureGeometryTrianglesDataKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkAccelerationStructureGeometryTrianglesDataKHR *>( this );
    }

    operator VkAccelerationStructureGeometryTrianglesDataKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkAccelerationStructureGeometryTrianglesDataKHR *>( this );
    }

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType        = StructureType::eAccelerationStructureGeometryTrianglesDataKHR;
    const void *                        pNext        = {};
    VULKAN_HPP_NAMESPACE::Format        vertexFormat = VULKAN_HPP_NAMESPACE::Format::eUndefined;
    VULKAN_HPP_NAMESPACE::DeviceOrHostAddressConstKHR vertexData    = {};
    VULKAN_HPP_NAMESPACE::DeviceSize                  vertexStride  = {};
    uint32_t                                          maxVertex     = {};
    VULKAN_HPP_NAMESPACE::IndexType                   indexType     = VULKAN_HPP_NAMESPACE::IndexType::eUint16;
    VULKAN_HPP_NAMESPACE::DeviceOrHostAddressConstKHR indexData     = {};
    VULKAN_HPP_NAMESPACE::DeviceOrHostAddressConstKHR transformData = {};
  };
  static_assert( sizeof( AccelerationStructureGeometryTrianglesDataKHR ) ==
                   sizeof( VkAccelerationStructureGeometryTrianglesDataKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<AccelerationStructureGeometryTrianglesDataKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eAccelerationStructureGeometryTrianglesDataKHR>
  {
    using Type = AccelerationStructureGeometryTrianglesDataKHR;
  };

  struct AccelerationStructureGeometryAabbsDataKHR
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eAccelerationStructureGeometryAabbsDataKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    AccelerationStructureGeometryAabbsDataKHR( VULKAN_HPP_NAMESPACE::DeviceOrHostAddressConstKHR data_ = {},
                                               VULKAN_HPP_NAMESPACE::DeviceSize stride_ = {} ) VULKAN_HPP_NOEXCEPT
      : data( data_ )
      , stride( stride_ )
    {}

    AccelerationStructureGeometryAabbsDataKHR( AccelerationStructureGeometryAabbsDataKHR const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    AccelerationStructureGeometryAabbsDataKHR( VkAccelerationStructureGeometryAabbsDataKHR const & rhs )
      VULKAN_HPP_NOEXCEPT
      : AccelerationStructureGeometryAabbsDataKHR(
          *reinterpret_cast<AccelerationStructureGeometryAabbsDataKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    AccelerationStructureGeometryAabbsDataKHR &
      operator=( AccelerationStructureGeometryAabbsDataKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AccelerationStructureGeometryAabbsDataKHR &
      operator=( VkAccelerationStructureGeometryAabbsDataKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::AccelerationStructureGeometryAabbsDataKHR const *>( &rhs );
      return *this;
    }

    AccelerationStructureGeometryAabbsDataKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    AccelerationStructureGeometryAabbsDataKHR &
      setData( VULKAN_HPP_NAMESPACE::DeviceOrHostAddressConstKHR const & data_ ) VULKAN_HPP_NOEXCEPT
    {
      data = data_;
      return *this;
    }

    AccelerationStructureGeometryAabbsDataKHR &
      setStride( VULKAN_HPP_NAMESPACE::DeviceSize stride_ ) VULKAN_HPP_NOEXCEPT
    {
      stride = stride_;
      return *this;
    }

    operator VkAccelerationStructureGeometryAabbsDataKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkAccelerationStructureGeometryAabbsDataKHR *>( this );
    }

    operator VkAccelerationStructureGeometryAabbsDataKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkAccelerationStructureGeometryAabbsDataKHR *>( this );
    }

  public:
    VULKAN_HPP_NAMESPACE::StructureType               sType = StructureType::eAccelerationStructureGeometryAabbsDataKHR;
    const void *                                      pNext = {};
    VULKAN_HPP_NAMESPACE::DeviceOrHostAddressConstKHR data  = {};
    VULKAN_HPP_NAMESPACE::DeviceSize                  stride = {};
  };
  static_assert( sizeof( AccelerationStructureGeometryAabbsDataKHR ) ==
                   sizeof( VkAccelerationStructureGeometryAabbsDataKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<AccelerationStructureGeometryAabbsDataKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eAccelerationStructureGeometryAabbsDataKHR>
  {
    using Type = AccelerationStructureGeometryAabbsDataKHR;
  };

  struct AccelerationStructureGeometryInstancesDataKHR
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eAccelerationStructureGeometryInstancesDataKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    AccelerationStructureGeometryInstancesDataKHR( VULKAN_HPP_NAMESPACE::Bool32 arrayOfPointers_           = {},
                                                   VULKAN_HPP_NAMESPACE::DeviceOrHostAddressConstKHR data_ = {} )
      VULKAN_HPP_NOEXCEPT
      : arrayOfPointers( arrayOfPointers_ )
      , data( data_ )
    {}

    AccelerationStructureGeometryInstancesDataKHR( AccelerationStructureGeometryInstancesDataKHR const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    AccelerationStructureGeometryInstancesDataKHR( VkAccelerationStructureGeometryInstancesDataKHR const & rhs )
      VULKAN_HPP_NOEXCEPT
      : AccelerationStructureGeometryInstancesDataKHR(
          *reinterpret_cast<AccelerationStructureGeometryInstancesDataKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    AccelerationStructureGeometryInstancesDataKHR &
      operator=( AccelerationStructureGeometryInstancesDataKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AccelerationStructureGeometryInstancesDataKHR &
      operator=( VkAccelerationStructureGeometryInstancesDataKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::AccelerationStructureGeometryInstancesDataKHR const *>( &rhs );
      return *this;
    }

    AccelerationStructureGeometryInstancesDataKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    AccelerationStructureGeometryInstancesDataKHR &
      setArrayOfPointers( VULKAN_HPP_NAMESPACE::Bool32 arrayOfPointers_ ) VULKAN_HPP_NOEXCEPT
    {
      arrayOfPointers = arrayOfPointers_;
      return *this;
    }

    AccelerationStructureGeometryInstancesDataKHR &
      setData( VULKAN_HPP_NAMESPACE::DeviceOrHostAddressConstKHR const & data_ ) VULKAN_HPP_NOEXCEPT
    {
      data = data_;
      return *this;
    }

    operator VkAccelerationStructureGeometryInstancesDataKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkAccelerationStructureGeometryInstancesDataKHR *>( this );
    }

    operator VkAccelerationStructureGeometryInstancesDataKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkAccelerationStructureGeometryInstancesDataKHR *>( this );
    }

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType           = StructureType::eAccelerationStructureGeometryInstancesDataKHR;
    const void *                        pNext           = {};
    VULKAN_HPP_NAMESPACE::Bool32        arrayOfPointers = {};
    VULKAN_HPP_NAMESPACE::DeviceOrHostAddressConstKHR data = {};
  };
  static_assert( sizeof( AccelerationStructureGeometryInstancesDataKHR ) ==
                   sizeof( VkAccelerationStructureGeometryInstancesDataKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<AccelerationStructureGeometryInstancesDataKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eAccelerationStructureGeometryInstancesDataKHR>
  {
    using Type = AccelerationStructureGeometryInstancesDataKHR;
  };

  union AccelerationStructureGeometryDataKHR
  {
    AccelerationStructureGeometryDataKHR( VULKAN_HPP_NAMESPACE::AccelerationStructureGeometryDataKHR const & rhs )
      VULKAN_HPP_NOEXCEPT
    {
      memcpy( static_cast<void *>( this ), &rhs, sizeof( VULKAN_HPP_NAMESPACE::AccelerationStructureGeometryDataKHR ) );
    }

    AccelerationStructureGeometryDataKHR(
      VULKAN_HPP_NAMESPACE::AccelerationStructureGeometryTrianglesDataKHR triangles_ = {} )
      : triangles( triangles_ )
    {}

    AccelerationStructureGeometryDataKHR( VULKAN_HPP_NAMESPACE::AccelerationStructureGeometryAabbsDataKHR aabbs_ )
      : aabbs( aabbs_ )
    {}

    AccelerationStructureGeometryDataKHR(
      VULKAN_HPP_NAMESPACE::AccelerationStructureGeometryInstancesDataKHR instances_ )
      : instances( instances_ )
    {}

    AccelerationStructureGeometryDataKHR & setTriangles(
      VULKAN_HPP_NAMESPACE::AccelerationStructureGeometryTrianglesDataKHR const & triangles_ ) VULKAN_HPP_NOEXCEPT
    {
      triangles = triangles_;
      return *this;
    }

    AccelerationStructureGeometryDataKHR &
      setAabbs( VULKAN_HPP_NAMESPACE::AccelerationStructureGeometryAabbsDataKHR const & aabbs_ ) VULKAN_HPP_NOEXCEPT
    {
      aabbs = aabbs_;
      return *this;
    }

    AccelerationStructureGeometryDataKHR & setInstances(
      VULKAN_HPP_NAMESPACE::AccelerationStructureGeometryInstancesDataKHR const & instances_ ) VULKAN_HPP_NOEXCEPT
    {
      instances = instances_;
      return *this;
    }

    VULKAN_HPP_NAMESPACE::AccelerationStructureGeometryDataKHR &
      operator=( VULKAN_HPP_NAMESPACE::AccelerationStructureGeometryDataKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      memcpy( static_cast<void *>( this ), &rhs, sizeof( VULKAN_HPP_NAMESPACE::AccelerationStructureGeometryDataKHR ) );
      return *this;
    }

    operator VkAccelerationStructureGeometryDataKHR const &() const
    {
      return *reinterpret_cast<const VkAccelerationStructureGeometryDataKHR *>( this );
    }

    operator VkAccelerationStructureGeometryDataKHR &()
    {
      return *reinterpret_cast<VkAccelerationStructureGeometryDataKHR *>( this );
    }

#ifdef VULKAN_HPP_HAS_UNRESTRICTED_UNIONS
    VULKAN_HPP_NAMESPACE::AccelerationStructureGeometryTrianglesDataKHR triangles;
    VULKAN_HPP_NAMESPACE::AccelerationStructureGeometryAabbsDataKHR     aabbs;
    VULKAN_HPP_NAMESPACE::AccelerationStructureGeometryInstancesDataKHR instances;
#else
    VkAccelerationStructureGeometryTrianglesDataKHR triangles;
    VkAccelerationStructureGeometryAabbsDataKHR     aabbs;
    VkAccelerationStructureGeometryInstancesDataKHR instances;
#endif /*VULKAN_HPP_HAS_UNRESTRICTED_UNIONS*/
  };

  struct AccelerationStructureGeometryKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eAccelerationStructureGeometryKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    AccelerationStructureGeometryKHR(
      VULKAN_HPP_NAMESPACE::GeometryTypeKHR geometryType_ = VULKAN_HPP_NAMESPACE::GeometryTypeKHR::eTriangles,
      VULKAN_HPP_NAMESPACE::AccelerationStructureGeometryDataKHR geometry_ = {},
      VULKAN_HPP_NAMESPACE::GeometryFlagsKHR                     flags_    = {} ) VULKAN_HPP_NOEXCEPT
      : geometryType( geometryType_ )
      , geometry( geometry_ )
      , flags( flags_ )
    {}

    AccelerationStructureGeometryKHR( AccelerationStructureGeometryKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AccelerationStructureGeometryKHR( VkAccelerationStructureGeometryKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : AccelerationStructureGeometryKHR( *reinterpret_cast<AccelerationStructureGeometryKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    AccelerationStructureGeometryKHR &
      operator=( AccelerationStructureGeometryKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AccelerationStructureGeometryKHR & operator=( VkAccelerationStructureGeometryKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::AccelerationStructureGeometryKHR const *>( &rhs );
      return *this;
    }

    AccelerationStructureGeometryKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    AccelerationStructureGeometryKHR &
      setGeometryType( VULKAN_HPP_NAMESPACE::GeometryTypeKHR geometryType_ ) VULKAN_HPP_NOEXCEPT
    {
      geometryType = geometryType_;
      return *this;
    }

    AccelerationStructureGeometryKHR &
      setGeometry( VULKAN_HPP_NAMESPACE::AccelerationStructureGeometryDataKHR const & geometry_ ) VULKAN_HPP_NOEXCEPT
    {
      geometry = geometry_;
      return *this;
    }

    AccelerationStructureGeometryKHR & setFlags( VULKAN_HPP_NAMESPACE::GeometryFlagsKHR flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    operator VkAccelerationStructureGeometryKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkAccelerationStructureGeometryKHR *>( this );
    }

    operator VkAccelerationStructureGeometryKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkAccelerationStructureGeometryKHR *>( this );
    }

  public:
    VULKAN_HPP_NAMESPACE::StructureType   sType        = StructureType::eAccelerationStructureGeometryKHR;
    const void *                          pNext        = {};
    VULKAN_HPP_NAMESPACE::GeometryTypeKHR geometryType = VULKAN_HPP_NAMESPACE::GeometryTypeKHR::eTriangles;
    VULKAN_HPP_NAMESPACE::AccelerationStructureGeometryDataKHR geometry = {};
    VULKAN_HPP_NAMESPACE::GeometryFlagsKHR                     flags    = {};
  };
  static_assert( sizeof( AccelerationStructureGeometryKHR ) == sizeof( VkAccelerationStructureGeometryKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<AccelerationStructureGeometryKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eAccelerationStructureGeometryKHR>
  {
    using Type = AccelerationStructureGeometryKHR;
  };

  union DeviceOrHostAddressKHR
  {
    DeviceOrHostAddressKHR( VULKAN_HPP_NAMESPACE::DeviceOrHostAddressKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      memcpy( static_cast<void *>( this ), &rhs, sizeof( VULKAN_HPP_NAMESPACE::DeviceOrHostAddressKHR ) );
    }

    DeviceOrHostAddressKHR( VULKAN_HPP_NAMESPACE::DeviceAddress deviceAddress_ = {} ) : deviceAddress( deviceAddress_ )
    {}

    DeviceOrHostAddressKHR( void * hostAddress_ ) : hostAddress( hostAddress_ ) {}

    DeviceOrHostAddressKHR & setDeviceAddress( VULKAN_HPP_NAMESPACE::DeviceAddress deviceAddress_ ) VULKAN_HPP_NOEXCEPT
    {
      deviceAddress = deviceAddress_;
      return *this;
    }

    DeviceOrHostAddressKHR & setHostAddress( void * hostAddress_ ) VULKAN_HPP_NOEXCEPT
    {
      hostAddress = hostAddress_;
      return *this;
    }

    VULKAN_HPP_NAMESPACE::DeviceOrHostAddressKHR &
      operator=( VULKAN_HPP_NAMESPACE::DeviceOrHostAddressKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      memcpy( static_cast<void *>( this ), &rhs, sizeof( VULKAN_HPP_NAMESPACE::DeviceOrHostAddressKHR ) );
      return *this;
    }

    operator VkDeviceOrHostAddressKHR const &() const
    {
      return *reinterpret_cast<const VkDeviceOrHostAddressKHR *>( this );
    }

    operator VkDeviceOrHostAddressKHR &()
    {
      return *reinterpret_cast<VkDeviceOrHostAddressKHR *>( this );
    }

#ifdef VULKAN_HPP_HAS_UNRESTRICTED_UNIONS
    VULKAN_HPP_NAMESPACE::DeviceAddress deviceAddress;
    void *                              hostAddress;
#else
    VkDeviceAddress                                 deviceAddress;
    void *                                          hostAddress;
#endif /*VULKAN_HPP_HAS_UNRESTRICTED_UNIONS*/
  };

  struct AccelerationStructureBuildGeometryInfoKHR
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eAccelerationStructureBuildGeometryInfoKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    AccelerationStructureBuildGeometryInfoKHR(
      VULKAN_HPP_NAMESPACE::AccelerationStructureTypeKHR type_ =
        VULKAN_HPP_NAMESPACE::AccelerationStructureTypeKHR::eTopLevel,
      VULKAN_HPP_NAMESPACE::BuildAccelerationStructureFlagsKHR flags_ = {},
      VULKAN_HPP_NAMESPACE::BuildAccelerationStructureModeKHR  mode_ =
        VULKAN_HPP_NAMESPACE::BuildAccelerationStructureModeKHR::eBuild,
      VULKAN_HPP_NAMESPACE::AccelerationStructureKHR                         srcAccelerationStructure_ = {},
      VULKAN_HPP_NAMESPACE::AccelerationStructureKHR                         dstAccelerationStructure_ = {},
      uint32_t                                                               geometryCount_            = {},
      const VULKAN_HPP_NAMESPACE::AccelerationStructureGeometryKHR *         pGeometries_              = {},
      const VULKAN_HPP_NAMESPACE::AccelerationStructureGeometryKHR * const * ppGeometries_             = {},
      VULKAN_HPP_NAMESPACE::DeviceOrHostAddressKHR                           scratchData_ = {} ) VULKAN_HPP_NOEXCEPT
      : type( type_ )
      , flags( flags_ )
      , mode( mode_ )
      , srcAccelerationStructure( srcAccelerationStructure_ )
      , dstAccelerationStructure( dstAccelerationStructure_ )
      , geometryCount( geometryCount_ )
      , pGeometries( pGeometries_ )
      , ppGeometries( ppGeometries_ )
      , scratchData( scratchData_ )
    {}

    AccelerationStructureBuildGeometryInfoKHR( AccelerationStructureBuildGeometryInfoKHR const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    AccelerationStructureBuildGeometryInfoKHR( VkAccelerationStructureBuildGeometryInfoKHR const & rhs )
      VULKAN_HPP_NOEXCEPT
      : AccelerationStructureBuildGeometryInfoKHR(
          *reinterpret_cast<AccelerationStructureBuildGeometryInfoKHR const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    AccelerationStructureBuildGeometryInfoKHR(
      VULKAN_HPP_NAMESPACE::AccelerationStructureTypeKHR       type_,
      VULKAN_HPP_NAMESPACE::BuildAccelerationStructureFlagsKHR flags_,
      VULKAN_HPP_NAMESPACE::BuildAccelerationStructureModeKHR  mode_,
      VULKAN_HPP_NAMESPACE::AccelerationStructureKHR           srcAccelerationStructure_,
      VULKAN_HPP_NAMESPACE::AccelerationStructureKHR           dstAccelerationStructure_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<
        const VULKAN_HPP_NAMESPACE::AccelerationStructureGeometryKHR> const & geometries_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<
        const VULKAN_HPP_NAMESPACE::AccelerationStructureGeometryKHR * const> const & pGeometries_ = {},
      VULKAN_HPP_NAMESPACE::DeviceOrHostAddressKHR                                    scratchData_ = {} )
      : type( type_ )
      , flags( flags_ )
      , mode( mode_ )
      , srcAccelerationStructure( srcAccelerationStructure_ )
      , dstAccelerationStructure( dstAccelerationStructure_ )
      , geometryCount( static_cast<uint32_t>( !geometries_.empty() ? geometries_.size() : pGeometries_.size() ) )
      , pGeometries( geometries_.data() )
      , ppGeometries( pGeometries_.data() )
      , scratchData( scratchData_ )
    {
#    ifdef VULKAN_HPP_NO_EXCEPTIONS
      VULKAN_HPP_ASSERT( ( !geometries_.empty() + !pGeometries_.empty() ) <= 1 );
#    else
      if ( 1 < ( !geometries_.empty() + !pGeometries_.empty() ) )
      {
        throw LogicError(
          VULKAN_HPP_NAMESPACE_STRING
          "::AccelerationStructureBuildGeometryInfoKHR::AccelerationStructureBuildGeometryInfoKHR: 1 < ( !geometries_.empty() + !pGeometries_.empty() )" );
      }
#    endif /*VULKAN_HPP_NO_EXCEPTIONS*/
    }
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    AccelerationStructureBuildGeometryInfoKHR &
      operator=( AccelerationStructureBuildGeometryInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AccelerationStructureBuildGeometryInfoKHR &
      operator=( VkAccelerationStructureBuildGeometryInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::AccelerationStructureBuildGeometryInfoKHR const *>( &rhs );
      return *this;
    }

    AccelerationStructureBuildGeometryInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    AccelerationStructureBuildGeometryInfoKHR &
      setType( VULKAN_HPP_NAMESPACE::AccelerationStructureTypeKHR type_ ) VULKAN_HPP_NOEXCEPT
    {
      type = type_;
      return *this;
    }

    AccelerationStructureBuildGeometryInfoKHR &
      setFlags( VULKAN_HPP_NAMESPACE::BuildAccelerationStructureFlagsKHR flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    AccelerationStructureBuildGeometryInfoKHR &
      setMode( VULKAN_HPP_NAMESPACE::BuildAccelerationStructureModeKHR mode_ ) VULKAN_HPP_NOEXCEPT
    {
      mode = mode_;
      return *this;
    }

    AccelerationStructureBuildGeometryInfoKHR & setSrcAccelerationStructure(
      VULKAN_HPP_NAMESPACE::AccelerationStructureKHR srcAccelerationStructure_ ) VULKAN_HPP_NOEXCEPT
    {
      srcAccelerationStructure = srcAccelerationStructure_;
      return *this;
    }

    AccelerationStructureBuildGeometryInfoKHR & setDstAccelerationStructure(
      VULKAN_HPP_NAMESPACE::AccelerationStructureKHR dstAccelerationStructure_ ) VULKAN_HPP_NOEXCEPT
    {
      dstAccelerationStructure = dstAccelerationStructure_;
      return *this;
    }

    AccelerationStructureBuildGeometryInfoKHR & setGeometryCount( uint32_t geometryCount_ ) VULKAN_HPP_NOEXCEPT
    {
      geometryCount = geometryCount_;
      return *this;
    }

    AccelerationStructureBuildGeometryInfoKHR &
      setPGeometries( const VULKAN_HPP_NAMESPACE::AccelerationStructureGeometryKHR * pGeometries_ ) VULKAN_HPP_NOEXCEPT
    {
      pGeometries = pGeometries_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    AccelerationStructureBuildGeometryInfoKHR & setGeometries(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<
        const VULKAN_HPP_NAMESPACE::AccelerationStructureGeometryKHR> const & geometries_ ) VULKAN_HPP_NOEXCEPT
    {
      geometryCount = static_cast<uint32_t>( geometries_.size() );
      pGeometries   = geometries_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    AccelerationStructureBuildGeometryInfoKHR & setPpGeometries(
      const VULKAN_HPP_NAMESPACE::AccelerationStructureGeometryKHR * const * ppGeometries_ ) VULKAN_HPP_NOEXCEPT
    {
      ppGeometries = ppGeometries_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    AccelerationStructureBuildGeometryInfoKHR & setPGeometries(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<
        const VULKAN_HPP_NAMESPACE::AccelerationStructureGeometryKHR * const> const & pGeometries_ ) VULKAN_HPP_NOEXCEPT
    {
      geometryCount = static_cast<uint32_t>( pGeometries_.size() );
      ppGeometries  = pGeometries_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    AccelerationStructureBuildGeometryInfoKHR &
      setScratchData( VULKAN_HPP_NAMESPACE::DeviceOrHostAddressKHR const & scratchData_ ) VULKAN_HPP_NOEXCEPT
    {
      scratchData = scratchData_;
      return *this;
    }

    operator VkAccelerationStructureBuildGeometryInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkAccelerationStructureBuildGeometryInfoKHR *>( this );
    }

    operator VkAccelerationStructureBuildGeometryInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkAccelerationStructureBuildGeometryInfoKHR *>( this );
    }

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::eAccelerationStructureBuildGeometryInfoKHR;
    const void *                        pNext = {};
    VULKAN_HPP_NAMESPACE::AccelerationStructureTypeKHR type =
      VULKAN_HPP_NAMESPACE::AccelerationStructureTypeKHR::eTopLevel;
    VULKAN_HPP_NAMESPACE::BuildAccelerationStructureFlagsKHR flags = {};
    VULKAN_HPP_NAMESPACE::BuildAccelerationStructureModeKHR  mode =
      VULKAN_HPP_NAMESPACE::BuildAccelerationStructureModeKHR::eBuild;
    VULKAN_HPP_NAMESPACE::AccelerationStructureKHR                         srcAccelerationStructure = {};
    VULKAN_HPP_NAMESPACE::AccelerationStructureKHR                         dstAccelerationStructure = {};
    uint32_t                                                               geometryCount            = {};
    const VULKAN_HPP_NAMESPACE::AccelerationStructureGeometryKHR *         pGeometries              = {};
    const VULKAN_HPP_NAMESPACE::AccelerationStructureGeometryKHR * const * ppGeometries             = {};
    VULKAN_HPP_NAMESPACE::DeviceOrHostAddressKHR                           scratchData              = {};
  };
  static_assert( sizeof( AccelerationStructureBuildGeometryInfoKHR ) ==
                   sizeof( VkAccelerationStructureBuildGeometryInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<AccelerationStructureBuildGeometryInfoKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eAccelerationStructureBuildGeometryInfoKHR>
  {
    using Type = AccelerationStructureBuildGeometryInfoKHR;
  };

  struct AccelerationStructureBuildRangeInfoKHR
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR AccelerationStructureBuildRangeInfoKHR( uint32_t primitiveCount_  = {},
                                                                 uint32_t primitiveOffset_ = {},
                                                                 uint32_t firstVertex_     = {},
                                                                 uint32_t transformOffset_ = {} ) VULKAN_HPP_NOEXCEPT
      : primitiveCount( primitiveCount_ )
      , primitiveOffset( primitiveOffset_ )
      , firstVertex( firstVertex_ )
      , transformOffset( transformOffset_ )
    {}

    VULKAN_HPP_CONSTEXPR AccelerationStructureBuildRangeInfoKHR( AccelerationStructureBuildRangeInfoKHR const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    AccelerationStructureBuildRangeInfoKHR( VkAccelerationStructureBuildRangeInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : AccelerationStructureBuildRangeInfoKHR(
          *reinterpret_cast<AccelerationStructureBuildRangeInfoKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 AccelerationStructureBuildRangeInfoKHR &
                            operator=( AccelerationStructureBuildRangeInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AccelerationStructureBuildRangeInfoKHR &
      operator=( VkAccelerationStructureBuildRangeInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::AccelerationStructureBuildRangeInfoKHR const *>( &rhs );
      return *this;
    }

    AccelerationStructureBuildRangeInfoKHR & setPrimitiveCount( uint32_t primitiveCount_ ) VULKAN_HPP_NOEXCEPT
    {
      primitiveCount = primitiveCount_;
      return *this;
    }

    AccelerationStructureBuildRangeInfoKHR & setPrimitiveOffset( uint32_t primitiveOffset_ ) VULKAN_HPP_NOEXCEPT
    {
      primitiveOffset = primitiveOffset_;
      return *this;
    }

    AccelerationStructureBuildRangeInfoKHR & setFirstVertex( uint32_t firstVertex_ ) VULKAN_HPP_NOEXCEPT
    {
      firstVertex = firstVertex_;
      return *this;
    }

    AccelerationStructureBuildRangeInfoKHR & setTransformOffset( uint32_t transformOffset_ ) VULKAN_HPP_NOEXCEPT
    {
      transformOffset = transformOffset_;
      return *this;
    }

    operator VkAccelerationStructureBuildRangeInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkAccelerationStructureBuildRangeInfoKHR *>( this );
    }

    operator VkAccelerationStructureBuildRangeInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkAccelerationStructureBuildRangeInfoKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( AccelerationStructureBuildRangeInfoKHR const & ) const = default;
#else
    bool operator==( AccelerationStructureBuildRangeInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( primitiveCount == rhs.primitiveCount ) && ( primitiveOffset == rhs.primitiveOffset ) &&
             ( firstVertex == rhs.firstVertex ) && ( transformOffset == rhs.transformOffset );
    }

    bool operator!=( AccelerationStructureBuildRangeInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    uint32_t primitiveCount  = {};
    uint32_t primitiveOffset = {};
    uint32_t firstVertex     = {};
    uint32_t transformOffset = {};
  };
  static_assert( sizeof( AccelerationStructureBuildRangeInfoKHR ) == sizeof( VkAccelerationStructureBuildRangeInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<AccelerationStructureBuildRangeInfoKHR>::value,
                 "struct wrapper is not a standard layout!" );

  struct AccelerationStructureBuildSizesInfoKHR
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eAccelerationStructureBuildSizesInfoKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR AccelerationStructureBuildSizesInfoKHR(
      VULKAN_HPP_NAMESPACE::DeviceSize accelerationStructureSize_ = {},
      VULKAN_HPP_NAMESPACE::DeviceSize updateScratchSize_         = {},
      VULKAN_HPP_NAMESPACE::DeviceSize buildScratchSize_          = {} ) VULKAN_HPP_NOEXCEPT
      : accelerationStructureSize( accelerationStructureSize_ )
      , updateScratchSize( updateScratchSize_ )
      , buildScratchSize( buildScratchSize_ )
    {}

    VULKAN_HPP_CONSTEXPR AccelerationStructureBuildSizesInfoKHR( AccelerationStructureBuildSizesInfoKHR const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    AccelerationStructureBuildSizesInfoKHR( VkAccelerationStructureBuildSizesInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : AccelerationStructureBuildSizesInfoKHR(
          *reinterpret_cast<AccelerationStructureBuildSizesInfoKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 AccelerationStructureBuildSizesInfoKHR &
                            operator=( AccelerationStructureBuildSizesInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AccelerationStructureBuildSizesInfoKHR &
      operator=( VkAccelerationStructureBuildSizesInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::AccelerationStructureBuildSizesInfoKHR const *>( &rhs );
      return *this;
    }

    AccelerationStructureBuildSizesInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    AccelerationStructureBuildSizesInfoKHR &
      setAccelerationStructureSize( VULKAN_HPP_NAMESPACE::DeviceSize accelerationStructureSize_ ) VULKAN_HPP_NOEXCEPT
    {
      accelerationStructureSize = accelerationStructureSize_;
      return *this;
    }

    AccelerationStructureBuildSizesInfoKHR &
      setUpdateScratchSize( VULKAN_HPP_NAMESPACE::DeviceSize updateScratchSize_ ) VULKAN_HPP_NOEXCEPT
    {
      updateScratchSize = updateScratchSize_;
      return *this;
    }

    AccelerationStructureBuildSizesInfoKHR &
      setBuildScratchSize( VULKAN_HPP_NAMESPACE::DeviceSize buildScratchSize_ ) VULKAN_HPP_NOEXCEPT
    {
      buildScratchSize = buildScratchSize_;
      return *this;
    }

    operator VkAccelerationStructureBuildSizesInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkAccelerationStructureBuildSizesInfoKHR *>( this );
    }

    operator VkAccelerationStructureBuildSizesInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkAccelerationStructureBuildSizesInfoKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( AccelerationStructureBuildSizesInfoKHR const & ) const = default;
#else
    bool operator==( AccelerationStructureBuildSizesInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( accelerationStructureSize == rhs.accelerationStructureSize ) &&
             ( updateScratchSize == rhs.updateScratchSize ) && ( buildScratchSize == rhs.buildScratchSize );
    }

    bool operator!=( AccelerationStructureBuildSizesInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::eAccelerationStructureBuildSizesInfoKHR;
    const void *                        pNext = {};
    VULKAN_HPP_NAMESPACE::DeviceSize    accelerationStructureSize = {};
    VULKAN_HPP_NAMESPACE::DeviceSize    updateScratchSize         = {};
    VULKAN_HPP_NAMESPACE::DeviceSize    buildScratchSize          = {};
  };
  static_assert( sizeof( AccelerationStructureBuildSizesInfoKHR ) == sizeof( VkAccelerationStructureBuildSizesInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<AccelerationStructureBuildSizesInfoKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eAccelerationStructureBuildSizesInfoKHR>
  {
    using Type = AccelerationStructureBuildSizesInfoKHR;
  };

  struct AccelerationStructureCreateInfoKHR
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eAccelerationStructureCreateInfoKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      AccelerationStructureCreateInfoKHR( VULKAN_HPP_NAMESPACE::AccelerationStructureCreateFlagsKHR createFlags_ = {},
                                          VULKAN_HPP_NAMESPACE::Buffer                              buffer_      = {},
                                          VULKAN_HPP_NAMESPACE::DeviceSize                          offset_      = {},
                                          VULKAN_HPP_NAMESPACE::DeviceSize                          size_        = {},
                                          VULKAN_HPP_NAMESPACE::AccelerationStructureTypeKHR        type_ =
                                            VULKAN_HPP_NAMESPACE::AccelerationStructureTypeKHR::eTopLevel,
                                          VULKAN_HPP_NAMESPACE::DeviceAddress deviceAddress_ = {} ) VULKAN_HPP_NOEXCEPT
      : createFlags( createFlags_ )
      , buffer( buffer_ )
      , offset( offset_ )
      , size( size_ )
      , type( type_ )
      , deviceAddress( deviceAddress_ )
    {}

    VULKAN_HPP_CONSTEXPR AccelerationStructureCreateInfoKHR( AccelerationStructureCreateInfoKHR const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    AccelerationStructureCreateInfoKHR( VkAccelerationStructureCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : AccelerationStructureCreateInfoKHR( *reinterpret_cast<AccelerationStructureCreateInfoKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 AccelerationStructureCreateInfoKHR &
                            operator=( AccelerationStructureCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AccelerationStructureCreateInfoKHR &
      operator=( VkAccelerationStructureCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::AccelerationStructureCreateInfoKHR const *>( &rhs );
      return *this;
    }

    AccelerationStructureCreateInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    AccelerationStructureCreateInfoKHR &
      setCreateFlags( VULKAN_HPP_NAMESPACE::AccelerationStructureCreateFlagsKHR createFlags_ ) VULKAN_HPP_NOEXCEPT
    {
      createFlags = createFlags_;
      return *this;
    }

    AccelerationStructureCreateInfoKHR & setBuffer( VULKAN_HPP_NAMESPACE::Buffer buffer_ ) VULKAN_HPP_NOEXCEPT
    {
      buffer = buffer_;
      return *this;
    }

    AccelerationStructureCreateInfoKHR & setOffset( VULKAN_HPP_NAMESPACE::DeviceSize offset_ ) VULKAN_HPP_NOEXCEPT
    {
      offset = offset_;
      return *this;
    }

    AccelerationStructureCreateInfoKHR & setSize( VULKAN_HPP_NAMESPACE::DeviceSize size_ ) VULKAN_HPP_NOEXCEPT
    {
      size = size_;
      return *this;
    }

    AccelerationStructureCreateInfoKHR &
      setType( VULKAN_HPP_NAMESPACE::AccelerationStructureTypeKHR type_ ) VULKAN_HPP_NOEXCEPT
    {
      type = type_;
      return *this;
    }

    AccelerationStructureCreateInfoKHR &
      setDeviceAddress( VULKAN_HPP_NAMESPACE::DeviceAddress deviceAddress_ ) VULKAN_HPP_NOEXCEPT
    {
      deviceAddress = deviceAddress_;
      return *this;
    }

    operator VkAccelerationStructureCreateInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkAccelerationStructureCreateInfoKHR *>( this );
    }

    operator VkAccelerationStructureCreateInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkAccelerationStructureCreateInfoKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( AccelerationStructureCreateInfoKHR const & ) const = default;
#else
    bool operator==( AccelerationStructureCreateInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( createFlags == rhs.createFlags ) &&
             ( buffer == rhs.buffer ) && ( offset == rhs.offset ) && ( size == rhs.size ) && ( type == rhs.type ) &&
             ( deviceAddress == rhs.deviceAddress );
    }

    bool operator!=( AccelerationStructureCreateInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::eAccelerationStructureCreateInfoKHR;
    const void *                        pNext = {};
    VULKAN_HPP_NAMESPACE::AccelerationStructureCreateFlagsKHR createFlags = {};
    VULKAN_HPP_NAMESPACE::Buffer                              buffer      = {};
    VULKAN_HPP_NAMESPACE::DeviceSize                          offset      = {};
    VULKAN_HPP_NAMESPACE::DeviceSize                          size        = {};
    VULKAN_HPP_NAMESPACE::AccelerationStructureTypeKHR        type =
      VULKAN_HPP_NAMESPACE::AccelerationStructureTypeKHR::eTopLevel;
    VULKAN_HPP_NAMESPACE::DeviceAddress deviceAddress = {};
  };
  static_assert( sizeof( AccelerationStructureCreateInfoKHR ) == sizeof( VkAccelerationStructureCreateInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<AccelerationStructureCreateInfoKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eAccelerationStructureCreateInfoKHR>
  {
    using Type = AccelerationStructureCreateInfoKHR;
  };

  struct GeometryTrianglesNV
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eGeometryTrianglesNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      GeometryTrianglesNV( VULKAN_HPP_NAMESPACE::Buffer     vertexData_      = {},
                           VULKAN_HPP_NAMESPACE::DeviceSize vertexOffset_    = {},
                           uint32_t                         vertexCount_     = {},
                           VULKAN_HPP_NAMESPACE::DeviceSize vertexStride_    = {},
                           VULKAN_HPP_NAMESPACE::Format     vertexFormat_    = VULKAN_HPP_NAMESPACE::Format::eUndefined,
                           VULKAN_HPP_NAMESPACE::Buffer     indexData_       = {},
                           VULKAN_HPP_NAMESPACE::DeviceSize indexOffset_     = {},
                           uint32_t                         indexCount_      = {},
                           VULKAN_HPP_NAMESPACE::IndexType  indexType_       = VULKAN_HPP_NAMESPACE::IndexType::eUint16,
                           VULKAN_HPP_NAMESPACE::Buffer     transformData_   = {},
                           VULKAN_HPP_NAMESPACE::DeviceSize transformOffset_ = {} ) VULKAN_HPP_NOEXCEPT
      : vertexData( vertexData_ )
      , vertexOffset( vertexOffset_ )
      , vertexCount( vertexCount_ )
      , vertexStride( vertexStride_ )
      , vertexFormat( vertexFormat_ )
      , indexData( indexData_ )
      , indexOffset( indexOffset_ )
      , indexCount( indexCount_ )
      , indexType( indexType_ )
      , transformData( transformData_ )
      , transformOffset( transformOffset_ )
    {}

    VULKAN_HPP_CONSTEXPR GeometryTrianglesNV( GeometryTrianglesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    GeometryTrianglesNV( VkGeometryTrianglesNV const & rhs ) VULKAN_HPP_NOEXCEPT
      : GeometryTrianglesNV( *reinterpret_cast<GeometryTrianglesNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 GeometryTrianglesNV &
                            operator=( GeometryTrianglesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    GeometryTrianglesNV & operator=( VkGeometryTrianglesNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::GeometryTrianglesNV const *>( &rhs );
      return *this;
    }

    GeometryTrianglesNV & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    GeometryTrianglesNV & setVertexData( VULKAN_HPP_NAMESPACE::Buffer vertexData_ ) VULKAN_HPP_NOEXCEPT
    {
      vertexData = vertexData_;
      return *this;
    }

    GeometryTrianglesNV & setVertexOffset( VULKAN_HPP_NAMESPACE::DeviceSize vertexOffset_ ) VULKAN_HPP_NOEXCEPT
    {
      vertexOffset = vertexOffset_;
      return *this;
    }

    GeometryTrianglesNV & setVertexCount( uint32_t vertexCount_ ) VULKAN_HPP_NOEXCEPT
    {
      vertexCount = vertexCount_;
      return *this;
    }

    GeometryTrianglesNV & setVertexStride( VULKAN_HPP_NAMESPACE::DeviceSize vertexStride_ ) VULKAN_HPP_NOEXCEPT
    {
      vertexStride = vertexStride_;
      return *this;
    }

    GeometryTrianglesNV & setVertexFormat( VULKAN_HPP_NAMESPACE::Format vertexFormat_ ) VULKAN_HPP_NOEXCEPT
    {
      vertexFormat = vertexFormat_;
      return *this;
    }

    GeometryTrianglesNV & setIndexData( VULKAN_HPP_NAMESPACE::Buffer indexData_ ) VULKAN_HPP_NOEXCEPT
    {
      indexData = indexData_;
      return *this;
    }

    GeometryTrianglesNV & setIndexOffset( VULKAN_HPP_NAMESPACE::DeviceSize indexOffset_ ) VULKAN_HPP_NOEXCEPT
    {
      indexOffset = indexOffset_;
      return *this;
    }

    GeometryTrianglesNV & setIndexCount( uint32_t indexCount_ ) VULKAN_HPP_NOEXCEPT
    {
      indexCount = indexCount_;
      return *this;
    }

    GeometryTrianglesNV & setIndexType( VULKAN_HPP_NAMESPACE::IndexType indexType_ ) VULKAN_HPP_NOEXCEPT
    {
      indexType = indexType_;
      return *this;
    }

    GeometryTrianglesNV & setTransformData( VULKAN_HPP_NAMESPACE::Buffer transformData_ ) VULKAN_HPP_NOEXCEPT
    {
      transformData = transformData_;
      return *this;
    }

    GeometryTrianglesNV & setTransformOffset( VULKAN_HPP_NAMESPACE::DeviceSize transformOffset_ ) VULKAN_HPP_NOEXCEPT
    {
      transformOffset = transformOffset_;
      return *this;
    }

    operator VkGeometryTrianglesNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkGeometryTrianglesNV *>( this );
    }

    operator VkGeometryTrianglesNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkGeometryTrianglesNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( GeometryTrianglesNV const & ) const = default;
#else
    bool operator==( GeometryTrianglesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( vertexData == rhs.vertexData ) &&
             ( vertexOffset == rhs.vertexOffset ) && ( vertexCount == rhs.vertexCount ) &&
             ( vertexStride == rhs.vertexStride ) && ( vertexFormat == rhs.vertexFormat ) &&
             ( indexData == rhs.indexData ) && ( indexOffset == rhs.indexOffset ) && ( indexCount == rhs.indexCount ) &&
             ( indexType == rhs.indexType ) && ( transformData == rhs.transformData ) &&
             ( transformOffset == rhs.transformOffset );
    }

    bool operator!=( GeometryTrianglesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType           = StructureType::eGeometryTrianglesNV;
    const void *                        pNext           = {};
    VULKAN_HPP_NAMESPACE::Buffer        vertexData      = {};
    VULKAN_HPP_NAMESPACE::DeviceSize    vertexOffset    = {};
    uint32_t                            vertexCount     = {};
    VULKAN_HPP_NAMESPACE::DeviceSize    vertexStride    = {};
    VULKAN_HPP_NAMESPACE::Format        vertexFormat    = VULKAN_HPP_NAMESPACE::Format::eUndefined;
    VULKAN_HPP_NAMESPACE::Buffer        indexData       = {};
    VULKAN_HPP_NAMESPACE::DeviceSize    indexOffset     = {};
    uint32_t                            indexCount      = {};
    VULKAN_HPP_NAMESPACE::IndexType     indexType       = VULKAN_HPP_NAMESPACE::IndexType::eUint16;
    VULKAN_HPP_NAMESPACE::Buffer        transformData   = {};
    VULKAN_HPP_NAMESPACE::DeviceSize    transformOffset = {};
  };
  static_assert( sizeof( GeometryTrianglesNV ) == sizeof( VkGeometryTrianglesNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<GeometryTrianglesNV>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eGeometryTrianglesNV>
  {
    using Type = GeometryTrianglesNV;
  };

  struct GeometryAABBNV
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eGeometryAabbNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR GeometryAABBNV( VULKAN_HPP_NAMESPACE::Buffer     aabbData_ = {},
                                         uint32_t                         numAABBs_ = {},
                                         uint32_t                         stride_   = {},
                                         VULKAN_HPP_NAMESPACE::DeviceSize offset_   = {} ) VULKAN_HPP_NOEXCEPT
      : aabbData( aabbData_ )
      , numAABBs( numAABBs_ )
      , stride( stride_ )
      , offset( offset_ )
    {}

    VULKAN_HPP_CONSTEXPR GeometryAABBNV( GeometryAABBNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    GeometryAABBNV( VkGeometryAABBNV const & rhs ) VULKAN_HPP_NOEXCEPT
      : GeometryAABBNV( *reinterpret_cast<GeometryAABBNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 GeometryAABBNV & operator=( GeometryAABBNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    GeometryAABBNV & operator=( VkGeometryAABBNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::GeometryAABBNV const *>( &rhs );
      return *this;
    }

    GeometryAABBNV & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    GeometryAABBNV & setAabbData( VULKAN_HPP_NAMESPACE::Buffer aabbData_ ) VULKAN_HPP_NOEXCEPT
    {
      aabbData = aabbData_;
      return *this;
    }

    GeometryAABBNV & setNumAABBs( uint32_t numAABBs_ ) VULKAN_HPP_NOEXCEPT
    {
      numAABBs = numAABBs_;
      return *this;
    }

    GeometryAABBNV & setStride( uint32_t stride_ ) VULKAN_HPP_NOEXCEPT
    {
      stride = stride_;
      return *this;
    }

    GeometryAABBNV & setOffset( VULKAN_HPP_NAMESPACE::DeviceSize offset_ ) VULKAN_HPP_NOEXCEPT
    {
      offset = offset_;
      return *this;
    }

    operator VkGeometryAABBNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkGeometryAABBNV *>( this );
    }

    operator VkGeometryAABBNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkGeometryAABBNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( GeometryAABBNV const & ) const = default;
#else
    bool operator==( GeometryAABBNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( aabbData == rhs.aabbData ) &&
             ( numAABBs == rhs.numAABBs ) && ( stride == rhs.stride ) && ( offset == rhs.offset );
    }

    bool operator!=( GeometryAABBNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType    = StructureType::eGeometryAabbNV;
    const void *                        pNext    = {};
    VULKAN_HPP_NAMESPACE::Buffer        aabbData = {};
    uint32_t                            numAABBs = {};
    uint32_t                            stride   = {};
    VULKAN_HPP_NAMESPACE::DeviceSize    offset   = {};
  };
  static_assert( sizeof( GeometryAABBNV ) == sizeof( VkGeometryAABBNV ), "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<GeometryAABBNV>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eGeometryAabbNV>
  {
    using Type = GeometryAABBNV;
  };

  struct GeometryDataNV
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR GeometryDataNV( VULKAN_HPP_NAMESPACE::GeometryTrianglesNV triangles_ = {},
                                         VULKAN_HPP_NAMESPACE::GeometryAABBNV      aabbs_     = {} ) VULKAN_HPP_NOEXCEPT
      : triangles( triangles_ )
      , aabbs( aabbs_ )
    {}

    VULKAN_HPP_CONSTEXPR GeometryDataNV( GeometryDataNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    GeometryDataNV( VkGeometryDataNV const & rhs ) VULKAN_HPP_NOEXCEPT
      : GeometryDataNV( *reinterpret_cast<GeometryDataNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 GeometryDataNV & operator=( GeometryDataNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    GeometryDataNV & operator=( VkGeometryDataNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::GeometryDataNV const *>( &rhs );
      return *this;
    }

    GeometryDataNV & setTriangles( VULKAN_HPP_NAMESPACE::GeometryTrianglesNV const & triangles_ ) VULKAN_HPP_NOEXCEPT
    {
      triangles = triangles_;
      return *this;
    }

    GeometryDataNV & setAabbs( VULKAN_HPP_NAMESPACE::GeometryAABBNV const & aabbs_ ) VULKAN_HPP_NOEXCEPT
    {
      aabbs = aabbs_;
      return *this;
    }

    operator VkGeometryDataNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkGeometryDataNV *>( this );
    }

    operator VkGeometryDataNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkGeometryDataNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( GeometryDataNV const & ) const = default;
#else
    bool operator==( GeometryDataNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( triangles == rhs.triangles ) && ( aabbs == rhs.aabbs );
    }

    bool operator!=( GeometryDataNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::GeometryTrianglesNV triangles = {};
    VULKAN_HPP_NAMESPACE::GeometryAABBNV      aabbs     = {};
  };
  static_assert( sizeof( GeometryDataNV ) == sizeof( VkGeometryDataNV ), "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<GeometryDataNV>::value, "struct wrapper is not a standard layout!" );

  struct GeometryNV
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eGeometryNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR GeometryNV(
      VULKAN_HPP_NAMESPACE::GeometryTypeKHR  geometryType_ = VULKAN_HPP_NAMESPACE::GeometryTypeKHR::eTriangles,
      VULKAN_HPP_NAMESPACE::GeometryDataNV   geometry_     = {},
      VULKAN_HPP_NAMESPACE::GeometryFlagsKHR flags_        = {} ) VULKAN_HPP_NOEXCEPT
      : geometryType( geometryType_ )
      , geometry( geometry_ )
      , flags( flags_ )
    {}

    VULKAN_HPP_CONSTEXPR GeometryNV( GeometryNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    GeometryNV( VkGeometryNV const & rhs ) VULKAN_HPP_NOEXCEPT
      : GeometryNV( *reinterpret_cast<GeometryNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 GeometryNV & operator=( GeometryNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    GeometryNV & operator=( VkGeometryNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::GeometryNV const *>( &rhs );
      return *this;
    }

    GeometryNV & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    GeometryNV & setGeometryType( VULKAN_HPP_NAMESPACE::GeometryTypeKHR geometryType_ ) VULKAN_HPP_NOEXCEPT
    {
      geometryType = geometryType_;
      return *this;
    }

    GeometryNV & setGeometry( VULKAN_HPP_NAMESPACE::GeometryDataNV const & geometry_ ) VULKAN_HPP_NOEXCEPT
    {
      geometry = geometry_;
      return *this;
    }

    GeometryNV & setFlags( VULKAN_HPP_NAMESPACE::GeometryFlagsKHR flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    operator VkGeometryNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkGeometryNV *>( this );
    }

    operator VkGeometryNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkGeometryNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( GeometryNV const & ) const = default;
#else
    bool operator==( GeometryNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( geometryType == rhs.geometryType ) &&
             ( geometry == rhs.geometry ) && ( flags == rhs.flags );
    }

    bool operator!=( GeometryNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType    sType        = StructureType::eGeometryNV;
    const void *                           pNext        = {};
    VULKAN_HPP_NAMESPACE::GeometryTypeKHR  geometryType = VULKAN_HPP_NAMESPACE::GeometryTypeKHR::eTriangles;
    VULKAN_HPP_NAMESPACE::GeometryDataNV   geometry     = {};
    VULKAN_HPP_NAMESPACE::GeometryFlagsKHR flags        = {};
  };
  static_assert( sizeof( GeometryNV ) == sizeof( VkGeometryNV ), "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<GeometryNV>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eGeometryNV>
  {
    using Type = GeometryNV;
  };

  struct AccelerationStructureInfoNV
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eAccelerationStructureInfoNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      AccelerationStructureInfoNV( VULKAN_HPP_NAMESPACE::AccelerationStructureTypeNV       type_          = {},
                                   VULKAN_HPP_NAMESPACE::BuildAccelerationStructureFlagsNV flags_         = {},
                                   uint32_t                                                instanceCount_ = {},
                                   uint32_t                                                geometryCount_ = {},
                                   const VULKAN_HPP_NAMESPACE::GeometryNV * pGeometries_ = {} ) VULKAN_HPP_NOEXCEPT
      : type( type_ )
      , flags( flags_ )
      , instanceCount( instanceCount_ )
      , geometryCount( geometryCount_ )
      , pGeometries( pGeometries_ )
    {}

    VULKAN_HPP_CONSTEXPR
      AccelerationStructureInfoNV( AccelerationStructureInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AccelerationStructureInfoNV( VkAccelerationStructureInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
      : AccelerationStructureInfoNV( *reinterpret_cast<AccelerationStructureInfoNV const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    AccelerationStructureInfoNV(
      VULKAN_HPP_NAMESPACE::AccelerationStructureTypeNV                                             type_,
      VULKAN_HPP_NAMESPACE::BuildAccelerationStructureFlagsNV                                       flags_,
      uint32_t                                                                                      instanceCount_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::GeometryNV> const & geometries_ )
      : type( type_ )
      , flags( flags_ )
      , instanceCount( instanceCount_ )
      , geometryCount( static_cast<uint32_t>( geometries_.size() ) )
      , pGeometries( geometries_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 AccelerationStructureInfoNV &
                            operator=( AccelerationStructureInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AccelerationStructureInfoNV & operator=( VkAccelerationStructureInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::AccelerationStructureInfoNV const *>( &rhs );
      return *this;
    }

    AccelerationStructureInfoNV & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    AccelerationStructureInfoNV & setType( VULKAN_HPP_NAMESPACE::AccelerationStructureTypeNV type_ ) VULKAN_HPP_NOEXCEPT
    {
      type = type_;
      return *this;
    }

    AccelerationStructureInfoNV &
      setFlags( VULKAN_HPP_NAMESPACE::BuildAccelerationStructureFlagsNV flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    AccelerationStructureInfoNV & setInstanceCount( uint32_t instanceCount_ ) VULKAN_HPP_NOEXCEPT
    {
      instanceCount = instanceCount_;
      return *this;
    }

    AccelerationStructureInfoNV & setGeometryCount( uint32_t geometryCount_ ) VULKAN_HPP_NOEXCEPT
    {
      geometryCount = geometryCount_;
      return *this;
    }

    AccelerationStructureInfoNV &
      setPGeometries( const VULKAN_HPP_NAMESPACE::GeometryNV * pGeometries_ ) VULKAN_HPP_NOEXCEPT
    {
      pGeometries = pGeometries_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    AccelerationStructureInfoNV & setGeometries(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::GeometryNV> const & geometries_ )
      VULKAN_HPP_NOEXCEPT
    {
      geometryCount = static_cast<uint32_t>( geometries_.size() );
      pGeometries   = geometries_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkAccelerationStructureInfoNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkAccelerationStructureInfoNV *>( this );
    }

    operator VkAccelerationStructureInfoNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkAccelerationStructureInfoNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( AccelerationStructureInfoNV const & ) const = default;
#else
    bool operator==( AccelerationStructureInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( type == rhs.type ) && ( flags == rhs.flags ) &&
             ( instanceCount == rhs.instanceCount ) && ( geometryCount == rhs.geometryCount ) &&
             ( pGeometries == rhs.pGeometries );
    }

    bool operator!=( AccelerationStructureInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                     sType         = StructureType::eAccelerationStructureInfoNV;
    const void *                                            pNext         = {};
    VULKAN_HPP_NAMESPACE::AccelerationStructureTypeNV       type          = {};
    VULKAN_HPP_NAMESPACE::BuildAccelerationStructureFlagsNV flags         = {};
    uint32_t                                                instanceCount = {};
    uint32_t                                                geometryCount = {};
    const VULKAN_HPP_NAMESPACE::GeometryNV *                pGeometries   = {};
  };
  static_assert( sizeof( AccelerationStructureInfoNV ) == sizeof( VkAccelerationStructureInfoNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<AccelerationStructureInfoNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eAccelerationStructureInfoNV>
  {
    using Type = AccelerationStructureInfoNV;
  };

  struct AccelerationStructureCreateInfoNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eAccelerationStructureCreateInfoNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR AccelerationStructureCreateInfoNV(
      VULKAN_HPP_NAMESPACE::DeviceSize                  compactedSize_ = {},
      VULKAN_HPP_NAMESPACE::AccelerationStructureInfoNV info_          = {} ) VULKAN_HPP_NOEXCEPT
      : compactedSize( compactedSize_ )
      , info( info_ )
    {}

    VULKAN_HPP_CONSTEXPR
      AccelerationStructureCreateInfoNV( AccelerationStructureCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AccelerationStructureCreateInfoNV( VkAccelerationStructureCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
      : AccelerationStructureCreateInfoNV( *reinterpret_cast<AccelerationStructureCreateInfoNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 AccelerationStructureCreateInfoNV &
                            operator=( AccelerationStructureCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AccelerationStructureCreateInfoNV & operator=( VkAccelerationStructureCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::AccelerationStructureCreateInfoNV const *>( &rhs );
      return *this;
    }

    AccelerationStructureCreateInfoNV & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    AccelerationStructureCreateInfoNV &
      setCompactedSize( VULKAN_HPP_NAMESPACE::DeviceSize compactedSize_ ) VULKAN_HPP_NOEXCEPT
    {
      compactedSize = compactedSize_;
      return *this;
    }

    AccelerationStructureCreateInfoNV &
      setInfo( VULKAN_HPP_NAMESPACE::AccelerationStructureInfoNV const & info_ ) VULKAN_HPP_NOEXCEPT
    {
      info = info_;
      return *this;
    }

    operator VkAccelerationStructureCreateInfoNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkAccelerationStructureCreateInfoNV *>( this );
    }

    operator VkAccelerationStructureCreateInfoNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkAccelerationStructureCreateInfoNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( AccelerationStructureCreateInfoNV const & ) const = default;
#else
    bool operator==( AccelerationStructureCreateInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( compactedSize == rhs.compactedSize ) &&
             ( info == rhs.info );
    }

    bool operator!=( AccelerationStructureCreateInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType               sType         = StructureType::eAccelerationStructureCreateInfoNV;
    const void *                                      pNext         = {};
    VULKAN_HPP_NAMESPACE::DeviceSize                  compactedSize = {};
    VULKAN_HPP_NAMESPACE::AccelerationStructureInfoNV info          = {};
  };
  static_assert( sizeof( AccelerationStructureCreateInfoNV ) == sizeof( VkAccelerationStructureCreateInfoNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<AccelerationStructureCreateInfoNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eAccelerationStructureCreateInfoNV>
  {
    using Type = AccelerationStructureCreateInfoNV;
  };

  struct AccelerationStructureDeviceAddressInfoKHR
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eAccelerationStructureDeviceAddressInfoKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR AccelerationStructureDeviceAddressInfoKHR(
      VULKAN_HPP_NAMESPACE::AccelerationStructureKHR accelerationStructure_ = {} ) VULKAN_HPP_NOEXCEPT
      : accelerationStructure( accelerationStructure_ )
    {}

    VULKAN_HPP_CONSTEXPR AccelerationStructureDeviceAddressInfoKHR(
      AccelerationStructureDeviceAddressInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AccelerationStructureDeviceAddressInfoKHR( VkAccelerationStructureDeviceAddressInfoKHR const & rhs )
      VULKAN_HPP_NOEXCEPT
      : AccelerationStructureDeviceAddressInfoKHR(
          *reinterpret_cast<AccelerationStructureDeviceAddressInfoKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 AccelerationStructureDeviceAddressInfoKHR &
                            operator=( AccelerationStructureDeviceAddressInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AccelerationStructureDeviceAddressInfoKHR &
      operator=( VkAccelerationStructureDeviceAddressInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::AccelerationStructureDeviceAddressInfoKHR const *>( &rhs );
      return *this;
    }

    AccelerationStructureDeviceAddressInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    AccelerationStructureDeviceAddressInfoKHR & setAccelerationStructure(
      VULKAN_HPP_NAMESPACE::AccelerationStructureKHR accelerationStructure_ ) VULKAN_HPP_NOEXCEPT
    {
      accelerationStructure = accelerationStructure_;
      return *this;
    }

    operator VkAccelerationStructureDeviceAddressInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkAccelerationStructureDeviceAddressInfoKHR *>( this );
    }

    operator VkAccelerationStructureDeviceAddressInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkAccelerationStructureDeviceAddressInfoKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( AccelerationStructureDeviceAddressInfoKHR const & ) const = default;
#else
    bool operator==( AccelerationStructureDeviceAddressInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( accelerationStructure == rhs.accelerationStructure );
    }

    bool operator!=( AccelerationStructureDeviceAddressInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType            sType = StructureType::eAccelerationStructureDeviceAddressInfoKHR;
    const void *                                   pNext = {};
    VULKAN_HPP_NAMESPACE::AccelerationStructureKHR accelerationStructure = {};
  };
  static_assert( sizeof( AccelerationStructureDeviceAddressInfoKHR ) ==
                   sizeof( VkAccelerationStructureDeviceAddressInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<AccelerationStructureDeviceAddressInfoKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eAccelerationStructureDeviceAddressInfoKHR>
  {
    using Type = AccelerationStructureDeviceAddressInfoKHR;
  };

  struct AccelerationStructureGeometryMotionTrianglesDataNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eAccelerationStructureGeometryMotionTrianglesDataNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    AccelerationStructureGeometryMotionTrianglesDataNV(
      VULKAN_HPP_NAMESPACE::DeviceOrHostAddressConstKHR vertexData_ = {} ) VULKAN_HPP_NOEXCEPT
      : vertexData( vertexData_ )
    {}

    AccelerationStructureGeometryMotionTrianglesDataNV( AccelerationStructureGeometryMotionTrianglesDataNV const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    AccelerationStructureGeometryMotionTrianglesDataNV(
      VkAccelerationStructureGeometryMotionTrianglesDataNV const & rhs ) VULKAN_HPP_NOEXCEPT
      : AccelerationStructureGeometryMotionTrianglesDataNV(
          *reinterpret_cast<AccelerationStructureGeometryMotionTrianglesDataNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    AccelerationStructureGeometryMotionTrianglesDataNV &
      operator=( AccelerationStructureGeometryMotionTrianglesDataNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AccelerationStructureGeometryMotionTrianglesDataNV &
      operator=( VkAccelerationStructureGeometryMotionTrianglesDataNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this =
        *reinterpret_cast<VULKAN_HPP_NAMESPACE::AccelerationStructureGeometryMotionTrianglesDataNV const *>( &rhs );
      return *this;
    }

    AccelerationStructureGeometryMotionTrianglesDataNV & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    AccelerationStructureGeometryMotionTrianglesDataNV &
      setVertexData( VULKAN_HPP_NAMESPACE::DeviceOrHostAddressConstKHR const & vertexData_ ) VULKAN_HPP_NOEXCEPT
    {
      vertexData = vertexData_;
      return *this;
    }

    operator VkAccelerationStructureGeometryMotionTrianglesDataNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkAccelerationStructureGeometryMotionTrianglesDataNV *>( this );
    }

    operator VkAccelerationStructureGeometryMotionTrianglesDataNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkAccelerationStructureGeometryMotionTrianglesDataNV *>( this );
    }

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::eAccelerationStructureGeometryMotionTrianglesDataNV;
    const void *                        pNext = {};
    VULKAN_HPP_NAMESPACE::DeviceOrHostAddressConstKHR vertexData = {};
  };
  static_assert( sizeof( AccelerationStructureGeometryMotionTrianglesDataNV ) ==
                   sizeof( VkAccelerationStructureGeometryMotionTrianglesDataNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<AccelerationStructureGeometryMotionTrianglesDataNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eAccelerationStructureGeometryMotionTrianglesDataNV>
  {
    using Type = AccelerationStructureGeometryMotionTrianglesDataNV;
  };

  struct TransformMatrixKHR
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR_14
      TransformMatrixKHR( std::array<std::array<float, 4>, 3> const & matrix_ = {} ) VULKAN_HPP_NOEXCEPT
      : matrix( matrix_ )
    {}

    VULKAN_HPP_CONSTEXPR_14 TransformMatrixKHR( TransformMatrixKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    TransformMatrixKHR( VkTransformMatrixKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : TransformMatrixKHR( *reinterpret_cast<TransformMatrixKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 TransformMatrixKHR &
                            operator=( TransformMatrixKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    TransformMatrixKHR & operator=( VkTransformMatrixKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::TransformMatrixKHR const *>( &rhs );
      return *this;
    }

    TransformMatrixKHR & setMatrix( std::array<std::array<float, 4>, 3> matrix_ ) VULKAN_HPP_NOEXCEPT
    {
      matrix = matrix_;
      return *this;
    }

    operator VkTransformMatrixKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkTransformMatrixKHR *>( this );
    }

    operator VkTransformMatrixKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkTransformMatrixKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( TransformMatrixKHR const & ) const = default;
#else
    bool operator==( TransformMatrixKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( matrix == rhs.matrix );
    }

    bool operator!=( TransformMatrixKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::ArrayWrapper2D<float, 3, 4> matrix = {};
  };
  static_assert( sizeof( TransformMatrixKHR ) == sizeof( VkTransformMatrixKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<TransformMatrixKHR>::value, "struct wrapper is not a standard layout!" );
  using TransformMatrixNV = TransformMatrixKHR;

  struct AccelerationStructureInstanceKHR
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR_14
      AccelerationStructureInstanceKHR( VULKAN_HPP_NAMESPACE::TransformMatrixKHR transform_           = {},
                                        uint32_t                                 instanceCustomIndex_ = {},
                                        uint32_t                                 mask_                = {},
                                        uint32_t instanceShaderBindingTableRecordOffset_              = {},
                                        VULKAN_HPP_NAMESPACE::GeometryInstanceFlagsKHR flags_         = {},
                                        uint64_t accelerationStructureReference_ = {} ) VULKAN_HPP_NOEXCEPT
      : transform( transform_ )
      , instanceCustomIndex( instanceCustomIndex_ )
      , mask( mask_ )
      , instanceShaderBindingTableRecordOffset( instanceShaderBindingTableRecordOffset_ )
      , flags( flags_ )
      , accelerationStructureReference( accelerationStructureReference_ )
    {}

    VULKAN_HPP_CONSTEXPR_14
      AccelerationStructureInstanceKHR( AccelerationStructureInstanceKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AccelerationStructureInstanceKHR( VkAccelerationStructureInstanceKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : AccelerationStructureInstanceKHR( *reinterpret_cast<AccelerationStructureInstanceKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 AccelerationStructureInstanceKHR &
                            operator=( AccelerationStructureInstanceKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AccelerationStructureInstanceKHR & operator=( VkAccelerationStructureInstanceKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::AccelerationStructureInstanceKHR const *>( &rhs );
      return *this;
    }

    AccelerationStructureInstanceKHR &
      setTransform( VULKAN_HPP_NAMESPACE::TransformMatrixKHR const & transform_ ) VULKAN_HPP_NOEXCEPT
    {
      transform = transform_;
      return *this;
    }

    AccelerationStructureInstanceKHR & setInstanceCustomIndex( uint32_t instanceCustomIndex_ ) VULKAN_HPP_NOEXCEPT
    {
      instanceCustomIndex = instanceCustomIndex_;
      return *this;
    }

    AccelerationStructureInstanceKHR & setMask( uint32_t mask_ ) VULKAN_HPP_NOEXCEPT
    {
      mask = mask_;
      return *this;
    }

    AccelerationStructureInstanceKHR &
      setInstanceShaderBindingTableRecordOffset( uint32_t instanceShaderBindingTableRecordOffset_ ) VULKAN_HPP_NOEXCEPT
    {
      instanceShaderBindingTableRecordOffset = instanceShaderBindingTableRecordOffset_;
      return *this;
    }

    AccelerationStructureInstanceKHR &
      setFlags( VULKAN_HPP_NAMESPACE::GeometryInstanceFlagsKHR flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = *reinterpret_cast<VkGeometryInstanceFlagsKHR *>( &flags_ );
      return *this;
    }

    AccelerationStructureInstanceKHR &
      setAccelerationStructureReference( uint64_t accelerationStructureReference_ ) VULKAN_HPP_NOEXCEPT
    {
      accelerationStructureReference = accelerationStructureReference_;
      return *this;
    }

    operator VkAccelerationStructureInstanceKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkAccelerationStructureInstanceKHR *>( this );
    }

    operator VkAccelerationStructureInstanceKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkAccelerationStructureInstanceKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( AccelerationStructureInstanceKHR const & ) const = default;
#else
    bool operator==( AccelerationStructureInstanceKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( transform == rhs.transform ) && ( instanceCustomIndex == rhs.instanceCustomIndex ) &&
             ( mask == rhs.mask ) &&
             ( instanceShaderBindingTableRecordOffset == rhs.instanceShaderBindingTableRecordOffset ) &&
             ( flags == rhs.flags ) && ( accelerationStructureReference == rhs.accelerationStructureReference );
    }

    bool operator!=( AccelerationStructureInstanceKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::TransformMatrixKHR transform = {};
    uint32_t                                 instanceCustomIndex : 24;
    uint32_t                                 mask : 8;
    uint32_t                                 instanceShaderBindingTableRecordOffset : 24;
    VkGeometryInstanceFlagsKHR               flags : 8;
    uint64_t                                 accelerationStructureReference = {};
  };
  static_assert( sizeof( AccelerationStructureInstanceKHR ) == sizeof( VkAccelerationStructureInstanceKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<AccelerationStructureInstanceKHR>::value,
                 "struct wrapper is not a standard layout!" );
  using AccelerationStructureInstanceNV = AccelerationStructureInstanceKHR;

  struct AccelerationStructureMatrixMotionInstanceNV
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR_14
      AccelerationStructureMatrixMotionInstanceNV( VULKAN_HPP_NAMESPACE::TransformMatrixKHR transformT0_         = {},
                                                   VULKAN_HPP_NAMESPACE::TransformMatrixKHR transformT1_         = {},
                                                   uint32_t                                 instanceCustomIndex_ = {},
                                                   uint32_t                                 mask_                = {},
                                                   uint32_t instanceShaderBindingTableRecordOffset_              = {},
                                                   VULKAN_HPP_NAMESPACE::GeometryInstanceFlagsKHR flags_         = {},
                                                   uint64_t accelerationStructureReference_ = {} ) VULKAN_HPP_NOEXCEPT
      : transformT0( transformT0_ )
      , transformT1( transformT1_ )
      , instanceCustomIndex( instanceCustomIndex_ )
      , mask( mask_ )
      , instanceShaderBindingTableRecordOffset( instanceShaderBindingTableRecordOffset_ )
      , flags( flags_ )
      , accelerationStructureReference( accelerationStructureReference_ )
    {}

    VULKAN_HPP_CONSTEXPR_14 AccelerationStructureMatrixMotionInstanceNV(
      AccelerationStructureMatrixMotionInstanceNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AccelerationStructureMatrixMotionInstanceNV( VkAccelerationStructureMatrixMotionInstanceNV const & rhs )
      VULKAN_HPP_NOEXCEPT
      : AccelerationStructureMatrixMotionInstanceNV(
          *reinterpret_cast<AccelerationStructureMatrixMotionInstanceNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 AccelerationStructureMatrixMotionInstanceNV &
                            operator=( AccelerationStructureMatrixMotionInstanceNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AccelerationStructureMatrixMotionInstanceNV &
      operator=( VkAccelerationStructureMatrixMotionInstanceNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::AccelerationStructureMatrixMotionInstanceNV const *>( &rhs );
      return *this;
    }

    AccelerationStructureMatrixMotionInstanceNV &
      setTransformT0( VULKAN_HPP_NAMESPACE::TransformMatrixKHR const & transformT0_ ) VULKAN_HPP_NOEXCEPT
    {
      transformT0 = transformT0_;
      return *this;
    }

    AccelerationStructureMatrixMotionInstanceNV &
      setTransformT1( VULKAN_HPP_NAMESPACE::TransformMatrixKHR const & transformT1_ ) VULKAN_HPP_NOEXCEPT
    {
      transformT1 = transformT1_;
      return *this;
    }

    AccelerationStructureMatrixMotionInstanceNV &
      setInstanceCustomIndex( uint32_t instanceCustomIndex_ ) VULKAN_HPP_NOEXCEPT
    {
      instanceCustomIndex = instanceCustomIndex_;
      return *this;
    }

    AccelerationStructureMatrixMotionInstanceNV & setMask( uint32_t mask_ ) VULKAN_HPP_NOEXCEPT
    {
      mask = mask_;
      return *this;
    }

    AccelerationStructureMatrixMotionInstanceNV &
      setInstanceShaderBindingTableRecordOffset( uint32_t instanceShaderBindingTableRecordOffset_ ) VULKAN_HPP_NOEXCEPT
    {
      instanceShaderBindingTableRecordOffset = instanceShaderBindingTableRecordOffset_;
      return *this;
    }

    AccelerationStructureMatrixMotionInstanceNV &
      setFlags( VULKAN_HPP_NAMESPACE::GeometryInstanceFlagsKHR flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = *reinterpret_cast<VkGeometryInstanceFlagsKHR *>( &flags_ );
      return *this;
    }

    AccelerationStructureMatrixMotionInstanceNV &
      setAccelerationStructureReference( uint64_t accelerationStructureReference_ ) VULKAN_HPP_NOEXCEPT
    {
      accelerationStructureReference = accelerationStructureReference_;
      return *this;
    }

    operator VkAccelerationStructureMatrixMotionInstanceNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkAccelerationStructureMatrixMotionInstanceNV *>( this );
    }

    operator VkAccelerationStructureMatrixMotionInstanceNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkAccelerationStructureMatrixMotionInstanceNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( AccelerationStructureMatrixMotionInstanceNV const & ) const = default;
#else
    bool operator==( AccelerationStructureMatrixMotionInstanceNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( transformT0 == rhs.transformT0 ) && ( transformT1 == rhs.transformT1 ) &&
             ( instanceCustomIndex == rhs.instanceCustomIndex ) && ( mask == rhs.mask ) &&
             ( instanceShaderBindingTableRecordOffset == rhs.instanceShaderBindingTableRecordOffset ) &&
             ( flags == rhs.flags ) && ( accelerationStructureReference == rhs.accelerationStructureReference );
    }

    bool operator!=( AccelerationStructureMatrixMotionInstanceNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::TransformMatrixKHR transformT0 = {};
    VULKAN_HPP_NAMESPACE::TransformMatrixKHR transformT1 = {};
    uint32_t                                 instanceCustomIndex : 24;
    uint32_t                                 mask : 8;
    uint32_t                                 instanceShaderBindingTableRecordOffset : 24;
    VkGeometryInstanceFlagsKHR               flags : 8;
    uint64_t                                 accelerationStructureReference = {};
  };
  static_assert( sizeof( AccelerationStructureMatrixMotionInstanceNV ) ==
                   sizeof( VkAccelerationStructureMatrixMotionInstanceNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<AccelerationStructureMatrixMotionInstanceNV>::value,
                 "struct wrapper is not a standard layout!" );

  struct AccelerationStructureMemoryRequirementsInfoNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eAccelerationStructureMemoryRequirementsInfoNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR AccelerationStructureMemoryRequirementsInfoNV(
      VULKAN_HPP_NAMESPACE::AccelerationStructureMemoryRequirementsTypeNV type_ =
        VULKAN_HPP_NAMESPACE::AccelerationStructureMemoryRequirementsTypeNV::eObject,
      VULKAN_HPP_NAMESPACE::AccelerationStructureNV accelerationStructure_ = {} ) VULKAN_HPP_NOEXCEPT
      : type( type_ )
      , accelerationStructure( accelerationStructure_ )
    {}

    VULKAN_HPP_CONSTEXPR AccelerationStructureMemoryRequirementsInfoNV(
      AccelerationStructureMemoryRequirementsInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AccelerationStructureMemoryRequirementsInfoNV( VkAccelerationStructureMemoryRequirementsInfoNV const & rhs )
      VULKAN_HPP_NOEXCEPT
      : AccelerationStructureMemoryRequirementsInfoNV(
          *reinterpret_cast<AccelerationStructureMemoryRequirementsInfoNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 AccelerationStructureMemoryRequirementsInfoNV &
                            operator=( AccelerationStructureMemoryRequirementsInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AccelerationStructureMemoryRequirementsInfoNV &
      operator=( VkAccelerationStructureMemoryRequirementsInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::AccelerationStructureMemoryRequirementsInfoNV const *>( &rhs );
      return *this;
    }

    AccelerationStructureMemoryRequirementsInfoNV & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    AccelerationStructureMemoryRequirementsInfoNV &
      setType( VULKAN_HPP_NAMESPACE::AccelerationStructureMemoryRequirementsTypeNV type_ ) VULKAN_HPP_NOEXCEPT
    {
      type = type_;
      return *this;
    }

    AccelerationStructureMemoryRequirementsInfoNV & setAccelerationStructure(
      VULKAN_HPP_NAMESPACE::AccelerationStructureNV accelerationStructure_ ) VULKAN_HPP_NOEXCEPT
    {
      accelerationStructure = accelerationStructure_;
      return *this;
    }

    operator VkAccelerationStructureMemoryRequirementsInfoNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkAccelerationStructureMemoryRequirementsInfoNV *>( this );
    }

    operator VkAccelerationStructureMemoryRequirementsInfoNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkAccelerationStructureMemoryRequirementsInfoNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( AccelerationStructureMemoryRequirementsInfoNV const & ) const = default;
#else
    bool operator==( AccelerationStructureMemoryRequirementsInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( type == rhs.type ) &&
             ( accelerationStructure == rhs.accelerationStructure );
    }

    bool operator!=( AccelerationStructureMemoryRequirementsInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::eAccelerationStructureMemoryRequirementsInfoNV;
    const void *                        pNext = {};
    VULKAN_HPP_NAMESPACE::AccelerationStructureMemoryRequirementsTypeNV type =
      VULKAN_HPP_NAMESPACE::AccelerationStructureMemoryRequirementsTypeNV::eObject;
    VULKAN_HPP_NAMESPACE::AccelerationStructureNV accelerationStructure = {};
  };
  static_assert( sizeof( AccelerationStructureMemoryRequirementsInfoNV ) ==
                   sizeof( VkAccelerationStructureMemoryRequirementsInfoNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<AccelerationStructureMemoryRequirementsInfoNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eAccelerationStructureMemoryRequirementsInfoNV>
  {
    using Type = AccelerationStructureMemoryRequirementsInfoNV;
  };

  struct AccelerationStructureMotionInfoNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eAccelerationStructureMotionInfoNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR AccelerationStructureMotionInfoNV(
      uint32_t                                                     maxInstances_ = {},
      VULKAN_HPP_NAMESPACE::AccelerationStructureMotionInfoFlagsNV flags_        = {} ) VULKAN_HPP_NOEXCEPT
      : maxInstances( maxInstances_ )
      , flags( flags_ )
    {}

    VULKAN_HPP_CONSTEXPR
      AccelerationStructureMotionInfoNV( AccelerationStructureMotionInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AccelerationStructureMotionInfoNV( VkAccelerationStructureMotionInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
      : AccelerationStructureMotionInfoNV( *reinterpret_cast<AccelerationStructureMotionInfoNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 AccelerationStructureMotionInfoNV &
                            operator=( AccelerationStructureMotionInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AccelerationStructureMotionInfoNV & operator=( VkAccelerationStructureMotionInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::AccelerationStructureMotionInfoNV const *>( &rhs );
      return *this;
    }

    AccelerationStructureMotionInfoNV & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    AccelerationStructureMotionInfoNV & setMaxInstances( uint32_t maxInstances_ ) VULKAN_HPP_NOEXCEPT
    {
      maxInstances = maxInstances_;
      return *this;
    }

    AccelerationStructureMotionInfoNV &
      setFlags( VULKAN_HPP_NAMESPACE::AccelerationStructureMotionInfoFlagsNV flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    operator VkAccelerationStructureMotionInfoNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkAccelerationStructureMotionInfoNV *>( this );
    }

    operator VkAccelerationStructureMotionInfoNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkAccelerationStructureMotionInfoNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( AccelerationStructureMotionInfoNV const & ) const = default;
#else
    bool operator==( AccelerationStructureMotionInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( maxInstances == rhs.maxInstances ) &&
             ( flags == rhs.flags );
    }

    bool operator!=( AccelerationStructureMotionInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType        = StructureType::eAccelerationStructureMotionInfoNV;
    const void *                        pNext        = {};
    uint32_t                            maxInstances = {};
    VULKAN_HPP_NAMESPACE::AccelerationStructureMotionInfoFlagsNV flags = {};
  };
  static_assert( sizeof( AccelerationStructureMotionInfoNV ) == sizeof( VkAccelerationStructureMotionInfoNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<AccelerationStructureMotionInfoNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eAccelerationStructureMotionInfoNV>
  {
    using Type = AccelerationStructureMotionInfoNV;
  };

  struct SRTDataNV
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR SRTDataNV( float sx_  = {},
                                    float a_   = {},
                                    float b_   = {},
                                    float pvx_ = {},
                                    float sy_  = {},
                                    float c_   = {},
                                    float pvy_ = {},
                                    float sz_  = {},
                                    float pvz_ = {},
                                    float qx_  = {},
                                    float qy_  = {},
                                    float qz_  = {},
                                    float qw_  = {},
                                    float tx_  = {},
                                    float ty_  = {},
                                    float tz_  = {} ) VULKAN_HPP_NOEXCEPT
      : sx( sx_ )
      , a( a_ )
      , b( b_ )
      , pvx( pvx_ )
      , sy( sy_ )
      , c( c_ )
      , pvy( pvy_ )
      , sz( sz_ )
      , pvz( pvz_ )
      , qx( qx_ )
      , qy( qy_ )
      , qz( qz_ )
      , qw( qw_ )
      , tx( tx_ )
      , ty( ty_ )
      , tz( tz_ )
    {}

    VULKAN_HPP_CONSTEXPR SRTDataNV( SRTDataNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SRTDataNV( VkSRTDataNV const & rhs ) VULKAN_HPP_NOEXCEPT : SRTDataNV( *reinterpret_cast<SRTDataNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SRTDataNV & operator=( SRTDataNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SRTDataNV & operator=( VkSRTDataNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SRTDataNV const *>( &rhs );
      return *this;
    }

    SRTDataNV & setSx( float sx_ ) VULKAN_HPP_NOEXCEPT
    {
      sx = sx_;
      return *this;
    }

    SRTDataNV & setA( float a_ ) VULKAN_HPP_NOEXCEPT
    {
      a = a_;
      return *this;
    }

    SRTDataNV & setB( float b_ ) VULKAN_HPP_NOEXCEPT
    {
      b = b_;
      return *this;
    }

    SRTDataNV & setPvx( float pvx_ ) VULKAN_HPP_NOEXCEPT
    {
      pvx = pvx_;
      return *this;
    }

    SRTDataNV & setSy( float sy_ ) VULKAN_HPP_NOEXCEPT
    {
      sy = sy_;
      return *this;
    }

    SRTDataNV & setC( float c_ ) VULKAN_HPP_NOEXCEPT
    {
      c = c_;
      return *this;
    }

    SRTDataNV & setPvy( float pvy_ ) VULKAN_HPP_NOEXCEPT
    {
      pvy = pvy_;
      return *this;
    }

    SRTDataNV & setSz( float sz_ ) VULKAN_HPP_NOEXCEPT
    {
      sz = sz_;
      return *this;
    }

    SRTDataNV & setPvz( float pvz_ ) VULKAN_HPP_NOEXCEPT
    {
      pvz = pvz_;
      return *this;
    }

    SRTDataNV & setQx( float qx_ ) VULKAN_HPP_NOEXCEPT
    {
      qx = qx_;
      return *this;
    }

    SRTDataNV & setQy( float qy_ ) VULKAN_HPP_NOEXCEPT
    {
      qy = qy_;
      return *this;
    }

    SRTDataNV & setQz( float qz_ ) VULKAN_HPP_NOEXCEPT
    {
      qz = qz_;
      return *this;
    }

    SRTDataNV & setQw( float qw_ ) VULKAN_HPP_NOEXCEPT
    {
      qw = qw_;
      return *this;
    }

    SRTDataNV & setTx( float tx_ ) VULKAN_HPP_NOEXCEPT
    {
      tx = tx_;
      return *this;
    }

    SRTDataNV & setTy( float ty_ ) VULKAN_HPP_NOEXCEPT
    {
      ty = ty_;
      return *this;
    }

    SRTDataNV & setTz( float tz_ ) VULKAN_HPP_NOEXCEPT
    {
      tz = tz_;
      return *this;
    }

    operator VkSRTDataNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSRTDataNV *>( this );
    }

    operator VkSRTDataNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSRTDataNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SRTDataNV const & ) const = default;
#else
    bool operator==( SRTDataNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sx == rhs.sx ) && ( a == rhs.a ) && ( b == rhs.b ) && ( pvx == rhs.pvx ) && ( sy == rhs.sy ) &&
             ( c == rhs.c ) && ( pvy == rhs.pvy ) && ( sz == rhs.sz ) && ( pvz == rhs.pvz ) && ( qx == rhs.qx ) &&
             ( qy == rhs.qy ) && ( qz == rhs.qz ) && ( qw == rhs.qw ) && ( tx == rhs.tx ) && ( ty == rhs.ty ) &&
             ( tz == rhs.tz );
    }

    bool operator!=( SRTDataNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    float sx  = {};
    float a   = {};
    float b   = {};
    float pvx = {};
    float sy  = {};
    float c   = {};
    float pvy = {};
    float sz  = {};
    float pvz = {};
    float qx  = {};
    float qy  = {};
    float qz  = {};
    float qw  = {};
    float tx  = {};
    float ty  = {};
    float tz  = {};
  };
  static_assert( sizeof( SRTDataNV ) == sizeof( VkSRTDataNV ), "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SRTDataNV>::value, "struct wrapper is not a standard layout!" );

  struct AccelerationStructureSRTMotionInstanceNV
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      AccelerationStructureSRTMotionInstanceNV( VULKAN_HPP_NAMESPACE::SRTDataNV transformT0_          = {},
                                                VULKAN_HPP_NAMESPACE::SRTDataNV transformT1_          = {},
                                                uint32_t                        instanceCustomIndex_  = {},
                                                uint32_t                        mask_                 = {},
                                                uint32_t instanceShaderBindingTableRecordOffset_      = {},
                                                VULKAN_HPP_NAMESPACE::GeometryInstanceFlagsKHR flags_ = {},
                                                uint64_t accelerationStructureReference_ = {} ) VULKAN_HPP_NOEXCEPT
      : transformT0( transformT0_ )
      , transformT1( transformT1_ )
      , instanceCustomIndex( instanceCustomIndex_ )
      , mask( mask_ )
      , instanceShaderBindingTableRecordOffset( instanceShaderBindingTableRecordOffset_ )
      , flags( flags_ )
      , accelerationStructureReference( accelerationStructureReference_ )
    {}

    VULKAN_HPP_CONSTEXPR AccelerationStructureSRTMotionInstanceNV(
      AccelerationStructureSRTMotionInstanceNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AccelerationStructureSRTMotionInstanceNV( VkAccelerationStructureSRTMotionInstanceNV const & rhs )
      VULKAN_HPP_NOEXCEPT
      : AccelerationStructureSRTMotionInstanceNV(
          *reinterpret_cast<AccelerationStructureSRTMotionInstanceNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 AccelerationStructureSRTMotionInstanceNV &
                            operator=( AccelerationStructureSRTMotionInstanceNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AccelerationStructureSRTMotionInstanceNV &
      operator=( VkAccelerationStructureSRTMotionInstanceNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::AccelerationStructureSRTMotionInstanceNV const *>( &rhs );
      return *this;
    }

    AccelerationStructureSRTMotionInstanceNV &
      setTransformT0( VULKAN_HPP_NAMESPACE::SRTDataNV const & transformT0_ ) VULKAN_HPP_NOEXCEPT
    {
      transformT0 = transformT0_;
      return *this;
    }

    AccelerationStructureSRTMotionInstanceNV &
      setTransformT1( VULKAN_HPP_NAMESPACE::SRTDataNV const & transformT1_ ) VULKAN_HPP_NOEXCEPT
    {
      transformT1 = transformT1_;
      return *this;
    }

    AccelerationStructureSRTMotionInstanceNV &
      setInstanceCustomIndex( uint32_t instanceCustomIndex_ ) VULKAN_HPP_NOEXCEPT
    {
      instanceCustomIndex = instanceCustomIndex_;
      return *this;
    }

    AccelerationStructureSRTMotionInstanceNV & setMask( uint32_t mask_ ) VULKAN_HPP_NOEXCEPT
    {
      mask = mask_;
      return *this;
    }

    AccelerationStructureSRTMotionInstanceNV &
      setInstanceShaderBindingTableRecordOffset( uint32_t instanceShaderBindingTableRecordOffset_ ) VULKAN_HPP_NOEXCEPT
    {
      instanceShaderBindingTableRecordOffset = instanceShaderBindingTableRecordOffset_;
      return *this;
    }

    AccelerationStructureSRTMotionInstanceNV &
      setFlags( VULKAN_HPP_NAMESPACE::GeometryInstanceFlagsKHR flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = *reinterpret_cast<VkGeometryInstanceFlagsKHR *>( &flags_ );
      return *this;
    }

    AccelerationStructureSRTMotionInstanceNV &
      setAccelerationStructureReference( uint64_t accelerationStructureReference_ ) VULKAN_HPP_NOEXCEPT
    {
      accelerationStructureReference = accelerationStructureReference_;
      return *this;
    }

    operator VkAccelerationStructureSRTMotionInstanceNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkAccelerationStructureSRTMotionInstanceNV *>( this );
    }

    operator VkAccelerationStructureSRTMotionInstanceNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkAccelerationStructureSRTMotionInstanceNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( AccelerationStructureSRTMotionInstanceNV const & ) const = default;
#else
    bool operator==( AccelerationStructureSRTMotionInstanceNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( transformT0 == rhs.transformT0 ) && ( transformT1 == rhs.transformT1 ) &&
             ( instanceCustomIndex == rhs.instanceCustomIndex ) && ( mask == rhs.mask ) &&
             ( instanceShaderBindingTableRecordOffset == rhs.instanceShaderBindingTableRecordOffset ) &&
             ( flags == rhs.flags ) && ( accelerationStructureReference == rhs.accelerationStructureReference );
    }

    bool operator!=( AccelerationStructureSRTMotionInstanceNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::SRTDataNV transformT0 = {};
    VULKAN_HPP_NAMESPACE::SRTDataNV transformT1 = {};
    uint32_t                        instanceCustomIndex : 24;
    uint32_t                        mask : 8;
    uint32_t                        instanceShaderBindingTableRecordOffset : 24;
    VkGeometryInstanceFlagsKHR      flags : 8;
    uint64_t                        accelerationStructureReference = {};
  };
  static_assert( sizeof( AccelerationStructureSRTMotionInstanceNV ) ==
                   sizeof( VkAccelerationStructureSRTMotionInstanceNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<AccelerationStructureSRTMotionInstanceNV>::value,
                 "struct wrapper is not a standard layout!" );

  union AccelerationStructureMotionInstanceDataNV
  {
    AccelerationStructureMotionInstanceDataNV(
      VULKAN_HPP_NAMESPACE::AccelerationStructureMotionInstanceDataNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      memcpy(
        static_cast<void *>( this ), &rhs, sizeof( VULKAN_HPP_NAMESPACE::AccelerationStructureMotionInstanceDataNV ) );
    }

    AccelerationStructureMotionInstanceDataNV(
      VULKAN_HPP_NAMESPACE::AccelerationStructureInstanceKHR staticInstance_ = {} )
      : staticInstance( staticInstance_ )
    {}

    AccelerationStructureMotionInstanceDataNV(
      VULKAN_HPP_NAMESPACE::AccelerationStructureMatrixMotionInstanceNV matrixMotionInstance_ )
      : matrixMotionInstance( matrixMotionInstance_ )
    {}

    AccelerationStructureMotionInstanceDataNV(
      VULKAN_HPP_NAMESPACE::AccelerationStructureSRTMotionInstanceNV srtMotionInstance_ )
      : srtMotionInstance( srtMotionInstance_ )
    {}

    AccelerationStructureMotionInstanceDataNV & setStaticInstance(
      VULKAN_HPP_NAMESPACE::AccelerationStructureInstanceKHR const & staticInstance_ ) VULKAN_HPP_NOEXCEPT
    {
      staticInstance = staticInstance_;
      return *this;
    }

    AccelerationStructureMotionInstanceDataNV & setMatrixMotionInstance(
      VULKAN_HPP_NAMESPACE::AccelerationStructureMatrixMotionInstanceNV const & matrixMotionInstance_ )
      VULKAN_HPP_NOEXCEPT
    {
      matrixMotionInstance = matrixMotionInstance_;
      return *this;
    }

    AccelerationStructureMotionInstanceDataNV & setSrtMotionInstance(
      VULKAN_HPP_NAMESPACE::AccelerationStructureSRTMotionInstanceNV const & srtMotionInstance_ ) VULKAN_HPP_NOEXCEPT
    {
      srtMotionInstance = srtMotionInstance_;
      return *this;
    }

    VULKAN_HPP_NAMESPACE::AccelerationStructureMotionInstanceDataNV &
      operator=( VULKAN_HPP_NAMESPACE::AccelerationStructureMotionInstanceDataNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      memcpy(
        static_cast<void *>( this ), &rhs, sizeof( VULKAN_HPP_NAMESPACE::AccelerationStructureMotionInstanceDataNV ) );
      return *this;
    }

    operator VkAccelerationStructureMotionInstanceDataNV const &() const
    {
      return *reinterpret_cast<const VkAccelerationStructureMotionInstanceDataNV *>( this );
    }

    operator VkAccelerationStructureMotionInstanceDataNV &()
    {
      return *reinterpret_cast<VkAccelerationStructureMotionInstanceDataNV *>( this );
    }

#ifdef VULKAN_HPP_HAS_UNRESTRICTED_UNIONS
    VULKAN_HPP_NAMESPACE::AccelerationStructureInstanceKHR            staticInstance;
    VULKAN_HPP_NAMESPACE::AccelerationStructureMatrixMotionInstanceNV matrixMotionInstance;
    VULKAN_HPP_NAMESPACE::AccelerationStructureSRTMotionInstanceNV    srtMotionInstance;
#else
    VkAccelerationStructureInstanceKHR            staticInstance;
    VkAccelerationStructureMatrixMotionInstanceNV matrixMotionInstance;
    VkAccelerationStructureSRTMotionInstanceNV    srtMotionInstance;
#endif /*VULKAN_HPP_HAS_UNRESTRICTED_UNIONS*/
  };

  struct AccelerationStructureMotionInstanceNV
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    AccelerationStructureMotionInstanceNV( VULKAN_HPP_NAMESPACE::AccelerationStructureMotionInstanceTypeNV type_ =
                                             VULKAN_HPP_NAMESPACE::AccelerationStructureMotionInstanceTypeNV::eStatic,
                                           VULKAN_HPP_NAMESPACE::AccelerationStructureMotionInstanceFlagsNV flags_ = {},
                                           VULKAN_HPP_NAMESPACE::AccelerationStructureMotionInstanceDataNV  data_ = {} )
      VULKAN_HPP_NOEXCEPT
      : type( type_ )
      , flags( flags_ )
      , data( data_ )
    {}

    AccelerationStructureMotionInstanceNV( AccelerationStructureMotionInstanceNV const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    AccelerationStructureMotionInstanceNV( VkAccelerationStructureMotionInstanceNV const & rhs ) VULKAN_HPP_NOEXCEPT
      : AccelerationStructureMotionInstanceNV(
          *reinterpret_cast<AccelerationStructureMotionInstanceNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    AccelerationStructureMotionInstanceNV &
      operator=( AccelerationStructureMotionInstanceNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AccelerationStructureMotionInstanceNV &
      operator=( VkAccelerationStructureMotionInstanceNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::AccelerationStructureMotionInstanceNV const *>( &rhs );
      return *this;
    }

    AccelerationStructureMotionInstanceNV &
      setType( VULKAN_HPP_NAMESPACE::AccelerationStructureMotionInstanceTypeNV type_ ) VULKAN_HPP_NOEXCEPT
    {
      type = type_;
      return *this;
    }

    AccelerationStructureMotionInstanceNV &
      setFlags( VULKAN_HPP_NAMESPACE::AccelerationStructureMotionInstanceFlagsNV flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    AccelerationStructureMotionInstanceNV &
      setData( VULKAN_HPP_NAMESPACE::AccelerationStructureMotionInstanceDataNV const & data_ ) VULKAN_HPP_NOEXCEPT
    {
      data = data_;
      return *this;
    }

    operator VkAccelerationStructureMotionInstanceNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkAccelerationStructureMotionInstanceNV *>( this );
    }

    operator VkAccelerationStructureMotionInstanceNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkAccelerationStructureMotionInstanceNV *>( this );
    }

  public:
    VULKAN_HPP_NAMESPACE::AccelerationStructureMotionInstanceTypeNV type =
      VULKAN_HPP_NAMESPACE::AccelerationStructureMotionInstanceTypeNV::eStatic;
    VULKAN_HPP_NAMESPACE::AccelerationStructureMotionInstanceFlagsNV flags = {};
    VULKAN_HPP_NAMESPACE::AccelerationStructureMotionInstanceDataNV  data  = {};
  };
  static_assert( sizeof( AccelerationStructureMotionInstanceNV ) == sizeof( VkAccelerationStructureMotionInstanceNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<AccelerationStructureMotionInstanceNV>::value,
                 "struct wrapper is not a standard layout!" );

  struct AccelerationStructureVersionInfoKHR
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eAccelerationStructureVersionInfoKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR AccelerationStructureVersionInfoKHR( const uint8_t * pVersionData_ = {} ) VULKAN_HPP_NOEXCEPT
      : pVersionData( pVersionData_ )
    {}

    VULKAN_HPP_CONSTEXPR AccelerationStructureVersionInfoKHR( AccelerationStructureVersionInfoKHR const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    AccelerationStructureVersionInfoKHR( VkAccelerationStructureVersionInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : AccelerationStructureVersionInfoKHR( *reinterpret_cast<AccelerationStructureVersionInfoKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 AccelerationStructureVersionInfoKHR &
                            operator=( AccelerationStructureVersionInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AccelerationStructureVersionInfoKHR &
      operator=( VkAccelerationStructureVersionInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::AccelerationStructureVersionInfoKHR const *>( &rhs );
      return *this;
    }

    AccelerationStructureVersionInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    AccelerationStructureVersionInfoKHR & setPVersionData( const uint8_t * pVersionData_ ) VULKAN_HPP_NOEXCEPT
    {
      pVersionData = pVersionData_;
      return *this;
    }

    operator VkAccelerationStructureVersionInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkAccelerationStructureVersionInfoKHR *>( this );
    }

    operator VkAccelerationStructureVersionInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkAccelerationStructureVersionInfoKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( AccelerationStructureVersionInfoKHR const & ) const = default;
#else
    bool operator==( AccelerationStructureVersionInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( pVersionData == rhs.pVersionData );
    }

    bool operator!=( AccelerationStructureVersionInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType        = StructureType::eAccelerationStructureVersionInfoKHR;
    const void *                        pNext        = {};
    const uint8_t *                     pVersionData = {};
  };
  static_assert( sizeof( AccelerationStructureVersionInfoKHR ) == sizeof( VkAccelerationStructureVersionInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<AccelerationStructureVersionInfoKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eAccelerationStructureVersionInfoKHR>
  {
    using Type = AccelerationStructureVersionInfoKHR;
  };

  struct AcquireNextImageInfoKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eAcquireNextImageInfoKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR AcquireNextImageInfoKHR( VULKAN_HPP_NAMESPACE::SwapchainKHR swapchain_ = {},
                                                  uint64_t                           timeout_   = {},
                                                  VULKAN_HPP_NAMESPACE::Semaphore    semaphore_ = {},
                                                  VULKAN_HPP_NAMESPACE::Fence        fence_     = {},
                                                  uint32_t deviceMask_ = {} ) VULKAN_HPP_NOEXCEPT
      : swapchain( swapchain_ )
      , timeout( timeout_ )
      , semaphore( semaphore_ )
      , fence( fence_ )
      , deviceMask( deviceMask_ )
    {}

    VULKAN_HPP_CONSTEXPR AcquireNextImageInfoKHR( AcquireNextImageInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AcquireNextImageInfoKHR( VkAcquireNextImageInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : AcquireNextImageInfoKHR( *reinterpret_cast<AcquireNextImageInfoKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 AcquireNextImageInfoKHR &
                            operator=( AcquireNextImageInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AcquireNextImageInfoKHR & operator=( VkAcquireNextImageInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::AcquireNextImageInfoKHR const *>( &rhs );
      return *this;
    }

    AcquireNextImageInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    AcquireNextImageInfoKHR & setSwapchain( VULKAN_HPP_NAMESPACE::SwapchainKHR swapchain_ ) VULKAN_HPP_NOEXCEPT
    {
      swapchain = swapchain_;
      return *this;
    }

    AcquireNextImageInfoKHR & setTimeout( uint64_t timeout_ ) VULKAN_HPP_NOEXCEPT
    {
      timeout = timeout_;
      return *this;
    }

    AcquireNextImageInfoKHR & setSemaphore( VULKAN_HPP_NAMESPACE::Semaphore semaphore_ ) VULKAN_HPP_NOEXCEPT
    {
      semaphore = semaphore_;
      return *this;
    }

    AcquireNextImageInfoKHR & setFence( VULKAN_HPP_NAMESPACE::Fence fence_ ) VULKAN_HPP_NOEXCEPT
    {
      fence = fence_;
      return *this;
    }

    AcquireNextImageInfoKHR & setDeviceMask( uint32_t deviceMask_ ) VULKAN_HPP_NOEXCEPT
    {
      deviceMask = deviceMask_;
      return *this;
    }

    operator VkAcquireNextImageInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkAcquireNextImageInfoKHR *>( this );
    }

    operator VkAcquireNextImageInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkAcquireNextImageInfoKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( AcquireNextImageInfoKHR const & ) const = default;
#else
    bool operator==( AcquireNextImageInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( swapchain == rhs.swapchain ) &&
             ( timeout == rhs.timeout ) && ( semaphore == rhs.semaphore ) && ( fence == rhs.fence ) &&
             ( deviceMask == rhs.deviceMask );
    }

    bool operator!=( AcquireNextImageInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType      = StructureType::eAcquireNextImageInfoKHR;
    const void *                        pNext      = {};
    VULKAN_HPP_NAMESPACE::SwapchainKHR  swapchain  = {};
    uint64_t                            timeout    = {};
    VULKAN_HPP_NAMESPACE::Semaphore     semaphore  = {};
    VULKAN_HPP_NAMESPACE::Fence         fence      = {};
    uint32_t                            deviceMask = {};
  };
  static_assert( sizeof( AcquireNextImageInfoKHR ) == sizeof( VkAcquireNextImageInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<AcquireNextImageInfoKHR>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eAcquireNextImageInfoKHR>
  {
    using Type = AcquireNextImageInfoKHR;
  };

  struct AcquireProfilingLockInfoKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eAcquireProfilingLockInfoKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR AcquireProfilingLockInfoKHR( VULKAN_HPP_NAMESPACE::AcquireProfilingLockFlagsKHR flags_ = {},
                                                      uint64_t timeout_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , timeout( timeout_ )
    {}

    VULKAN_HPP_CONSTEXPR
      AcquireProfilingLockInfoKHR( AcquireProfilingLockInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AcquireProfilingLockInfoKHR( VkAcquireProfilingLockInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : AcquireProfilingLockInfoKHR( *reinterpret_cast<AcquireProfilingLockInfoKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 AcquireProfilingLockInfoKHR &
                            operator=( AcquireProfilingLockInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AcquireProfilingLockInfoKHR & operator=( VkAcquireProfilingLockInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::AcquireProfilingLockInfoKHR const *>( &rhs );
      return *this;
    }

    AcquireProfilingLockInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    AcquireProfilingLockInfoKHR &
      setFlags( VULKAN_HPP_NAMESPACE::AcquireProfilingLockFlagsKHR flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    AcquireProfilingLockInfoKHR & setTimeout( uint64_t timeout_ ) VULKAN_HPP_NOEXCEPT
    {
      timeout = timeout_;
      return *this;
    }

    operator VkAcquireProfilingLockInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkAcquireProfilingLockInfoKHR *>( this );
    }

    operator VkAcquireProfilingLockInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkAcquireProfilingLockInfoKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( AcquireProfilingLockInfoKHR const & ) const = default;
#else
    bool operator==( AcquireProfilingLockInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) && ( timeout == rhs.timeout );
    }

    bool operator!=( AcquireProfilingLockInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                sType   = StructureType::eAcquireProfilingLockInfoKHR;
    const void *                                       pNext   = {};
    VULKAN_HPP_NAMESPACE::AcquireProfilingLockFlagsKHR flags   = {};
    uint64_t                                           timeout = {};
  };
  static_assert( sizeof( AcquireProfilingLockInfoKHR ) == sizeof( VkAcquireProfilingLockInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<AcquireProfilingLockInfoKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eAcquireProfilingLockInfoKHR>
  {
    using Type = AcquireProfilingLockInfoKHR;
  };

  struct AllocationCallbacks
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR AllocationCallbacks( void *                               pUserData_             = {},
                                              PFN_vkAllocationFunction             pfnAllocation_         = {},
                                              PFN_vkReallocationFunction           pfnReallocation_       = {},
                                              PFN_vkFreeFunction                   pfnFree_               = {},
                                              PFN_vkInternalAllocationNotification pfnInternalAllocation_ = {},
                                              PFN_vkInternalFreeNotification pfnInternalFree_ = {} ) VULKAN_HPP_NOEXCEPT
      : pUserData( pUserData_ )
      , pfnAllocation( pfnAllocation_ )
      , pfnReallocation( pfnReallocation_ )
      , pfnFree( pfnFree_ )
      , pfnInternalAllocation( pfnInternalAllocation_ )
      , pfnInternalFree( pfnInternalFree_ )
    {}

    VULKAN_HPP_CONSTEXPR AllocationCallbacks( AllocationCallbacks const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AllocationCallbacks( VkAllocationCallbacks const & rhs ) VULKAN_HPP_NOEXCEPT
      : AllocationCallbacks( *reinterpret_cast<AllocationCallbacks const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 AllocationCallbacks &
                            operator=( AllocationCallbacks const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AllocationCallbacks & operator=( VkAllocationCallbacks const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::AllocationCallbacks const *>( &rhs );
      return *this;
    }

    AllocationCallbacks & setPUserData( void * pUserData_ ) VULKAN_HPP_NOEXCEPT
    {
      pUserData = pUserData_;
      return *this;
    }

    AllocationCallbacks & setPfnAllocation( PFN_vkAllocationFunction pfnAllocation_ ) VULKAN_HPP_NOEXCEPT
    {
      pfnAllocation = pfnAllocation_;
      return *this;
    }

    AllocationCallbacks & setPfnReallocation( PFN_vkReallocationFunction pfnReallocation_ ) VULKAN_HPP_NOEXCEPT
    {
      pfnReallocation = pfnReallocation_;
      return *this;
    }

    AllocationCallbacks & setPfnFree( PFN_vkFreeFunction pfnFree_ ) VULKAN_HPP_NOEXCEPT
    {
      pfnFree = pfnFree_;
      return *this;
    }

    AllocationCallbacks &
      setPfnInternalAllocation( PFN_vkInternalAllocationNotification pfnInternalAllocation_ ) VULKAN_HPP_NOEXCEPT
    {
      pfnInternalAllocation = pfnInternalAllocation_;
      return *this;
    }

    AllocationCallbacks & setPfnInternalFree( PFN_vkInternalFreeNotification pfnInternalFree_ ) VULKAN_HPP_NOEXCEPT
    {
      pfnInternalFree = pfnInternalFree_;
      return *this;
    }

    operator VkAllocationCallbacks const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkAllocationCallbacks *>( this );
    }

    operator VkAllocationCallbacks &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkAllocationCallbacks *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( AllocationCallbacks const & ) const = default;
#else
    bool operator==( AllocationCallbacks const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( pUserData == rhs.pUserData ) && ( pfnAllocation == rhs.pfnAllocation ) &&
             ( pfnReallocation == rhs.pfnReallocation ) && ( pfnFree == rhs.pfnFree ) &&
             ( pfnInternalAllocation == rhs.pfnInternalAllocation ) && ( pfnInternalFree == rhs.pfnInternalFree );
    }

    bool operator!=( AllocationCallbacks const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    void *                               pUserData             = {};
    PFN_vkAllocationFunction             pfnAllocation         = {};
    PFN_vkReallocationFunction           pfnReallocation       = {};
    PFN_vkFreeFunction                   pfnFree               = {};
    PFN_vkInternalAllocationNotification pfnInternalAllocation = {};
    PFN_vkInternalFreeNotification       pfnInternalFree       = {};
  };
  static_assert( sizeof( AllocationCallbacks ) == sizeof( VkAllocationCallbacks ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<AllocationCallbacks>::value, "struct wrapper is not a standard layout!" );

  struct ComponentMapping
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      ComponentMapping( VULKAN_HPP_NAMESPACE::ComponentSwizzle r_ = VULKAN_HPP_NAMESPACE::ComponentSwizzle::eIdentity,
                        VULKAN_HPP_NAMESPACE::ComponentSwizzle g_ = VULKAN_HPP_NAMESPACE::ComponentSwizzle::eIdentity,
                        VULKAN_HPP_NAMESPACE::ComponentSwizzle b_ = VULKAN_HPP_NAMESPACE::ComponentSwizzle::eIdentity,
                        VULKAN_HPP_NAMESPACE::ComponentSwizzle a_ = VULKAN_HPP_NAMESPACE::ComponentSwizzle::eIdentity )
        VULKAN_HPP_NOEXCEPT
      : r( r_ )
      , g( g_ )
      , b( b_ )
      , a( a_ )
    {}

    VULKAN_HPP_CONSTEXPR ComponentMapping( ComponentMapping const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ComponentMapping( VkComponentMapping const & rhs ) VULKAN_HPP_NOEXCEPT
      : ComponentMapping( *reinterpret_cast<ComponentMapping const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ComponentMapping & operator=( ComponentMapping const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ComponentMapping & operator=( VkComponentMapping const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ComponentMapping const *>( &rhs );
      return *this;
    }

    ComponentMapping & setR( VULKAN_HPP_NAMESPACE::ComponentSwizzle r_ ) VULKAN_HPP_NOEXCEPT
    {
      r = r_;
      return *this;
    }

    ComponentMapping & setG( VULKAN_HPP_NAMESPACE::ComponentSwizzle g_ ) VULKAN_HPP_NOEXCEPT
    {
      g = g_;
      return *this;
    }

    ComponentMapping & setB( VULKAN_HPP_NAMESPACE::ComponentSwizzle b_ ) VULKAN_HPP_NOEXCEPT
    {
      b = b_;
      return *this;
    }

    ComponentMapping & setA( VULKAN_HPP_NAMESPACE::ComponentSwizzle a_ ) VULKAN_HPP_NOEXCEPT
    {
      a = a_;
      return *this;
    }

    operator VkComponentMapping const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkComponentMapping *>( this );
    }

    operator VkComponentMapping &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkComponentMapping *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ComponentMapping const & ) const = default;
#else
    bool operator==( ComponentMapping const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( r == rhs.r ) && ( g == rhs.g ) && ( b == rhs.b ) && ( a == rhs.a );
    }

    bool operator!=( ComponentMapping const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::ComponentSwizzle r = VULKAN_HPP_NAMESPACE::ComponentSwizzle::eIdentity;
    VULKAN_HPP_NAMESPACE::ComponentSwizzle g = VULKAN_HPP_NAMESPACE::ComponentSwizzle::eIdentity;
    VULKAN_HPP_NAMESPACE::ComponentSwizzle b = VULKAN_HPP_NAMESPACE::ComponentSwizzle::eIdentity;
    VULKAN_HPP_NAMESPACE::ComponentSwizzle a = VULKAN_HPP_NAMESPACE::ComponentSwizzle::eIdentity;
  };
  static_assert( sizeof( ComponentMapping ) == sizeof( VkComponentMapping ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ComponentMapping>::value, "struct wrapper is not a standard layout!" );

#if defined( VK_USE_PLATFORM_ANDROID_KHR )
  struct AndroidHardwareBufferFormatPropertiesANDROID
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eAndroidHardwareBufferFormatPropertiesANDROID;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR AndroidHardwareBufferFormatPropertiesANDROID(
      VULKAN_HPP_NAMESPACE::Format                      format_         = VULKAN_HPP_NAMESPACE::Format::eUndefined,
      uint64_t                                          externalFormat_ = {},
      VULKAN_HPP_NAMESPACE::FormatFeatureFlags          formatFeatures_ = {},
      VULKAN_HPP_NAMESPACE::ComponentMapping            samplerYcbcrConversionComponents_ = {},
      VULKAN_HPP_NAMESPACE::SamplerYcbcrModelConversion suggestedYcbcrModel_ =
        VULKAN_HPP_NAMESPACE::SamplerYcbcrModelConversion::eRgbIdentity,
      VULKAN_HPP_NAMESPACE::SamplerYcbcrRange suggestedYcbcrRange_ = VULKAN_HPP_NAMESPACE::SamplerYcbcrRange::eItuFull,
      VULKAN_HPP_NAMESPACE::ChromaLocation suggestedXChromaOffset_ = VULKAN_HPP_NAMESPACE::ChromaLocation::eCositedEven,
      VULKAN_HPP_NAMESPACE::ChromaLocation suggestedYChromaOffset_ =
        VULKAN_HPP_NAMESPACE::ChromaLocation::eCositedEven ) VULKAN_HPP_NOEXCEPT
      : format( format_ )
      , externalFormat( externalFormat_ )
      , formatFeatures( formatFeatures_ )
      , samplerYcbcrConversionComponents( samplerYcbcrConversionComponents_ )
      , suggestedYcbcrModel( suggestedYcbcrModel_ )
      , suggestedYcbcrRange( suggestedYcbcrRange_ )
      , suggestedXChromaOffset( suggestedXChromaOffset_ )
      , suggestedYChromaOffset( suggestedYChromaOffset_ )
    {}

    VULKAN_HPP_CONSTEXPR AndroidHardwareBufferFormatPropertiesANDROID(
      AndroidHardwareBufferFormatPropertiesANDROID const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AndroidHardwareBufferFormatPropertiesANDROID( VkAndroidHardwareBufferFormatPropertiesANDROID const & rhs )
      VULKAN_HPP_NOEXCEPT
      : AndroidHardwareBufferFormatPropertiesANDROID(
          *reinterpret_cast<AndroidHardwareBufferFormatPropertiesANDROID const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 AndroidHardwareBufferFormatPropertiesANDROID &
                            operator=( AndroidHardwareBufferFormatPropertiesANDROID const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AndroidHardwareBufferFormatPropertiesANDROID &
      operator=( VkAndroidHardwareBufferFormatPropertiesANDROID const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::AndroidHardwareBufferFormatPropertiesANDROID const *>( &rhs );
      return *this;
    }

    operator VkAndroidHardwareBufferFormatPropertiesANDROID const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkAndroidHardwareBufferFormatPropertiesANDROID *>( this );
    }

    operator VkAndroidHardwareBufferFormatPropertiesANDROID &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkAndroidHardwareBufferFormatPropertiesANDROID *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( AndroidHardwareBufferFormatPropertiesANDROID const & ) const = default;
#  else
    bool operator==( AndroidHardwareBufferFormatPropertiesANDROID const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( format == rhs.format ) &&
             ( externalFormat == rhs.externalFormat ) && ( formatFeatures == rhs.formatFeatures ) &&
             ( samplerYcbcrConversionComponents == rhs.samplerYcbcrConversionComponents ) &&
             ( suggestedYcbcrModel == rhs.suggestedYcbcrModel ) && ( suggestedYcbcrRange == rhs.suggestedYcbcrRange ) &&
             ( suggestedXChromaOffset == rhs.suggestedXChromaOffset ) &&
             ( suggestedYChromaOffset == rhs.suggestedYChromaOffset );
    }

    bool operator!=( AndroidHardwareBufferFormatPropertiesANDROID const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType      sType  = StructureType::eAndroidHardwareBufferFormatPropertiesANDROID;
    void *                                   pNext  = {};
    VULKAN_HPP_NAMESPACE::Format             format = VULKAN_HPP_NAMESPACE::Format::eUndefined;
    uint64_t                                 externalFormat                   = {};
    VULKAN_HPP_NAMESPACE::FormatFeatureFlags formatFeatures                   = {};
    VULKAN_HPP_NAMESPACE::ComponentMapping   samplerYcbcrConversionComponents = {};
    VULKAN_HPP_NAMESPACE::SamplerYcbcrModelConversion suggestedYcbcrModel =
      VULKAN_HPP_NAMESPACE::SamplerYcbcrModelConversion::eRgbIdentity;
    VULKAN_HPP_NAMESPACE::SamplerYcbcrRange suggestedYcbcrRange    = VULKAN_HPP_NAMESPACE::SamplerYcbcrRange::eItuFull;
    VULKAN_HPP_NAMESPACE::ChromaLocation    suggestedXChromaOffset = VULKAN_HPP_NAMESPACE::ChromaLocation::eCositedEven;
    VULKAN_HPP_NAMESPACE::ChromaLocation    suggestedYChromaOffset = VULKAN_HPP_NAMESPACE::ChromaLocation::eCositedEven;
  };
  static_assert( sizeof( AndroidHardwareBufferFormatPropertiesANDROID ) ==
                   sizeof( VkAndroidHardwareBufferFormatPropertiesANDROID ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<AndroidHardwareBufferFormatPropertiesANDROID>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eAndroidHardwareBufferFormatPropertiesANDROID>
  {
    using Type = AndroidHardwareBufferFormatPropertiesANDROID;
  };
#endif /*VK_USE_PLATFORM_ANDROID_KHR*/

#if defined( VK_USE_PLATFORM_ANDROID_KHR )
  struct AndroidHardwareBufferPropertiesANDROID
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eAndroidHardwareBufferPropertiesANDROID;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR AndroidHardwareBufferPropertiesANDROID( VULKAN_HPP_NAMESPACE::DeviceSize allocationSize_ = {},
                                                                 uint32_t memoryTypeBits_ = {} ) VULKAN_HPP_NOEXCEPT
      : allocationSize( allocationSize_ )
      , memoryTypeBits( memoryTypeBits_ )
    {}

    VULKAN_HPP_CONSTEXPR AndroidHardwareBufferPropertiesANDROID( AndroidHardwareBufferPropertiesANDROID const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    AndroidHardwareBufferPropertiesANDROID( VkAndroidHardwareBufferPropertiesANDROID const & rhs ) VULKAN_HPP_NOEXCEPT
      : AndroidHardwareBufferPropertiesANDROID(
          *reinterpret_cast<AndroidHardwareBufferPropertiesANDROID const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 AndroidHardwareBufferPropertiesANDROID &
                            operator=( AndroidHardwareBufferPropertiesANDROID const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AndroidHardwareBufferPropertiesANDROID &
      operator=( VkAndroidHardwareBufferPropertiesANDROID const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::AndroidHardwareBufferPropertiesANDROID const *>( &rhs );
      return *this;
    }

    operator VkAndroidHardwareBufferPropertiesANDROID const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkAndroidHardwareBufferPropertiesANDROID *>( this );
    }

    operator VkAndroidHardwareBufferPropertiesANDROID &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkAndroidHardwareBufferPropertiesANDROID *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( AndroidHardwareBufferPropertiesANDROID const & ) const = default;
#  else
    bool operator==( AndroidHardwareBufferPropertiesANDROID const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( allocationSize == rhs.allocationSize ) &&
             ( memoryTypeBits == rhs.memoryTypeBits );
    }

    bool operator!=( AndroidHardwareBufferPropertiesANDROID const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType          = StructureType::eAndroidHardwareBufferPropertiesANDROID;
    void *                              pNext          = {};
    VULKAN_HPP_NAMESPACE::DeviceSize    allocationSize = {};
    uint32_t                            memoryTypeBits = {};
  };
  static_assert( sizeof( AndroidHardwareBufferPropertiesANDROID ) == sizeof( VkAndroidHardwareBufferPropertiesANDROID ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<AndroidHardwareBufferPropertiesANDROID>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eAndroidHardwareBufferPropertiesANDROID>
  {
    using Type = AndroidHardwareBufferPropertiesANDROID;
  };
#endif /*VK_USE_PLATFORM_ANDROID_KHR*/

#if defined( VK_USE_PLATFORM_ANDROID_KHR )
  struct AndroidHardwareBufferUsageANDROID
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eAndroidHardwareBufferUsageANDROID;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      AndroidHardwareBufferUsageANDROID( uint64_t androidHardwareBufferUsage_ = {} ) VULKAN_HPP_NOEXCEPT
      : androidHardwareBufferUsage( androidHardwareBufferUsage_ )
    {}

    VULKAN_HPP_CONSTEXPR
      AndroidHardwareBufferUsageANDROID( AndroidHardwareBufferUsageANDROID const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AndroidHardwareBufferUsageANDROID( VkAndroidHardwareBufferUsageANDROID const & rhs ) VULKAN_HPP_NOEXCEPT
      : AndroidHardwareBufferUsageANDROID( *reinterpret_cast<AndroidHardwareBufferUsageANDROID const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 AndroidHardwareBufferUsageANDROID &
                            operator=( AndroidHardwareBufferUsageANDROID const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AndroidHardwareBufferUsageANDROID & operator=( VkAndroidHardwareBufferUsageANDROID const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::AndroidHardwareBufferUsageANDROID const *>( &rhs );
      return *this;
    }

    operator VkAndroidHardwareBufferUsageANDROID const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkAndroidHardwareBufferUsageANDROID *>( this );
    }

    operator VkAndroidHardwareBufferUsageANDROID &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkAndroidHardwareBufferUsageANDROID *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( AndroidHardwareBufferUsageANDROID const & ) const = default;
#  else
    bool operator==( AndroidHardwareBufferUsageANDROID const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( androidHardwareBufferUsage == rhs.androidHardwareBufferUsage );
    }

    bool operator!=( AndroidHardwareBufferUsageANDROID const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType                      = StructureType::eAndroidHardwareBufferUsageANDROID;
    void *                              pNext                      = {};
    uint64_t                            androidHardwareBufferUsage = {};
  };
  static_assert( sizeof( AndroidHardwareBufferUsageANDROID ) == sizeof( VkAndroidHardwareBufferUsageANDROID ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<AndroidHardwareBufferUsageANDROID>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eAndroidHardwareBufferUsageANDROID>
  {
    using Type = AndroidHardwareBufferUsageANDROID;
  };
#endif /*VK_USE_PLATFORM_ANDROID_KHR*/

#if defined( VK_USE_PLATFORM_ANDROID_KHR )
  struct AndroidSurfaceCreateInfoKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eAndroidSurfaceCreateInfoKHR;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR AndroidSurfaceCreateInfoKHR( VULKAN_HPP_NAMESPACE::AndroidSurfaceCreateFlagsKHR flags_ = {},
                                                      struct ANativeWindow * window_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , window( window_ )
    {}

    VULKAN_HPP_CONSTEXPR
      AndroidSurfaceCreateInfoKHR( AndroidSurfaceCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AndroidSurfaceCreateInfoKHR( VkAndroidSurfaceCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : AndroidSurfaceCreateInfoKHR( *reinterpret_cast<AndroidSurfaceCreateInfoKHR const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 AndroidSurfaceCreateInfoKHR &
                            operator=( AndroidSurfaceCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AndroidSurfaceCreateInfoKHR & operator=( VkAndroidSurfaceCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::AndroidSurfaceCreateInfoKHR const *>( &rhs );
      return *this;
    }

    AndroidSurfaceCreateInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    AndroidSurfaceCreateInfoKHR &
      setFlags( VULKAN_HPP_NAMESPACE::AndroidSurfaceCreateFlagsKHR flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    AndroidSurfaceCreateInfoKHR & setWindow( struct ANativeWindow * window_ ) VULKAN_HPP_NOEXCEPT
    {
      window = window_;
      return *this;
    }

    operator VkAndroidSurfaceCreateInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkAndroidSurfaceCreateInfoKHR *>( this );
    }

    operator VkAndroidSurfaceCreateInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkAndroidSurfaceCreateInfoKHR *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( AndroidSurfaceCreateInfoKHR const & ) const = default;
#  else
    bool operator==( AndroidSurfaceCreateInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) && ( window == rhs.window );
    }

    bool operator!=( AndroidSurfaceCreateInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                sType  = StructureType::eAndroidSurfaceCreateInfoKHR;
    const void *                                       pNext  = {};
    VULKAN_HPP_NAMESPACE::AndroidSurfaceCreateFlagsKHR flags  = {};
    struct ANativeWindow *                             window = {};
  };
  static_assert( sizeof( AndroidSurfaceCreateInfoKHR ) == sizeof( VkAndroidSurfaceCreateInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<AndroidSurfaceCreateInfoKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eAndroidSurfaceCreateInfoKHR>
  {
    using Type = AndroidSurfaceCreateInfoKHR;
  };
#endif /*VK_USE_PLATFORM_ANDROID_KHR*/

  struct ApplicationInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eApplicationInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ApplicationInfo( const char * pApplicationName_   = {},
                                          uint32_t     applicationVersion_ = {},
                                          const char * pEngineName_        = {},
                                          uint32_t     engineVersion_      = {},
                                          uint32_t     apiVersion_         = {} ) VULKAN_HPP_NOEXCEPT
      : pApplicationName( pApplicationName_ )
      , applicationVersion( applicationVersion_ )
      , pEngineName( pEngineName_ )
      , engineVersion( engineVersion_ )
      , apiVersion( apiVersion_ )
    {}

    VULKAN_HPP_CONSTEXPR ApplicationInfo( ApplicationInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ApplicationInfo( VkApplicationInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : ApplicationInfo( *reinterpret_cast<ApplicationInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ApplicationInfo & operator=( ApplicationInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ApplicationInfo & operator=( VkApplicationInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ApplicationInfo const *>( &rhs );
      return *this;
    }

    ApplicationInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ApplicationInfo & setPApplicationName( const char * pApplicationName_ ) VULKAN_HPP_NOEXCEPT
    {
      pApplicationName = pApplicationName_;
      return *this;
    }

    ApplicationInfo & setApplicationVersion( uint32_t applicationVersion_ ) VULKAN_HPP_NOEXCEPT
    {
      applicationVersion = applicationVersion_;
      return *this;
    }

    ApplicationInfo & setPEngineName( const char * pEngineName_ ) VULKAN_HPP_NOEXCEPT
    {
      pEngineName = pEngineName_;
      return *this;
    }

    ApplicationInfo & setEngineVersion( uint32_t engineVersion_ ) VULKAN_HPP_NOEXCEPT
    {
      engineVersion = engineVersion_;
      return *this;
    }

    ApplicationInfo & setApiVersion( uint32_t apiVersion_ ) VULKAN_HPP_NOEXCEPT
    {
      apiVersion = apiVersion_;
      return *this;
    }

    operator VkApplicationInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkApplicationInfo *>( this );
    }

    operator VkApplicationInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkApplicationInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ApplicationInfo const & ) const = default;
#else
    bool operator==( ApplicationInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( pApplicationName == rhs.pApplicationName ) &&
             ( applicationVersion == rhs.applicationVersion ) && ( pEngineName == rhs.pEngineName ) &&
             ( engineVersion == rhs.engineVersion ) && ( apiVersion == rhs.apiVersion );
    }

    bool operator!=( ApplicationInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType              = StructureType::eApplicationInfo;
    const void *                        pNext              = {};
    const char *                        pApplicationName   = {};
    uint32_t                            applicationVersion = {};
    const char *                        pEngineName        = {};
    uint32_t                            engineVersion      = {};
    uint32_t                            apiVersion         = {};
  };
  static_assert( sizeof( ApplicationInfo ) == sizeof( VkApplicationInfo ), "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ApplicationInfo>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eApplicationInfo>
  {
    using Type = ApplicationInfo;
  };

  struct AttachmentDescription
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR AttachmentDescription(
      VULKAN_HPP_NAMESPACE::AttachmentDescriptionFlags flags_         = {},
      VULKAN_HPP_NAMESPACE::Format                     format_        = VULKAN_HPP_NAMESPACE::Format::eUndefined,
      VULKAN_HPP_NAMESPACE::SampleCountFlagBits        samples_       = VULKAN_HPP_NAMESPACE::SampleCountFlagBits::e1,
      VULKAN_HPP_NAMESPACE::AttachmentLoadOp           loadOp_        = VULKAN_HPP_NAMESPACE::AttachmentLoadOp::eLoad,
      VULKAN_HPP_NAMESPACE::AttachmentStoreOp          storeOp_       = VULKAN_HPP_NAMESPACE::AttachmentStoreOp::eStore,
      VULKAN_HPP_NAMESPACE::AttachmentLoadOp           stencilLoadOp_ = VULKAN_HPP_NAMESPACE::AttachmentLoadOp::eLoad,
      VULKAN_HPP_NAMESPACE::AttachmentStoreOp stencilStoreOp_         = VULKAN_HPP_NAMESPACE::AttachmentStoreOp::eStore,
      VULKAN_HPP_NAMESPACE::ImageLayout       initialLayout_          = VULKAN_HPP_NAMESPACE::ImageLayout::eUndefined,
      VULKAN_HPP_NAMESPACE::ImageLayout       finalLayout_            = VULKAN_HPP_NAMESPACE::ImageLayout::eUndefined )
      VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , format( format_ )
      , samples( samples_ )
      , loadOp( loadOp_ )
      , storeOp( storeOp_ )
      , stencilLoadOp( stencilLoadOp_ )
      , stencilStoreOp( stencilStoreOp_ )
      , initialLayout( initialLayout_ )
      , finalLayout( finalLayout_ )
    {}

    VULKAN_HPP_CONSTEXPR AttachmentDescription( AttachmentDescription const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AttachmentDescription( VkAttachmentDescription const & rhs ) VULKAN_HPP_NOEXCEPT
      : AttachmentDescription( *reinterpret_cast<AttachmentDescription const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 AttachmentDescription &
                            operator=( AttachmentDescription const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AttachmentDescription & operator=( VkAttachmentDescription const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::AttachmentDescription const *>( &rhs );
      return *this;
    }

    AttachmentDescription & setFlags( VULKAN_HPP_NAMESPACE::AttachmentDescriptionFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    AttachmentDescription & setFormat( VULKAN_HPP_NAMESPACE::Format format_ ) VULKAN_HPP_NOEXCEPT
    {
      format = format_;
      return *this;
    }

    AttachmentDescription & setSamples( VULKAN_HPP_NAMESPACE::SampleCountFlagBits samples_ ) VULKAN_HPP_NOEXCEPT
    {
      samples = samples_;
      return *this;
    }

    AttachmentDescription & setLoadOp( VULKAN_HPP_NAMESPACE::AttachmentLoadOp loadOp_ ) VULKAN_HPP_NOEXCEPT
    {
      loadOp = loadOp_;
      return *this;
    }

    AttachmentDescription & setStoreOp( VULKAN_HPP_NAMESPACE::AttachmentStoreOp storeOp_ ) VULKAN_HPP_NOEXCEPT
    {
      storeOp = storeOp_;
      return *this;
    }

    AttachmentDescription &
      setStencilLoadOp( VULKAN_HPP_NAMESPACE::AttachmentLoadOp stencilLoadOp_ ) VULKAN_HPP_NOEXCEPT
    {
      stencilLoadOp = stencilLoadOp_;
      return *this;
    }

    AttachmentDescription &
      setStencilStoreOp( VULKAN_HPP_NAMESPACE::AttachmentStoreOp stencilStoreOp_ ) VULKAN_HPP_NOEXCEPT
    {
      stencilStoreOp = stencilStoreOp_;
      return *this;
    }

    AttachmentDescription & setInitialLayout( VULKAN_HPP_NAMESPACE::ImageLayout initialLayout_ ) VULKAN_HPP_NOEXCEPT
    {
      initialLayout = initialLayout_;
      return *this;
    }

    AttachmentDescription & setFinalLayout( VULKAN_HPP_NAMESPACE::ImageLayout finalLayout_ ) VULKAN_HPP_NOEXCEPT
    {
      finalLayout = finalLayout_;
      return *this;
    }

    operator VkAttachmentDescription const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkAttachmentDescription *>( this );
    }

    operator VkAttachmentDescription &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkAttachmentDescription *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( AttachmentDescription const & ) const = default;
#else
    bool operator==( AttachmentDescription const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( flags == rhs.flags ) && ( format == rhs.format ) && ( samples == rhs.samples ) &&
             ( loadOp == rhs.loadOp ) && ( storeOp == rhs.storeOp ) && ( stencilLoadOp == rhs.stencilLoadOp ) &&
             ( stencilStoreOp == rhs.stencilStoreOp ) && ( initialLayout == rhs.initialLayout ) &&
             ( finalLayout == rhs.finalLayout );
    }

    bool operator!=( AttachmentDescription const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::AttachmentDescriptionFlags flags          = {};
    VULKAN_HPP_NAMESPACE::Format                     format         = VULKAN_HPP_NAMESPACE::Format::eUndefined;
    VULKAN_HPP_NAMESPACE::SampleCountFlagBits        samples        = VULKAN_HPP_NAMESPACE::SampleCountFlagBits::e1;
    VULKAN_HPP_NAMESPACE::AttachmentLoadOp           loadOp         = VULKAN_HPP_NAMESPACE::AttachmentLoadOp::eLoad;
    VULKAN_HPP_NAMESPACE::AttachmentStoreOp          storeOp        = VULKAN_HPP_NAMESPACE::AttachmentStoreOp::eStore;
    VULKAN_HPP_NAMESPACE::AttachmentLoadOp           stencilLoadOp  = VULKAN_HPP_NAMESPACE::AttachmentLoadOp::eLoad;
    VULKAN_HPP_NAMESPACE::AttachmentStoreOp          stencilStoreOp = VULKAN_HPP_NAMESPACE::AttachmentStoreOp::eStore;
    VULKAN_HPP_NAMESPACE::ImageLayout                initialLayout  = VULKAN_HPP_NAMESPACE::ImageLayout::eUndefined;
    VULKAN_HPP_NAMESPACE::ImageLayout                finalLayout    = VULKAN_HPP_NAMESPACE::ImageLayout::eUndefined;
  };
  static_assert( sizeof( AttachmentDescription ) == sizeof( VkAttachmentDescription ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<AttachmentDescription>::value, "struct wrapper is not a standard layout!" );

  struct AttachmentDescription2
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eAttachmentDescription2;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR AttachmentDescription2(
      VULKAN_HPP_NAMESPACE::AttachmentDescriptionFlags flags_         = {},
      VULKAN_HPP_NAMESPACE::Format                     format_        = VULKAN_HPP_NAMESPACE::Format::eUndefined,
      VULKAN_HPP_NAMESPACE::SampleCountFlagBits        samples_       = VULKAN_HPP_NAMESPACE::SampleCountFlagBits::e1,
      VULKAN_HPP_NAMESPACE::AttachmentLoadOp           loadOp_        = VULKAN_HPP_NAMESPACE::AttachmentLoadOp::eLoad,
      VULKAN_HPP_NAMESPACE::AttachmentStoreOp          storeOp_       = VULKAN_HPP_NAMESPACE::AttachmentStoreOp::eStore,
      VULKAN_HPP_NAMESPACE::AttachmentLoadOp           stencilLoadOp_ = VULKAN_HPP_NAMESPACE::AttachmentLoadOp::eLoad,
      VULKAN_HPP_NAMESPACE::AttachmentStoreOp stencilStoreOp_         = VULKAN_HPP_NAMESPACE::AttachmentStoreOp::eStore,
      VULKAN_HPP_NAMESPACE::ImageLayout       initialLayout_          = VULKAN_HPP_NAMESPACE::ImageLayout::eUndefined,
      VULKAN_HPP_NAMESPACE::ImageLayout       finalLayout_            = VULKAN_HPP_NAMESPACE::ImageLayout::eUndefined )
      VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , format( format_ )
      , samples( samples_ )
      , loadOp( loadOp_ )
      , storeOp( storeOp_ )
      , stencilLoadOp( stencilLoadOp_ )
      , stencilStoreOp( stencilStoreOp_ )
      , initialLayout( initialLayout_ )
      , finalLayout( finalLayout_ )
    {}

    VULKAN_HPP_CONSTEXPR AttachmentDescription2( AttachmentDescription2 const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AttachmentDescription2( VkAttachmentDescription2 const & rhs ) VULKAN_HPP_NOEXCEPT
      : AttachmentDescription2( *reinterpret_cast<AttachmentDescription2 const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 AttachmentDescription2 &
                            operator=( AttachmentDescription2 const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AttachmentDescription2 & operator=( VkAttachmentDescription2 const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::AttachmentDescription2 const *>( &rhs );
      return *this;
    }

    AttachmentDescription2 & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    AttachmentDescription2 & setFlags( VULKAN_HPP_NAMESPACE::AttachmentDescriptionFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    AttachmentDescription2 & setFormat( VULKAN_HPP_NAMESPACE::Format format_ ) VULKAN_HPP_NOEXCEPT
    {
      format = format_;
      return *this;
    }

    AttachmentDescription2 & setSamples( VULKAN_HPP_NAMESPACE::SampleCountFlagBits samples_ ) VULKAN_HPP_NOEXCEPT
    {
      samples = samples_;
      return *this;
    }

    AttachmentDescription2 & setLoadOp( VULKAN_HPP_NAMESPACE::AttachmentLoadOp loadOp_ ) VULKAN_HPP_NOEXCEPT
    {
      loadOp = loadOp_;
      return *this;
    }

    AttachmentDescription2 & setStoreOp( VULKAN_HPP_NAMESPACE::AttachmentStoreOp storeOp_ ) VULKAN_HPP_NOEXCEPT
    {
      storeOp = storeOp_;
      return *this;
    }

    AttachmentDescription2 &
      setStencilLoadOp( VULKAN_HPP_NAMESPACE::AttachmentLoadOp stencilLoadOp_ ) VULKAN_HPP_NOEXCEPT
    {
      stencilLoadOp = stencilLoadOp_;
      return *this;
    }

    AttachmentDescription2 &
      setStencilStoreOp( VULKAN_HPP_NAMESPACE::AttachmentStoreOp stencilStoreOp_ ) VULKAN_HPP_NOEXCEPT
    {
      stencilStoreOp = stencilStoreOp_;
      return *this;
    }

    AttachmentDescription2 & setInitialLayout( VULKAN_HPP_NAMESPACE::ImageLayout initialLayout_ ) VULKAN_HPP_NOEXCEPT
    {
      initialLayout = initialLayout_;
      return *this;
    }

    AttachmentDescription2 & setFinalLayout( VULKAN_HPP_NAMESPACE::ImageLayout finalLayout_ ) VULKAN_HPP_NOEXCEPT
    {
      finalLayout = finalLayout_;
      return *this;
    }

    operator VkAttachmentDescription2 const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkAttachmentDescription2 *>( this );
    }

    operator VkAttachmentDescription2 &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkAttachmentDescription2 *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( AttachmentDescription2 const & ) const = default;
#else
    bool operator==( AttachmentDescription2 const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) && ( format == rhs.format ) &&
             ( samples == rhs.samples ) && ( loadOp == rhs.loadOp ) && ( storeOp == rhs.storeOp ) &&
             ( stencilLoadOp == rhs.stencilLoadOp ) && ( stencilStoreOp == rhs.stencilStoreOp ) &&
             ( initialLayout == rhs.initialLayout ) && ( finalLayout == rhs.finalLayout );
    }

    bool operator!=( AttachmentDescription2 const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType              sType          = StructureType::eAttachmentDescription2;
    const void *                                     pNext          = {};
    VULKAN_HPP_NAMESPACE::AttachmentDescriptionFlags flags          = {};
    VULKAN_HPP_NAMESPACE::Format                     format         = VULKAN_HPP_NAMESPACE::Format::eUndefined;
    VULKAN_HPP_NAMESPACE::SampleCountFlagBits        samples        = VULKAN_HPP_NAMESPACE::SampleCountFlagBits::e1;
    VULKAN_HPP_NAMESPACE::AttachmentLoadOp           loadOp         = VULKAN_HPP_NAMESPACE::AttachmentLoadOp::eLoad;
    VULKAN_HPP_NAMESPACE::AttachmentStoreOp          storeOp        = VULKAN_HPP_NAMESPACE::AttachmentStoreOp::eStore;
    VULKAN_HPP_NAMESPACE::AttachmentLoadOp           stencilLoadOp  = VULKAN_HPP_NAMESPACE::AttachmentLoadOp::eLoad;
    VULKAN_HPP_NAMESPACE::AttachmentStoreOp          stencilStoreOp = VULKAN_HPP_NAMESPACE::AttachmentStoreOp::eStore;
    VULKAN_HPP_NAMESPACE::ImageLayout                initialLayout  = VULKAN_HPP_NAMESPACE::ImageLayout::eUndefined;
    VULKAN_HPP_NAMESPACE::ImageLayout                finalLayout    = VULKAN_HPP_NAMESPACE::ImageLayout::eUndefined;
  };
  static_assert( sizeof( AttachmentDescription2 ) == sizeof( VkAttachmentDescription2 ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<AttachmentDescription2>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eAttachmentDescription2>
  {
    using Type = AttachmentDescription2;
  };
  using AttachmentDescription2KHR = AttachmentDescription2;

  struct AttachmentDescriptionStencilLayout
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eAttachmentDescriptionStencilLayout;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR AttachmentDescriptionStencilLayout(
      VULKAN_HPP_NAMESPACE::ImageLayout stencilInitialLayout_ = VULKAN_HPP_NAMESPACE::ImageLayout::eUndefined,
      VULKAN_HPP_NAMESPACE::ImageLayout stencilFinalLayout_   = VULKAN_HPP_NAMESPACE::ImageLayout::eUndefined )
      VULKAN_HPP_NOEXCEPT
      : stencilInitialLayout( stencilInitialLayout_ )
      , stencilFinalLayout( stencilFinalLayout_ )
    {}

    VULKAN_HPP_CONSTEXPR AttachmentDescriptionStencilLayout( AttachmentDescriptionStencilLayout const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    AttachmentDescriptionStencilLayout( VkAttachmentDescriptionStencilLayout const & rhs ) VULKAN_HPP_NOEXCEPT
      : AttachmentDescriptionStencilLayout( *reinterpret_cast<AttachmentDescriptionStencilLayout const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 AttachmentDescriptionStencilLayout &
                            operator=( AttachmentDescriptionStencilLayout const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AttachmentDescriptionStencilLayout &
      operator=( VkAttachmentDescriptionStencilLayout const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::AttachmentDescriptionStencilLayout const *>( &rhs );
      return *this;
    }

    AttachmentDescriptionStencilLayout & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    AttachmentDescriptionStencilLayout &
      setStencilInitialLayout( VULKAN_HPP_NAMESPACE::ImageLayout stencilInitialLayout_ ) VULKAN_HPP_NOEXCEPT
    {
      stencilInitialLayout = stencilInitialLayout_;
      return *this;
    }

    AttachmentDescriptionStencilLayout &
      setStencilFinalLayout( VULKAN_HPP_NAMESPACE::ImageLayout stencilFinalLayout_ ) VULKAN_HPP_NOEXCEPT
    {
      stencilFinalLayout = stencilFinalLayout_;
      return *this;
    }

    operator VkAttachmentDescriptionStencilLayout const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkAttachmentDescriptionStencilLayout *>( this );
    }

    operator VkAttachmentDescriptionStencilLayout &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkAttachmentDescriptionStencilLayout *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( AttachmentDescriptionStencilLayout const & ) const = default;
#else
    bool operator==( AttachmentDescriptionStencilLayout const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( stencilInitialLayout == rhs.stencilInitialLayout ) &&
             ( stencilFinalLayout == rhs.stencilFinalLayout );
    }

    bool operator!=( AttachmentDescriptionStencilLayout const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType                = StructureType::eAttachmentDescriptionStencilLayout;
    void *                              pNext                = {};
    VULKAN_HPP_NAMESPACE::ImageLayout   stencilInitialLayout = VULKAN_HPP_NAMESPACE::ImageLayout::eUndefined;
    VULKAN_HPP_NAMESPACE::ImageLayout   stencilFinalLayout   = VULKAN_HPP_NAMESPACE::ImageLayout::eUndefined;
  };
  static_assert( sizeof( AttachmentDescriptionStencilLayout ) == sizeof( VkAttachmentDescriptionStencilLayout ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<AttachmentDescriptionStencilLayout>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eAttachmentDescriptionStencilLayout>
  {
    using Type = AttachmentDescriptionStencilLayout;
  };
  using AttachmentDescriptionStencilLayoutKHR = AttachmentDescriptionStencilLayout;

  struct AttachmentReference
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR AttachmentReference(
      uint32_t                          attachment_ = {},
      VULKAN_HPP_NAMESPACE::ImageLayout layout_ = VULKAN_HPP_NAMESPACE::ImageLayout::eUndefined ) VULKAN_HPP_NOEXCEPT
      : attachment( attachment_ )
      , layout( layout_ )
    {}

    VULKAN_HPP_CONSTEXPR AttachmentReference( AttachmentReference const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AttachmentReference( VkAttachmentReference const & rhs ) VULKAN_HPP_NOEXCEPT
      : AttachmentReference( *reinterpret_cast<AttachmentReference const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 AttachmentReference &
                            operator=( AttachmentReference const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AttachmentReference & operator=( VkAttachmentReference const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::AttachmentReference const *>( &rhs );
      return *this;
    }

    AttachmentReference & setAttachment( uint32_t attachment_ ) VULKAN_HPP_NOEXCEPT
    {
      attachment = attachment_;
      return *this;
    }

    AttachmentReference & setLayout( VULKAN_HPP_NAMESPACE::ImageLayout layout_ ) VULKAN_HPP_NOEXCEPT
    {
      layout = layout_;
      return *this;
    }

    operator VkAttachmentReference const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkAttachmentReference *>( this );
    }

    operator VkAttachmentReference &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkAttachmentReference *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( AttachmentReference const & ) const = default;
#else
    bool operator==( AttachmentReference const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( attachment == rhs.attachment ) && ( layout == rhs.layout );
    }

    bool operator!=( AttachmentReference const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    uint32_t                          attachment = {};
    VULKAN_HPP_NAMESPACE::ImageLayout layout     = VULKAN_HPP_NAMESPACE::ImageLayout::eUndefined;
  };
  static_assert( sizeof( AttachmentReference ) == sizeof( VkAttachmentReference ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<AttachmentReference>::value, "struct wrapper is not a standard layout!" );

  struct AttachmentReference2
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eAttachmentReference2;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      AttachmentReference2( uint32_t                          attachment_ = {},
                            VULKAN_HPP_NAMESPACE::ImageLayout layout_ = VULKAN_HPP_NAMESPACE::ImageLayout::eUndefined,
                            VULKAN_HPP_NAMESPACE::ImageAspectFlags aspectMask_ = {} ) VULKAN_HPP_NOEXCEPT
      : attachment( attachment_ )
      , layout( layout_ )
      , aspectMask( aspectMask_ )
    {}

    VULKAN_HPP_CONSTEXPR AttachmentReference2( AttachmentReference2 const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AttachmentReference2( VkAttachmentReference2 const & rhs ) VULKAN_HPP_NOEXCEPT
      : AttachmentReference2( *reinterpret_cast<AttachmentReference2 const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 AttachmentReference2 &
                            operator=( AttachmentReference2 const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AttachmentReference2 & operator=( VkAttachmentReference2 const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::AttachmentReference2 const *>( &rhs );
      return *this;
    }

    AttachmentReference2 & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    AttachmentReference2 & setAttachment( uint32_t attachment_ ) VULKAN_HPP_NOEXCEPT
    {
      attachment = attachment_;
      return *this;
    }

    AttachmentReference2 & setLayout( VULKAN_HPP_NAMESPACE::ImageLayout layout_ ) VULKAN_HPP_NOEXCEPT
    {
      layout = layout_;
      return *this;
    }

    AttachmentReference2 & setAspectMask( VULKAN_HPP_NAMESPACE::ImageAspectFlags aspectMask_ ) VULKAN_HPP_NOEXCEPT
    {
      aspectMask = aspectMask_;
      return *this;
    }

    operator VkAttachmentReference2 const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkAttachmentReference2 *>( this );
    }

    operator VkAttachmentReference2 &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkAttachmentReference2 *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( AttachmentReference2 const & ) const = default;
#else
    bool operator==( AttachmentReference2 const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( attachment == rhs.attachment ) &&
             ( layout == rhs.layout ) && ( aspectMask == rhs.aspectMask );
    }

    bool operator!=( AttachmentReference2 const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType    sType      = StructureType::eAttachmentReference2;
    const void *                           pNext      = {};
    uint32_t                               attachment = {};
    VULKAN_HPP_NAMESPACE::ImageLayout      layout     = VULKAN_HPP_NAMESPACE::ImageLayout::eUndefined;
    VULKAN_HPP_NAMESPACE::ImageAspectFlags aspectMask = {};
  };
  static_assert( sizeof( AttachmentReference2 ) == sizeof( VkAttachmentReference2 ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<AttachmentReference2>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eAttachmentReference2>
  {
    using Type = AttachmentReference2;
  };
  using AttachmentReference2KHR = AttachmentReference2;

  struct AttachmentReferenceStencilLayout
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eAttachmentReferenceStencilLayout;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      AttachmentReferenceStencilLayout( VULKAN_HPP_NAMESPACE::ImageLayout stencilLayout_ =
                                          VULKAN_HPP_NAMESPACE::ImageLayout::eUndefined ) VULKAN_HPP_NOEXCEPT
      : stencilLayout( stencilLayout_ )
    {}

    VULKAN_HPP_CONSTEXPR
      AttachmentReferenceStencilLayout( AttachmentReferenceStencilLayout const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AttachmentReferenceStencilLayout( VkAttachmentReferenceStencilLayout const & rhs ) VULKAN_HPP_NOEXCEPT
      : AttachmentReferenceStencilLayout( *reinterpret_cast<AttachmentReferenceStencilLayout const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 AttachmentReferenceStencilLayout &
                            operator=( AttachmentReferenceStencilLayout const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AttachmentReferenceStencilLayout & operator=( VkAttachmentReferenceStencilLayout const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::AttachmentReferenceStencilLayout const *>( &rhs );
      return *this;
    }

    AttachmentReferenceStencilLayout & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    AttachmentReferenceStencilLayout &
      setStencilLayout( VULKAN_HPP_NAMESPACE::ImageLayout stencilLayout_ ) VULKAN_HPP_NOEXCEPT
    {
      stencilLayout = stencilLayout_;
      return *this;
    }

    operator VkAttachmentReferenceStencilLayout const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkAttachmentReferenceStencilLayout *>( this );
    }

    operator VkAttachmentReferenceStencilLayout &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkAttachmentReferenceStencilLayout *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( AttachmentReferenceStencilLayout const & ) const = default;
#else
    bool operator==( AttachmentReferenceStencilLayout const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( stencilLayout == rhs.stencilLayout );
    }

    bool operator!=( AttachmentReferenceStencilLayout const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType         = StructureType::eAttachmentReferenceStencilLayout;
    void *                              pNext         = {};
    VULKAN_HPP_NAMESPACE::ImageLayout   stencilLayout = VULKAN_HPP_NAMESPACE::ImageLayout::eUndefined;
  };
  static_assert( sizeof( AttachmentReferenceStencilLayout ) == sizeof( VkAttachmentReferenceStencilLayout ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<AttachmentReferenceStencilLayout>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eAttachmentReferenceStencilLayout>
  {
    using Type = AttachmentReferenceStencilLayout;
  };
  using AttachmentReferenceStencilLayoutKHR = AttachmentReferenceStencilLayout;

  struct Extent2D
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR Extent2D( uint32_t width_ = {}, uint32_t height_ = {} ) VULKAN_HPP_NOEXCEPT
      : width( width_ )
      , height( height_ )
    {}

    VULKAN_HPP_CONSTEXPR Extent2D( Extent2D const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    Extent2D( VkExtent2D const & rhs ) VULKAN_HPP_NOEXCEPT : Extent2D( *reinterpret_cast<Extent2D const *>( &rhs ) ) {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 Extent2D & operator=( Extent2D const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    Extent2D & operator=( VkExtent2D const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::Extent2D const *>( &rhs );
      return *this;
    }

    Extent2D & setWidth( uint32_t width_ ) VULKAN_HPP_NOEXCEPT
    {
      width = width_;
      return *this;
    }

    Extent2D & setHeight( uint32_t height_ ) VULKAN_HPP_NOEXCEPT
    {
      height = height_;
      return *this;
    }

    operator VkExtent2D const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkExtent2D *>( this );
    }

    operator VkExtent2D &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkExtent2D *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( Extent2D const & ) const = default;
#else
    bool operator==( Extent2D const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( width == rhs.width ) && ( height == rhs.height );
    }

    bool operator!=( Extent2D const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    uint32_t width  = {};
    uint32_t height = {};
  };
  static_assert( sizeof( Extent2D ) == sizeof( VkExtent2D ), "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<Extent2D>::value, "struct wrapper is not a standard layout!" );

  struct SampleLocationEXT
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR SampleLocationEXT( float x_ = {}, float y_ = {} ) VULKAN_HPP_NOEXCEPT
      : x( x_ )
      , y( y_ )
    {}

    VULKAN_HPP_CONSTEXPR SampleLocationEXT( SampleLocationEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SampleLocationEXT( VkSampleLocationEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : SampleLocationEXT( *reinterpret_cast<SampleLocationEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SampleLocationEXT &
                            operator=( SampleLocationEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SampleLocationEXT & operator=( VkSampleLocationEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SampleLocationEXT const *>( &rhs );
      return *this;
    }

    SampleLocationEXT & setX( float x_ ) VULKAN_HPP_NOEXCEPT
    {
      x = x_;
      return *this;
    }

    SampleLocationEXT & setY( float y_ ) VULKAN_HPP_NOEXCEPT
    {
      y = y_;
      return *this;
    }

    operator VkSampleLocationEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSampleLocationEXT *>( this );
    }

    operator VkSampleLocationEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSampleLocationEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SampleLocationEXT const & ) const = default;
#else
    bool operator==( SampleLocationEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( x == rhs.x ) && ( y == rhs.y );
    }

    bool operator!=( SampleLocationEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    float x = {};
    float y = {};
  };
  static_assert( sizeof( SampleLocationEXT ) == sizeof( VkSampleLocationEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SampleLocationEXT>::value, "struct wrapper is not a standard layout!" );

  struct SampleLocationsInfoEXT
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eSampleLocationsInfoEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR SampleLocationsInfoEXT(
      VULKAN_HPP_NAMESPACE::SampleCountFlagBits sampleLocationsPerPixel_ =
        VULKAN_HPP_NAMESPACE::SampleCountFlagBits::e1,
      VULKAN_HPP_NAMESPACE::Extent2D                  sampleLocationGridSize_ = {},
      uint32_t                                        sampleLocationsCount_   = {},
      const VULKAN_HPP_NAMESPACE::SampleLocationEXT * pSampleLocations_       = {} ) VULKAN_HPP_NOEXCEPT
      : sampleLocationsPerPixel( sampleLocationsPerPixel_ )
      , sampleLocationGridSize( sampleLocationGridSize_ )
      , sampleLocationsCount( sampleLocationsCount_ )
      , pSampleLocations( pSampleLocations_ )
    {}

    VULKAN_HPP_CONSTEXPR SampleLocationsInfoEXT( SampleLocationsInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SampleLocationsInfoEXT( VkSampleLocationsInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : SampleLocationsInfoEXT( *reinterpret_cast<SampleLocationsInfoEXT const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    SampleLocationsInfoEXT(
      VULKAN_HPP_NAMESPACE::SampleCountFlagBits sampleLocationsPerPixel_,
      VULKAN_HPP_NAMESPACE::Extent2D            sampleLocationGridSize_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::SampleLocationEXT> const &
        sampleLocations_ )
      : sampleLocationsPerPixel( sampleLocationsPerPixel_ )
      , sampleLocationGridSize( sampleLocationGridSize_ )
      , sampleLocationsCount( static_cast<uint32_t>( sampleLocations_.size() ) )
      , pSampleLocations( sampleLocations_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SampleLocationsInfoEXT &
                            operator=( SampleLocationsInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SampleLocationsInfoEXT & operator=( VkSampleLocationsInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SampleLocationsInfoEXT const *>( &rhs );
      return *this;
    }

    SampleLocationsInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    SampleLocationsInfoEXT & setSampleLocationsPerPixel(
      VULKAN_HPP_NAMESPACE::SampleCountFlagBits sampleLocationsPerPixel_ ) VULKAN_HPP_NOEXCEPT
    {
      sampleLocationsPerPixel = sampleLocationsPerPixel_;
      return *this;
    }

    SampleLocationsInfoEXT &
      setSampleLocationGridSize( VULKAN_HPP_NAMESPACE::Extent2D const & sampleLocationGridSize_ ) VULKAN_HPP_NOEXCEPT
    {
      sampleLocationGridSize = sampleLocationGridSize_;
      return *this;
    }

    SampleLocationsInfoEXT & setSampleLocationsCount( uint32_t sampleLocationsCount_ ) VULKAN_HPP_NOEXCEPT
    {
      sampleLocationsCount = sampleLocationsCount_;
      return *this;
    }

    SampleLocationsInfoEXT &
      setPSampleLocations( const VULKAN_HPP_NAMESPACE::SampleLocationEXT * pSampleLocations_ ) VULKAN_HPP_NOEXCEPT
    {
      pSampleLocations = pSampleLocations_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    SampleLocationsInfoEXT & setSampleLocations(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::SampleLocationEXT> const &
        sampleLocations_ ) VULKAN_HPP_NOEXCEPT
    {
      sampleLocationsCount = static_cast<uint32_t>( sampleLocations_.size() );
      pSampleLocations     = sampleLocations_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkSampleLocationsInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSampleLocationsInfoEXT *>( this );
    }

    operator VkSampleLocationsInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSampleLocationsInfoEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SampleLocationsInfoEXT const & ) const = default;
#else
    bool operator==( SampleLocationsInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( sampleLocationsPerPixel == rhs.sampleLocationsPerPixel ) &&
             ( sampleLocationGridSize == rhs.sampleLocationGridSize ) &&
             ( sampleLocationsCount == rhs.sampleLocationsCount ) && ( pSampleLocations == rhs.pSampleLocations );
    }

    bool operator!=( SampleLocationsInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType       sType                   = StructureType::eSampleLocationsInfoEXT;
    const void *                              pNext                   = {};
    VULKAN_HPP_NAMESPACE::SampleCountFlagBits sampleLocationsPerPixel = VULKAN_HPP_NAMESPACE::SampleCountFlagBits::e1;
    VULKAN_HPP_NAMESPACE::Extent2D            sampleLocationGridSize  = {};
    uint32_t                                  sampleLocationsCount    = {};
    const VULKAN_HPP_NAMESPACE::SampleLocationEXT * pSampleLocations  = {};
  };
  static_assert( sizeof( SampleLocationsInfoEXT ) == sizeof( VkSampleLocationsInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SampleLocationsInfoEXT>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eSampleLocationsInfoEXT>
  {
    using Type = SampleLocationsInfoEXT;
  };

  struct AttachmentSampleLocationsEXT
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR AttachmentSampleLocationsEXT(
      uint32_t                                     attachmentIndex_     = {},
      VULKAN_HPP_NAMESPACE::SampleLocationsInfoEXT sampleLocationsInfo_ = {} ) VULKAN_HPP_NOEXCEPT
      : attachmentIndex( attachmentIndex_ )
      , sampleLocationsInfo( sampleLocationsInfo_ )
    {}

    VULKAN_HPP_CONSTEXPR
      AttachmentSampleLocationsEXT( AttachmentSampleLocationsEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AttachmentSampleLocationsEXT( VkAttachmentSampleLocationsEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : AttachmentSampleLocationsEXT( *reinterpret_cast<AttachmentSampleLocationsEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 AttachmentSampleLocationsEXT &
                            operator=( AttachmentSampleLocationsEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    AttachmentSampleLocationsEXT & operator=( VkAttachmentSampleLocationsEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::AttachmentSampleLocationsEXT const *>( &rhs );
      return *this;
    }

    AttachmentSampleLocationsEXT & setAttachmentIndex( uint32_t attachmentIndex_ ) VULKAN_HPP_NOEXCEPT
    {
      attachmentIndex = attachmentIndex_;
      return *this;
    }

    AttachmentSampleLocationsEXT & setSampleLocationsInfo(
      VULKAN_HPP_NAMESPACE::SampleLocationsInfoEXT const & sampleLocationsInfo_ ) VULKAN_HPP_NOEXCEPT
    {
      sampleLocationsInfo = sampleLocationsInfo_;
      return *this;
    }

    operator VkAttachmentSampleLocationsEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkAttachmentSampleLocationsEXT *>( this );
    }

    operator VkAttachmentSampleLocationsEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkAttachmentSampleLocationsEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( AttachmentSampleLocationsEXT const & ) const = default;
#else
    bool operator==( AttachmentSampleLocationsEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( attachmentIndex == rhs.attachmentIndex ) && ( sampleLocationsInfo == rhs.sampleLocationsInfo );
    }

    bool operator!=( AttachmentSampleLocationsEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    uint32_t                                     attachmentIndex     = {};
    VULKAN_HPP_NAMESPACE::SampleLocationsInfoEXT sampleLocationsInfo = {};
  };
  static_assert( sizeof( AttachmentSampleLocationsEXT ) == sizeof( VkAttachmentSampleLocationsEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<AttachmentSampleLocationsEXT>::value,
                 "struct wrapper is not a standard layout!" );

  struct BaseInStructure
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    BaseInStructure( VULKAN_HPP_NAMESPACE::StructureType sType_ =
                       VULKAN_HPP_NAMESPACE::StructureType::eApplicationInfo ) VULKAN_HPP_NOEXCEPT : sType( sType_ )
    {}

    BaseInStructure( BaseInStructure const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    BaseInStructure( VkBaseInStructure const & rhs ) VULKAN_HPP_NOEXCEPT
      : BaseInStructure( *reinterpret_cast<BaseInStructure const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    BaseInStructure & operator=( BaseInStructure const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    BaseInStructure & operator=( VkBaseInStructure const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::BaseInStructure const *>( &rhs );
      return *this;
    }

    BaseInStructure & setPNext( const struct VULKAN_HPP_NAMESPACE::BaseInStructure * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    operator VkBaseInStructure const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkBaseInStructure *>( this );
    }

    operator VkBaseInStructure &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkBaseInStructure *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( BaseInStructure const & ) const = default;
#else
    bool operator==( BaseInStructure const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext );
    }

    bool operator!=( BaseInStructure const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                  sType = VULKAN_HPP_NAMESPACE::StructureType::eApplicationInfo;
    const struct VULKAN_HPP_NAMESPACE::BaseInStructure * pNext = {};
  };
  static_assert( sizeof( BaseInStructure ) == sizeof( VkBaseInStructure ), "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<BaseInStructure>::value, "struct wrapper is not a standard layout!" );

  struct BaseOutStructure
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    BaseOutStructure( VULKAN_HPP_NAMESPACE::StructureType sType_ =
                        VULKAN_HPP_NAMESPACE::StructureType::eApplicationInfo ) VULKAN_HPP_NOEXCEPT : sType( sType_ )
    {}

    BaseOutStructure( BaseOutStructure const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    BaseOutStructure( VkBaseOutStructure const & rhs ) VULKAN_HPP_NOEXCEPT
      : BaseOutStructure( *reinterpret_cast<BaseOutStructure const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    BaseOutStructure & operator=( BaseOutStructure const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    BaseOutStructure & operator=( VkBaseOutStructure const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::BaseOutStructure const *>( &rhs );
      return *this;
    }

    BaseOutStructure & setPNext( struct VULKAN_HPP_NAMESPACE::BaseOutStructure * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    operator VkBaseOutStructure const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkBaseOutStructure *>( this );
    }

    operator VkBaseOutStructure &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkBaseOutStructure *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( BaseOutStructure const & ) const = default;
#else
    bool operator==( BaseOutStructure const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext );
    }

    bool operator!=( BaseOutStructure const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType             sType = VULKAN_HPP_NAMESPACE::StructureType::eApplicationInfo;
    struct VULKAN_HPP_NAMESPACE::BaseOutStructure * pNext = {};
  };
  static_assert( sizeof( BaseOutStructure ) == sizeof( VkBaseOutStructure ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<BaseOutStructure>::value, "struct wrapper is not a standard layout!" );

  struct BindAccelerationStructureMemoryInfoNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eBindAccelerationStructureMemoryInfoNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      BindAccelerationStructureMemoryInfoNV( VULKAN_HPP_NAMESPACE::AccelerationStructureNV accelerationStructure_ = {},
                                             VULKAN_HPP_NAMESPACE::DeviceMemory            memory_                = {},
                                             VULKAN_HPP_NAMESPACE::DeviceSize              memoryOffset_          = {},
                                             uint32_t                                      deviceIndexCount_      = {},
                                             const uint32_t * pDeviceIndices_ = {} ) VULKAN_HPP_NOEXCEPT
      : accelerationStructure( accelerationStructure_ )
      , memory( memory_ )
      , memoryOffset( memoryOffset_ )
      , deviceIndexCount( deviceIndexCount_ )
      , pDeviceIndices( pDeviceIndices_ )
    {}

    VULKAN_HPP_CONSTEXPR BindAccelerationStructureMemoryInfoNV( BindAccelerationStructureMemoryInfoNV const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    BindAccelerationStructureMemoryInfoNV( VkBindAccelerationStructureMemoryInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
      : BindAccelerationStructureMemoryInfoNV(
          *reinterpret_cast<BindAccelerationStructureMemoryInfoNV const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    BindAccelerationStructureMemoryInfoNV(
      VULKAN_HPP_NAMESPACE::AccelerationStructureNV                         accelerationStructure_,
      VULKAN_HPP_NAMESPACE::DeviceMemory                                    memory_,
      VULKAN_HPP_NAMESPACE::DeviceSize                                      memoryOffset_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const & deviceIndices_ )
      : accelerationStructure( accelerationStructure_ )
      , memory( memory_ )
      , memoryOffset( memoryOffset_ )
      , deviceIndexCount( static_cast<uint32_t>( deviceIndices_.size() ) )
      , pDeviceIndices( deviceIndices_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 BindAccelerationStructureMemoryInfoNV &
                            operator=( BindAccelerationStructureMemoryInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    BindAccelerationStructureMemoryInfoNV &
      operator=( VkBindAccelerationStructureMemoryInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::BindAccelerationStructureMemoryInfoNV const *>( &rhs );
      return *this;
    }

    BindAccelerationStructureMemoryInfoNV & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    BindAccelerationStructureMemoryInfoNV & setAccelerationStructure(
      VULKAN_HPP_NAMESPACE::AccelerationStructureNV accelerationStructure_ ) VULKAN_HPP_NOEXCEPT
    {
      accelerationStructure = accelerationStructure_;
      return *this;
    }

    BindAccelerationStructureMemoryInfoNV & setMemory( VULKAN_HPP_NAMESPACE::DeviceMemory memory_ ) VULKAN_HPP_NOEXCEPT
    {
      memory = memory_;
      return *this;
    }

    BindAccelerationStructureMemoryInfoNV &
      setMemoryOffset( VULKAN_HPP_NAMESPACE::DeviceSize memoryOffset_ ) VULKAN_HPP_NOEXCEPT
    {
      memoryOffset = memoryOffset_;
      return *this;
    }

    BindAccelerationStructureMemoryInfoNV & setDeviceIndexCount( uint32_t deviceIndexCount_ ) VULKAN_HPP_NOEXCEPT
    {
      deviceIndexCount = deviceIndexCount_;
      return *this;
    }

    BindAccelerationStructureMemoryInfoNV & setPDeviceIndices( const uint32_t * pDeviceIndices_ ) VULKAN_HPP_NOEXCEPT
    {
      pDeviceIndices = pDeviceIndices_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    BindAccelerationStructureMemoryInfoNV & setDeviceIndices(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const & deviceIndices_ ) VULKAN_HPP_NOEXCEPT
    {
      deviceIndexCount = static_cast<uint32_t>( deviceIndices_.size() );
      pDeviceIndices   = deviceIndices_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkBindAccelerationStructureMemoryInfoNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkBindAccelerationStructureMemoryInfoNV *>( this );
    }

    operator VkBindAccelerationStructureMemoryInfoNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkBindAccelerationStructureMemoryInfoNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( BindAccelerationStructureMemoryInfoNV const & ) const = default;
#else
    bool operator==( BindAccelerationStructureMemoryInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( accelerationStructure == rhs.accelerationStructure ) && ( memory == rhs.memory ) &&
             ( memoryOffset == rhs.memoryOffset ) && ( deviceIndexCount == rhs.deviceIndexCount ) &&
             ( pDeviceIndices == rhs.pDeviceIndices );
    }

    bool operator!=( BindAccelerationStructureMemoryInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType           sType = StructureType::eBindAccelerationStructureMemoryInfoNV;
    const void *                                  pNext = {};
    VULKAN_HPP_NAMESPACE::AccelerationStructureNV accelerationStructure = {};
    VULKAN_HPP_NAMESPACE::DeviceMemory            memory                = {};
    VULKAN_HPP_NAMESPACE::DeviceSize              memoryOffset          = {};
    uint32_t                                      deviceIndexCount      = {};
    const uint32_t *                              pDeviceIndices        = {};
  };
  static_assert( sizeof( BindAccelerationStructureMemoryInfoNV ) == sizeof( VkBindAccelerationStructureMemoryInfoNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<BindAccelerationStructureMemoryInfoNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eBindAccelerationStructureMemoryInfoNV>
  {
    using Type = BindAccelerationStructureMemoryInfoNV;
  };

  struct BindBufferMemoryDeviceGroupInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eBindBufferMemoryDeviceGroupInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR BindBufferMemoryDeviceGroupInfo( uint32_t         deviceIndexCount_ = {},
                                                          const uint32_t * pDeviceIndices_   = {} ) VULKAN_HPP_NOEXCEPT
      : deviceIndexCount( deviceIndexCount_ )
      , pDeviceIndices( pDeviceIndices_ )
    {}

    VULKAN_HPP_CONSTEXPR
      BindBufferMemoryDeviceGroupInfo( BindBufferMemoryDeviceGroupInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    BindBufferMemoryDeviceGroupInfo( VkBindBufferMemoryDeviceGroupInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : BindBufferMemoryDeviceGroupInfo( *reinterpret_cast<BindBufferMemoryDeviceGroupInfo const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    BindBufferMemoryDeviceGroupInfo(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const & deviceIndices_ )
      : deviceIndexCount( static_cast<uint32_t>( deviceIndices_.size() ) ), pDeviceIndices( deviceIndices_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 BindBufferMemoryDeviceGroupInfo &
                            operator=( BindBufferMemoryDeviceGroupInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    BindBufferMemoryDeviceGroupInfo & operator=( VkBindBufferMemoryDeviceGroupInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::BindBufferMemoryDeviceGroupInfo const *>( &rhs );
      return *this;
    }

    BindBufferMemoryDeviceGroupInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    BindBufferMemoryDeviceGroupInfo & setDeviceIndexCount( uint32_t deviceIndexCount_ ) VULKAN_HPP_NOEXCEPT
    {
      deviceIndexCount = deviceIndexCount_;
      return *this;
    }

    BindBufferMemoryDeviceGroupInfo & setPDeviceIndices( const uint32_t * pDeviceIndices_ ) VULKAN_HPP_NOEXCEPT
    {
      pDeviceIndices = pDeviceIndices_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    BindBufferMemoryDeviceGroupInfo & setDeviceIndices(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const & deviceIndices_ ) VULKAN_HPP_NOEXCEPT
    {
      deviceIndexCount = static_cast<uint32_t>( deviceIndices_.size() );
      pDeviceIndices   = deviceIndices_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkBindBufferMemoryDeviceGroupInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkBindBufferMemoryDeviceGroupInfo *>( this );
    }

    operator VkBindBufferMemoryDeviceGroupInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkBindBufferMemoryDeviceGroupInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( BindBufferMemoryDeviceGroupInfo const & ) const = default;
#else
    bool operator==( BindBufferMemoryDeviceGroupInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( deviceIndexCount == rhs.deviceIndexCount ) &&
             ( pDeviceIndices == rhs.pDeviceIndices );
    }

    bool operator!=( BindBufferMemoryDeviceGroupInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType            = StructureType::eBindBufferMemoryDeviceGroupInfo;
    const void *                        pNext            = {};
    uint32_t                            deviceIndexCount = {};
    const uint32_t *                    pDeviceIndices   = {};
  };
  static_assert( sizeof( BindBufferMemoryDeviceGroupInfo ) == sizeof( VkBindBufferMemoryDeviceGroupInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<BindBufferMemoryDeviceGroupInfo>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eBindBufferMemoryDeviceGroupInfo>
  {
    using Type = BindBufferMemoryDeviceGroupInfo;
  };
  using BindBufferMemoryDeviceGroupInfoKHR = BindBufferMemoryDeviceGroupInfo;

  struct BindBufferMemoryInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eBindBufferMemoryInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR BindBufferMemoryInfo( VULKAN_HPP_NAMESPACE::Buffer       buffer_     = {},
                                               VULKAN_HPP_NAMESPACE::DeviceMemory memory_     = {},
                                               VULKAN_HPP_NAMESPACE::DeviceSize memoryOffset_ = {} ) VULKAN_HPP_NOEXCEPT
      : buffer( buffer_ )
      , memory( memory_ )
      , memoryOffset( memoryOffset_ )
    {}

    VULKAN_HPP_CONSTEXPR BindBufferMemoryInfo( BindBufferMemoryInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    BindBufferMemoryInfo( VkBindBufferMemoryInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : BindBufferMemoryInfo( *reinterpret_cast<BindBufferMemoryInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 BindBufferMemoryInfo &
                            operator=( BindBufferMemoryInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    BindBufferMemoryInfo & operator=( VkBindBufferMemoryInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::BindBufferMemoryInfo const *>( &rhs );
      return *this;
    }

    BindBufferMemoryInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    BindBufferMemoryInfo & setBuffer( VULKAN_HPP_NAMESPACE::Buffer buffer_ ) VULKAN_HPP_NOEXCEPT
    {
      buffer = buffer_;
      return *this;
    }

    BindBufferMemoryInfo & setMemory( VULKAN_HPP_NAMESPACE::DeviceMemory memory_ ) VULKAN_HPP_NOEXCEPT
    {
      memory = memory_;
      return *this;
    }

    BindBufferMemoryInfo & setMemoryOffset( VULKAN_HPP_NAMESPACE::DeviceSize memoryOffset_ ) VULKAN_HPP_NOEXCEPT
    {
      memoryOffset = memoryOffset_;
      return *this;
    }

    operator VkBindBufferMemoryInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkBindBufferMemoryInfo *>( this );
    }

    operator VkBindBufferMemoryInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkBindBufferMemoryInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( BindBufferMemoryInfo const & ) const = default;
#else
    bool operator==( BindBufferMemoryInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( buffer == rhs.buffer ) && ( memory == rhs.memory ) &&
             ( memoryOffset == rhs.memoryOffset );
    }

    bool operator!=( BindBufferMemoryInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType        = StructureType::eBindBufferMemoryInfo;
    const void *                        pNext        = {};
    VULKAN_HPP_NAMESPACE::Buffer        buffer       = {};
    VULKAN_HPP_NAMESPACE::DeviceMemory  memory       = {};
    VULKAN_HPP_NAMESPACE::DeviceSize    memoryOffset = {};
  };
  static_assert( sizeof( BindBufferMemoryInfo ) == sizeof( VkBindBufferMemoryInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<BindBufferMemoryInfo>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eBindBufferMemoryInfo>
  {
    using Type = BindBufferMemoryInfo;
  };
  using BindBufferMemoryInfoKHR = BindBufferMemoryInfo;

  struct Offset2D
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR Offset2D( int32_t x_ = {}, int32_t y_ = {} ) VULKAN_HPP_NOEXCEPT
      : x( x_ )
      , y( y_ )
    {}

    VULKAN_HPP_CONSTEXPR Offset2D( Offset2D const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    Offset2D( VkOffset2D const & rhs ) VULKAN_HPP_NOEXCEPT : Offset2D( *reinterpret_cast<Offset2D const *>( &rhs ) ) {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 Offset2D & operator=( Offset2D const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    Offset2D & operator=( VkOffset2D const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::Offset2D const *>( &rhs );
      return *this;
    }

    Offset2D & setX( int32_t x_ ) VULKAN_HPP_NOEXCEPT
    {
      x = x_;
      return *this;
    }

    Offset2D & setY( int32_t y_ ) VULKAN_HPP_NOEXCEPT
    {
      y = y_;
      return *this;
    }

    operator VkOffset2D const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkOffset2D *>( this );
    }

    operator VkOffset2D &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkOffset2D *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( Offset2D const & ) const = default;
#else
    bool operator==( Offset2D const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( x == rhs.x ) && ( y == rhs.y );
    }

    bool operator!=( Offset2D const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    int32_t x = {};
    int32_t y = {};
  };
  static_assert( sizeof( Offset2D ) == sizeof( VkOffset2D ), "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<Offset2D>::value, "struct wrapper is not a standard layout!" );

  struct Rect2D
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR Rect2D( VULKAN_HPP_NAMESPACE::Offset2D offset_ = {},
                                 VULKAN_HPP_NAMESPACE::Extent2D extent_ = {} ) VULKAN_HPP_NOEXCEPT
      : offset( offset_ )
      , extent( extent_ )
    {}

    VULKAN_HPP_CONSTEXPR Rect2D( Rect2D const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    Rect2D( VkRect2D const & rhs ) VULKAN_HPP_NOEXCEPT : Rect2D( *reinterpret_cast<Rect2D const *>( &rhs ) ) {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 Rect2D & operator=( Rect2D const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    Rect2D & operator=( VkRect2D const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::Rect2D const *>( &rhs );
      return *this;
    }

    Rect2D & setOffset( VULKAN_HPP_NAMESPACE::Offset2D const & offset_ ) VULKAN_HPP_NOEXCEPT
    {
      offset = offset_;
      return *this;
    }

    Rect2D & setExtent( VULKAN_HPP_NAMESPACE::Extent2D const & extent_ ) VULKAN_HPP_NOEXCEPT
    {
      extent = extent_;
      return *this;
    }

    operator VkRect2D const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkRect2D *>( this );
    }

    operator VkRect2D &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkRect2D *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( Rect2D const & ) const = default;
#else
    bool operator==( Rect2D const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( offset == rhs.offset ) && ( extent == rhs.extent );
    }

    bool operator!=( Rect2D const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::Offset2D offset = {};
    VULKAN_HPP_NAMESPACE::Extent2D extent = {};
  };
  static_assert( sizeof( Rect2D ) == sizeof( VkRect2D ), "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<Rect2D>::value, "struct wrapper is not a standard layout!" );

  struct BindImageMemoryDeviceGroupInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eBindImageMemoryDeviceGroupInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR BindImageMemoryDeviceGroupInfo(
      uint32_t                             deviceIndexCount_             = {},
      const uint32_t *                     pDeviceIndices_               = {},
      uint32_t                             splitInstanceBindRegionCount_ = {},
      const VULKAN_HPP_NAMESPACE::Rect2D * pSplitInstanceBindRegions_    = {} ) VULKAN_HPP_NOEXCEPT
      : deviceIndexCount( deviceIndexCount_ )
      , pDeviceIndices( pDeviceIndices_ )
      , splitInstanceBindRegionCount( splitInstanceBindRegionCount_ )
      , pSplitInstanceBindRegions( pSplitInstanceBindRegions_ )
    {}

    VULKAN_HPP_CONSTEXPR
      BindImageMemoryDeviceGroupInfo( BindImageMemoryDeviceGroupInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    BindImageMemoryDeviceGroupInfo( VkBindImageMemoryDeviceGroupInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : BindImageMemoryDeviceGroupInfo( *reinterpret_cast<BindImageMemoryDeviceGroupInfo const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    BindImageMemoryDeviceGroupInfo(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const & deviceIndices_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::Rect2D> const &
        splitInstanceBindRegions_ = {} )
      : deviceIndexCount( static_cast<uint32_t>( deviceIndices_.size() ) )
      , pDeviceIndices( deviceIndices_.data() )
      , splitInstanceBindRegionCount( static_cast<uint32_t>( splitInstanceBindRegions_.size() ) )
      , pSplitInstanceBindRegions( splitInstanceBindRegions_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 BindImageMemoryDeviceGroupInfo &
                            operator=( BindImageMemoryDeviceGroupInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    BindImageMemoryDeviceGroupInfo & operator=( VkBindImageMemoryDeviceGroupInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::BindImageMemoryDeviceGroupInfo const *>( &rhs );
      return *this;
    }

    BindImageMemoryDeviceGroupInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    BindImageMemoryDeviceGroupInfo & setDeviceIndexCount( uint32_t deviceIndexCount_ ) VULKAN_HPP_NOEXCEPT
    {
      deviceIndexCount = deviceIndexCount_;
      return *this;
    }

    BindImageMemoryDeviceGroupInfo & setPDeviceIndices( const uint32_t * pDeviceIndices_ ) VULKAN_HPP_NOEXCEPT
    {
      pDeviceIndices = pDeviceIndices_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    BindImageMemoryDeviceGroupInfo & setDeviceIndices(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const & deviceIndices_ ) VULKAN_HPP_NOEXCEPT
    {
      deviceIndexCount = static_cast<uint32_t>( deviceIndices_.size() );
      pDeviceIndices   = deviceIndices_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    BindImageMemoryDeviceGroupInfo &
      setSplitInstanceBindRegionCount( uint32_t splitInstanceBindRegionCount_ ) VULKAN_HPP_NOEXCEPT
    {
      splitInstanceBindRegionCount = splitInstanceBindRegionCount_;
      return *this;
    }

    BindImageMemoryDeviceGroupInfo & setPSplitInstanceBindRegions(
      const VULKAN_HPP_NAMESPACE::Rect2D * pSplitInstanceBindRegions_ ) VULKAN_HPP_NOEXCEPT
    {
      pSplitInstanceBindRegions = pSplitInstanceBindRegions_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    BindImageMemoryDeviceGroupInfo & setSplitInstanceBindRegions(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::Rect2D> const &
        splitInstanceBindRegions_ ) VULKAN_HPP_NOEXCEPT
    {
      splitInstanceBindRegionCount = static_cast<uint32_t>( splitInstanceBindRegions_.size() );
      pSplitInstanceBindRegions    = splitInstanceBindRegions_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkBindImageMemoryDeviceGroupInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkBindImageMemoryDeviceGroupInfo *>( this );
    }

    operator VkBindImageMemoryDeviceGroupInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkBindImageMemoryDeviceGroupInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( BindImageMemoryDeviceGroupInfo const & ) const = default;
#else
    bool operator==( BindImageMemoryDeviceGroupInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( deviceIndexCount == rhs.deviceIndexCount ) &&
             ( pDeviceIndices == rhs.pDeviceIndices ) &&
             ( splitInstanceBindRegionCount == rhs.splitInstanceBindRegionCount ) &&
             ( pSplitInstanceBindRegions == rhs.pSplitInstanceBindRegions );
    }

    bool operator!=( BindImageMemoryDeviceGroupInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType  sType                        = StructureType::eBindImageMemoryDeviceGroupInfo;
    const void *                         pNext                        = {};
    uint32_t                             deviceIndexCount             = {};
    const uint32_t *                     pDeviceIndices               = {};
    uint32_t                             splitInstanceBindRegionCount = {};
    const VULKAN_HPP_NAMESPACE::Rect2D * pSplitInstanceBindRegions    = {};
  };
  static_assert( sizeof( BindImageMemoryDeviceGroupInfo ) == sizeof( VkBindImageMemoryDeviceGroupInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<BindImageMemoryDeviceGroupInfo>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eBindImageMemoryDeviceGroupInfo>
  {
    using Type = BindImageMemoryDeviceGroupInfo;
  };
  using BindImageMemoryDeviceGroupInfoKHR = BindImageMemoryDeviceGroupInfo;

  struct BindImageMemoryInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eBindImageMemoryInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR BindImageMemoryInfo( VULKAN_HPP_NAMESPACE::Image        image_      = {},
                                              VULKAN_HPP_NAMESPACE::DeviceMemory memory_     = {},
                                              VULKAN_HPP_NAMESPACE::DeviceSize memoryOffset_ = {} ) VULKAN_HPP_NOEXCEPT
      : image( image_ )
      , memory( memory_ )
      , memoryOffset( memoryOffset_ )
    {}

    VULKAN_HPP_CONSTEXPR BindImageMemoryInfo( BindImageMemoryInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    BindImageMemoryInfo( VkBindImageMemoryInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : BindImageMemoryInfo( *reinterpret_cast<BindImageMemoryInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 BindImageMemoryInfo &
                            operator=( BindImageMemoryInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    BindImageMemoryInfo & operator=( VkBindImageMemoryInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::BindImageMemoryInfo const *>( &rhs );
      return *this;
    }

    BindImageMemoryInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    BindImageMemoryInfo & setImage( VULKAN_HPP_NAMESPACE::Image image_ ) VULKAN_HPP_NOEXCEPT
    {
      image = image_;
      return *this;
    }

    BindImageMemoryInfo & setMemory( VULKAN_HPP_NAMESPACE::DeviceMemory memory_ ) VULKAN_HPP_NOEXCEPT
    {
      memory = memory_;
      return *this;
    }

    BindImageMemoryInfo & setMemoryOffset( VULKAN_HPP_NAMESPACE::DeviceSize memoryOffset_ ) VULKAN_HPP_NOEXCEPT
    {
      memoryOffset = memoryOffset_;
      return *this;
    }

    operator VkBindImageMemoryInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkBindImageMemoryInfo *>( this );
    }

    operator VkBindImageMemoryInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkBindImageMemoryInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( BindImageMemoryInfo const & ) const = default;
#else
    bool operator==( BindImageMemoryInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( image == rhs.image ) && ( memory == rhs.memory ) &&
             ( memoryOffset == rhs.memoryOffset );
    }

    bool operator!=( BindImageMemoryInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType        = StructureType::eBindImageMemoryInfo;
    const void *                        pNext        = {};
    VULKAN_HPP_NAMESPACE::Image         image        = {};
    VULKAN_HPP_NAMESPACE::DeviceMemory  memory       = {};
    VULKAN_HPP_NAMESPACE::DeviceSize    memoryOffset = {};
  };
  static_assert( sizeof( BindImageMemoryInfo ) == sizeof( VkBindImageMemoryInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<BindImageMemoryInfo>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eBindImageMemoryInfo>
  {
    using Type = BindImageMemoryInfo;
  };
  using BindImageMemoryInfoKHR = BindImageMemoryInfo;

  struct BindImageMemorySwapchainInfoKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eBindImageMemorySwapchainInfoKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR BindImageMemorySwapchainInfoKHR( VULKAN_HPP_NAMESPACE::SwapchainKHR swapchain_ = {},
                                                          uint32_t imageIndex_ = {} ) VULKAN_HPP_NOEXCEPT
      : swapchain( swapchain_ )
      , imageIndex( imageIndex_ )
    {}

    VULKAN_HPP_CONSTEXPR
      BindImageMemorySwapchainInfoKHR( BindImageMemorySwapchainInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    BindImageMemorySwapchainInfoKHR( VkBindImageMemorySwapchainInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : BindImageMemorySwapchainInfoKHR( *reinterpret_cast<BindImageMemorySwapchainInfoKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 BindImageMemorySwapchainInfoKHR &
                            operator=( BindImageMemorySwapchainInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    BindImageMemorySwapchainInfoKHR & operator=( VkBindImageMemorySwapchainInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::BindImageMemorySwapchainInfoKHR const *>( &rhs );
      return *this;
    }

    BindImageMemorySwapchainInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    BindImageMemorySwapchainInfoKHR & setSwapchain( VULKAN_HPP_NAMESPACE::SwapchainKHR swapchain_ ) VULKAN_HPP_NOEXCEPT
    {
      swapchain = swapchain_;
      return *this;
    }

    BindImageMemorySwapchainInfoKHR & setImageIndex( uint32_t imageIndex_ ) VULKAN_HPP_NOEXCEPT
    {
      imageIndex = imageIndex_;
      return *this;
    }

    operator VkBindImageMemorySwapchainInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkBindImageMemorySwapchainInfoKHR *>( this );
    }

    operator VkBindImageMemorySwapchainInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkBindImageMemorySwapchainInfoKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( BindImageMemorySwapchainInfoKHR const & ) const = default;
#else
    bool operator==( BindImageMemorySwapchainInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( swapchain == rhs.swapchain ) &&
             ( imageIndex == rhs.imageIndex );
    }

    bool operator!=( BindImageMemorySwapchainInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType      = StructureType::eBindImageMemorySwapchainInfoKHR;
    const void *                        pNext      = {};
    VULKAN_HPP_NAMESPACE::SwapchainKHR  swapchain  = {};
    uint32_t                            imageIndex = {};
  };
  static_assert( sizeof( BindImageMemorySwapchainInfoKHR ) == sizeof( VkBindImageMemorySwapchainInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<BindImageMemorySwapchainInfoKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eBindImageMemorySwapchainInfoKHR>
  {
    using Type = BindImageMemorySwapchainInfoKHR;
  };

  struct BindImagePlaneMemoryInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eBindImagePlaneMemoryInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      BindImagePlaneMemoryInfo( VULKAN_HPP_NAMESPACE::ImageAspectFlagBits planeAspect_ =
                                  VULKAN_HPP_NAMESPACE::ImageAspectFlagBits::eColor ) VULKAN_HPP_NOEXCEPT
      : planeAspect( planeAspect_ )
    {}

    VULKAN_HPP_CONSTEXPR BindImagePlaneMemoryInfo( BindImagePlaneMemoryInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    BindImagePlaneMemoryInfo( VkBindImagePlaneMemoryInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : BindImagePlaneMemoryInfo( *reinterpret_cast<BindImagePlaneMemoryInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 BindImagePlaneMemoryInfo &
                            operator=( BindImagePlaneMemoryInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    BindImagePlaneMemoryInfo & operator=( VkBindImagePlaneMemoryInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::BindImagePlaneMemoryInfo const *>( &rhs );
      return *this;
    }

    BindImagePlaneMemoryInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    BindImagePlaneMemoryInfo &
      setPlaneAspect( VULKAN_HPP_NAMESPACE::ImageAspectFlagBits planeAspect_ ) VULKAN_HPP_NOEXCEPT
    {
      planeAspect = planeAspect_;
      return *this;
    }

    operator VkBindImagePlaneMemoryInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkBindImagePlaneMemoryInfo *>( this );
    }

    operator VkBindImagePlaneMemoryInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkBindImagePlaneMemoryInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( BindImagePlaneMemoryInfo const & ) const = default;
#else
    bool operator==( BindImagePlaneMemoryInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( planeAspect == rhs.planeAspect );
    }

    bool operator!=( BindImagePlaneMemoryInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType       sType       = StructureType::eBindImagePlaneMemoryInfo;
    const void *                              pNext       = {};
    VULKAN_HPP_NAMESPACE::ImageAspectFlagBits planeAspect = VULKAN_HPP_NAMESPACE::ImageAspectFlagBits::eColor;
  };
  static_assert( sizeof( BindImagePlaneMemoryInfo ) == sizeof( VkBindImagePlaneMemoryInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<BindImagePlaneMemoryInfo>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eBindImagePlaneMemoryInfo>
  {
    using Type = BindImagePlaneMemoryInfo;
  };
  using BindImagePlaneMemoryInfoKHR = BindImagePlaneMemoryInfo;

  struct BindIndexBufferIndirectCommandNV
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR BindIndexBufferIndirectCommandNV(
      VULKAN_HPP_NAMESPACE::DeviceAddress bufferAddress_ = {},
      uint32_t                            size_          = {},
      VULKAN_HPP_NAMESPACE::IndexType     indexType_ = VULKAN_HPP_NAMESPACE::IndexType::eUint16 ) VULKAN_HPP_NOEXCEPT
      : bufferAddress( bufferAddress_ )
      , size( size_ )
      , indexType( indexType_ )
    {}

    VULKAN_HPP_CONSTEXPR
      BindIndexBufferIndirectCommandNV( BindIndexBufferIndirectCommandNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    BindIndexBufferIndirectCommandNV( VkBindIndexBufferIndirectCommandNV const & rhs ) VULKAN_HPP_NOEXCEPT
      : BindIndexBufferIndirectCommandNV( *reinterpret_cast<BindIndexBufferIndirectCommandNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 BindIndexBufferIndirectCommandNV &
                            operator=( BindIndexBufferIndirectCommandNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    BindIndexBufferIndirectCommandNV & operator=( VkBindIndexBufferIndirectCommandNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::BindIndexBufferIndirectCommandNV const *>( &rhs );
      return *this;
    }

    BindIndexBufferIndirectCommandNV &
      setBufferAddress( VULKAN_HPP_NAMESPACE::DeviceAddress bufferAddress_ ) VULKAN_HPP_NOEXCEPT
    {
      bufferAddress = bufferAddress_;
      return *this;
    }

    BindIndexBufferIndirectCommandNV & setSize( uint32_t size_ ) VULKAN_HPP_NOEXCEPT
    {
      size = size_;
      return *this;
    }

    BindIndexBufferIndirectCommandNV & setIndexType( VULKAN_HPP_NAMESPACE::IndexType indexType_ ) VULKAN_HPP_NOEXCEPT
    {
      indexType = indexType_;
      return *this;
    }

    operator VkBindIndexBufferIndirectCommandNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkBindIndexBufferIndirectCommandNV *>( this );
    }

    operator VkBindIndexBufferIndirectCommandNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkBindIndexBufferIndirectCommandNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( BindIndexBufferIndirectCommandNV const & ) const = default;
#else
    bool operator==( BindIndexBufferIndirectCommandNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( bufferAddress == rhs.bufferAddress ) && ( size == rhs.size ) && ( indexType == rhs.indexType );
    }

    bool operator!=( BindIndexBufferIndirectCommandNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::DeviceAddress bufferAddress = {};
    uint32_t                            size          = {};
    VULKAN_HPP_NAMESPACE::IndexType     indexType     = VULKAN_HPP_NAMESPACE::IndexType::eUint16;
  };
  static_assert( sizeof( BindIndexBufferIndirectCommandNV ) == sizeof( VkBindIndexBufferIndirectCommandNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<BindIndexBufferIndirectCommandNV>::value,
                 "struct wrapper is not a standard layout!" );

  struct BindShaderGroupIndirectCommandNV
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR BindShaderGroupIndirectCommandNV( uint32_t groupIndex_ = {} ) VULKAN_HPP_NOEXCEPT
      : groupIndex( groupIndex_ )
    {}

    VULKAN_HPP_CONSTEXPR
      BindShaderGroupIndirectCommandNV( BindShaderGroupIndirectCommandNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    BindShaderGroupIndirectCommandNV( VkBindShaderGroupIndirectCommandNV const & rhs ) VULKAN_HPP_NOEXCEPT
      : BindShaderGroupIndirectCommandNV( *reinterpret_cast<BindShaderGroupIndirectCommandNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 BindShaderGroupIndirectCommandNV &
                            operator=( BindShaderGroupIndirectCommandNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    BindShaderGroupIndirectCommandNV & operator=( VkBindShaderGroupIndirectCommandNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::BindShaderGroupIndirectCommandNV const *>( &rhs );
      return *this;
    }

    BindShaderGroupIndirectCommandNV & setGroupIndex( uint32_t groupIndex_ ) VULKAN_HPP_NOEXCEPT
    {
      groupIndex = groupIndex_;
      return *this;
    }

    operator VkBindShaderGroupIndirectCommandNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkBindShaderGroupIndirectCommandNV *>( this );
    }

    operator VkBindShaderGroupIndirectCommandNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkBindShaderGroupIndirectCommandNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( BindShaderGroupIndirectCommandNV const & ) const = default;
#else
    bool operator==( BindShaderGroupIndirectCommandNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( groupIndex == rhs.groupIndex );
    }

    bool operator!=( BindShaderGroupIndirectCommandNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    uint32_t groupIndex = {};
  };
  static_assert( sizeof( BindShaderGroupIndirectCommandNV ) == sizeof( VkBindShaderGroupIndirectCommandNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<BindShaderGroupIndirectCommandNV>::value,
                 "struct wrapper is not a standard layout!" );

  struct SparseMemoryBind
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR SparseMemoryBind( VULKAN_HPP_NAMESPACE::DeviceSize            resourceOffset_ = {},
                                           VULKAN_HPP_NAMESPACE::DeviceSize            size_           = {},
                                           VULKAN_HPP_NAMESPACE::DeviceMemory          memory_         = {},
                                           VULKAN_HPP_NAMESPACE::DeviceSize            memoryOffset_   = {},
                                           VULKAN_HPP_NAMESPACE::SparseMemoryBindFlags flags_ = {} ) VULKAN_HPP_NOEXCEPT
      : resourceOffset( resourceOffset_ )
      , size( size_ )
      , memory( memory_ )
      , memoryOffset( memoryOffset_ )
      , flags( flags_ )
    {}

    VULKAN_HPP_CONSTEXPR SparseMemoryBind( SparseMemoryBind const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SparseMemoryBind( VkSparseMemoryBind const & rhs ) VULKAN_HPP_NOEXCEPT
      : SparseMemoryBind( *reinterpret_cast<SparseMemoryBind const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SparseMemoryBind & operator=( SparseMemoryBind const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SparseMemoryBind & operator=( VkSparseMemoryBind const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SparseMemoryBind const *>( &rhs );
      return *this;
    }

    SparseMemoryBind & setResourceOffset( VULKAN_HPP_NAMESPACE::DeviceSize resourceOffset_ ) VULKAN_HPP_NOEXCEPT
    {
      resourceOffset = resourceOffset_;
      return *this;
    }

    SparseMemoryBind & setSize( VULKAN_HPP_NAMESPACE::DeviceSize size_ ) VULKAN_HPP_NOEXCEPT
    {
      size = size_;
      return *this;
    }

    SparseMemoryBind & setMemory( VULKAN_HPP_NAMESPACE::DeviceMemory memory_ ) VULKAN_HPP_NOEXCEPT
    {
      memory = memory_;
      return *this;
    }

    SparseMemoryBind & setMemoryOffset( VULKAN_HPP_NAMESPACE::DeviceSize memoryOffset_ ) VULKAN_HPP_NOEXCEPT
    {
      memoryOffset = memoryOffset_;
      return *this;
    }

    SparseMemoryBind & setFlags( VULKAN_HPP_NAMESPACE::SparseMemoryBindFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    operator VkSparseMemoryBind const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSparseMemoryBind *>( this );
    }

    operator VkSparseMemoryBind &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSparseMemoryBind *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SparseMemoryBind const & ) const = default;
#else
    bool operator==( SparseMemoryBind const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( resourceOffset == rhs.resourceOffset ) && ( size == rhs.size ) && ( memory == rhs.memory ) &&
             ( memoryOffset == rhs.memoryOffset ) && ( flags == rhs.flags );
    }

    bool operator!=( SparseMemoryBind const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::DeviceSize            resourceOffset = {};
    VULKAN_HPP_NAMESPACE::DeviceSize            size           = {};
    VULKAN_HPP_NAMESPACE::DeviceMemory          memory         = {};
    VULKAN_HPP_NAMESPACE::DeviceSize            memoryOffset   = {};
    VULKAN_HPP_NAMESPACE::SparseMemoryBindFlags flags          = {};
  };
  static_assert( sizeof( SparseMemoryBind ) == sizeof( VkSparseMemoryBind ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SparseMemoryBind>::value, "struct wrapper is not a standard layout!" );

  struct SparseBufferMemoryBindInfo
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      SparseBufferMemoryBindInfo( VULKAN_HPP_NAMESPACE::Buffer                   buffer_    = {},
                                  uint32_t                                       bindCount_ = {},
                                  const VULKAN_HPP_NAMESPACE::SparseMemoryBind * pBinds_    = {} ) VULKAN_HPP_NOEXCEPT
      : buffer( buffer_ )
      , bindCount( bindCount_ )
      , pBinds( pBinds_ )
    {}

    VULKAN_HPP_CONSTEXPR
      SparseBufferMemoryBindInfo( SparseBufferMemoryBindInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SparseBufferMemoryBindInfo( VkSparseBufferMemoryBindInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : SparseBufferMemoryBindInfo( *reinterpret_cast<SparseBufferMemoryBindInfo const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    SparseBufferMemoryBindInfo(
      VULKAN_HPP_NAMESPACE::Buffer                                                                        buffer_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::SparseMemoryBind> const & binds_ )
      : buffer( buffer_ ), bindCount( static_cast<uint32_t>( binds_.size() ) ), pBinds( binds_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SparseBufferMemoryBindInfo &
                            operator=( SparseBufferMemoryBindInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SparseBufferMemoryBindInfo & operator=( VkSparseBufferMemoryBindInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SparseBufferMemoryBindInfo const *>( &rhs );
      return *this;
    }

    SparseBufferMemoryBindInfo & setBuffer( VULKAN_HPP_NAMESPACE::Buffer buffer_ ) VULKAN_HPP_NOEXCEPT
    {
      buffer = buffer_;
      return *this;
    }

    SparseBufferMemoryBindInfo & setBindCount( uint32_t bindCount_ ) VULKAN_HPP_NOEXCEPT
    {
      bindCount = bindCount_;
      return *this;
    }

    SparseBufferMemoryBindInfo & setPBinds( const VULKAN_HPP_NAMESPACE::SparseMemoryBind * pBinds_ ) VULKAN_HPP_NOEXCEPT
    {
      pBinds = pBinds_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    SparseBufferMemoryBindInfo & setBinds(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::SparseMemoryBind> const & binds_ )
      VULKAN_HPP_NOEXCEPT
    {
      bindCount = static_cast<uint32_t>( binds_.size() );
      pBinds    = binds_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkSparseBufferMemoryBindInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSparseBufferMemoryBindInfo *>( this );
    }

    operator VkSparseBufferMemoryBindInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSparseBufferMemoryBindInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SparseBufferMemoryBindInfo const & ) const = default;
#else
    bool operator==( SparseBufferMemoryBindInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( buffer == rhs.buffer ) && ( bindCount == rhs.bindCount ) && ( pBinds == rhs.pBinds );
    }

    bool operator!=( SparseBufferMemoryBindInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::Buffer                   buffer    = {};
    uint32_t                                       bindCount = {};
    const VULKAN_HPP_NAMESPACE::SparseMemoryBind * pBinds    = {};
  };
  static_assert( sizeof( SparseBufferMemoryBindInfo ) == sizeof( VkSparseBufferMemoryBindInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SparseBufferMemoryBindInfo>::value,
                 "struct wrapper is not a standard layout!" );

  struct SparseImageOpaqueMemoryBindInfo
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      SparseImageOpaqueMemoryBindInfo( VULKAN_HPP_NAMESPACE::Image                    image_     = {},
                                       uint32_t                                       bindCount_ = {},
                                       const VULKAN_HPP_NAMESPACE::SparseMemoryBind * pBinds_ = {} ) VULKAN_HPP_NOEXCEPT
      : image( image_ )
      , bindCount( bindCount_ )
      , pBinds( pBinds_ )
    {}

    VULKAN_HPP_CONSTEXPR
      SparseImageOpaqueMemoryBindInfo( SparseImageOpaqueMemoryBindInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SparseImageOpaqueMemoryBindInfo( VkSparseImageOpaqueMemoryBindInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : SparseImageOpaqueMemoryBindInfo( *reinterpret_cast<SparseImageOpaqueMemoryBindInfo const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    SparseImageOpaqueMemoryBindInfo(
      VULKAN_HPP_NAMESPACE::Image                                                                         image_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::SparseMemoryBind> const & binds_ )
      : image( image_ ), bindCount( static_cast<uint32_t>( binds_.size() ) ), pBinds( binds_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SparseImageOpaqueMemoryBindInfo &
                            operator=( SparseImageOpaqueMemoryBindInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SparseImageOpaqueMemoryBindInfo & operator=( VkSparseImageOpaqueMemoryBindInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SparseImageOpaqueMemoryBindInfo const *>( &rhs );
      return *this;
    }

    SparseImageOpaqueMemoryBindInfo & setImage( VULKAN_HPP_NAMESPACE::Image image_ ) VULKAN_HPP_NOEXCEPT
    {
      image = image_;
      return *this;
    }

    SparseImageOpaqueMemoryBindInfo & setBindCount( uint32_t bindCount_ ) VULKAN_HPP_NOEXCEPT
    {
      bindCount = bindCount_;
      return *this;
    }

    SparseImageOpaqueMemoryBindInfo &
      setPBinds( const VULKAN_HPP_NAMESPACE::SparseMemoryBind * pBinds_ ) VULKAN_HPP_NOEXCEPT
    {
      pBinds = pBinds_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    SparseImageOpaqueMemoryBindInfo & setBinds(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::SparseMemoryBind> const & binds_ )
      VULKAN_HPP_NOEXCEPT
    {
      bindCount = static_cast<uint32_t>( binds_.size() );
      pBinds    = binds_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkSparseImageOpaqueMemoryBindInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSparseImageOpaqueMemoryBindInfo *>( this );
    }

    operator VkSparseImageOpaqueMemoryBindInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSparseImageOpaqueMemoryBindInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SparseImageOpaqueMemoryBindInfo const & ) const = default;
#else
    bool operator==( SparseImageOpaqueMemoryBindInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( image == rhs.image ) && ( bindCount == rhs.bindCount ) && ( pBinds == rhs.pBinds );
    }

    bool operator!=( SparseImageOpaqueMemoryBindInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::Image                    image     = {};
    uint32_t                                       bindCount = {};
    const VULKAN_HPP_NAMESPACE::SparseMemoryBind * pBinds    = {};
  };
  static_assert( sizeof( SparseImageOpaqueMemoryBindInfo ) == sizeof( VkSparseImageOpaqueMemoryBindInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SparseImageOpaqueMemoryBindInfo>::value,
                 "struct wrapper is not a standard layout!" );

  struct ImageSubresource
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ImageSubresource( VULKAN_HPP_NAMESPACE::ImageAspectFlags aspectMask_ = {},
                                           uint32_t                               mipLevel_   = {},
                                           uint32_t                               arrayLayer_ = {} ) VULKAN_HPP_NOEXCEPT
      : aspectMask( aspectMask_ )
      , mipLevel( mipLevel_ )
      , arrayLayer( arrayLayer_ )
    {}

    VULKAN_HPP_CONSTEXPR ImageSubresource( ImageSubresource const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImageSubresource( VkImageSubresource const & rhs ) VULKAN_HPP_NOEXCEPT
      : ImageSubresource( *reinterpret_cast<ImageSubresource const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ImageSubresource & operator=( ImageSubresource const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImageSubresource & operator=( VkImageSubresource const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ImageSubresource const *>( &rhs );
      return *this;
    }

    ImageSubresource & setAspectMask( VULKAN_HPP_NAMESPACE::ImageAspectFlags aspectMask_ ) VULKAN_HPP_NOEXCEPT
    {
      aspectMask = aspectMask_;
      return *this;
    }

    ImageSubresource & setMipLevel( uint32_t mipLevel_ ) VULKAN_HPP_NOEXCEPT
    {
      mipLevel = mipLevel_;
      return *this;
    }

    ImageSubresource & setArrayLayer( uint32_t arrayLayer_ ) VULKAN_HPP_NOEXCEPT
    {
      arrayLayer = arrayLayer_;
      return *this;
    }

    operator VkImageSubresource const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkImageSubresource *>( this );
    }

    operator VkImageSubresource &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkImageSubresource *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ImageSubresource const & ) const = default;
#else
    bool operator==( ImageSubresource const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( aspectMask == rhs.aspectMask ) && ( mipLevel == rhs.mipLevel ) && ( arrayLayer == rhs.arrayLayer );
    }

    bool operator!=( ImageSubresource const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::ImageAspectFlags aspectMask = {};
    uint32_t                               mipLevel   = {};
    uint32_t                               arrayLayer = {};
  };
  static_assert( sizeof( ImageSubresource ) == sizeof( VkImageSubresource ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ImageSubresource>::value, "struct wrapper is not a standard layout!" );

  struct Offset3D
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR Offset3D( int32_t x_ = {}, int32_t y_ = {}, int32_t z_ = {} ) VULKAN_HPP_NOEXCEPT
      : x( x_ )
      , y( y_ )
      , z( z_ )
    {}

    VULKAN_HPP_CONSTEXPR Offset3D( Offset3D const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    Offset3D( VkOffset3D const & rhs ) VULKAN_HPP_NOEXCEPT : Offset3D( *reinterpret_cast<Offset3D const *>( &rhs ) ) {}

    explicit Offset3D( Offset2D const & offset2D, int32_t z_ = {} ) : x( offset2D.x ), y( offset2D.y ), z( z_ ) {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 Offset3D & operator=( Offset3D const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    Offset3D & operator=( VkOffset3D const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::Offset3D const *>( &rhs );
      return *this;
    }

    Offset3D & setX( int32_t x_ ) VULKAN_HPP_NOEXCEPT
    {
      x = x_;
      return *this;
    }

    Offset3D & setY( int32_t y_ ) VULKAN_HPP_NOEXCEPT
    {
      y = y_;
      return *this;
    }

    Offset3D & setZ( int32_t z_ ) VULKAN_HPP_NOEXCEPT
    {
      z = z_;
      return *this;
    }

    operator VkOffset3D const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkOffset3D *>( this );
    }

    operator VkOffset3D &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkOffset3D *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( Offset3D const & ) const = default;
#else
    bool operator==( Offset3D const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( x == rhs.x ) && ( y == rhs.y ) && ( z == rhs.z );
    }

    bool operator!=( Offset3D const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    int32_t x = {};
    int32_t y = {};
    int32_t z = {};
  };
  static_assert( sizeof( Offset3D ) == sizeof( VkOffset3D ), "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<Offset3D>::value, "struct wrapper is not a standard layout!" );

  struct Extent3D
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      Extent3D( uint32_t width_ = {}, uint32_t height_ = {}, uint32_t depth_ = {} ) VULKAN_HPP_NOEXCEPT
      : width( width_ )
      , height( height_ )
      , depth( depth_ )
    {}

    VULKAN_HPP_CONSTEXPR Extent3D( Extent3D const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    Extent3D( VkExtent3D const & rhs ) VULKAN_HPP_NOEXCEPT : Extent3D( *reinterpret_cast<Extent3D const *>( &rhs ) ) {}

    explicit Extent3D( Extent2D const & extent2D, uint32_t depth_ = {} )
      : width( extent2D.width ), height( extent2D.height ), depth( depth_ )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 Extent3D & operator=( Extent3D const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    Extent3D & operator=( VkExtent3D const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::Extent3D const *>( &rhs );
      return *this;
    }

    Extent3D & setWidth( uint32_t width_ ) VULKAN_HPP_NOEXCEPT
    {
      width = width_;
      return *this;
    }

    Extent3D & setHeight( uint32_t height_ ) VULKAN_HPP_NOEXCEPT
    {
      height = height_;
      return *this;
    }

    Extent3D & setDepth( uint32_t depth_ ) VULKAN_HPP_NOEXCEPT
    {
      depth = depth_;
      return *this;
    }

    operator VkExtent3D const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkExtent3D *>( this );
    }

    operator VkExtent3D &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkExtent3D *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( Extent3D const & ) const = default;
#else
    bool operator==( Extent3D const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( width == rhs.width ) && ( height == rhs.height ) && ( depth == rhs.depth );
    }

    bool operator!=( Extent3D const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    uint32_t width  = {};
    uint32_t height = {};
    uint32_t depth  = {};
  };
  static_assert( sizeof( Extent3D ) == sizeof( VkExtent3D ), "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<Extent3D>::value, "struct wrapper is not a standard layout!" );

  struct SparseImageMemoryBind
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      SparseImageMemoryBind( VULKAN_HPP_NAMESPACE::ImageSubresource      subresource_  = {},
                             VULKAN_HPP_NAMESPACE::Offset3D              offset_       = {},
                             VULKAN_HPP_NAMESPACE::Extent3D              extent_       = {},
                             VULKAN_HPP_NAMESPACE::DeviceMemory          memory_       = {},
                             VULKAN_HPP_NAMESPACE::DeviceSize            memoryOffset_ = {},
                             VULKAN_HPP_NAMESPACE::SparseMemoryBindFlags flags_        = {} ) VULKAN_HPP_NOEXCEPT
      : subresource( subresource_ )
      , offset( offset_ )
      , extent( extent_ )
      , memory( memory_ )
      , memoryOffset( memoryOffset_ )
      , flags( flags_ )
    {}

    VULKAN_HPP_CONSTEXPR SparseImageMemoryBind( SparseImageMemoryBind const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SparseImageMemoryBind( VkSparseImageMemoryBind const & rhs ) VULKAN_HPP_NOEXCEPT
      : SparseImageMemoryBind( *reinterpret_cast<SparseImageMemoryBind const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SparseImageMemoryBind &
                            operator=( SparseImageMemoryBind const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SparseImageMemoryBind & operator=( VkSparseImageMemoryBind const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SparseImageMemoryBind const *>( &rhs );
      return *this;
    }

    SparseImageMemoryBind &
      setSubresource( VULKAN_HPP_NAMESPACE::ImageSubresource const & subresource_ ) VULKAN_HPP_NOEXCEPT
    {
      subresource = subresource_;
      return *this;
    }

    SparseImageMemoryBind & setOffset( VULKAN_HPP_NAMESPACE::Offset3D const & offset_ ) VULKAN_HPP_NOEXCEPT
    {
      offset = offset_;
      return *this;
    }

    SparseImageMemoryBind & setExtent( VULKAN_HPP_NAMESPACE::Extent3D const & extent_ ) VULKAN_HPP_NOEXCEPT
    {
      extent = extent_;
      return *this;
    }

    SparseImageMemoryBind & setMemory( VULKAN_HPP_NAMESPACE::DeviceMemory memory_ ) VULKAN_HPP_NOEXCEPT
    {
      memory = memory_;
      return *this;
    }

    SparseImageMemoryBind & setMemoryOffset( VULKAN_HPP_NAMESPACE::DeviceSize memoryOffset_ ) VULKAN_HPP_NOEXCEPT
    {
      memoryOffset = memoryOffset_;
      return *this;
    }

    SparseImageMemoryBind & setFlags( VULKAN_HPP_NAMESPACE::SparseMemoryBindFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    operator VkSparseImageMemoryBind const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSparseImageMemoryBind *>( this );
    }

    operator VkSparseImageMemoryBind &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSparseImageMemoryBind *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SparseImageMemoryBind const & ) const = default;
#else
    bool operator==( SparseImageMemoryBind const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( subresource == rhs.subresource ) && ( offset == rhs.offset ) && ( extent == rhs.extent ) &&
             ( memory == rhs.memory ) && ( memoryOffset == rhs.memoryOffset ) && ( flags == rhs.flags );
    }

    bool operator!=( SparseImageMemoryBind const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::ImageSubresource      subresource  = {};
    VULKAN_HPP_NAMESPACE::Offset3D              offset       = {};
    VULKAN_HPP_NAMESPACE::Extent3D              extent       = {};
    VULKAN_HPP_NAMESPACE::DeviceMemory          memory       = {};
    VULKAN_HPP_NAMESPACE::DeviceSize            memoryOffset = {};
    VULKAN_HPP_NAMESPACE::SparseMemoryBindFlags flags        = {};
  };
  static_assert( sizeof( SparseImageMemoryBind ) == sizeof( VkSparseImageMemoryBind ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SparseImageMemoryBind>::value, "struct wrapper is not a standard layout!" );

  struct SparseImageMemoryBindInfo
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      SparseImageMemoryBindInfo( VULKAN_HPP_NAMESPACE::Image                         image_     = {},
                                 uint32_t                                            bindCount_ = {},
                                 const VULKAN_HPP_NAMESPACE::SparseImageMemoryBind * pBinds_ = {} ) VULKAN_HPP_NOEXCEPT
      : image( image_ )
      , bindCount( bindCount_ )
      , pBinds( pBinds_ )
    {}

    VULKAN_HPP_CONSTEXPR
      SparseImageMemoryBindInfo( SparseImageMemoryBindInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SparseImageMemoryBindInfo( VkSparseImageMemoryBindInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : SparseImageMemoryBindInfo( *reinterpret_cast<SparseImageMemoryBindInfo const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    SparseImageMemoryBindInfo(
      VULKAN_HPP_NAMESPACE::Image                                                                              image_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::SparseImageMemoryBind> const & binds_ )
      : image( image_ ), bindCount( static_cast<uint32_t>( binds_.size() ) ), pBinds( binds_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SparseImageMemoryBindInfo &
                            operator=( SparseImageMemoryBindInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SparseImageMemoryBindInfo & operator=( VkSparseImageMemoryBindInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SparseImageMemoryBindInfo const *>( &rhs );
      return *this;
    }

    SparseImageMemoryBindInfo & setImage( VULKAN_HPP_NAMESPACE::Image image_ ) VULKAN_HPP_NOEXCEPT
    {
      image = image_;
      return *this;
    }

    SparseImageMemoryBindInfo & setBindCount( uint32_t bindCount_ ) VULKAN_HPP_NOEXCEPT
    {
      bindCount = bindCount_;
      return *this;
    }

    SparseImageMemoryBindInfo &
      setPBinds( const VULKAN_HPP_NAMESPACE::SparseImageMemoryBind * pBinds_ ) VULKAN_HPP_NOEXCEPT
    {
      pBinds = pBinds_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    SparseImageMemoryBindInfo & setBinds(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::SparseImageMemoryBind> const & binds_ )
      VULKAN_HPP_NOEXCEPT
    {
      bindCount = static_cast<uint32_t>( binds_.size() );
      pBinds    = binds_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkSparseImageMemoryBindInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSparseImageMemoryBindInfo *>( this );
    }

    operator VkSparseImageMemoryBindInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSparseImageMemoryBindInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SparseImageMemoryBindInfo const & ) const = default;
#else
    bool operator==( SparseImageMemoryBindInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( image == rhs.image ) && ( bindCount == rhs.bindCount ) && ( pBinds == rhs.pBinds );
    }

    bool operator!=( SparseImageMemoryBindInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::Image                         image     = {};
    uint32_t                                            bindCount = {};
    const VULKAN_HPP_NAMESPACE::SparseImageMemoryBind * pBinds    = {};
  };
  static_assert( sizeof( SparseImageMemoryBindInfo ) == sizeof( VkSparseImageMemoryBindInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SparseImageMemoryBindInfo>::value,
                 "struct wrapper is not a standard layout!" );

  struct BindSparseInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eBindSparseInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      BindSparseInfo( uint32_t                                                      waitSemaphoreCount_   = {},
                      const VULKAN_HPP_NAMESPACE::Semaphore *                       pWaitSemaphores_      = {},
                      uint32_t                                                      bufferBindCount_      = {},
                      const VULKAN_HPP_NAMESPACE::SparseBufferMemoryBindInfo *      pBufferBinds_         = {},
                      uint32_t                                                      imageOpaqueBindCount_ = {},
                      const VULKAN_HPP_NAMESPACE::SparseImageOpaqueMemoryBindInfo * pImageOpaqueBinds_    = {},
                      uint32_t                                                      imageBindCount_       = {},
                      const VULKAN_HPP_NAMESPACE::SparseImageMemoryBindInfo *       pImageBinds_          = {},
                      uint32_t                                                      signalSemaphoreCount_ = {},
                      const VULKAN_HPP_NAMESPACE::Semaphore * pSignalSemaphores_ = {} ) VULKAN_HPP_NOEXCEPT
      : waitSemaphoreCount( waitSemaphoreCount_ )
      , pWaitSemaphores( pWaitSemaphores_ )
      , bufferBindCount( bufferBindCount_ )
      , pBufferBinds( pBufferBinds_ )
      , imageOpaqueBindCount( imageOpaqueBindCount_ )
      , pImageOpaqueBinds( pImageOpaqueBinds_ )
      , imageBindCount( imageBindCount_ )
      , pImageBinds( pImageBinds_ )
      , signalSemaphoreCount( signalSemaphoreCount_ )
      , pSignalSemaphores( pSignalSemaphores_ )
    {}

    VULKAN_HPP_CONSTEXPR BindSparseInfo( BindSparseInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    BindSparseInfo( VkBindSparseInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : BindSparseInfo( *reinterpret_cast<BindSparseInfo const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    BindSparseInfo(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::Semaphore> const & waitSemaphores_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::SparseBufferMemoryBindInfo> const &
        bufferBinds_ = {},
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::SparseImageOpaqueMemoryBindInfo> const &
        imageOpaqueBinds_ = {},
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::SparseImageMemoryBindInfo> const &
        imageBinds_ = {},
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::Semaphore> const &
        signalSemaphores_ = {} )
      : waitSemaphoreCount( static_cast<uint32_t>( waitSemaphores_.size() ) )
      , pWaitSemaphores( waitSemaphores_.data() )
      , bufferBindCount( static_cast<uint32_t>( bufferBinds_.size() ) )
      , pBufferBinds( bufferBinds_.data() )
      , imageOpaqueBindCount( static_cast<uint32_t>( imageOpaqueBinds_.size() ) )
      , pImageOpaqueBinds( imageOpaqueBinds_.data() )
      , imageBindCount( static_cast<uint32_t>( imageBinds_.size() ) )
      , pImageBinds( imageBinds_.data() )
      , signalSemaphoreCount( static_cast<uint32_t>( signalSemaphores_.size() ) )
      , pSignalSemaphores( signalSemaphores_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 BindSparseInfo & operator=( BindSparseInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    BindSparseInfo & operator=( VkBindSparseInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::BindSparseInfo const *>( &rhs );
      return *this;
    }

    BindSparseInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    BindSparseInfo & setWaitSemaphoreCount( uint32_t waitSemaphoreCount_ ) VULKAN_HPP_NOEXCEPT
    {
      waitSemaphoreCount = waitSemaphoreCount_;
      return *this;
    }

    BindSparseInfo & setPWaitSemaphores( const VULKAN_HPP_NAMESPACE::Semaphore * pWaitSemaphores_ ) VULKAN_HPP_NOEXCEPT
    {
      pWaitSemaphores = pWaitSemaphores_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    BindSparseInfo & setWaitSemaphores(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::Semaphore> const & waitSemaphores_ )
      VULKAN_HPP_NOEXCEPT
    {
      waitSemaphoreCount = static_cast<uint32_t>( waitSemaphores_.size() );
      pWaitSemaphores    = waitSemaphores_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    BindSparseInfo & setBufferBindCount( uint32_t bufferBindCount_ ) VULKAN_HPP_NOEXCEPT
    {
      bufferBindCount = bufferBindCount_;
      return *this;
    }

    BindSparseInfo &
      setPBufferBinds( const VULKAN_HPP_NAMESPACE::SparseBufferMemoryBindInfo * pBufferBinds_ ) VULKAN_HPP_NOEXCEPT
    {
      pBufferBinds = pBufferBinds_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    BindSparseInfo & setBufferBinds(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::SparseBufferMemoryBindInfo> const &
        bufferBinds_ ) VULKAN_HPP_NOEXCEPT
    {
      bufferBindCount = static_cast<uint32_t>( bufferBinds_.size() );
      pBufferBinds    = bufferBinds_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    BindSparseInfo & setImageOpaqueBindCount( uint32_t imageOpaqueBindCount_ ) VULKAN_HPP_NOEXCEPT
    {
      imageOpaqueBindCount = imageOpaqueBindCount_;
      return *this;
    }

    BindSparseInfo & setPImageOpaqueBinds(
      const VULKAN_HPP_NAMESPACE::SparseImageOpaqueMemoryBindInfo * pImageOpaqueBinds_ ) VULKAN_HPP_NOEXCEPT
    {
      pImageOpaqueBinds = pImageOpaqueBinds_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    BindSparseInfo & setImageOpaqueBinds(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::SparseImageOpaqueMemoryBindInfo> const &
        imageOpaqueBinds_ ) VULKAN_HPP_NOEXCEPT
    {
      imageOpaqueBindCount = static_cast<uint32_t>( imageOpaqueBinds_.size() );
      pImageOpaqueBinds    = imageOpaqueBinds_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    BindSparseInfo & setImageBindCount( uint32_t imageBindCount_ ) VULKAN_HPP_NOEXCEPT
    {
      imageBindCount = imageBindCount_;
      return *this;
    }

    BindSparseInfo &
      setPImageBinds( const VULKAN_HPP_NAMESPACE::SparseImageMemoryBindInfo * pImageBinds_ ) VULKAN_HPP_NOEXCEPT
    {
      pImageBinds = pImageBinds_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    BindSparseInfo & setImageBinds(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::SparseImageMemoryBindInfo> const &
        imageBinds_ ) VULKAN_HPP_NOEXCEPT
    {
      imageBindCount = static_cast<uint32_t>( imageBinds_.size() );
      pImageBinds    = imageBinds_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    BindSparseInfo & setSignalSemaphoreCount( uint32_t signalSemaphoreCount_ ) VULKAN_HPP_NOEXCEPT
    {
      signalSemaphoreCount = signalSemaphoreCount_;
      return *this;
    }

    BindSparseInfo &
      setPSignalSemaphores( const VULKAN_HPP_NAMESPACE::Semaphore * pSignalSemaphores_ ) VULKAN_HPP_NOEXCEPT
    {
      pSignalSemaphores = pSignalSemaphores_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    BindSparseInfo & setSignalSemaphores(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::Semaphore> const & signalSemaphores_ )
      VULKAN_HPP_NOEXCEPT
    {
      signalSemaphoreCount = static_cast<uint32_t>( signalSemaphores_.size() );
      pSignalSemaphores    = signalSemaphores_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkBindSparseInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkBindSparseInfo *>( this );
    }

    operator VkBindSparseInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkBindSparseInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( BindSparseInfo const & ) const = default;
#else
    bool operator==( BindSparseInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( waitSemaphoreCount == rhs.waitSemaphoreCount ) &&
             ( pWaitSemaphores == rhs.pWaitSemaphores ) && ( bufferBindCount == rhs.bufferBindCount ) &&
             ( pBufferBinds == rhs.pBufferBinds ) && ( imageOpaqueBindCount == rhs.imageOpaqueBindCount ) &&
             ( pImageOpaqueBinds == rhs.pImageOpaqueBinds ) && ( imageBindCount == rhs.imageBindCount ) &&
             ( pImageBinds == rhs.pImageBinds ) && ( signalSemaphoreCount == rhs.signalSemaphoreCount ) &&
             ( pSignalSemaphores == rhs.pSignalSemaphores );
    }

    bool operator!=( BindSparseInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                           sType                = StructureType::eBindSparseInfo;
    const void *                                                  pNext                = {};
    uint32_t                                                      waitSemaphoreCount   = {};
    const VULKAN_HPP_NAMESPACE::Semaphore *                       pWaitSemaphores      = {};
    uint32_t                                                      bufferBindCount      = {};
    const VULKAN_HPP_NAMESPACE::SparseBufferMemoryBindInfo *      pBufferBinds         = {};
    uint32_t                                                      imageOpaqueBindCount = {};
    const VULKAN_HPP_NAMESPACE::SparseImageOpaqueMemoryBindInfo * pImageOpaqueBinds    = {};
    uint32_t                                                      imageBindCount       = {};
    const VULKAN_HPP_NAMESPACE::SparseImageMemoryBindInfo *       pImageBinds          = {};
    uint32_t                                                      signalSemaphoreCount = {};
    const VULKAN_HPP_NAMESPACE::Semaphore *                       pSignalSemaphores    = {};
  };
  static_assert( sizeof( BindSparseInfo ) == sizeof( VkBindSparseInfo ), "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<BindSparseInfo>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eBindSparseInfo>
  {
    using Type = BindSparseInfo;
  };

  struct BindVertexBufferIndirectCommandNV
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR BindVertexBufferIndirectCommandNV( VULKAN_HPP_NAMESPACE::DeviceAddress bufferAddress_ = {},
                                                            uint32_t                            size_          = {},
                                                            uint32_t stride_ = {} ) VULKAN_HPP_NOEXCEPT
      : bufferAddress( bufferAddress_ )
      , size( size_ )
      , stride( stride_ )
    {}

    VULKAN_HPP_CONSTEXPR
      BindVertexBufferIndirectCommandNV( BindVertexBufferIndirectCommandNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    BindVertexBufferIndirectCommandNV( VkBindVertexBufferIndirectCommandNV const & rhs ) VULKAN_HPP_NOEXCEPT
      : BindVertexBufferIndirectCommandNV( *reinterpret_cast<BindVertexBufferIndirectCommandNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 BindVertexBufferIndirectCommandNV &
                            operator=( BindVertexBufferIndirectCommandNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    BindVertexBufferIndirectCommandNV & operator=( VkBindVertexBufferIndirectCommandNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::BindVertexBufferIndirectCommandNV const *>( &rhs );
      return *this;
    }

    BindVertexBufferIndirectCommandNV &
      setBufferAddress( VULKAN_HPP_NAMESPACE::DeviceAddress bufferAddress_ ) VULKAN_HPP_NOEXCEPT
    {
      bufferAddress = bufferAddress_;
      return *this;
    }

    BindVertexBufferIndirectCommandNV & setSize( uint32_t size_ ) VULKAN_HPP_NOEXCEPT
    {
      size = size_;
      return *this;
    }

    BindVertexBufferIndirectCommandNV & setStride( uint32_t stride_ ) VULKAN_HPP_NOEXCEPT
    {
      stride = stride_;
      return *this;
    }

    operator VkBindVertexBufferIndirectCommandNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkBindVertexBufferIndirectCommandNV *>( this );
    }

    operator VkBindVertexBufferIndirectCommandNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkBindVertexBufferIndirectCommandNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( BindVertexBufferIndirectCommandNV const & ) const = default;
#else
    bool operator==( BindVertexBufferIndirectCommandNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( bufferAddress == rhs.bufferAddress ) && ( size == rhs.size ) && ( stride == rhs.stride );
    }

    bool operator!=( BindVertexBufferIndirectCommandNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::DeviceAddress bufferAddress = {};
    uint32_t                            size          = {};
    uint32_t                            stride        = {};
  };
  static_assert( sizeof( BindVertexBufferIndirectCommandNV ) == sizeof( VkBindVertexBufferIndirectCommandNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<BindVertexBufferIndirectCommandNV>::value,
                 "struct wrapper is not a standard layout!" );

  struct ImageSubresourceLayers
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ImageSubresourceLayers( VULKAN_HPP_NAMESPACE::ImageAspectFlags aspectMask_     = {},
                                                 uint32_t                               mipLevel_       = {},
                                                 uint32_t                               baseArrayLayer_ = {},
                                                 uint32_t layerCount_ = {} ) VULKAN_HPP_NOEXCEPT
      : aspectMask( aspectMask_ )
      , mipLevel( mipLevel_ )
      , baseArrayLayer( baseArrayLayer_ )
      , layerCount( layerCount_ )
    {}

    VULKAN_HPP_CONSTEXPR ImageSubresourceLayers( ImageSubresourceLayers const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImageSubresourceLayers( VkImageSubresourceLayers const & rhs ) VULKAN_HPP_NOEXCEPT
      : ImageSubresourceLayers( *reinterpret_cast<ImageSubresourceLayers const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ImageSubresourceLayers &
                            operator=( ImageSubresourceLayers const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImageSubresourceLayers & operator=( VkImageSubresourceLayers const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ImageSubresourceLayers const *>( &rhs );
      return *this;
    }

    ImageSubresourceLayers & setAspectMask( VULKAN_HPP_NAMESPACE::ImageAspectFlags aspectMask_ ) VULKAN_HPP_NOEXCEPT
    {
      aspectMask = aspectMask_;
      return *this;
    }

    ImageSubresourceLayers & setMipLevel( uint32_t mipLevel_ ) VULKAN_HPP_NOEXCEPT
    {
      mipLevel = mipLevel_;
      return *this;
    }

    ImageSubresourceLayers & setBaseArrayLayer( uint32_t baseArrayLayer_ ) VULKAN_HPP_NOEXCEPT
    {
      baseArrayLayer = baseArrayLayer_;
      return *this;
    }

    ImageSubresourceLayers & setLayerCount( uint32_t layerCount_ ) VULKAN_HPP_NOEXCEPT
    {
      layerCount = layerCount_;
      return *this;
    }

    operator VkImageSubresourceLayers const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkImageSubresourceLayers *>( this );
    }

    operator VkImageSubresourceLayers &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkImageSubresourceLayers *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ImageSubresourceLayers const & ) const = default;
#else
    bool operator==( ImageSubresourceLayers const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( aspectMask == rhs.aspectMask ) && ( mipLevel == rhs.mipLevel ) &&
             ( baseArrayLayer == rhs.baseArrayLayer ) && ( layerCount == rhs.layerCount );
    }

    bool operator!=( ImageSubresourceLayers const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::ImageAspectFlags aspectMask     = {};
    uint32_t                               mipLevel       = {};
    uint32_t                               baseArrayLayer = {};
    uint32_t                               layerCount     = {};
  };
  static_assert( sizeof( ImageSubresourceLayers ) == sizeof( VkImageSubresourceLayers ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ImageSubresourceLayers>::value, "struct wrapper is not a standard layout!" );

  struct ImageBlit2KHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eImageBlit2KHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR_14
      ImageBlit2KHR( VULKAN_HPP_NAMESPACE::ImageSubresourceLayers          srcSubresource_ = {},
                     std::array<VULKAN_HPP_NAMESPACE::Offset3D, 2> const & srcOffsets_     = {},
                     VULKAN_HPP_NAMESPACE::ImageSubresourceLayers          dstSubresource_ = {},
                     std::array<VULKAN_HPP_NAMESPACE::Offset3D, 2> const & dstOffsets_     = {} ) VULKAN_HPP_NOEXCEPT
      : srcSubresource( srcSubresource_ )
      , srcOffsets( srcOffsets_ )
      , dstSubresource( dstSubresource_ )
      , dstOffsets( dstOffsets_ )
    {}

    VULKAN_HPP_CONSTEXPR_14 ImageBlit2KHR( ImageBlit2KHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImageBlit2KHR( VkImageBlit2KHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : ImageBlit2KHR( *reinterpret_cast<ImageBlit2KHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ImageBlit2KHR & operator=( ImageBlit2KHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImageBlit2KHR & operator=( VkImageBlit2KHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ImageBlit2KHR const *>( &rhs );
      return *this;
    }

    ImageBlit2KHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ImageBlit2KHR &
      setSrcSubresource( VULKAN_HPP_NAMESPACE::ImageSubresourceLayers const & srcSubresource_ ) VULKAN_HPP_NOEXCEPT
    {
      srcSubresource = srcSubresource_;
      return *this;
    }

    ImageBlit2KHR &
      setSrcOffsets( std::array<VULKAN_HPP_NAMESPACE::Offset3D, 2> const & srcOffsets_ ) VULKAN_HPP_NOEXCEPT
    {
      srcOffsets = srcOffsets_;
      return *this;
    }

    ImageBlit2KHR &
      setDstSubresource( VULKAN_HPP_NAMESPACE::ImageSubresourceLayers const & dstSubresource_ ) VULKAN_HPP_NOEXCEPT
    {
      dstSubresource = dstSubresource_;
      return *this;
    }

    ImageBlit2KHR &
      setDstOffsets( std::array<VULKAN_HPP_NAMESPACE::Offset3D, 2> const & dstOffsets_ ) VULKAN_HPP_NOEXCEPT
    {
      dstOffsets = dstOffsets_;
      return *this;
    }

    operator VkImageBlit2KHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkImageBlit2KHR *>( this );
    }

    operator VkImageBlit2KHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkImageBlit2KHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ImageBlit2KHR const & ) const = default;
#else
    bool operator==( ImageBlit2KHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( srcSubresource == rhs.srcSubresource ) &&
             ( srcOffsets == rhs.srcOffsets ) && ( dstSubresource == rhs.dstSubresource ) &&
             ( dstOffsets == rhs.dstOffsets );
    }

    bool operator!=( ImageBlit2KHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                                     sType = StructureType::eImageBlit2KHR;
    const void *                                                            pNext = {};
    VULKAN_HPP_NAMESPACE::ImageSubresourceLayers                            srcSubresource = {};
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<VULKAN_HPP_NAMESPACE::Offset3D, 2> srcOffsets     = {};
    VULKAN_HPP_NAMESPACE::ImageSubresourceLayers                            dstSubresource = {};
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<VULKAN_HPP_NAMESPACE::Offset3D, 2> dstOffsets     = {};
  };
  static_assert( sizeof( ImageBlit2KHR ) == sizeof( VkImageBlit2KHR ), "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ImageBlit2KHR>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eImageBlit2KHR>
  {
    using Type = ImageBlit2KHR;
  };

  struct BlitImageInfo2KHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eBlitImageInfo2KHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR_14 BlitImageInfo2KHR(
      VULKAN_HPP_NAMESPACE::Image                 srcImage_       = {},
      VULKAN_HPP_NAMESPACE::ImageLayout           srcImageLayout_ = VULKAN_HPP_NAMESPACE::ImageLayout::eUndefined,
      VULKAN_HPP_NAMESPACE::Image                 dstImage_       = {},
      VULKAN_HPP_NAMESPACE::ImageLayout           dstImageLayout_ = VULKAN_HPP_NAMESPACE::ImageLayout::eUndefined,
      uint32_t                                    regionCount_    = {},
      const VULKAN_HPP_NAMESPACE::ImageBlit2KHR * pRegions_       = {},
      VULKAN_HPP_NAMESPACE::Filter                filter_ = VULKAN_HPP_NAMESPACE::Filter::eNearest ) VULKAN_HPP_NOEXCEPT
      : srcImage( srcImage_ )
      , srcImageLayout( srcImageLayout_ )
      , dstImage( dstImage_ )
      , dstImageLayout( dstImageLayout_ )
      , regionCount( regionCount_ )
      , pRegions( pRegions_ )
      , filter( filter_ )
    {}

    VULKAN_HPP_CONSTEXPR_14 BlitImageInfo2KHR( BlitImageInfo2KHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    BlitImageInfo2KHR( VkBlitImageInfo2KHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : BlitImageInfo2KHR( *reinterpret_cast<BlitImageInfo2KHR const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    BlitImageInfo2KHR(
      VULKAN_HPP_NAMESPACE::Image                                                                      srcImage_,
      VULKAN_HPP_NAMESPACE::ImageLayout                                                                srcImageLayout_,
      VULKAN_HPP_NAMESPACE::Image                                                                      dstImage_,
      VULKAN_HPP_NAMESPACE::ImageLayout                                                                dstImageLayout_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::ImageBlit2KHR> const & regions_,
      VULKAN_HPP_NAMESPACE::Filter filter_ = VULKAN_HPP_NAMESPACE::Filter::eNearest )
      : srcImage( srcImage_ )
      , srcImageLayout( srcImageLayout_ )
      , dstImage( dstImage_ )
      , dstImageLayout( dstImageLayout_ )
      , regionCount( static_cast<uint32_t>( regions_.size() ) )
      , pRegions( regions_.data() )
      , filter( filter_ )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 BlitImageInfo2KHR &
                            operator=( BlitImageInfo2KHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    BlitImageInfo2KHR & operator=( VkBlitImageInfo2KHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::BlitImageInfo2KHR const *>( &rhs );
      return *this;
    }

    BlitImageInfo2KHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    BlitImageInfo2KHR & setSrcImage( VULKAN_HPP_NAMESPACE::Image srcImage_ ) VULKAN_HPP_NOEXCEPT
    {
      srcImage = srcImage_;
      return *this;
    }

    BlitImageInfo2KHR & setSrcImageLayout( VULKAN_HPP_NAMESPACE::ImageLayout srcImageLayout_ ) VULKAN_HPP_NOEXCEPT
    {
      srcImageLayout = srcImageLayout_;
      return *this;
    }

    BlitImageInfo2KHR & setDstImage( VULKAN_HPP_NAMESPACE::Image dstImage_ ) VULKAN_HPP_NOEXCEPT
    {
      dstImage = dstImage_;
      return *this;
    }

    BlitImageInfo2KHR & setDstImageLayout( VULKAN_HPP_NAMESPACE::ImageLayout dstImageLayout_ ) VULKAN_HPP_NOEXCEPT
    {
      dstImageLayout = dstImageLayout_;
      return *this;
    }

    BlitImageInfo2KHR & setRegionCount( uint32_t regionCount_ ) VULKAN_HPP_NOEXCEPT
    {
      regionCount = regionCount_;
      return *this;
    }

    BlitImageInfo2KHR & setPRegions( const VULKAN_HPP_NAMESPACE::ImageBlit2KHR * pRegions_ ) VULKAN_HPP_NOEXCEPT
    {
      pRegions = pRegions_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    BlitImageInfo2KHR & setRegions(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::ImageBlit2KHR> const & regions_ )
      VULKAN_HPP_NOEXCEPT
    {
      regionCount = static_cast<uint32_t>( regions_.size() );
      pRegions    = regions_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    BlitImageInfo2KHR & setFilter( VULKAN_HPP_NAMESPACE::Filter filter_ ) VULKAN_HPP_NOEXCEPT
    {
      filter = filter_;
      return *this;
    }

    operator VkBlitImageInfo2KHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkBlitImageInfo2KHR *>( this );
    }

    operator VkBlitImageInfo2KHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkBlitImageInfo2KHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( BlitImageInfo2KHR const & ) const = default;
#else
    bool operator==( BlitImageInfo2KHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( srcImage == rhs.srcImage ) &&
             ( srcImageLayout == rhs.srcImageLayout ) && ( dstImage == rhs.dstImage ) &&
             ( dstImageLayout == rhs.dstImageLayout ) && ( regionCount == rhs.regionCount ) &&
             ( pRegions == rhs.pRegions ) && ( filter == rhs.filter );
    }

    bool operator!=( BlitImageInfo2KHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType         sType          = StructureType::eBlitImageInfo2KHR;
    const void *                                pNext          = {};
    VULKAN_HPP_NAMESPACE::Image                 srcImage       = {};
    VULKAN_HPP_NAMESPACE::ImageLayout           srcImageLayout = VULKAN_HPP_NAMESPACE::ImageLayout::eUndefined;
    VULKAN_HPP_NAMESPACE::Image                 dstImage       = {};
    VULKAN_HPP_NAMESPACE::ImageLayout           dstImageLayout = VULKAN_HPP_NAMESPACE::ImageLayout::eUndefined;
    uint32_t                                    regionCount    = {};
    const VULKAN_HPP_NAMESPACE::ImageBlit2KHR * pRegions       = {};
    VULKAN_HPP_NAMESPACE::Filter                filter         = VULKAN_HPP_NAMESPACE::Filter::eNearest;
  };
  static_assert( sizeof( BlitImageInfo2KHR ) == sizeof( VkBlitImageInfo2KHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<BlitImageInfo2KHR>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eBlitImageInfo2KHR>
  {
    using Type = BlitImageInfo2KHR;
  };

  struct BufferCopy
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR BufferCopy( VULKAN_HPP_NAMESPACE::DeviceSize srcOffset_ = {},
                                     VULKAN_HPP_NAMESPACE::DeviceSize dstOffset_ = {},
                                     VULKAN_HPP_NAMESPACE::DeviceSize size_      = {} ) VULKAN_HPP_NOEXCEPT
      : srcOffset( srcOffset_ )
      , dstOffset( dstOffset_ )
      , size( size_ )
    {}

    VULKAN_HPP_CONSTEXPR BufferCopy( BufferCopy const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    BufferCopy( VkBufferCopy const & rhs ) VULKAN_HPP_NOEXCEPT
      : BufferCopy( *reinterpret_cast<BufferCopy const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 BufferCopy & operator=( BufferCopy const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    BufferCopy & operator=( VkBufferCopy const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::BufferCopy const *>( &rhs );
      return *this;
    }

    BufferCopy & setSrcOffset( VULKAN_HPP_NAMESPACE::DeviceSize srcOffset_ ) VULKAN_HPP_NOEXCEPT
    {
      srcOffset = srcOffset_;
      return *this;
    }

    BufferCopy & setDstOffset( VULKAN_HPP_NAMESPACE::DeviceSize dstOffset_ ) VULKAN_HPP_NOEXCEPT
    {
      dstOffset = dstOffset_;
      return *this;
    }

    BufferCopy & setSize( VULKAN_HPP_NAMESPACE::DeviceSize size_ ) VULKAN_HPP_NOEXCEPT
    {
      size = size_;
      return *this;
    }

    operator VkBufferCopy const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkBufferCopy *>( this );
    }

    operator VkBufferCopy &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkBufferCopy *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( BufferCopy const & ) const = default;
#else
    bool operator==( BufferCopy const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( srcOffset == rhs.srcOffset ) && ( dstOffset == rhs.dstOffset ) && ( size == rhs.size );
    }

    bool operator!=( BufferCopy const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::DeviceSize srcOffset = {};
    VULKAN_HPP_NAMESPACE::DeviceSize dstOffset = {};
    VULKAN_HPP_NAMESPACE::DeviceSize size      = {};
  };
  static_assert( sizeof( BufferCopy ) == sizeof( VkBufferCopy ), "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<BufferCopy>::value, "struct wrapper is not a standard layout!" );

  struct BufferCopy2KHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eBufferCopy2KHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR BufferCopy2KHR( VULKAN_HPP_NAMESPACE::DeviceSize srcOffset_ = {},
                                         VULKAN_HPP_NAMESPACE::DeviceSize dstOffset_ = {},
                                         VULKAN_HPP_NAMESPACE::DeviceSize size_      = {} ) VULKAN_HPP_NOEXCEPT
      : srcOffset( srcOffset_ )
      , dstOffset( dstOffset_ )
      , size( size_ )
    {}

    VULKAN_HPP_CONSTEXPR BufferCopy2KHR( BufferCopy2KHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    BufferCopy2KHR( VkBufferCopy2KHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : BufferCopy2KHR( *reinterpret_cast<BufferCopy2KHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 BufferCopy2KHR & operator=( BufferCopy2KHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    BufferCopy2KHR & operator=( VkBufferCopy2KHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::BufferCopy2KHR const *>( &rhs );
      return *this;
    }

    BufferCopy2KHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    BufferCopy2KHR & setSrcOffset( VULKAN_HPP_NAMESPACE::DeviceSize srcOffset_ ) VULKAN_HPP_NOEXCEPT
    {
      srcOffset = srcOffset_;
      return *this;
    }

    BufferCopy2KHR & setDstOffset( VULKAN_HPP_NAMESPACE::DeviceSize dstOffset_ ) VULKAN_HPP_NOEXCEPT
    {
      dstOffset = dstOffset_;
      return *this;
    }

    BufferCopy2KHR & setSize( VULKAN_HPP_NAMESPACE::DeviceSize size_ ) VULKAN_HPP_NOEXCEPT
    {
      size = size_;
      return *this;
    }

    operator VkBufferCopy2KHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkBufferCopy2KHR *>( this );
    }

    operator VkBufferCopy2KHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkBufferCopy2KHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( BufferCopy2KHR const & ) const = default;
#else
    bool operator==( BufferCopy2KHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( srcOffset == rhs.srcOffset ) &&
             ( dstOffset == rhs.dstOffset ) && ( size == rhs.size );
    }

    bool operator!=( BufferCopy2KHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType     = StructureType::eBufferCopy2KHR;
    const void *                        pNext     = {};
    VULKAN_HPP_NAMESPACE::DeviceSize    srcOffset = {};
    VULKAN_HPP_NAMESPACE::DeviceSize    dstOffset = {};
    VULKAN_HPP_NAMESPACE::DeviceSize    size      = {};
  };
  static_assert( sizeof( BufferCopy2KHR ) == sizeof( VkBufferCopy2KHR ), "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<BufferCopy2KHR>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eBufferCopy2KHR>
  {
    using Type = BufferCopy2KHR;
  };

  struct BufferCreateInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eBufferCreateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      BufferCreateInfo( VULKAN_HPP_NAMESPACE::BufferCreateFlags flags_ = {},
                        VULKAN_HPP_NAMESPACE::DeviceSize        size_  = {},
                        VULKAN_HPP_NAMESPACE::BufferUsageFlags  usage_ = {},
                        VULKAN_HPP_NAMESPACE::SharingMode sharingMode_ = VULKAN_HPP_NAMESPACE::SharingMode::eExclusive,
                        uint32_t                          queueFamilyIndexCount_ = {},
                        const uint32_t *                  pQueueFamilyIndices_   = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , size( size_ )
      , usage( usage_ )
      , sharingMode( sharingMode_ )
      , queueFamilyIndexCount( queueFamilyIndexCount_ )
      , pQueueFamilyIndices( pQueueFamilyIndices_ )
    {}

    VULKAN_HPP_CONSTEXPR BufferCreateInfo( BufferCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    BufferCreateInfo( VkBufferCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : BufferCreateInfo( *reinterpret_cast<BufferCreateInfo const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    BufferCreateInfo( VULKAN_HPP_NAMESPACE::BufferCreateFlags                               flags_,
                      VULKAN_HPP_NAMESPACE::DeviceSize                                      size_,
                      VULKAN_HPP_NAMESPACE::BufferUsageFlags                                usage_,
                      VULKAN_HPP_NAMESPACE::SharingMode                                     sharingMode_,
                      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const & queueFamilyIndices_ )
      : flags( flags_ )
      , size( size_ )
      , usage( usage_ )
      , sharingMode( sharingMode_ )
      , queueFamilyIndexCount( static_cast<uint32_t>( queueFamilyIndices_.size() ) )
      , pQueueFamilyIndices( queueFamilyIndices_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 BufferCreateInfo & operator=( BufferCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    BufferCreateInfo & operator=( VkBufferCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::BufferCreateInfo const *>( &rhs );
      return *this;
    }

    BufferCreateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    BufferCreateInfo & setFlags( VULKAN_HPP_NAMESPACE::BufferCreateFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    BufferCreateInfo & setSize( VULKAN_HPP_NAMESPACE::DeviceSize size_ ) VULKAN_HPP_NOEXCEPT
    {
      size = size_;
      return *this;
    }

    BufferCreateInfo & setUsage( VULKAN_HPP_NAMESPACE::BufferUsageFlags usage_ ) VULKAN_HPP_NOEXCEPT
    {
      usage = usage_;
      return *this;
    }

    BufferCreateInfo & setSharingMode( VULKAN_HPP_NAMESPACE::SharingMode sharingMode_ ) VULKAN_HPP_NOEXCEPT
    {
      sharingMode = sharingMode_;
      return *this;
    }

    BufferCreateInfo & setQueueFamilyIndexCount( uint32_t queueFamilyIndexCount_ ) VULKAN_HPP_NOEXCEPT
    {
      queueFamilyIndexCount = queueFamilyIndexCount_;
      return *this;
    }

    BufferCreateInfo & setPQueueFamilyIndices( const uint32_t * pQueueFamilyIndices_ ) VULKAN_HPP_NOEXCEPT
    {
      pQueueFamilyIndices = pQueueFamilyIndices_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    BufferCreateInfo & setQueueFamilyIndices(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const & queueFamilyIndices_ ) VULKAN_HPP_NOEXCEPT
    {
      queueFamilyIndexCount = static_cast<uint32_t>( queueFamilyIndices_.size() );
      pQueueFamilyIndices   = queueFamilyIndices_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkBufferCreateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkBufferCreateInfo *>( this );
    }

    operator VkBufferCreateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkBufferCreateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( BufferCreateInfo const & ) const = default;
#else
    bool operator==( BufferCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) && ( size == rhs.size ) &&
             ( usage == rhs.usage ) && ( sharingMode == rhs.sharingMode ) &&
             ( queueFamilyIndexCount == rhs.queueFamilyIndexCount ) &&
             ( pQueueFamilyIndices == rhs.pQueueFamilyIndices );
    }

    bool operator!=( BufferCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType     sType                 = StructureType::eBufferCreateInfo;
    const void *                            pNext                 = {};
    VULKAN_HPP_NAMESPACE::BufferCreateFlags flags                 = {};
    VULKAN_HPP_NAMESPACE::DeviceSize        size                  = {};
    VULKAN_HPP_NAMESPACE::BufferUsageFlags  usage                 = {};
    VULKAN_HPP_NAMESPACE::SharingMode       sharingMode           = VULKAN_HPP_NAMESPACE::SharingMode::eExclusive;
    uint32_t                                queueFamilyIndexCount = {};
    const uint32_t *                        pQueueFamilyIndices   = {};
  };
  static_assert( sizeof( BufferCreateInfo ) == sizeof( VkBufferCreateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<BufferCreateInfo>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eBufferCreateInfo>
  {
    using Type = BufferCreateInfo;
  };

  struct BufferDeviceAddressCreateInfoEXT
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eBufferDeviceAddressCreateInfoEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      BufferDeviceAddressCreateInfoEXT( VULKAN_HPP_NAMESPACE::DeviceAddress deviceAddress_ = {} ) VULKAN_HPP_NOEXCEPT
      : deviceAddress( deviceAddress_ )
    {}

    VULKAN_HPP_CONSTEXPR
      BufferDeviceAddressCreateInfoEXT( BufferDeviceAddressCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    BufferDeviceAddressCreateInfoEXT( VkBufferDeviceAddressCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : BufferDeviceAddressCreateInfoEXT( *reinterpret_cast<BufferDeviceAddressCreateInfoEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 BufferDeviceAddressCreateInfoEXT &
                            operator=( BufferDeviceAddressCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    BufferDeviceAddressCreateInfoEXT & operator=( VkBufferDeviceAddressCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::BufferDeviceAddressCreateInfoEXT const *>( &rhs );
      return *this;
    }

    BufferDeviceAddressCreateInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    BufferDeviceAddressCreateInfoEXT &
      setDeviceAddress( VULKAN_HPP_NAMESPACE::DeviceAddress deviceAddress_ ) VULKAN_HPP_NOEXCEPT
    {
      deviceAddress = deviceAddress_;
      return *this;
    }

    operator VkBufferDeviceAddressCreateInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkBufferDeviceAddressCreateInfoEXT *>( this );
    }

    operator VkBufferDeviceAddressCreateInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkBufferDeviceAddressCreateInfoEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( BufferDeviceAddressCreateInfoEXT const & ) const = default;
#else
    bool operator==( BufferDeviceAddressCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( deviceAddress == rhs.deviceAddress );
    }

    bool operator!=( BufferDeviceAddressCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType         = StructureType::eBufferDeviceAddressCreateInfoEXT;
    const void *                        pNext         = {};
    VULKAN_HPP_NAMESPACE::DeviceAddress deviceAddress = {};
  };
  static_assert( sizeof( BufferDeviceAddressCreateInfoEXT ) == sizeof( VkBufferDeviceAddressCreateInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<BufferDeviceAddressCreateInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eBufferDeviceAddressCreateInfoEXT>
  {
    using Type = BufferDeviceAddressCreateInfoEXT;
  };

  struct BufferDeviceAddressInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eBufferDeviceAddressInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR BufferDeviceAddressInfo( VULKAN_HPP_NAMESPACE::Buffer buffer_ = {} ) VULKAN_HPP_NOEXCEPT
      : buffer( buffer_ )
    {}

    VULKAN_HPP_CONSTEXPR BufferDeviceAddressInfo( BufferDeviceAddressInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    BufferDeviceAddressInfo( VkBufferDeviceAddressInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : BufferDeviceAddressInfo( *reinterpret_cast<BufferDeviceAddressInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 BufferDeviceAddressInfo &
                            operator=( BufferDeviceAddressInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    BufferDeviceAddressInfo & operator=( VkBufferDeviceAddressInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::BufferDeviceAddressInfo const *>( &rhs );
      return *this;
    }

    BufferDeviceAddressInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    BufferDeviceAddressInfo & setBuffer( VULKAN_HPP_NAMESPACE::Buffer buffer_ ) VULKAN_HPP_NOEXCEPT
    {
      buffer = buffer_;
      return *this;
    }

    operator VkBufferDeviceAddressInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkBufferDeviceAddressInfo *>( this );
    }

    operator VkBufferDeviceAddressInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkBufferDeviceAddressInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( BufferDeviceAddressInfo const & ) const = default;
#else
    bool operator==( BufferDeviceAddressInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( buffer == rhs.buffer );
    }

    bool operator!=( BufferDeviceAddressInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType  = StructureType::eBufferDeviceAddressInfo;
    const void *                        pNext  = {};
    VULKAN_HPP_NAMESPACE::Buffer        buffer = {};
  };
  static_assert( sizeof( BufferDeviceAddressInfo ) == sizeof( VkBufferDeviceAddressInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<BufferDeviceAddressInfo>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eBufferDeviceAddressInfo>
  {
    using Type = BufferDeviceAddressInfo;
  };
  using BufferDeviceAddressInfoEXT = BufferDeviceAddressInfo;
  using BufferDeviceAddressInfoKHR = BufferDeviceAddressInfo;

  struct BufferImageCopy
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR BufferImageCopy( VULKAN_HPP_NAMESPACE::DeviceSize             bufferOffset_      = {},
                                          uint32_t                                     bufferRowLength_   = {},
                                          uint32_t                                     bufferImageHeight_ = {},
                                          VULKAN_HPP_NAMESPACE::ImageSubresourceLayers imageSubresource_  = {},
                                          VULKAN_HPP_NAMESPACE::Offset3D               imageOffset_       = {},
                                          VULKAN_HPP_NAMESPACE::Extent3D imageExtent_ = {} ) VULKAN_HPP_NOEXCEPT
      : bufferOffset( bufferOffset_ )
      , bufferRowLength( bufferRowLength_ )
      , bufferImageHeight( bufferImageHeight_ )
      , imageSubresource( imageSubresource_ )
      , imageOffset( imageOffset_ )
      , imageExtent( imageExtent_ )
    {}

    VULKAN_HPP_CONSTEXPR BufferImageCopy( BufferImageCopy const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    BufferImageCopy( VkBufferImageCopy const & rhs ) VULKAN_HPP_NOEXCEPT
      : BufferImageCopy( *reinterpret_cast<BufferImageCopy const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 BufferImageCopy & operator=( BufferImageCopy const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    BufferImageCopy & operator=( VkBufferImageCopy const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::BufferImageCopy const *>( &rhs );
      return *this;
    }

    BufferImageCopy & setBufferOffset( VULKAN_HPP_NAMESPACE::DeviceSize bufferOffset_ ) VULKAN_HPP_NOEXCEPT
    {
      bufferOffset = bufferOffset_;
      return *this;
    }

    BufferImageCopy & setBufferRowLength( uint32_t bufferRowLength_ ) VULKAN_HPP_NOEXCEPT
    {
      bufferRowLength = bufferRowLength_;
      return *this;
    }

    BufferImageCopy & setBufferImageHeight( uint32_t bufferImageHeight_ ) VULKAN_HPP_NOEXCEPT
    {
      bufferImageHeight = bufferImageHeight_;
      return *this;
    }

    BufferImageCopy &
      setImageSubresource( VULKAN_HPP_NAMESPACE::ImageSubresourceLayers const & imageSubresource_ ) VULKAN_HPP_NOEXCEPT
    {
      imageSubresource = imageSubresource_;
      return *this;
    }

    BufferImageCopy & setImageOffset( VULKAN_HPP_NAMESPACE::Offset3D const & imageOffset_ ) VULKAN_HPP_NOEXCEPT
    {
      imageOffset = imageOffset_;
      return *this;
    }

    BufferImageCopy & setImageExtent( VULKAN_HPP_NAMESPACE::Extent3D const & imageExtent_ ) VULKAN_HPP_NOEXCEPT
    {
      imageExtent = imageExtent_;
      return *this;
    }

    operator VkBufferImageCopy const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkBufferImageCopy *>( this );
    }

    operator VkBufferImageCopy &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkBufferImageCopy *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( BufferImageCopy const & ) const = default;
#else
    bool operator==( BufferImageCopy const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( bufferOffset == rhs.bufferOffset ) && ( bufferRowLength == rhs.bufferRowLength ) &&
             ( bufferImageHeight == rhs.bufferImageHeight ) && ( imageSubresource == rhs.imageSubresource ) &&
             ( imageOffset == rhs.imageOffset ) && ( imageExtent == rhs.imageExtent );
    }

    bool operator!=( BufferImageCopy const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::DeviceSize             bufferOffset      = {};
    uint32_t                                     bufferRowLength   = {};
    uint32_t                                     bufferImageHeight = {};
    VULKAN_HPP_NAMESPACE::ImageSubresourceLayers imageSubresource  = {};
    VULKAN_HPP_NAMESPACE::Offset3D               imageOffset       = {};
    VULKAN_HPP_NAMESPACE::Extent3D               imageExtent       = {};
  };
  static_assert( sizeof( BufferImageCopy ) == sizeof( VkBufferImageCopy ), "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<BufferImageCopy>::value, "struct wrapper is not a standard layout!" );

  struct BufferImageCopy2KHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eBufferImageCopy2KHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR BufferImageCopy2KHR( VULKAN_HPP_NAMESPACE::DeviceSize             bufferOffset_      = {},
                                              uint32_t                                     bufferRowLength_   = {},
                                              uint32_t                                     bufferImageHeight_ = {},
                                              VULKAN_HPP_NAMESPACE::ImageSubresourceLayers imageSubresource_  = {},
                                              VULKAN_HPP_NAMESPACE::Offset3D               imageOffset_       = {},
                                              VULKAN_HPP_NAMESPACE::Extent3D imageExtent_ = {} ) VULKAN_HPP_NOEXCEPT
      : bufferOffset( bufferOffset_ )
      , bufferRowLength( bufferRowLength_ )
      , bufferImageHeight( bufferImageHeight_ )
      , imageSubresource( imageSubresource_ )
      , imageOffset( imageOffset_ )
      , imageExtent( imageExtent_ )
    {}

    VULKAN_HPP_CONSTEXPR BufferImageCopy2KHR( BufferImageCopy2KHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    BufferImageCopy2KHR( VkBufferImageCopy2KHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : BufferImageCopy2KHR( *reinterpret_cast<BufferImageCopy2KHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 BufferImageCopy2KHR &
                            operator=( BufferImageCopy2KHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    BufferImageCopy2KHR & operator=( VkBufferImageCopy2KHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::BufferImageCopy2KHR const *>( &rhs );
      return *this;
    }

    BufferImageCopy2KHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    BufferImageCopy2KHR & setBufferOffset( VULKAN_HPP_NAMESPACE::DeviceSize bufferOffset_ ) VULKAN_HPP_NOEXCEPT
    {
      bufferOffset = bufferOffset_;
      return *this;
    }

    BufferImageCopy2KHR & setBufferRowLength( uint32_t bufferRowLength_ ) VULKAN_HPP_NOEXCEPT
    {
      bufferRowLength = bufferRowLength_;
      return *this;
    }

    BufferImageCopy2KHR & setBufferImageHeight( uint32_t bufferImageHeight_ ) VULKAN_HPP_NOEXCEPT
    {
      bufferImageHeight = bufferImageHeight_;
      return *this;
    }

    BufferImageCopy2KHR &
      setImageSubresource( VULKAN_HPP_NAMESPACE::ImageSubresourceLayers const & imageSubresource_ ) VULKAN_HPP_NOEXCEPT
    {
      imageSubresource = imageSubresource_;
      return *this;
    }

    BufferImageCopy2KHR & setImageOffset( VULKAN_HPP_NAMESPACE::Offset3D const & imageOffset_ ) VULKAN_HPP_NOEXCEPT
    {
      imageOffset = imageOffset_;
      return *this;
    }

    BufferImageCopy2KHR & setImageExtent( VULKAN_HPP_NAMESPACE::Extent3D const & imageExtent_ ) VULKAN_HPP_NOEXCEPT
    {
      imageExtent = imageExtent_;
      return *this;
    }

    operator VkBufferImageCopy2KHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkBufferImageCopy2KHR *>( this );
    }

    operator VkBufferImageCopy2KHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkBufferImageCopy2KHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( BufferImageCopy2KHR const & ) const = default;
#else
    bool operator==( BufferImageCopy2KHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( bufferOffset == rhs.bufferOffset ) &&
             ( bufferRowLength == rhs.bufferRowLength ) && ( bufferImageHeight == rhs.bufferImageHeight ) &&
             ( imageSubresource == rhs.imageSubresource ) && ( imageOffset == rhs.imageOffset ) &&
             ( imageExtent == rhs.imageExtent );
    }

    bool operator!=( BufferImageCopy2KHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType          sType             = StructureType::eBufferImageCopy2KHR;
    const void *                                 pNext             = {};
    VULKAN_HPP_NAMESPACE::DeviceSize             bufferOffset      = {};
    uint32_t                                     bufferRowLength   = {};
    uint32_t                                     bufferImageHeight = {};
    VULKAN_HPP_NAMESPACE::ImageSubresourceLayers imageSubresource  = {};
    VULKAN_HPP_NAMESPACE::Offset3D               imageOffset       = {};
    VULKAN_HPP_NAMESPACE::Extent3D               imageExtent       = {};
  };
  static_assert( sizeof( BufferImageCopy2KHR ) == sizeof( VkBufferImageCopy2KHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<BufferImageCopy2KHR>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eBufferImageCopy2KHR>
  {
    using Type = BufferImageCopy2KHR;
  };

  struct BufferMemoryBarrier
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eBufferMemoryBarrier;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR BufferMemoryBarrier( VULKAN_HPP_NAMESPACE::AccessFlags srcAccessMask_       = {},
                                              VULKAN_HPP_NAMESPACE::AccessFlags dstAccessMask_       = {},
                                              uint32_t                          srcQueueFamilyIndex_ = {},
                                              uint32_t                          dstQueueFamilyIndex_ = {},
                                              VULKAN_HPP_NAMESPACE::Buffer      buffer_              = {},
                                              VULKAN_HPP_NAMESPACE::DeviceSize  offset_              = {},
                                              VULKAN_HPP_NAMESPACE::DeviceSize  size_ = {} ) VULKAN_HPP_NOEXCEPT
      : srcAccessMask( srcAccessMask_ )
      , dstAccessMask( dstAccessMask_ )
      , srcQueueFamilyIndex( srcQueueFamilyIndex_ )
      , dstQueueFamilyIndex( dstQueueFamilyIndex_ )
      , buffer( buffer_ )
      , offset( offset_ )
      , size( size_ )
    {}

    VULKAN_HPP_CONSTEXPR BufferMemoryBarrier( BufferMemoryBarrier const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    BufferMemoryBarrier( VkBufferMemoryBarrier const & rhs ) VULKAN_HPP_NOEXCEPT
      : BufferMemoryBarrier( *reinterpret_cast<BufferMemoryBarrier const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 BufferMemoryBarrier &
                            operator=( BufferMemoryBarrier const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    BufferMemoryBarrier & operator=( VkBufferMemoryBarrier const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::BufferMemoryBarrier const *>( &rhs );
      return *this;
    }

    BufferMemoryBarrier & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    BufferMemoryBarrier & setSrcAccessMask( VULKAN_HPP_NAMESPACE::AccessFlags srcAccessMask_ ) VULKAN_HPP_NOEXCEPT
    {
      srcAccessMask = srcAccessMask_;
      return *this;
    }

    BufferMemoryBarrier & setDstAccessMask( VULKAN_HPP_NAMESPACE::AccessFlags dstAccessMask_ ) VULKAN_HPP_NOEXCEPT
    {
      dstAccessMask = dstAccessMask_;
      return *this;
    }

    BufferMemoryBarrier & setSrcQueueFamilyIndex( uint32_t srcQueueFamilyIndex_ ) VULKAN_HPP_NOEXCEPT
    {
      srcQueueFamilyIndex = srcQueueFamilyIndex_;
      return *this;
    }

    BufferMemoryBarrier & setDstQueueFamilyIndex( uint32_t dstQueueFamilyIndex_ ) VULKAN_HPP_NOEXCEPT
    {
      dstQueueFamilyIndex = dstQueueFamilyIndex_;
      return *this;
    }

    BufferMemoryBarrier & setBuffer( VULKAN_HPP_NAMESPACE::Buffer buffer_ ) VULKAN_HPP_NOEXCEPT
    {
      buffer = buffer_;
      return *this;
    }

    BufferMemoryBarrier & setOffset( VULKAN_HPP_NAMESPACE::DeviceSize offset_ ) VULKAN_HPP_NOEXCEPT
    {
      offset = offset_;
      return *this;
    }

    BufferMemoryBarrier & setSize( VULKAN_HPP_NAMESPACE::DeviceSize size_ ) VULKAN_HPP_NOEXCEPT
    {
      size = size_;
      return *this;
    }

    operator VkBufferMemoryBarrier const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkBufferMemoryBarrier *>( this );
    }

    operator VkBufferMemoryBarrier &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkBufferMemoryBarrier *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( BufferMemoryBarrier const & ) const = default;
#else
    bool operator==( BufferMemoryBarrier const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( srcAccessMask == rhs.srcAccessMask ) &&
             ( dstAccessMask == rhs.dstAccessMask ) && ( srcQueueFamilyIndex == rhs.srcQueueFamilyIndex ) &&
             ( dstQueueFamilyIndex == rhs.dstQueueFamilyIndex ) && ( buffer == rhs.buffer ) &&
             ( offset == rhs.offset ) && ( size == rhs.size );
    }

    bool operator!=( BufferMemoryBarrier const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType               = StructureType::eBufferMemoryBarrier;
    const void *                        pNext               = {};
    VULKAN_HPP_NAMESPACE::AccessFlags   srcAccessMask       = {};
    VULKAN_HPP_NAMESPACE::AccessFlags   dstAccessMask       = {};
    uint32_t                            srcQueueFamilyIndex = {};
    uint32_t                            dstQueueFamilyIndex = {};
    VULKAN_HPP_NAMESPACE::Buffer        buffer              = {};
    VULKAN_HPP_NAMESPACE::DeviceSize    offset              = {};
    VULKAN_HPP_NAMESPACE::DeviceSize    size                = {};
  };
  static_assert( sizeof( BufferMemoryBarrier ) == sizeof( VkBufferMemoryBarrier ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<BufferMemoryBarrier>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eBufferMemoryBarrier>
  {
    using Type = BufferMemoryBarrier;
  };

  struct BufferMemoryBarrier2KHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eBufferMemoryBarrier2KHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR BufferMemoryBarrier2KHR( VULKAN_HPP_NAMESPACE::PipelineStageFlags2KHR srcStageMask_  = {},
                                                  VULKAN_HPP_NAMESPACE::AccessFlags2KHR        srcAccessMask_ = {},
                                                  VULKAN_HPP_NAMESPACE::PipelineStageFlags2KHR dstStageMask_  = {},
                                                  VULKAN_HPP_NAMESPACE::AccessFlags2KHR        dstAccessMask_ = {},
                                                  uint32_t                         srcQueueFamilyIndex_       = {},
                                                  uint32_t                         dstQueueFamilyIndex_       = {},
                                                  VULKAN_HPP_NAMESPACE::Buffer     buffer_                    = {},
                                                  VULKAN_HPP_NAMESPACE::DeviceSize offset_                    = {},
                                                  VULKAN_HPP_NAMESPACE::DeviceSize size_ = {} ) VULKAN_HPP_NOEXCEPT
      : srcStageMask( srcStageMask_ )
      , srcAccessMask( srcAccessMask_ )
      , dstStageMask( dstStageMask_ )
      , dstAccessMask( dstAccessMask_ )
      , srcQueueFamilyIndex( srcQueueFamilyIndex_ )
      , dstQueueFamilyIndex( dstQueueFamilyIndex_ )
      , buffer( buffer_ )
      , offset( offset_ )
      , size( size_ )
    {}

    VULKAN_HPP_CONSTEXPR BufferMemoryBarrier2KHR( BufferMemoryBarrier2KHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    BufferMemoryBarrier2KHR( VkBufferMemoryBarrier2KHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : BufferMemoryBarrier2KHR( *reinterpret_cast<BufferMemoryBarrier2KHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 BufferMemoryBarrier2KHR &
                            operator=( BufferMemoryBarrier2KHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    BufferMemoryBarrier2KHR & operator=( VkBufferMemoryBarrier2KHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::BufferMemoryBarrier2KHR const *>( &rhs );
      return *this;
    }

    BufferMemoryBarrier2KHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    BufferMemoryBarrier2KHR &
      setSrcStageMask( VULKAN_HPP_NAMESPACE::PipelineStageFlags2KHR srcStageMask_ ) VULKAN_HPP_NOEXCEPT
    {
      srcStageMask = srcStageMask_;
      return *this;
    }

    BufferMemoryBarrier2KHR &
      setSrcAccessMask( VULKAN_HPP_NAMESPACE::AccessFlags2KHR srcAccessMask_ ) VULKAN_HPP_NOEXCEPT
    {
      srcAccessMask = srcAccessMask_;
      return *this;
    }

    BufferMemoryBarrier2KHR &
      setDstStageMask( VULKAN_HPP_NAMESPACE::PipelineStageFlags2KHR dstStageMask_ ) VULKAN_HPP_NOEXCEPT
    {
      dstStageMask = dstStageMask_;
      return *this;
    }

    BufferMemoryBarrier2KHR &
      setDstAccessMask( VULKAN_HPP_NAMESPACE::AccessFlags2KHR dstAccessMask_ ) VULKAN_HPP_NOEXCEPT
    {
      dstAccessMask = dstAccessMask_;
      return *this;
    }

    BufferMemoryBarrier2KHR & setSrcQueueFamilyIndex( uint32_t srcQueueFamilyIndex_ ) VULKAN_HPP_NOEXCEPT
    {
      srcQueueFamilyIndex = srcQueueFamilyIndex_;
      return *this;
    }

    BufferMemoryBarrier2KHR & setDstQueueFamilyIndex( uint32_t dstQueueFamilyIndex_ ) VULKAN_HPP_NOEXCEPT
    {
      dstQueueFamilyIndex = dstQueueFamilyIndex_;
      return *this;
    }

    BufferMemoryBarrier2KHR & setBuffer( VULKAN_HPP_NAMESPACE::Buffer buffer_ ) VULKAN_HPP_NOEXCEPT
    {
      buffer = buffer_;
      return *this;
    }

    BufferMemoryBarrier2KHR & setOffset( VULKAN_HPP_NAMESPACE::DeviceSize offset_ ) VULKAN_HPP_NOEXCEPT
    {
      offset = offset_;
      return *this;
    }

    BufferMemoryBarrier2KHR & setSize( VULKAN_HPP_NAMESPACE::DeviceSize size_ ) VULKAN_HPP_NOEXCEPT
    {
      size = size_;
      return *this;
    }

    operator VkBufferMemoryBarrier2KHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkBufferMemoryBarrier2KHR *>( this );
    }

    operator VkBufferMemoryBarrier2KHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkBufferMemoryBarrier2KHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( BufferMemoryBarrier2KHR const & ) const = default;
#else
    bool operator==( BufferMemoryBarrier2KHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( srcStageMask == rhs.srcStageMask ) &&
             ( srcAccessMask == rhs.srcAccessMask ) && ( dstStageMask == rhs.dstStageMask ) &&
             ( dstAccessMask == rhs.dstAccessMask ) && ( srcQueueFamilyIndex == rhs.srcQueueFamilyIndex ) &&
             ( dstQueueFamilyIndex == rhs.dstQueueFamilyIndex ) && ( buffer == rhs.buffer ) &&
             ( offset == rhs.offset ) && ( size == rhs.size );
    }

    bool operator!=( BufferMemoryBarrier2KHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType          sType               = StructureType::eBufferMemoryBarrier2KHR;
    const void *                                 pNext               = {};
    VULKAN_HPP_NAMESPACE::PipelineStageFlags2KHR srcStageMask        = {};
    VULKAN_HPP_NAMESPACE::AccessFlags2KHR        srcAccessMask       = {};
    VULKAN_HPP_NAMESPACE::PipelineStageFlags2KHR dstStageMask        = {};
    VULKAN_HPP_NAMESPACE::AccessFlags2KHR        dstAccessMask       = {};
    uint32_t                                     srcQueueFamilyIndex = {};
    uint32_t                                     dstQueueFamilyIndex = {};
    VULKAN_HPP_NAMESPACE::Buffer                 buffer              = {};
    VULKAN_HPP_NAMESPACE::DeviceSize             offset              = {};
    VULKAN_HPP_NAMESPACE::DeviceSize             size                = {};
  };
  static_assert( sizeof( BufferMemoryBarrier2KHR ) == sizeof( VkBufferMemoryBarrier2KHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<BufferMemoryBarrier2KHR>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eBufferMemoryBarrier2KHR>
  {
    using Type = BufferMemoryBarrier2KHR;
  };

  struct BufferMemoryRequirementsInfo2
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eBufferMemoryRequirementsInfo2;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR BufferMemoryRequirementsInfo2( VULKAN_HPP_NAMESPACE::Buffer buffer_ = {} ) VULKAN_HPP_NOEXCEPT
      : buffer( buffer_ )
    {}

    VULKAN_HPP_CONSTEXPR
      BufferMemoryRequirementsInfo2( BufferMemoryRequirementsInfo2 const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    BufferMemoryRequirementsInfo2( VkBufferMemoryRequirementsInfo2 const & rhs ) VULKAN_HPP_NOEXCEPT
      : BufferMemoryRequirementsInfo2( *reinterpret_cast<BufferMemoryRequirementsInfo2 const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 BufferMemoryRequirementsInfo2 &
                            operator=( BufferMemoryRequirementsInfo2 const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    BufferMemoryRequirementsInfo2 & operator=( VkBufferMemoryRequirementsInfo2 const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::BufferMemoryRequirementsInfo2 const *>( &rhs );
      return *this;
    }

    BufferMemoryRequirementsInfo2 & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    BufferMemoryRequirementsInfo2 & setBuffer( VULKAN_HPP_NAMESPACE::Buffer buffer_ ) VULKAN_HPP_NOEXCEPT
    {
      buffer = buffer_;
      return *this;
    }

    operator VkBufferMemoryRequirementsInfo2 const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkBufferMemoryRequirementsInfo2 *>( this );
    }

    operator VkBufferMemoryRequirementsInfo2 &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkBufferMemoryRequirementsInfo2 *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( BufferMemoryRequirementsInfo2 const & ) const = default;
#else
    bool operator==( BufferMemoryRequirementsInfo2 const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( buffer == rhs.buffer );
    }

    bool operator!=( BufferMemoryRequirementsInfo2 const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType  = StructureType::eBufferMemoryRequirementsInfo2;
    const void *                        pNext  = {};
    VULKAN_HPP_NAMESPACE::Buffer        buffer = {};
  };
  static_assert( sizeof( BufferMemoryRequirementsInfo2 ) == sizeof( VkBufferMemoryRequirementsInfo2 ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<BufferMemoryRequirementsInfo2>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eBufferMemoryRequirementsInfo2>
  {
    using Type = BufferMemoryRequirementsInfo2;
  };
  using BufferMemoryRequirementsInfo2KHR = BufferMemoryRequirementsInfo2;

  struct BufferOpaqueCaptureAddressCreateInfo
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eBufferOpaqueCaptureAddressCreateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR BufferOpaqueCaptureAddressCreateInfo( uint64_t opaqueCaptureAddress_ = {} ) VULKAN_HPP_NOEXCEPT
      : opaqueCaptureAddress( opaqueCaptureAddress_ )
    {}

    VULKAN_HPP_CONSTEXPR BufferOpaqueCaptureAddressCreateInfo( BufferOpaqueCaptureAddressCreateInfo const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    BufferOpaqueCaptureAddressCreateInfo( VkBufferOpaqueCaptureAddressCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : BufferOpaqueCaptureAddressCreateInfo( *reinterpret_cast<BufferOpaqueCaptureAddressCreateInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 BufferOpaqueCaptureAddressCreateInfo &
                            operator=( BufferOpaqueCaptureAddressCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    BufferOpaqueCaptureAddressCreateInfo &
      operator=( VkBufferOpaqueCaptureAddressCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::BufferOpaqueCaptureAddressCreateInfo const *>( &rhs );
      return *this;
    }

    BufferOpaqueCaptureAddressCreateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    BufferOpaqueCaptureAddressCreateInfo & setOpaqueCaptureAddress( uint64_t opaqueCaptureAddress_ ) VULKAN_HPP_NOEXCEPT
    {
      opaqueCaptureAddress = opaqueCaptureAddress_;
      return *this;
    }

    operator VkBufferOpaqueCaptureAddressCreateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkBufferOpaqueCaptureAddressCreateInfo *>( this );
    }

    operator VkBufferOpaqueCaptureAddressCreateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkBufferOpaqueCaptureAddressCreateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( BufferOpaqueCaptureAddressCreateInfo const & ) const = default;
#else
    bool operator==( BufferOpaqueCaptureAddressCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( opaqueCaptureAddress == rhs.opaqueCaptureAddress );
    }

    bool operator!=( BufferOpaqueCaptureAddressCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType                = StructureType::eBufferOpaqueCaptureAddressCreateInfo;
    const void *                        pNext                = {};
    uint64_t                            opaqueCaptureAddress = {};
  };
  static_assert( sizeof( BufferOpaqueCaptureAddressCreateInfo ) == sizeof( VkBufferOpaqueCaptureAddressCreateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<BufferOpaqueCaptureAddressCreateInfo>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eBufferOpaqueCaptureAddressCreateInfo>
  {
    using Type = BufferOpaqueCaptureAddressCreateInfo;
  };
  using BufferOpaqueCaptureAddressCreateInfoKHR = BufferOpaqueCaptureAddressCreateInfo;

  struct BufferViewCreateInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eBufferViewCreateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      BufferViewCreateInfo( VULKAN_HPP_NAMESPACE::BufferViewCreateFlags flags_  = {},
                            VULKAN_HPP_NAMESPACE::Buffer                buffer_ = {},
                            VULKAN_HPP_NAMESPACE::Format     format_ = VULKAN_HPP_NAMESPACE::Format::eUndefined,
                            VULKAN_HPP_NAMESPACE::DeviceSize offset_ = {},
                            VULKAN_HPP_NAMESPACE::DeviceSize range_  = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , buffer( buffer_ )
      , format( format_ )
      , offset( offset_ )
      , range( range_ )
    {}

    VULKAN_HPP_CONSTEXPR BufferViewCreateInfo( BufferViewCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    BufferViewCreateInfo( VkBufferViewCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : BufferViewCreateInfo( *reinterpret_cast<BufferViewCreateInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 BufferViewCreateInfo &
                            operator=( BufferViewCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    BufferViewCreateInfo & operator=( VkBufferViewCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::BufferViewCreateInfo const *>( &rhs );
      return *this;
    }

    BufferViewCreateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    BufferViewCreateInfo & setFlags( VULKAN_HPP_NAMESPACE::BufferViewCreateFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    BufferViewCreateInfo & setBuffer( VULKAN_HPP_NAMESPACE::Buffer buffer_ ) VULKAN_HPP_NOEXCEPT
    {
      buffer = buffer_;
      return *this;
    }

    BufferViewCreateInfo & setFormat( VULKAN_HPP_NAMESPACE::Format format_ ) VULKAN_HPP_NOEXCEPT
    {
      format = format_;
      return *this;
    }

    BufferViewCreateInfo & setOffset( VULKAN_HPP_NAMESPACE::DeviceSize offset_ ) VULKAN_HPP_NOEXCEPT
    {
      offset = offset_;
      return *this;
    }

    BufferViewCreateInfo & setRange( VULKAN_HPP_NAMESPACE::DeviceSize range_ ) VULKAN_HPP_NOEXCEPT
    {
      range = range_;
      return *this;
    }

    operator VkBufferViewCreateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkBufferViewCreateInfo *>( this );
    }

    operator VkBufferViewCreateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkBufferViewCreateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( BufferViewCreateInfo const & ) const = default;
#else
    bool operator==( BufferViewCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) && ( buffer == rhs.buffer ) &&
             ( format == rhs.format ) && ( offset == rhs.offset ) && ( range == rhs.range );
    }

    bool operator!=( BufferViewCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType         sType  = StructureType::eBufferViewCreateInfo;
    const void *                                pNext  = {};
    VULKAN_HPP_NAMESPACE::BufferViewCreateFlags flags  = {};
    VULKAN_HPP_NAMESPACE::Buffer                buffer = {};
    VULKAN_HPP_NAMESPACE::Format                format = VULKAN_HPP_NAMESPACE::Format::eUndefined;
    VULKAN_HPP_NAMESPACE::DeviceSize            offset = {};
    VULKAN_HPP_NAMESPACE::DeviceSize            range  = {};
  };
  static_assert( sizeof( BufferViewCreateInfo ) == sizeof( VkBufferViewCreateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<BufferViewCreateInfo>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eBufferViewCreateInfo>
  {
    using Type = BufferViewCreateInfo;
  };

  struct CalibratedTimestampInfoEXT
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eCalibratedTimestampInfoEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      CalibratedTimestampInfoEXT( VULKAN_HPP_NAMESPACE::TimeDomainEXT timeDomain_ =
                                    VULKAN_HPP_NAMESPACE::TimeDomainEXT::eDevice ) VULKAN_HPP_NOEXCEPT
      : timeDomain( timeDomain_ )
    {}

    VULKAN_HPP_CONSTEXPR
      CalibratedTimestampInfoEXT( CalibratedTimestampInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    CalibratedTimestampInfoEXT( VkCalibratedTimestampInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : CalibratedTimestampInfoEXT( *reinterpret_cast<CalibratedTimestampInfoEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 CalibratedTimestampInfoEXT &
                            operator=( CalibratedTimestampInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    CalibratedTimestampInfoEXT & operator=( VkCalibratedTimestampInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::CalibratedTimestampInfoEXT const *>( &rhs );
      return *this;
    }

    CalibratedTimestampInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    CalibratedTimestampInfoEXT & setTimeDomain( VULKAN_HPP_NAMESPACE::TimeDomainEXT timeDomain_ ) VULKAN_HPP_NOEXCEPT
    {
      timeDomain = timeDomain_;
      return *this;
    }

    operator VkCalibratedTimestampInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkCalibratedTimestampInfoEXT *>( this );
    }

    operator VkCalibratedTimestampInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkCalibratedTimestampInfoEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( CalibratedTimestampInfoEXT const & ) const = default;
#else
    bool operator==( CalibratedTimestampInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( timeDomain == rhs.timeDomain );
    }

    bool operator!=( CalibratedTimestampInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType      = StructureType::eCalibratedTimestampInfoEXT;
    const void *                        pNext      = {};
    VULKAN_HPP_NAMESPACE::TimeDomainEXT timeDomain = VULKAN_HPP_NAMESPACE::TimeDomainEXT::eDevice;
  };
  static_assert( sizeof( CalibratedTimestampInfoEXT ) == sizeof( VkCalibratedTimestampInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<CalibratedTimestampInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eCalibratedTimestampInfoEXT>
  {
    using Type = CalibratedTimestampInfoEXT;
  };

  struct CheckpointData2NV
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eCheckpointData2NV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR CheckpointData2NV( VULKAN_HPP_NAMESPACE::PipelineStageFlags2KHR stage_ = {},
                                            void * pCheckpointMarker_ = {} ) VULKAN_HPP_NOEXCEPT
      : stage( stage_ )
      , pCheckpointMarker( pCheckpointMarker_ )
    {}

    VULKAN_HPP_CONSTEXPR CheckpointData2NV( CheckpointData2NV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    CheckpointData2NV( VkCheckpointData2NV const & rhs ) VULKAN_HPP_NOEXCEPT
      : CheckpointData2NV( *reinterpret_cast<CheckpointData2NV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 CheckpointData2NV &
                            operator=( CheckpointData2NV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    CheckpointData2NV & operator=( VkCheckpointData2NV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::CheckpointData2NV const *>( &rhs );
      return *this;
    }

    operator VkCheckpointData2NV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkCheckpointData2NV *>( this );
    }

    operator VkCheckpointData2NV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkCheckpointData2NV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( CheckpointData2NV const & ) const = default;
#else
    bool operator==( CheckpointData2NV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( stage == rhs.stage ) &&
             ( pCheckpointMarker == rhs.pCheckpointMarker );
    }

    bool operator!=( CheckpointData2NV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType          sType             = StructureType::eCheckpointData2NV;
    void *                                       pNext             = {};
    VULKAN_HPP_NAMESPACE::PipelineStageFlags2KHR stage             = {};
    void *                                       pCheckpointMarker = {};
  };
  static_assert( sizeof( CheckpointData2NV ) == sizeof( VkCheckpointData2NV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<CheckpointData2NV>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eCheckpointData2NV>
  {
    using Type = CheckpointData2NV;
  };

  struct CheckpointDataNV
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eCheckpointDataNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR CheckpointDataNV(
      VULKAN_HPP_NAMESPACE::PipelineStageFlagBits stage_ = VULKAN_HPP_NAMESPACE::PipelineStageFlagBits::eTopOfPipe,
      void *                                      pCheckpointMarker_ = {} ) VULKAN_HPP_NOEXCEPT
      : stage( stage_ )
      , pCheckpointMarker( pCheckpointMarker_ )
    {}

    VULKAN_HPP_CONSTEXPR CheckpointDataNV( CheckpointDataNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    CheckpointDataNV( VkCheckpointDataNV const & rhs ) VULKAN_HPP_NOEXCEPT
      : CheckpointDataNV( *reinterpret_cast<CheckpointDataNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 CheckpointDataNV & operator=( CheckpointDataNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    CheckpointDataNV & operator=( VkCheckpointDataNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::CheckpointDataNV const *>( &rhs );
      return *this;
    }

    operator VkCheckpointDataNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkCheckpointDataNV *>( this );
    }

    operator VkCheckpointDataNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkCheckpointDataNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( CheckpointDataNV const & ) const = default;
#else
    bool operator==( CheckpointDataNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( stage == rhs.stage ) &&
             ( pCheckpointMarker == rhs.pCheckpointMarker );
    }

    bool operator!=( CheckpointDataNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType         sType = StructureType::eCheckpointDataNV;
    void *                                      pNext = {};
    VULKAN_HPP_NAMESPACE::PipelineStageFlagBits stage = VULKAN_HPP_NAMESPACE::PipelineStageFlagBits::eTopOfPipe;
    void *                                      pCheckpointMarker = {};
  };
  static_assert( sizeof( CheckpointDataNV ) == sizeof( VkCheckpointDataNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<CheckpointDataNV>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eCheckpointDataNV>
  {
    using Type = CheckpointDataNV;
  };

  union ClearColorValue
  {
    ClearColorValue( VULKAN_HPP_NAMESPACE::ClearColorValue const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      memcpy( static_cast<void *>( this ), &rhs, sizeof( VULKAN_HPP_NAMESPACE::ClearColorValue ) );
    }

    ClearColorValue( const std::array<float, 4> & float32_ = {} ) : float32( float32_ ) {}

    ClearColorValue( const std::array<int32_t, 4> & int32_ ) : int32( int32_ ) {}

    ClearColorValue( const std::array<uint32_t, 4> & uint32_ ) : uint32( uint32_ ) {}

    ClearColorValue & setFloat32( std::array<float, 4> float32_ ) VULKAN_HPP_NOEXCEPT
    {
      float32 = float32_;
      return *this;
    }

    ClearColorValue & setInt32( std::array<int32_t, 4> int32_ ) VULKAN_HPP_NOEXCEPT
    {
      int32 = int32_;
      return *this;
    }

    ClearColorValue & setUint32( std::array<uint32_t, 4> uint32_ ) VULKAN_HPP_NOEXCEPT
    {
      uint32 = uint32_;
      return *this;
    }

    VULKAN_HPP_NAMESPACE::ClearColorValue &
      operator=( VULKAN_HPP_NAMESPACE::ClearColorValue const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      memcpy( static_cast<void *>( this ), &rhs, sizeof( VULKAN_HPP_NAMESPACE::ClearColorValue ) );
      return *this;
    }

    operator VkClearColorValue const &() const
    {
      return *reinterpret_cast<const VkClearColorValue *>( this );
    }

    operator VkClearColorValue &()
    {
      return *reinterpret_cast<VkClearColorValue *>( this );
    }

    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<float, 4>    float32;
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<int32_t, 4>  int32;
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<uint32_t, 4> uint32;
  };

  struct ClearDepthStencilValue
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ClearDepthStencilValue( float depth_ = {}, uint32_t stencil_ = {} ) VULKAN_HPP_NOEXCEPT
      : depth( depth_ )
      , stencil( stencil_ )
    {}

    VULKAN_HPP_CONSTEXPR ClearDepthStencilValue( ClearDepthStencilValue const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ClearDepthStencilValue( VkClearDepthStencilValue const & rhs ) VULKAN_HPP_NOEXCEPT
      : ClearDepthStencilValue( *reinterpret_cast<ClearDepthStencilValue const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ClearDepthStencilValue &
                            operator=( ClearDepthStencilValue const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ClearDepthStencilValue & operator=( VkClearDepthStencilValue const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ClearDepthStencilValue const *>( &rhs );
      return *this;
    }

    ClearDepthStencilValue & setDepth( float depth_ ) VULKAN_HPP_NOEXCEPT
    {
      depth = depth_;
      return *this;
    }

    ClearDepthStencilValue & setStencil( uint32_t stencil_ ) VULKAN_HPP_NOEXCEPT
    {
      stencil = stencil_;
      return *this;
    }

    operator VkClearDepthStencilValue const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkClearDepthStencilValue *>( this );
    }

    operator VkClearDepthStencilValue &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkClearDepthStencilValue *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ClearDepthStencilValue const & ) const = default;
#else
    bool operator==( ClearDepthStencilValue const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( depth == rhs.depth ) && ( stencil == rhs.stencil );
    }

    bool operator!=( ClearDepthStencilValue const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    float    depth   = {};
    uint32_t stencil = {};
  };
  static_assert( sizeof( ClearDepthStencilValue ) == sizeof( VkClearDepthStencilValue ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ClearDepthStencilValue>::value, "struct wrapper is not a standard layout!" );

  union ClearValue
  {
    ClearValue( VULKAN_HPP_NAMESPACE::ClearValue const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      memcpy( static_cast<void *>( this ), &rhs, sizeof( VULKAN_HPP_NAMESPACE::ClearValue ) );
    }

    ClearValue( VULKAN_HPP_NAMESPACE::ClearColorValue color_ = {} ) : color( color_ ) {}

    ClearValue( VULKAN_HPP_NAMESPACE::ClearDepthStencilValue depthStencil_ ) : depthStencil( depthStencil_ ) {}

    ClearValue & setColor( VULKAN_HPP_NAMESPACE::ClearColorValue const & color_ ) VULKAN_HPP_NOEXCEPT
    {
      color = color_;
      return *this;
    }

    ClearValue &
      setDepthStencil( VULKAN_HPP_NAMESPACE::ClearDepthStencilValue const & depthStencil_ ) VULKAN_HPP_NOEXCEPT
    {
      depthStencil = depthStencil_;
      return *this;
    }

    VULKAN_HPP_NAMESPACE::ClearValue & operator=( VULKAN_HPP_NAMESPACE::ClearValue const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      memcpy( static_cast<void *>( this ), &rhs, sizeof( VULKAN_HPP_NAMESPACE::ClearValue ) );
      return *this;
    }

    operator VkClearValue const &() const
    {
      return *reinterpret_cast<const VkClearValue *>( this );
    }

    operator VkClearValue &()
    {
      return *reinterpret_cast<VkClearValue *>( this );
    }

#ifdef VULKAN_HPP_HAS_UNRESTRICTED_UNIONS
    VULKAN_HPP_NAMESPACE::ClearColorValue        color;
    VULKAN_HPP_NAMESPACE::ClearDepthStencilValue depthStencil;
#else
    VkClearColorValue        color;
    VkClearDepthStencilValue depthStencil;
#endif /*VULKAN_HPP_HAS_UNRESTRICTED_UNIONS*/
  };

  struct ClearAttachment
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    ClearAttachment( VULKAN_HPP_NAMESPACE::ImageAspectFlags aspectMask_      = {},
                     uint32_t                               colorAttachment_ = {},
                     VULKAN_HPP_NAMESPACE::ClearValue       clearValue_      = {} ) VULKAN_HPP_NOEXCEPT
      : aspectMask( aspectMask_ )
      , colorAttachment( colorAttachment_ )
      , clearValue( clearValue_ )
    {}

    ClearAttachment( ClearAttachment const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ClearAttachment( VkClearAttachment const & rhs ) VULKAN_HPP_NOEXCEPT
      : ClearAttachment( *reinterpret_cast<ClearAttachment const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    ClearAttachment & operator=( ClearAttachment const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ClearAttachment & operator=( VkClearAttachment const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ClearAttachment const *>( &rhs );
      return *this;
    }

    ClearAttachment & setAspectMask( VULKAN_HPP_NAMESPACE::ImageAspectFlags aspectMask_ ) VULKAN_HPP_NOEXCEPT
    {
      aspectMask = aspectMask_;
      return *this;
    }

    ClearAttachment & setColorAttachment( uint32_t colorAttachment_ ) VULKAN_HPP_NOEXCEPT
    {
      colorAttachment = colorAttachment_;
      return *this;
    }

    ClearAttachment & setClearValue( VULKAN_HPP_NAMESPACE::ClearValue const & clearValue_ ) VULKAN_HPP_NOEXCEPT
    {
      clearValue = clearValue_;
      return *this;
    }

    operator VkClearAttachment const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkClearAttachment *>( this );
    }

    operator VkClearAttachment &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkClearAttachment *>( this );
    }

  public:
    VULKAN_HPP_NAMESPACE::ImageAspectFlags aspectMask      = {};
    uint32_t                               colorAttachment = {};
    VULKAN_HPP_NAMESPACE::ClearValue       clearValue      = {};
  };
  static_assert( sizeof( ClearAttachment ) == sizeof( VkClearAttachment ), "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ClearAttachment>::value, "struct wrapper is not a standard layout!" );

  struct ClearRect
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ClearRect( VULKAN_HPP_NAMESPACE::Rect2D rect_           = {},
                                    uint32_t                     baseArrayLayer_ = {},
                                    uint32_t                     layerCount_     = {} ) VULKAN_HPP_NOEXCEPT
      : rect( rect_ )
      , baseArrayLayer( baseArrayLayer_ )
      , layerCount( layerCount_ )
    {}

    VULKAN_HPP_CONSTEXPR ClearRect( ClearRect const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ClearRect( VkClearRect const & rhs ) VULKAN_HPP_NOEXCEPT : ClearRect( *reinterpret_cast<ClearRect const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ClearRect & operator=( ClearRect const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ClearRect & operator=( VkClearRect const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ClearRect const *>( &rhs );
      return *this;
    }

    ClearRect & setRect( VULKAN_HPP_NAMESPACE::Rect2D const & rect_ ) VULKAN_HPP_NOEXCEPT
    {
      rect = rect_;
      return *this;
    }

    ClearRect & setBaseArrayLayer( uint32_t baseArrayLayer_ ) VULKAN_HPP_NOEXCEPT
    {
      baseArrayLayer = baseArrayLayer_;
      return *this;
    }

    ClearRect & setLayerCount( uint32_t layerCount_ ) VULKAN_HPP_NOEXCEPT
    {
      layerCount = layerCount_;
      return *this;
    }

    operator VkClearRect const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkClearRect *>( this );
    }

    operator VkClearRect &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkClearRect *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ClearRect const & ) const = default;
#else
    bool                     operator==( ClearRect const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( rect == rhs.rect ) && ( baseArrayLayer == rhs.baseArrayLayer ) && ( layerCount == rhs.layerCount );
    }

    bool operator!=( ClearRect const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::Rect2D rect           = {};
    uint32_t                     baseArrayLayer = {};
    uint32_t                     layerCount     = {};
  };
  static_assert( sizeof( ClearRect ) == sizeof( VkClearRect ), "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ClearRect>::value, "struct wrapper is not a standard layout!" );

  struct CoarseSampleLocationNV
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      CoarseSampleLocationNV( uint32_t pixelX_ = {}, uint32_t pixelY_ = {}, uint32_t sample_ = {} ) VULKAN_HPP_NOEXCEPT
      : pixelX( pixelX_ )
      , pixelY( pixelY_ )
      , sample( sample_ )
    {}

    VULKAN_HPP_CONSTEXPR CoarseSampleLocationNV( CoarseSampleLocationNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    CoarseSampleLocationNV( VkCoarseSampleLocationNV const & rhs ) VULKAN_HPP_NOEXCEPT
      : CoarseSampleLocationNV( *reinterpret_cast<CoarseSampleLocationNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 CoarseSampleLocationNV &
                            operator=( CoarseSampleLocationNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    CoarseSampleLocationNV & operator=( VkCoarseSampleLocationNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::CoarseSampleLocationNV const *>( &rhs );
      return *this;
    }

    CoarseSampleLocationNV & setPixelX( uint32_t pixelX_ ) VULKAN_HPP_NOEXCEPT
    {
      pixelX = pixelX_;
      return *this;
    }

    CoarseSampleLocationNV & setPixelY( uint32_t pixelY_ ) VULKAN_HPP_NOEXCEPT
    {
      pixelY = pixelY_;
      return *this;
    }

    CoarseSampleLocationNV & setSample( uint32_t sample_ ) VULKAN_HPP_NOEXCEPT
    {
      sample = sample_;
      return *this;
    }

    operator VkCoarseSampleLocationNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkCoarseSampleLocationNV *>( this );
    }

    operator VkCoarseSampleLocationNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkCoarseSampleLocationNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( CoarseSampleLocationNV const & ) const = default;
#else
    bool operator==( CoarseSampleLocationNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( pixelX == rhs.pixelX ) && ( pixelY == rhs.pixelY ) && ( sample == rhs.sample );
    }

    bool operator!=( CoarseSampleLocationNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    uint32_t pixelX = {};
    uint32_t pixelY = {};
    uint32_t sample = {};
  };
  static_assert( sizeof( CoarseSampleLocationNV ) == sizeof( VkCoarseSampleLocationNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<CoarseSampleLocationNV>::value, "struct wrapper is not a standard layout!" );

  struct CoarseSampleOrderCustomNV
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR CoarseSampleOrderCustomNV(
      VULKAN_HPP_NAMESPACE::ShadingRatePaletteEntryNV shadingRate_ =
        VULKAN_HPP_NAMESPACE::ShadingRatePaletteEntryNV::eNoInvocations,
      uint32_t                                             sampleCount_         = {},
      uint32_t                                             sampleLocationCount_ = {},
      const VULKAN_HPP_NAMESPACE::CoarseSampleLocationNV * pSampleLocations_    = {} ) VULKAN_HPP_NOEXCEPT
      : shadingRate( shadingRate_ )
      , sampleCount( sampleCount_ )
      , sampleLocationCount( sampleLocationCount_ )
      , pSampleLocations( pSampleLocations_ )
    {}

    VULKAN_HPP_CONSTEXPR
      CoarseSampleOrderCustomNV( CoarseSampleOrderCustomNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    CoarseSampleOrderCustomNV( VkCoarseSampleOrderCustomNV const & rhs ) VULKAN_HPP_NOEXCEPT
      : CoarseSampleOrderCustomNV( *reinterpret_cast<CoarseSampleOrderCustomNV const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    CoarseSampleOrderCustomNV(
      VULKAN_HPP_NAMESPACE::ShadingRatePaletteEntryNV shadingRate_,
      uint32_t                                        sampleCount_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::CoarseSampleLocationNV> const &
        sampleLocations_ )
      : shadingRate( shadingRate_ )
      , sampleCount( sampleCount_ )
      , sampleLocationCount( static_cast<uint32_t>( sampleLocations_.size() ) )
      , pSampleLocations( sampleLocations_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 CoarseSampleOrderCustomNV &
                            operator=( CoarseSampleOrderCustomNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    CoarseSampleOrderCustomNV & operator=( VkCoarseSampleOrderCustomNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::CoarseSampleOrderCustomNV const *>( &rhs );
      return *this;
    }

    CoarseSampleOrderCustomNV &
      setShadingRate( VULKAN_HPP_NAMESPACE::ShadingRatePaletteEntryNV shadingRate_ ) VULKAN_HPP_NOEXCEPT
    {
      shadingRate = shadingRate_;
      return *this;
    }

    CoarseSampleOrderCustomNV & setSampleCount( uint32_t sampleCount_ ) VULKAN_HPP_NOEXCEPT
    {
      sampleCount = sampleCount_;
      return *this;
    }

    CoarseSampleOrderCustomNV & setSampleLocationCount( uint32_t sampleLocationCount_ ) VULKAN_HPP_NOEXCEPT
    {
      sampleLocationCount = sampleLocationCount_;
      return *this;
    }

    CoarseSampleOrderCustomNV &
      setPSampleLocations( const VULKAN_HPP_NAMESPACE::CoarseSampleLocationNV * pSampleLocations_ ) VULKAN_HPP_NOEXCEPT
    {
      pSampleLocations = pSampleLocations_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    CoarseSampleOrderCustomNV & setSampleLocations(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::CoarseSampleLocationNV> const &
        sampleLocations_ ) VULKAN_HPP_NOEXCEPT
    {
      sampleLocationCount = static_cast<uint32_t>( sampleLocations_.size() );
      pSampleLocations    = sampleLocations_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkCoarseSampleOrderCustomNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkCoarseSampleOrderCustomNV *>( this );
    }

    operator VkCoarseSampleOrderCustomNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkCoarseSampleOrderCustomNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( CoarseSampleOrderCustomNV const & ) const = default;
#else
    bool operator==( CoarseSampleOrderCustomNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( shadingRate == rhs.shadingRate ) && ( sampleCount == rhs.sampleCount ) &&
             ( sampleLocationCount == rhs.sampleLocationCount ) && ( pSampleLocations == rhs.pSampleLocations );
    }

    bool operator!=( CoarseSampleOrderCustomNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::ShadingRatePaletteEntryNV shadingRate =
      VULKAN_HPP_NAMESPACE::ShadingRatePaletteEntryNV::eNoInvocations;
    uint32_t                                             sampleCount         = {};
    uint32_t                                             sampleLocationCount = {};
    const VULKAN_HPP_NAMESPACE::CoarseSampleLocationNV * pSampleLocations    = {};
  };
  static_assert( sizeof( CoarseSampleOrderCustomNV ) == sizeof( VkCoarseSampleOrderCustomNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<CoarseSampleOrderCustomNV>::value,
                 "struct wrapper is not a standard layout!" );

  struct CommandBufferAllocateInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eCommandBufferAllocateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR CommandBufferAllocateInfo(
      VULKAN_HPP_NAMESPACE::CommandPool        commandPool_        = {},
      VULKAN_HPP_NAMESPACE::CommandBufferLevel level_              = VULKAN_HPP_NAMESPACE::CommandBufferLevel::ePrimary,
      uint32_t                                 commandBufferCount_ = {} ) VULKAN_HPP_NOEXCEPT
      : commandPool( commandPool_ )
      , level( level_ )
      , commandBufferCount( commandBufferCount_ )
    {}

    VULKAN_HPP_CONSTEXPR
      CommandBufferAllocateInfo( CommandBufferAllocateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    CommandBufferAllocateInfo( VkCommandBufferAllocateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : CommandBufferAllocateInfo( *reinterpret_cast<CommandBufferAllocateInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 CommandBufferAllocateInfo &
                            operator=( CommandBufferAllocateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    CommandBufferAllocateInfo & operator=( VkCommandBufferAllocateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::CommandBufferAllocateInfo const *>( &rhs );
      return *this;
    }

    CommandBufferAllocateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    CommandBufferAllocateInfo & setCommandPool( VULKAN_HPP_NAMESPACE::CommandPool commandPool_ ) VULKAN_HPP_NOEXCEPT
    {
      commandPool = commandPool_;
      return *this;
    }

    CommandBufferAllocateInfo & setLevel( VULKAN_HPP_NAMESPACE::CommandBufferLevel level_ ) VULKAN_HPP_NOEXCEPT
    {
      level = level_;
      return *this;
    }

    CommandBufferAllocateInfo & setCommandBufferCount( uint32_t commandBufferCount_ ) VULKAN_HPP_NOEXCEPT
    {
      commandBufferCount = commandBufferCount_;
      return *this;
    }

    operator VkCommandBufferAllocateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkCommandBufferAllocateInfo *>( this );
    }

    operator VkCommandBufferAllocateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkCommandBufferAllocateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( CommandBufferAllocateInfo const & ) const = default;
#else
    bool operator==( CommandBufferAllocateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( commandPool == rhs.commandPool ) &&
             ( level == rhs.level ) && ( commandBufferCount == rhs.commandBufferCount );
    }

    bool operator!=( CommandBufferAllocateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType      sType              = StructureType::eCommandBufferAllocateInfo;
    const void *                             pNext              = {};
    VULKAN_HPP_NAMESPACE::CommandPool        commandPool        = {};
    VULKAN_HPP_NAMESPACE::CommandBufferLevel level              = VULKAN_HPP_NAMESPACE::CommandBufferLevel::ePrimary;
    uint32_t                                 commandBufferCount = {};
  };
  static_assert( sizeof( CommandBufferAllocateInfo ) == sizeof( VkCommandBufferAllocateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<CommandBufferAllocateInfo>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eCommandBufferAllocateInfo>
  {
    using Type = CommandBufferAllocateInfo;
  };

  struct CommandBufferInheritanceInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eCommandBufferInheritanceInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR CommandBufferInheritanceInfo(
      VULKAN_HPP_NAMESPACE::RenderPass                  renderPass_           = {},
      uint32_t                                          subpass_              = {},
      VULKAN_HPP_NAMESPACE::Framebuffer                 framebuffer_          = {},
      VULKAN_HPP_NAMESPACE::Bool32                      occlusionQueryEnable_ = {},
      VULKAN_HPP_NAMESPACE::QueryControlFlags           queryFlags_           = {},
      VULKAN_HPP_NAMESPACE::QueryPipelineStatisticFlags pipelineStatistics_   = {} ) VULKAN_HPP_NOEXCEPT
      : renderPass( renderPass_ )
      , subpass( subpass_ )
      , framebuffer( framebuffer_ )
      , occlusionQueryEnable( occlusionQueryEnable_ )
      , queryFlags( queryFlags_ )
      , pipelineStatistics( pipelineStatistics_ )
    {}

    VULKAN_HPP_CONSTEXPR
      CommandBufferInheritanceInfo( CommandBufferInheritanceInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    CommandBufferInheritanceInfo( VkCommandBufferInheritanceInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : CommandBufferInheritanceInfo( *reinterpret_cast<CommandBufferInheritanceInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 CommandBufferInheritanceInfo &
                            operator=( CommandBufferInheritanceInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    CommandBufferInheritanceInfo & operator=( VkCommandBufferInheritanceInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::CommandBufferInheritanceInfo const *>( &rhs );
      return *this;
    }

    CommandBufferInheritanceInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    CommandBufferInheritanceInfo & setRenderPass( VULKAN_HPP_NAMESPACE::RenderPass renderPass_ ) VULKAN_HPP_NOEXCEPT
    {
      renderPass = renderPass_;
      return *this;
    }

    CommandBufferInheritanceInfo & setSubpass( uint32_t subpass_ ) VULKAN_HPP_NOEXCEPT
    {
      subpass = subpass_;
      return *this;
    }

    CommandBufferInheritanceInfo & setFramebuffer( VULKAN_HPP_NAMESPACE::Framebuffer framebuffer_ ) VULKAN_HPP_NOEXCEPT
    {
      framebuffer = framebuffer_;
      return *this;
    }

    CommandBufferInheritanceInfo &
      setOcclusionQueryEnable( VULKAN_HPP_NAMESPACE::Bool32 occlusionQueryEnable_ ) VULKAN_HPP_NOEXCEPT
    {
      occlusionQueryEnable = occlusionQueryEnable_;
      return *this;
    }

    CommandBufferInheritanceInfo &
      setQueryFlags( VULKAN_HPP_NAMESPACE::QueryControlFlags queryFlags_ ) VULKAN_HPP_NOEXCEPT
    {
      queryFlags = queryFlags_;
      return *this;
    }

    CommandBufferInheritanceInfo &
      setPipelineStatistics( VULKAN_HPP_NAMESPACE::QueryPipelineStatisticFlags pipelineStatistics_ ) VULKAN_HPP_NOEXCEPT
    {
      pipelineStatistics = pipelineStatistics_;
      return *this;
    }

    operator VkCommandBufferInheritanceInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkCommandBufferInheritanceInfo *>( this );
    }

    operator VkCommandBufferInheritanceInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkCommandBufferInheritanceInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( CommandBufferInheritanceInfo const & ) const = default;
#else
    bool operator==( CommandBufferInheritanceInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( renderPass == rhs.renderPass ) &&
             ( subpass == rhs.subpass ) && ( framebuffer == rhs.framebuffer ) &&
             ( occlusionQueryEnable == rhs.occlusionQueryEnable ) && ( queryFlags == rhs.queryFlags ) &&
             ( pipelineStatistics == rhs.pipelineStatistics );
    }

    bool operator!=( CommandBufferInheritanceInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType               sType       = StructureType::eCommandBufferInheritanceInfo;
    const void *                                      pNext       = {};
    VULKAN_HPP_NAMESPACE::RenderPass                  renderPass  = {};
    uint32_t                                          subpass     = {};
    VULKAN_HPP_NAMESPACE::Framebuffer                 framebuffer = {};
    VULKAN_HPP_NAMESPACE::Bool32                      occlusionQueryEnable = {};
    VULKAN_HPP_NAMESPACE::QueryControlFlags           queryFlags           = {};
    VULKAN_HPP_NAMESPACE::QueryPipelineStatisticFlags pipelineStatistics   = {};
  };
  static_assert( sizeof( CommandBufferInheritanceInfo ) == sizeof( VkCommandBufferInheritanceInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<CommandBufferInheritanceInfo>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eCommandBufferInheritanceInfo>
  {
    using Type = CommandBufferInheritanceInfo;
  };

  struct CommandBufferBeginInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eCommandBufferBeginInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR CommandBufferBeginInfo(
      VULKAN_HPP_NAMESPACE::CommandBufferUsageFlags              flags_            = {},
      const VULKAN_HPP_NAMESPACE::CommandBufferInheritanceInfo * pInheritanceInfo_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , pInheritanceInfo( pInheritanceInfo_ )
    {}

    VULKAN_HPP_CONSTEXPR CommandBufferBeginInfo( CommandBufferBeginInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    CommandBufferBeginInfo( VkCommandBufferBeginInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : CommandBufferBeginInfo( *reinterpret_cast<CommandBufferBeginInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 CommandBufferBeginInfo &
                            operator=( CommandBufferBeginInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    CommandBufferBeginInfo & operator=( VkCommandBufferBeginInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::CommandBufferBeginInfo const *>( &rhs );
      return *this;
    }

    CommandBufferBeginInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    CommandBufferBeginInfo & setFlags( VULKAN_HPP_NAMESPACE::CommandBufferUsageFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    CommandBufferBeginInfo & setPInheritanceInfo(
      const VULKAN_HPP_NAMESPACE::CommandBufferInheritanceInfo * pInheritanceInfo_ ) VULKAN_HPP_NOEXCEPT
    {
      pInheritanceInfo = pInheritanceInfo_;
      return *this;
    }

    operator VkCommandBufferBeginInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkCommandBufferBeginInfo *>( this );
    }

    operator VkCommandBufferBeginInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkCommandBufferBeginInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( CommandBufferBeginInfo const & ) const = default;
#else
    bool operator==( CommandBufferBeginInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( pInheritanceInfo == rhs.pInheritanceInfo );
    }

    bool operator!=( CommandBufferBeginInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                        sType = StructureType::eCommandBufferBeginInfo;
    const void *                                               pNext = {};
    VULKAN_HPP_NAMESPACE::CommandBufferUsageFlags              flags = {};
    const VULKAN_HPP_NAMESPACE::CommandBufferInheritanceInfo * pInheritanceInfo = {};
  };
  static_assert( sizeof( CommandBufferBeginInfo ) == sizeof( VkCommandBufferBeginInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<CommandBufferBeginInfo>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eCommandBufferBeginInfo>
  {
    using Type = CommandBufferBeginInfo;
  };

  struct CommandBufferInheritanceConditionalRenderingInfoEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eCommandBufferInheritanceConditionalRenderingInfoEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR CommandBufferInheritanceConditionalRenderingInfoEXT(
      VULKAN_HPP_NAMESPACE::Bool32 conditionalRenderingEnable_ = {} ) VULKAN_HPP_NOEXCEPT
      : conditionalRenderingEnable( conditionalRenderingEnable_ )
    {}

    VULKAN_HPP_CONSTEXPR CommandBufferInheritanceConditionalRenderingInfoEXT(
      CommandBufferInheritanceConditionalRenderingInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    CommandBufferInheritanceConditionalRenderingInfoEXT(
      VkCommandBufferInheritanceConditionalRenderingInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : CommandBufferInheritanceConditionalRenderingInfoEXT(
          *reinterpret_cast<CommandBufferInheritanceConditionalRenderingInfoEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 CommandBufferInheritanceConditionalRenderingInfoEXT &
                            operator=( CommandBufferInheritanceConditionalRenderingInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    CommandBufferInheritanceConditionalRenderingInfoEXT &
      operator=( VkCommandBufferInheritanceConditionalRenderingInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this =
        *reinterpret_cast<VULKAN_HPP_NAMESPACE::CommandBufferInheritanceConditionalRenderingInfoEXT const *>( &rhs );
      return *this;
    }

    CommandBufferInheritanceConditionalRenderingInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    CommandBufferInheritanceConditionalRenderingInfoEXT &
      setConditionalRenderingEnable( VULKAN_HPP_NAMESPACE::Bool32 conditionalRenderingEnable_ ) VULKAN_HPP_NOEXCEPT
    {
      conditionalRenderingEnable = conditionalRenderingEnable_;
      return *this;
    }

    operator VkCommandBufferInheritanceConditionalRenderingInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkCommandBufferInheritanceConditionalRenderingInfoEXT *>( this );
    }

    operator VkCommandBufferInheritanceConditionalRenderingInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkCommandBufferInheritanceConditionalRenderingInfoEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( CommandBufferInheritanceConditionalRenderingInfoEXT const & ) const = default;
#else
    bool operator==( CommandBufferInheritanceConditionalRenderingInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( conditionalRenderingEnable == rhs.conditionalRenderingEnable );
    }

    bool operator!=( CommandBufferInheritanceConditionalRenderingInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::eCommandBufferInheritanceConditionalRenderingInfoEXT;
    const void *                        pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        conditionalRenderingEnable = {};
  };
  static_assert( sizeof( CommandBufferInheritanceConditionalRenderingInfoEXT ) ==
                   sizeof( VkCommandBufferInheritanceConditionalRenderingInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<CommandBufferInheritanceConditionalRenderingInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eCommandBufferInheritanceConditionalRenderingInfoEXT>
  {
    using Type = CommandBufferInheritanceConditionalRenderingInfoEXT;
  };

  struct CommandBufferInheritanceRenderPassTransformInfoQCOM
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eCommandBufferInheritanceRenderPassTransformInfoQCOM;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR CommandBufferInheritanceRenderPassTransformInfoQCOM(
      VULKAN_HPP_NAMESPACE::SurfaceTransformFlagBitsKHR transform_ =
        VULKAN_HPP_NAMESPACE::SurfaceTransformFlagBitsKHR::eIdentity,
      VULKAN_HPP_NAMESPACE::Rect2D renderArea_ = {} ) VULKAN_HPP_NOEXCEPT
      : transform( transform_ )
      , renderArea( renderArea_ )
    {}

    VULKAN_HPP_CONSTEXPR CommandBufferInheritanceRenderPassTransformInfoQCOM(
      CommandBufferInheritanceRenderPassTransformInfoQCOM const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    CommandBufferInheritanceRenderPassTransformInfoQCOM(
      VkCommandBufferInheritanceRenderPassTransformInfoQCOM const & rhs ) VULKAN_HPP_NOEXCEPT
      : CommandBufferInheritanceRenderPassTransformInfoQCOM(
          *reinterpret_cast<CommandBufferInheritanceRenderPassTransformInfoQCOM const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 CommandBufferInheritanceRenderPassTransformInfoQCOM &
                            operator=( CommandBufferInheritanceRenderPassTransformInfoQCOM const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    CommandBufferInheritanceRenderPassTransformInfoQCOM &
      operator=( VkCommandBufferInheritanceRenderPassTransformInfoQCOM const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this =
        *reinterpret_cast<VULKAN_HPP_NAMESPACE::CommandBufferInheritanceRenderPassTransformInfoQCOM const *>( &rhs );
      return *this;
    }

    CommandBufferInheritanceRenderPassTransformInfoQCOM & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    CommandBufferInheritanceRenderPassTransformInfoQCOM &
      setTransform( VULKAN_HPP_NAMESPACE::SurfaceTransformFlagBitsKHR transform_ ) VULKAN_HPP_NOEXCEPT
    {
      transform = transform_;
      return *this;
    }

    CommandBufferInheritanceRenderPassTransformInfoQCOM &
      setRenderArea( VULKAN_HPP_NAMESPACE::Rect2D const & renderArea_ ) VULKAN_HPP_NOEXCEPT
    {
      renderArea = renderArea_;
      return *this;
    }

    operator VkCommandBufferInheritanceRenderPassTransformInfoQCOM const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkCommandBufferInheritanceRenderPassTransformInfoQCOM *>( this );
    }

    operator VkCommandBufferInheritanceRenderPassTransformInfoQCOM &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkCommandBufferInheritanceRenderPassTransformInfoQCOM *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( CommandBufferInheritanceRenderPassTransformInfoQCOM const & ) const = default;
#else
    bool operator==( CommandBufferInheritanceRenderPassTransformInfoQCOM const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( transform == rhs.transform ) &&
             ( renderArea == rhs.renderArea );
    }

    bool operator!=( CommandBufferInheritanceRenderPassTransformInfoQCOM const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::eCommandBufferInheritanceRenderPassTransformInfoQCOM;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::SurfaceTransformFlagBitsKHR transform =
      VULKAN_HPP_NAMESPACE::SurfaceTransformFlagBitsKHR::eIdentity;
    VULKAN_HPP_NAMESPACE::Rect2D renderArea = {};
  };
  static_assert( sizeof( CommandBufferInheritanceRenderPassTransformInfoQCOM ) ==
                   sizeof( VkCommandBufferInheritanceRenderPassTransformInfoQCOM ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<CommandBufferInheritanceRenderPassTransformInfoQCOM>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eCommandBufferInheritanceRenderPassTransformInfoQCOM>
  {
    using Type = CommandBufferInheritanceRenderPassTransformInfoQCOM;
  };

  struct Viewport
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR Viewport( float x_        = {},
                                   float y_        = {},
                                   float width_    = {},
                                   float height_   = {},
                                   float minDepth_ = {},
                                   float maxDepth_ = {} ) VULKAN_HPP_NOEXCEPT
      : x( x_ )
      , y( y_ )
      , width( width_ )
      , height( height_ )
      , minDepth( minDepth_ )
      , maxDepth( maxDepth_ )
    {}

    VULKAN_HPP_CONSTEXPR Viewport( Viewport const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    Viewport( VkViewport const & rhs ) VULKAN_HPP_NOEXCEPT : Viewport( *reinterpret_cast<Viewport const *>( &rhs ) ) {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 Viewport & operator=( Viewport const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    Viewport & operator=( VkViewport const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::Viewport const *>( &rhs );
      return *this;
    }

    Viewport & setX( float x_ ) VULKAN_HPP_NOEXCEPT
    {
      x = x_;
      return *this;
    }

    Viewport & setY( float y_ ) VULKAN_HPP_NOEXCEPT
    {
      y = y_;
      return *this;
    }

    Viewport & setWidth( float width_ ) VULKAN_HPP_NOEXCEPT
    {
      width = width_;
      return *this;
    }

    Viewport & setHeight( float height_ ) VULKAN_HPP_NOEXCEPT
    {
      height = height_;
      return *this;
    }

    Viewport & setMinDepth( float minDepth_ ) VULKAN_HPP_NOEXCEPT
    {
      minDepth = minDepth_;
      return *this;
    }

    Viewport & setMaxDepth( float maxDepth_ ) VULKAN_HPP_NOEXCEPT
    {
      maxDepth = maxDepth_;
      return *this;
    }

    operator VkViewport const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkViewport *>( this );
    }

    operator VkViewport &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkViewport *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( Viewport const & ) const = default;
#else
    bool operator==( Viewport const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( x == rhs.x ) && ( y == rhs.y ) && ( width == rhs.width ) && ( height == rhs.height ) &&
             ( minDepth == rhs.minDepth ) && ( maxDepth == rhs.maxDepth );
    }

    bool operator!=( Viewport const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    float x        = {};
    float y        = {};
    float width    = {};
    float height   = {};
    float minDepth = {};
    float maxDepth = {};
  };
  static_assert( sizeof( Viewport ) == sizeof( VkViewport ), "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<Viewport>::value, "struct wrapper is not a standard layout!" );

  struct CommandBufferInheritanceViewportScissorInfoNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eCommandBufferInheritanceViewportScissorInfoNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR CommandBufferInheritanceViewportScissorInfoNV(
      VULKAN_HPP_NAMESPACE::Bool32           viewportScissor2D_  = {},
      uint32_t                               viewportDepthCount_ = {},
      const VULKAN_HPP_NAMESPACE::Viewport * pViewportDepths_    = {} ) VULKAN_HPP_NOEXCEPT
      : viewportScissor2D( viewportScissor2D_ )
      , viewportDepthCount( viewportDepthCount_ )
      , pViewportDepths( pViewportDepths_ )
    {}

    VULKAN_HPP_CONSTEXPR CommandBufferInheritanceViewportScissorInfoNV(
      CommandBufferInheritanceViewportScissorInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    CommandBufferInheritanceViewportScissorInfoNV( VkCommandBufferInheritanceViewportScissorInfoNV const & rhs )
      VULKAN_HPP_NOEXCEPT
      : CommandBufferInheritanceViewportScissorInfoNV(
          *reinterpret_cast<CommandBufferInheritanceViewportScissorInfoNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 CommandBufferInheritanceViewportScissorInfoNV &
                            operator=( CommandBufferInheritanceViewportScissorInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    CommandBufferInheritanceViewportScissorInfoNV &
      operator=( VkCommandBufferInheritanceViewportScissorInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::CommandBufferInheritanceViewportScissorInfoNV const *>( &rhs );
      return *this;
    }

    CommandBufferInheritanceViewportScissorInfoNV & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    CommandBufferInheritanceViewportScissorInfoNV &
      setViewportScissor2D( VULKAN_HPP_NAMESPACE::Bool32 viewportScissor2D_ ) VULKAN_HPP_NOEXCEPT
    {
      viewportScissor2D = viewportScissor2D_;
      return *this;
    }

    CommandBufferInheritanceViewportScissorInfoNV &
      setViewportDepthCount( uint32_t viewportDepthCount_ ) VULKAN_HPP_NOEXCEPT
    {
      viewportDepthCount = viewportDepthCount_;
      return *this;
    }

    CommandBufferInheritanceViewportScissorInfoNV &
      setPViewportDepths( const VULKAN_HPP_NAMESPACE::Viewport * pViewportDepths_ ) VULKAN_HPP_NOEXCEPT
    {
      pViewportDepths = pViewportDepths_;
      return *this;
    }

    operator VkCommandBufferInheritanceViewportScissorInfoNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkCommandBufferInheritanceViewportScissorInfoNV *>( this );
    }

    operator VkCommandBufferInheritanceViewportScissorInfoNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkCommandBufferInheritanceViewportScissorInfoNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( CommandBufferInheritanceViewportScissorInfoNV const & ) const = default;
#else
    bool operator==( CommandBufferInheritanceViewportScissorInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( viewportScissor2D == rhs.viewportScissor2D ) &&
             ( viewportDepthCount == rhs.viewportDepthCount ) && ( pViewportDepths == rhs.pViewportDepths );
    }

    bool operator!=( CommandBufferInheritanceViewportScissorInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType    sType = StructureType::eCommandBufferInheritanceViewportScissorInfoNV;
    const void *                           pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32           viewportScissor2D  = {};
    uint32_t                               viewportDepthCount = {};
    const VULKAN_HPP_NAMESPACE::Viewport * pViewportDepths    = {};
  };
  static_assert( sizeof( CommandBufferInheritanceViewportScissorInfoNV ) ==
                   sizeof( VkCommandBufferInheritanceViewportScissorInfoNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<CommandBufferInheritanceViewportScissorInfoNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eCommandBufferInheritanceViewportScissorInfoNV>
  {
    using Type = CommandBufferInheritanceViewportScissorInfoNV;
  };

  struct CommandBufferSubmitInfoKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eCommandBufferSubmitInfoKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR CommandBufferSubmitInfoKHR( VULKAN_HPP_NAMESPACE::CommandBuffer commandBuffer_ = {},
                                                     uint32_t deviceMask_ = {} ) VULKAN_HPP_NOEXCEPT
      : commandBuffer( commandBuffer_ )
      , deviceMask( deviceMask_ )
    {}

    VULKAN_HPP_CONSTEXPR
      CommandBufferSubmitInfoKHR( CommandBufferSubmitInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    CommandBufferSubmitInfoKHR( VkCommandBufferSubmitInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : CommandBufferSubmitInfoKHR( *reinterpret_cast<CommandBufferSubmitInfoKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 CommandBufferSubmitInfoKHR &
                            operator=( CommandBufferSubmitInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    CommandBufferSubmitInfoKHR & operator=( VkCommandBufferSubmitInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::CommandBufferSubmitInfoKHR const *>( &rhs );
      return *this;
    }

    CommandBufferSubmitInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    CommandBufferSubmitInfoKHR &
      setCommandBuffer( VULKAN_HPP_NAMESPACE::CommandBuffer commandBuffer_ ) VULKAN_HPP_NOEXCEPT
    {
      commandBuffer = commandBuffer_;
      return *this;
    }

    CommandBufferSubmitInfoKHR & setDeviceMask( uint32_t deviceMask_ ) VULKAN_HPP_NOEXCEPT
    {
      deviceMask = deviceMask_;
      return *this;
    }

    operator VkCommandBufferSubmitInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkCommandBufferSubmitInfoKHR *>( this );
    }

    operator VkCommandBufferSubmitInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkCommandBufferSubmitInfoKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( CommandBufferSubmitInfoKHR const & ) const = default;
#else
    bool operator==( CommandBufferSubmitInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( commandBuffer == rhs.commandBuffer ) &&
             ( deviceMask == rhs.deviceMask );
    }

    bool operator!=( CommandBufferSubmitInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType         = StructureType::eCommandBufferSubmitInfoKHR;
    const void *                        pNext         = {};
    VULKAN_HPP_NAMESPACE::CommandBuffer commandBuffer = {};
    uint32_t                            deviceMask    = {};
  };
  static_assert( sizeof( CommandBufferSubmitInfoKHR ) == sizeof( VkCommandBufferSubmitInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<CommandBufferSubmitInfoKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eCommandBufferSubmitInfoKHR>
  {
    using Type = CommandBufferSubmitInfoKHR;
  };

  struct CommandPoolCreateInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eCommandPoolCreateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR CommandPoolCreateInfo( VULKAN_HPP_NAMESPACE::CommandPoolCreateFlags flags_ = {},
                                                uint32_t queueFamilyIndex_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , queueFamilyIndex( queueFamilyIndex_ )
    {}

    VULKAN_HPP_CONSTEXPR CommandPoolCreateInfo( CommandPoolCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    CommandPoolCreateInfo( VkCommandPoolCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : CommandPoolCreateInfo( *reinterpret_cast<CommandPoolCreateInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 CommandPoolCreateInfo &
                            operator=( CommandPoolCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    CommandPoolCreateInfo & operator=( VkCommandPoolCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::CommandPoolCreateInfo const *>( &rhs );
      return *this;
    }

    CommandPoolCreateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    CommandPoolCreateInfo & setFlags( VULKAN_HPP_NAMESPACE::CommandPoolCreateFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    CommandPoolCreateInfo & setQueueFamilyIndex( uint32_t queueFamilyIndex_ ) VULKAN_HPP_NOEXCEPT
    {
      queueFamilyIndex = queueFamilyIndex_;
      return *this;
    }

    operator VkCommandPoolCreateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkCommandPoolCreateInfo *>( this );
    }

    operator VkCommandPoolCreateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkCommandPoolCreateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( CommandPoolCreateInfo const & ) const = default;
#else
    bool operator==( CommandPoolCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( queueFamilyIndex == rhs.queueFamilyIndex );
    }

    bool operator!=( CommandPoolCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType          sType            = StructureType::eCommandPoolCreateInfo;
    const void *                                 pNext            = {};
    VULKAN_HPP_NAMESPACE::CommandPoolCreateFlags flags            = {};
    uint32_t                                     queueFamilyIndex = {};
  };
  static_assert( sizeof( CommandPoolCreateInfo ) == sizeof( VkCommandPoolCreateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<CommandPoolCreateInfo>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eCommandPoolCreateInfo>
  {
    using Type = CommandPoolCreateInfo;
  };

  struct SpecializationMapEntry
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      SpecializationMapEntry( uint32_t constantID_ = {}, uint32_t offset_ = {}, size_t size_ = {} ) VULKAN_HPP_NOEXCEPT
      : constantID( constantID_ )
      , offset( offset_ )
      , size( size_ )
    {}

    VULKAN_HPP_CONSTEXPR SpecializationMapEntry( SpecializationMapEntry const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SpecializationMapEntry( VkSpecializationMapEntry const & rhs ) VULKAN_HPP_NOEXCEPT
      : SpecializationMapEntry( *reinterpret_cast<SpecializationMapEntry const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SpecializationMapEntry &
                            operator=( SpecializationMapEntry const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SpecializationMapEntry & operator=( VkSpecializationMapEntry const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SpecializationMapEntry const *>( &rhs );
      return *this;
    }

    SpecializationMapEntry & setConstantID( uint32_t constantID_ ) VULKAN_HPP_NOEXCEPT
    {
      constantID = constantID_;
      return *this;
    }

    SpecializationMapEntry & setOffset( uint32_t offset_ ) VULKAN_HPP_NOEXCEPT
    {
      offset = offset_;
      return *this;
    }

    SpecializationMapEntry & setSize( size_t size_ ) VULKAN_HPP_NOEXCEPT
    {
      size = size_;
      return *this;
    }

    operator VkSpecializationMapEntry const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSpecializationMapEntry *>( this );
    }

    operator VkSpecializationMapEntry &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSpecializationMapEntry *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SpecializationMapEntry const & ) const = default;
#else
    bool operator==( SpecializationMapEntry const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( constantID == rhs.constantID ) && ( offset == rhs.offset ) && ( size == rhs.size );
    }

    bool operator!=( SpecializationMapEntry const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    uint32_t constantID = {};
    uint32_t offset     = {};
    size_t   size       = {};
  };
  static_assert( sizeof( SpecializationMapEntry ) == sizeof( VkSpecializationMapEntry ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SpecializationMapEntry>::value, "struct wrapper is not a standard layout!" );

  struct SpecializationInfo
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR SpecializationInfo( uint32_t                                             mapEntryCount_ = {},
                                             const VULKAN_HPP_NAMESPACE::SpecializationMapEntry * pMapEntries_   = {},
                                             size_t                                               dataSize_      = {},
                                             const void * pData_ = {} ) VULKAN_HPP_NOEXCEPT
      : mapEntryCount( mapEntryCount_ )
      , pMapEntries( pMapEntries_ )
      , dataSize( dataSize_ )
      , pData( pData_ )
    {}

    VULKAN_HPP_CONSTEXPR SpecializationInfo( SpecializationInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SpecializationInfo( VkSpecializationInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : SpecializationInfo( *reinterpret_cast<SpecializationInfo const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    template <typename T>
    SpecializationInfo( VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<
                          const VULKAN_HPP_NAMESPACE::SpecializationMapEntry> const &  mapEntries_,
                        VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const T> const & data_ = {} )
      : mapEntryCount( static_cast<uint32_t>( mapEntries_.size() ) )
      , pMapEntries( mapEntries_.data() )
      , dataSize( data_.size() * sizeof( T ) )
      , pData( data_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SpecializationInfo &
                            operator=( SpecializationInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SpecializationInfo & operator=( VkSpecializationInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SpecializationInfo const *>( &rhs );
      return *this;
    }

    SpecializationInfo & setMapEntryCount( uint32_t mapEntryCount_ ) VULKAN_HPP_NOEXCEPT
    {
      mapEntryCount = mapEntryCount_;
      return *this;
    }

    SpecializationInfo &
      setPMapEntries( const VULKAN_HPP_NAMESPACE::SpecializationMapEntry * pMapEntries_ ) VULKAN_HPP_NOEXCEPT
    {
      pMapEntries = pMapEntries_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    SpecializationInfo & setMapEntries(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::SpecializationMapEntry> const &
        mapEntries_ ) VULKAN_HPP_NOEXCEPT
    {
      mapEntryCount = static_cast<uint32_t>( mapEntries_.size() );
      pMapEntries   = mapEntries_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    SpecializationInfo & setDataSize( size_t dataSize_ ) VULKAN_HPP_NOEXCEPT
    {
      dataSize = dataSize_;
      return *this;
    }

    SpecializationInfo & setPData( const void * pData_ ) VULKAN_HPP_NOEXCEPT
    {
      pData = pData_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    template <typename T>
    SpecializationInfo &
      setData( VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const T> const & data_ ) VULKAN_HPP_NOEXCEPT
    {
      dataSize = data_.size() * sizeof( T );
      pData    = data_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkSpecializationInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSpecializationInfo *>( this );
    }

    operator VkSpecializationInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSpecializationInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SpecializationInfo const & ) const = default;
#else
    bool operator==( SpecializationInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( mapEntryCount == rhs.mapEntryCount ) && ( pMapEntries == rhs.pMapEntries ) &&
             ( dataSize == rhs.dataSize ) && ( pData == rhs.pData );
    }

    bool operator!=( SpecializationInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    uint32_t                                             mapEntryCount = {};
    const VULKAN_HPP_NAMESPACE::SpecializationMapEntry * pMapEntries   = {};
    size_t                                               dataSize      = {};
    const void *                                         pData         = {};
  };
  static_assert( sizeof( SpecializationInfo ) == sizeof( VkSpecializationInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SpecializationInfo>::value, "struct wrapper is not a standard layout!" );

  struct PipelineShaderStageCreateInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::ePipelineShaderStageCreateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PipelineShaderStageCreateInfo(
      VULKAN_HPP_NAMESPACE::PipelineShaderStageCreateFlags flags_  = {},
      VULKAN_HPP_NAMESPACE::ShaderStageFlagBits            stage_  = VULKAN_HPP_NAMESPACE::ShaderStageFlagBits::eVertex,
      VULKAN_HPP_NAMESPACE::ShaderModule                   module_ = {},
      const char *                                         pName_  = {},
      const VULKAN_HPP_NAMESPACE::SpecializationInfo *     pSpecializationInfo_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , stage( stage_ )
      , module( module_ )
      , pName( pName_ )
      , pSpecializationInfo( pSpecializationInfo_ )
    {}

    VULKAN_HPP_CONSTEXPR
      PipelineShaderStageCreateInfo( PipelineShaderStageCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineShaderStageCreateInfo( VkPipelineShaderStageCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : PipelineShaderStageCreateInfo( *reinterpret_cast<PipelineShaderStageCreateInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PipelineShaderStageCreateInfo &
                            operator=( PipelineShaderStageCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineShaderStageCreateInfo & operator=( VkPipelineShaderStageCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PipelineShaderStageCreateInfo const *>( &rhs );
      return *this;
    }

    PipelineShaderStageCreateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PipelineShaderStageCreateInfo &
      setFlags( VULKAN_HPP_NAMESPACE::PipelineShaderStageCreateFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    PipelineShaderStageCreateInfo & setStage( VULKAN_HPP_NAMESPACE::ShaderStageFlagBits stage_ ) VULKAN_HPP_NOEXCEPT
    {
      stage = stage_;
      return *this;
    }

    PipelineShaderStageCreateInfo & setModule( VULKAN_HPP_NAMESPACE::ShaderModule module_ ) VULKAN_HPP_NOEXCEPT
    {
      module = module_;
      return *this;
    }

    PipelineShaderStageCreateInfo & setPName( const char * pName_ ) VULKAN_HPP_NOEXCEPT
    {
      pName = pName_;
      return *this;
    }

    PipelineShaderStageCreateInfo & setPSpecializationInfo(
      const VULKAN_HPP_NAMESPACE::SpecializationInfo * pSpecializationInfo_ ) VULKAN_HPP_NOEXCEPT
    {
      pSpecializationInfo = pSpecializationInfo_;
      return *this;
    }

    operator VkPipelineShaderStageCreateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPipelineShaderStageCreateInfo *>( this );
    }

    operator VkPipelineShaderStageCreateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPipelineShaderStageCreateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PipelineShaderStageCreateInfo const & ) const = default;
#else
    bool operator==( PipelineShaderStageCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) && ( stage == rhs.stage ) &&
             ( module == rhs.module ) && ( pName == rhs.pName ) && ( pSpecializationInfo == rhs.pSpecializationInfo );
    }

    bool operator!=( PipelineShaderStageCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                  sType  = StructureType::ePipelineShaderStageCreateInfo;
    const void *                                         pNext  = {};
    VULKAN_HPP_NAMESPACE::PipelineShaderStageCreateFlags flags  = {};
    VULKAN_HPP_NAMESPACE::ShaderStageFlagBits            stage  = VULKAN_HPP_NAMESPACE::ShaderStageFlagBits::eVertex;
    VULKAN_HPP_NAMESPACE::ShaderModule                   module = {};
    const char *                                         pName  = {};
    const VULKAN_HPP_NAMESPACE::SpecializationInfo *     pSpecializationInfo = {};
  };
  static_assert( sizeof( PipelineShaderStageCreateInfo ) == sizeof( VkPipelineShaderStageCreateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PipelineShaderStageCreateInfo>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePipelineShaderStageCreateInfo>
  {
    using Type = PipelineShaderStageCreateInfo;
  };

  struct ComputePipelineCreateInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eComputePipelineCreateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ComputePipelineCreateInfo( VULKAN_HPP_NAMESPACE::PipelineCreateFlags           flags_  = {},
                                                    VULKAN_HPP_NAMESPACE::PipelineShaderStageCreateInfo stage_  = {},
                                                    VULKAN_HPP_NAMESPACE::PipelineLayout                layout_ = {},
                                                    VULKAN_HPP_NAMESPACE::Pipeline basePipelineHandle_          = {},
                                                    int32_t basePipelineIndex_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , stage( stage_ )
      , layout( layout_ )
      , basePipelineHandle( basePipelineHandle_ )
      , basePipelineIndex( basePipelineIndex_ )
    {}

    VULKAN_HPP_CONSTEXPR
      ComputePipelineCreateInfo( ComputePipelineCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ComputePipelineCreateInfo( VkComputePipelineCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : ComputePipelineCreateInfo( *reinterpret_cast<ComputePipelineCreateInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ComputePipelineCreateInfo &
                            operator=( ComputePipelineCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ComputePipelineCreateInfo & operator=( VkComputePipelineCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ComputePipelineCreateInfo const *>( &rhs );
      return *this;
    }

    ComputePipelineCreateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ComputePipelineCreateInfo & setFlags( VULKAN_HPP_NAMESPACE::PipelineCreateFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    ComputePipelineCreateInfo &
      setStage( VULKAN_HPP_NAMESPACE::PipelineShaderStageCreateInfo const & stage_ ) VULKAN_HPP_NOEXCEPT
    {
      stage = stage_;
      return *this;
    }

    ComputePipelineCreateInfo & setLayout( VULKAN_HPP_NAMESPACE::PipelineLayout layout_ ) VULKAN_HPP_NOEXCEPT
    {
      layout = layout_;
      return *this;
    }

    ComputePipelineCreateInfo &
      setBasePipelineHandle( VULKAN_HPP_NAMESPACE::Pipeline basePipelineHandle_ ) VULKAN_HPP_NOEXCEPT
    {
      basePipelineHandle = basePipelineHandle_;
      return *this;
    }

    ComputePipelineCreateInfo & setBasePipelineIndex( int32_t basePipelineIndex_ ) VULKAN_HPP_NOEXCEPT
    {
      basePipelineIndex = basePipelineIndex_;
      return *this;
    }

    operator VkComputePipelineCreateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkComputePipelineCreateInfo *>( this );
    }

    operator VkComputePipelineCreateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkComputePipelineCreateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ComputePipelineCreateInfo const & ) const = default;
#else
    bool operator==( ComputePipelineCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) && ( stage == rhs.stage ) &&
             ( layout == rhs.layout ) && ( basePipelineHandle == rhs.basePipelineHandle ) &&
             ( basePipelineIndex == rhs.basePipelineIndex );
    }

    bool operator!=( ComputePipelineCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                 sType              = StructureType::eComputePipelineCreateInfo;
    const void *                                        pNext              = {};
    VULKAN_HPP_NAMESPACE::PipelineCreateFlags           flags              = {};
    VULKAN_HPP_NAMESPACE::PipelineShaderStageCreateInfo stage              = {};
    VULKAN_HPP_NAMESPACE::PipelineLayout                layout             = {};
    VULKAN_HPP_NAMESPACE::Pipeline                      basePipelineHandle = {};
    int32_t                                             basePipelineIndex  = {};
  };
  static_assert( sizeof( ComputePipelineCreateInfo ) == sizeof( VkComputePipelineCreateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ComputePipelineCreateInfo>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eComputePipelineCreateInfo>
  {
    using Type = ComputePipelineCreateInfo;
  };

  struct ConditionalRenderingBeginInfoEXT
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eConditionalRenderingBeginInfoEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ConditionalRenderingBeginInfoEXT(
      VULKAN_HPP_NAMESPACE::Buffer                       buffer_ = {},
      VULKAN_HPP_NAMESPACE::DeviceSize                   offset_ = {},
      VULKAN_HPP_NAMESPACE::ConditionalRenderingFlagsEXT flags_  = {} ) VULKAN_HPP_NOEXCEPT
      : buffer( buffer_ )
      , offset( offset_ )
      , flags( flags_ )
    {}

    VULKAN_HPP_CONSTEXPR
      ConditionalRenderingBeginInfoEXT( ConditionalRenderingBeginInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ConditionalRenderingBeginInfoEXT( VkConditionalRenderingBeginInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : ConditionalRenderingBeginInfoEXT( *reinterpret_cast<ConditionalRenderingBeginInfoEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ConditionalRenderingBeginInfoEXT &
                            operator=( ConditionalRenderingBeginInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ConditionalRenderingBeginInfoEXT & operator=( VkConditionalRenderingBeginInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ConditionalRenderingBeginInfoEXT const *>( &rhs );
      return *this;
    }

    ConditionalRenderingBeginInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ConditionalRenderingBeginInfoEXT & setBuffer( VULKAN_HPP_NAMESPACE::Buffer buffer_ ) VULKAN_HPP_NOEXCEPT
    {
      buffer = buffer_;
      return *this;
    }

    ConditionalRenderingBeginInfoEXT & setOffset( VULKAN_HPP_NAMESPACE::DeviceSize offset_ ) VULKAN_HPP_NOEXCEPT
    {
      offset = offset_;
      return *this;
    }

    ConditionalRenderingBeginInfoEXT &
      setFlags( VULKAN_HPP_NAMESPACE::ConditionalRenderingFlagsEXT flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    operator VkConditionalRenderingBeginInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkConditionalRenderingBeginInfoEXT *>( this );
    }

    operator VkConditionalRenderingBeginInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkConditionalRenderingBeginInfoEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ConditionalRenderingBeginInfoEXT const & ) const = default;
#else
    bool operator==( ConditionalRenderingBeginInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( buffer == rhs.buffer ) && ( offset == rhs.offset ) &&
             ( flags == rhs.flags );
    }

    bool operator!=( ConditionalRenderingBeginInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                sType  = StructureType::eConditionalRenderingBeginInfoEXT;
    const void *                                       pNext  = {};
    VULKAN_HPP_NAMESPACE::Buffer                       buffer = {};
    VULKAN_HPP_NAMESPACE::DeviceSize                   offset = {};
    VULKAN_HPP_NAMESPACE::ConditionalRenderingFlagsEXT flags  = {};
  };
  static_assert( sizeof( ConditionalRenderingBeginInfoEXT ) == sizeof( VkConditionalRenderingBeginInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ConditionalRenderingBeginInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eConditionalRenderingBeginInfoEXT>
  {
    using Type = ConditionalRenderingBeginInfoEXT;
  };

  struct ConformanceVersion
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ConformanceVersion( uint8_t major_    = {},
                                             uint8_t minor_    = {},
                                             uint8_t subminor_ = {},
                                             uint8_t patch_    = {} ) VULKAN_HPP_NOEXCEPT
      : major( major_ )
      , minor( minor_ )
      , subminor( subminor_ )
      , patch( patch_ )
    {}

    VULKAN_HPP_CONSTEXPR ConformanceVersion( ConformanceVersion const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ConformanceVersion( VkConformanceVersion const & rhs ) VULKAN_HPP_NOEXCEPT
      : ConformanceVersion( *reinterpret_cast<ConformanceVersion const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ConformanceVersion &
                            operator=( ConformanceVersion const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ConformanceVersion & operator=( VkConformanceVersion const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ConformanceVersion const *>( &rhs );
      return *this;
    }

    ConformanceVersion & setMajor( uint8_t major_ ) VULKAN_HPP_NOEXCEPT
    {
      major = major_;
      return *this;
    }

    ConformanceVersion & setMinor( uint8_t minor_ ) VULKAN_HPP_NOEXCEPT
    {
      minor = minor_;
      return *this;
    }

    ConformanceVersion & setSubminor( uint8_t subminor_ ) VULKAN_HPP_NOEXCEPT
    {
      subminor = subminor_;
      return *this;
    }

    ConformanceVersion & setPatch( uint8_t patch_ ) VULKAN_HPP_NOEXCEPT
    {
      patch = patch_;
      return *this;
    }

    operator VkConformanceVersion const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkConformanceVersion *>( this );
    }

    operator VkConformanceVersion &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkConformanceVersion *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ConformanceVersion const & ) const = default;
#else
    bool operator==( ConformanceVersion const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( major == rhs.major ) && ( minor == rhs.minor ) && ( subminor == rhs.subminor ) && ( patch == rhs.patch );
    }

    bool operator!=( ConformanceVersion const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    uint8_t major    = {};
    uint8_t minor    = {};
    uint8_t subminor = {};
    uint8_t patch    = {};
  };
  static_assert( sizeof( ConformanceVersion ) == sizeof( VkConformanceVersion ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ConformanceVersion>::value, "struct wrapper is not a standard layout!" );
  using ConformanceVersionKHR = ConformanceVersion;

  struct CooperativeMatrixPropertiesNV
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eCooperativeMatrixPropertiesNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR CooperativeMatrixPropertiesNV(
      uint32_t                              MSize_ = {},
      uint32_t                              NSize_ = {},
      uint32_t                              KSize_ = {},
      VULKAN_HPP_NAMESPACE::ComponentTypeNV AType_ = VULKAN_HPP_NAMESPACE::ComponentTypeNV::eFloat16,
      VULKAN_HPP_NAMESPACE::ComponentTypeNV BType_ = VULKAN_HPP_NAMESPACE::ComponentTypeNV::eFloat16,
      VULKAN_HPP_NAMESPACE::ComponentTypeNV CType_ = VULKAN_HPP_NAMESPACE::ComponentTypeNV::eFloat16,
      VULKAN_HPP_NAMESPACE::ComponentTypeNV DType_ = VULKAN_HPP_NAMESPACE::ComponentTypeNV::eFloat16,
      VULKAN_HPP_NAMESPACE::ScopeNV         scope_ = VULKAN_HPP_NAMESPACE::ScopeNV::eDevice ) VULKAN_HPP_NOEXCEPT
      : MSize( MSize_ )
      , NSize( NSize_ )
      , KSize( KSize_ )
      , AType( AType_ )
      , BType( BType_ )
      , CType( CType_ )
      , DType( DType_ )
      , scope( scope_ )
    {}

    VULKAN_HPP_CONSTEXPR
      CooperativeMatrixPropertiesNV( CooperativeMatrixPropertiesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    CooperativeMatrixPropertiesNV( VkCooperativeMatrixPropertiesNV const & rhs ) VULKAN_HPP_NOEXCEPT
      : CooperativeMatrixPropertiesNV( *reinterpret_cast<CooperativeMatrixPropertiesNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 CooperativeMatrixPropertiesNV &
                            operator=( CooperativeMatrixPropertiesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    CooperativeMatrixPropertiesNV & operator=( VkCooperativeMatrixPropertiesNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::CooperativeMatrixPropertiesNV const *>( &rhs );
      return *this;
    }

    CooperativeMatrixPropertiesNV & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    CooperativeMatrixPropertiesNV & setMSize( uint32_t MSize_ ) VULKAN_HPP_NOEXCEPT
    {
      MSize = MSize_;
      return *this;
    }

    CooperativeMatrixPropertiesNV & setNSize( uint32_t NSize_ ) VULKAN_HPP_NOEXCEPT
    {
      NSize = NSize_;
      return *this;
    }

    CooperativeMatrixPropertiesNV & setKSize( uint32_t KSize_ ) VULKAN_HPP_NOEXCEPT
    {
      KSize = KSize_;
      return *this;
    }

    CooperativeMatrixPropertiesNV & setAType( VULKAN_HPP_NAMESPACE::ComponentTypeNV AType_ ) VULKAN_HPP_NOEXCEPT
    {
      AType = AType_;
      return *this;
    }

    CooperativeMatrixPropertiesNV & setBType( VULKAN_HPP_NAMESPACE::ComponentTypeNV BType_ ) VULKAN_HPP_NOEXCEPT
    {
      BType = BType_;
      return *this;
    }

    CooperativeMatrixPropertiesNV & setCType( VULKAN_HPP_NAMESPACE::ComponentTypeNV CType_ ) VULKAN_HPP_NOEXCEPT
    {
      CType = CType_;
      return *this;
    }

    CooperativeMatrixPropertiesNV & setDType( VULKAN_HPP_NAMESPACE::ComponentTypeNV DType_ ) VULKAN_HPP_NOEXCEPT
    {
      DType = DType_;
      return *this;
    }

    CooperativeMatrixPropertiesNV & setScope( VULKAN_HPP_NAMESPACE::ScopeNV scope_ ) VULKAN_HPP_NOEXCEPT
    {
      scope = scope_;
      return *this;
    }

    operator VkCooperativeMatrixPropertiesNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkCooperativeMatrixPropertiesNV *>( this );
    }

    operator VkCooperativeMatrixPropertiesNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkCooperativeMatrixPropertiesNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( CooperativeMatrixPropertiesNV const & ) const = default;
#else
    bool operator==( CooperativeMatrixPropertiesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( MSize == rhs.MSize ) && ( NSize == rhs.NSize ) &&
             ( KSize == rhs.KSize ) && ( AType == rhs.AType ) && ( BType == rhs.BType ) && ( CType == rhs.CType ) &&
             ( DType == rhs.DType ) && ( scope == rhs.scope );
    }

    bool operator!=( CooperativeMatrixPropertiesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType   sType = StructureType::eCooperativeMatrixPropertiesNV;
    void *                                pNext = {};
    uint32_t                              MSize = {};
    uint32_t                              NSize = {};
    uint32_t                              KSize = {};
    VULKAN_HPP_NAMESPACE::ComponentTypeNV AType = VULKAN_HPP_NAMESPACE::ComponentTypeNV::eFloat16;
    VULKAN_HPP_NAMESPACE::ComponentTypeNV BType = VULKAN_HPP_NAMESPACE::ComponentTypeNV::eFloat16;
    VULKAN_HPP_NAMESPACE::ComponentTypeNV CType = VULKAN_HPP_NAMESPACE::ComponentTypeNV::eFloat16;
    VULKAN_HPP_NAMESPACE::ComponentTypeNV DType = VULKAN_HPP_NAMESPACE::ComponentTypeNV::eFloat16;
    VULKAN_HPP_NAMESPACE::ScopeNV         scope = VULKAN_HPP_NAMESPACE::ScopeNV::eDevice;
  };
  static_assert( sizeof( CooperativeMatrixPropertiesNV ) == sizeof( VkCooperativeMatrixPropertiesNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<CooperativeMatrixPropertiesNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eCooperativeMatrixPropertiesNV>
  {
    using Type = CooperativeMatrixPropertiesNV;
  };

  struct CopyAccelerationStructureInfoKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eCopyAccelerationStructureInfoKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR CopyAccelerationStructureInfoKHR(
      VULKAN_HPP_NAMESPACE::AccelerationStructureKHR         src_ = {},
      VULKAN_HPP_NAMESPACE::AccelerationStructureKHR         dst_ = {},
      VULKAN_HPP_NAMESPACE::CopyAccelerationStructureModeKHR mode_ =
        VULKAN_HPP_NAMESPACE::CopyAccelerationStructureModeKHR::eClone ) VULKAN_HPP_NOEXCEPT
      : src( src_ )
      , dst( dst_ )
      , mode( mode_ )
    {}

    VULKAN_HPP_CONSTEXPR
      CopyAccelerationStructureInfoKHR( CopyAccelerationStructureInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    CopyAccelerationStructureInfoKHR( VkCopyAccelerationStructureInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : CopyAccelerationStructureInfoKHR( *reinterpret_cast<CopyAccelerationStructureInfoKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 CopyAccelerationStructureInfoKHR &
                            operator=( CopyAccelerationStructureInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    CopyAccelerationStructureInfoKHR & operator=( VkCopyAccelerationStructureInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::CopyAccelerationStructureInfoKHR const *>( &rhs );
      return *this;
    }

    CopyAccelerationStructureInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    CopyAccelerationStructureInfoKHR & setSrc( VULKAN_HPP_NAMESPACE::AccelerationStructureKHR src_ ) VULKAN_HPP_NOEXCEPT
    {
      src = src_;
      return *this;
    }

    CopyAccelerationStructureInfoKHR & setDst( VULKAN_HPP_NAMESPACE::AccelerationStructureKHR dst_ ) VULKAN_HPP_NOEXCEPT
    {
      dst = dst_;
      return *this;
    }

    CopyAccelerationStructureInfoKHR &
      setMode( VULKAN_HPP_NAMESPACE::CopyAccelerationStructureModeKHR mode_ ) VULKAN_HPP_NOEXCEPT
    {
      mode = mode_;
      return *this;
    }

    operator VkCopyAccelerationStructureInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkCopyAccelerationStructureInfoKHR *>( this );
    }

    operator VkCopyAccelerationStructureInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkCopyAccelerationStructureInfoKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( CopyAccelerationStructureInfoKHR const & ) const = default;
#else
    bool operator==( CopyAccelerationStructureInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( src == rhs.src ) && ( dst == rhs.dst ) &&
             ( mode == rhs.mode );
    }

    bool operator!=( CopyAccelerationStructureInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                    sType = StructureType::eCopyAccelerationStructureInfoKHR;
    const void *                                           pNext = {};
    VULKAN_HPP_NAMESPACE::AccelerationStructureKHR         src   = {};
    VULKAN_HPP_NAMESPACE::AccelerationStructureKHR         dst   = {};
    VULKAN_HPP_NAMESPACE::CopyAccelerationStructureModeKHR mode =
      VULKAN_HPP_NAMESPACE::CopyAccelerationStructureModeKHR::eClone;
  };
  static_assert( sizeof( CopyAccelerationStructureInfoKHR ) == sizeof( VkCopyAccelerationStructureInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<CopyAccelerationStructureInfoKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eCopyAccelerationStructureInfoKHR>
  {
    using Type = CopyAccelerationStructureInfoKHR;
  };

  struct CopyAccelerationStructureToMemoryInfoKHR
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eCopyAccelerationStructureToMemoryInfoKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    CopyAccelerationStructureToMemoryInfoKHR( VULKAN_HPP_NAMESPACE::AccelerationStructureKHR         src_ = {},
                                              VULKAN_HPP_NAMESPACE::DeviceOrHostAddressKHR           dst_ = {},
                                              VULKAN_HPP_NAMESPACE::CopyAccelerationStructureModeKHR mode_ =
                                                VULKAN_HPP_NAMESPACE::CopyAccelerationStructureModeKHR::eClone )
      VULKAN_HPP_NOEXCEPT
      : src( src_ )
      , dst( dst_ )
      , mode( mode_ )
    {}

    CopyAccelerationStructureToMemoryInfoKHR( CopyAccelerationStructureToMemoryInfoKHR const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    CopyAccelerationStructureToMemoryInfoKHR( VkCopyAccelerationStructureToMemoryInfoKHR const & rhs )
      VULKAN_HPP_NOEXCEPT
      : CopyAccelerationStructureToMemoryInfoKHR(
          *reinterpret_cast<CopyAccelerationStructureToMemoryInfoKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    CopyAccelerationStructureToMemoryInfoKHR &
      operator=( CopyAccelerationStructureToMemoryInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    CopyAccelerationStructureToMemoryInfoKHR &
      operator=( VkCopyAccelerationStructureToMemoryInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::CopyAccelerationStructureToMemoryInfoKHR const *>( &rhs );
      return *this;
    }

    CopyAccelerationStructureToMemoryInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    CopyAccelerationStructureToMemoryInfoKHR &
      setSrc( VULKAN_HPP_NAMESPACE::AccelerationStructureKHR src_ ) VULKAN_HPP_NOEXCEPT
    {
      src = src_;
      return *this;
    }

    CopyAccelerationStructureToMemoryInfoKHR &
      setDst( VULKAN_HPP_NAMESPACE::DeviceOrHostAddressKHR const & dst_ ) VULKAN_HPP_NOEXCEPT
    {
      dst = dst_;
      return *this;
    }

    CopyAccelerationStructureToMemoryInfoKHR &
      setMode( VULKAN_HPP_NAMESPACE::CopyAccelerationStructureModeKHR mode_ ) VULKAN_HPP_NOEXCEPT
    {
      mode = mode_;
      return *this;
    }

    operator VkCopyAccelerationStructureToMemoryInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkCopyAccelerationStructureToMemoryInfoKHR *>( this );
    }

    operator VkCopyAccelerationStructureToMemoryInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkCopyAccelerationStructureToMemoryInfoKHR *>( this );
    }

  public:
    VULKAN_HPP_NAMESPACE::StructureType            sType = StructureType::eCopyAccelerationStructureToMemoryInfoKHR;
    const void *                                   pNext = {};
    VULKAN_HPP_NAMESPACE::AccelerationStructureKHR src   = {};
    VULKAN_HPP_NAMESPACE::DeviceOrHostAddressKHR   dst   = {};
    VULKAN_HPP_NAMESPACE::CopyAccelerationStructureModeKHR mode =
      VULKAN_HPP_NAMESPACE::CopyAccelerationStructureModeKHR::eClone;
  };
  static_assert( sizeof( CopyAccelerationStructureToMemoryInfoKHR ) ==
                   sizeof( VkCopyAccelerationStructureToMemoryInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<CopyAccelerationStructureToMemoryInfoKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eCopyAccelerationStructureToMemoryInfoKHR>
  {
    using Type = CopyAccelerationStructureToMemoryInfoKHR;
  };

  struct CopyBufferInfo2KHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eCopyBufferInfo2KHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      CopyBufferInfo2KHR( VULKAN_HPP_NAMESPACE::Buffer                 srcBuffer_   = {},
                          VULKAN_HPP_NAMESPACE::Buffer                 dstBuffer_   = {},
                          uint32_t                                     regionCount_ = {},
                          const VULKAN_HPP_NAMESPACE::BufferCopy2KHR * pRegions_    = {} ) VULKAN_HPP_NOEXCEPT
      : srcBuffer( srcBuffer_ )
      , dstBuffer( dstBuffer_ )
      , regionCount( regionCount_ )
      , pRegions( pRegions_ )
    {}

    VULKAN_HPP_CONSTEXPR CopyBufferInfo2KHR( CopyBufferInfo2KHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    CopyBufferInfo2KHR( VkCopyBufferInfo2KHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : CopyBufferInfo2KHR( *reinterpret_cast<CopyBufferInfo2KHR const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    CopyBufferInfo2KHR(
      VULKAN_HPP_NAMESPACE::Buffer                                                                      srcBuffer_,
      VULKAN_HPP_NAMESPACE::Buffer                                                                      dstBuffer_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::BufferCopy2KHR> const & regions_ )
      : srcBuffer( srcBuffer_ )
      , dstBuffer( dstBuffer_ )
      , regionCount( static_cast<uint32_t>( regions_.size() ) )
      , pRegions( regions_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 CopyBufferInfo2KHR &
                            operator=( CopyBufferInfo2KHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    CopyBufferInfo2KHR & operator=( VkCopyBufferInfo2KHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::CopyBufferInfo2KHR const *>( &rhs );
      return *this;
    }

    CopyBufferInfo2KHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    CopyBufferInfo2KHR & setSrcBuffer( VULKAN_HPP_NAMESPACE::Buffer srcBuffer_ ) VULKAN_HPP_NOEXCEPT
    {
      srcBuffer = srcBuffer_;
      return *this;
    }

    CopyBufferInfo2KHR & setDstBuffer( VULKAN_HPP_NAMESPACE::Buffer dstBuffer_ ) VULKAN_HPP_NOEXCEPT
    {
      dstBuffer = dstBuffer_;
      return *this;
    }

    CopyBufferInfo2KHR & setRegionCount( uint32_t regionCount_ ) VULKAN_HPP_NOEXCEPT
    {
      regionCount = regionCount_;
      return *this;
    }

    CopyBufferInfo2KHR & setPRegions( const VULKAN_HPP_NAMESPACE::BufferCopy2KHR * pRegions_ ) VULKAN_HPP_NOEXCEPT
    {
      pRegions = pRegions_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    CopyBufferInfo2KHR & setRegions(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::BufferCopy2KHR> const & regions_ )
      VULKAN_HPP_NOEXCEPT
    {
      regionCount = static_cast<uint32_t>( regions_.size() );
      pRegions    = regions_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkCopyBufferInfo2KHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkCopyBufferInfo2KHR *>( this );
    }

    operator VkCopyBufferInfo2KHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkCopyBufferInfo2KHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( CopyBufferInfo2KHR const & ) const = default;
#else
    bool operator==( CopyBufferInfo2KHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( srcBuffer == rhs.srcBuffer ) &&
             ( dstBuffer == rhs.dstBuffer ) && ( regionCount == rhs.regionCount ) && ( pRegions == rhs.pRegions );
    }

    bool operator!=( CopyBufferInfo2KHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType          sType       = StructureType::eCopyBufferInfo2KHR;
    const void *                                 pNext       = {};
    VULKAN_HPP_NAMESPACE::Buffer                 srcBuffer   = {};
    VULKAN_HPP_NAMESPACE::Buffer                 dstBuffer   = {};
    uint32_t                                     regionCount = {};
    const VULKAN_HPP_NAMESPACE::BufferCopy2KHR * pRegions    = {};
  };
  static_assert( sizeof( CopyBufferInfo2KHR ) == sizeof( VkCopyBufferInfo2KHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<CopyBufferInfo2KHR>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eCopyBufferInfo2KHR>
  {
    using Type = CopyBufferInfo2KHR;
  };

  struct CopyBufferToImageInfo2KHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eCopyBufferToImageInfo2KHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR CopyBufferToImageInfo2KHR(
      VULKAN_HPP_NAMESPACE::Buffer                      srcBuffer_      = {},
      VULKAN_HPP_NAMESPACE::Image                       dstImage_       = {},
      VULKAN_HPP_NAMESPACE::ImageLayout                 dstImageLayout_ = VULKAN_HPP_NAMESPACE::ImageLayout::eUndefined,
      uint32_t                                          regionCount_    = {},
      const VULKAN_HPP_NAMESPACE::BufferImageCopy2KHR * pRegions_       = {} ) VULKAN_HPP_NOEXCEPT
      : srcBuffer( srcBuffer_ )
      , dstImage( dstImage_ )
      , dstImageLayout( dstImageLayout_ )
      , regionCount( regionCount_ )
      , pRegions( pRegions_ )
    {}

    VULKAN_HPP_CONSTEXPR
      CopyBufferToImageInfo2KHR( CopyBufferToImageInfo2KHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    CopyBufferToImageInfo2KHR( VkCopyBufferToImageInfo2KHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : CopyBufferToImageInfo2KHR( *reinterpret_cast<CopyBufferToImageInfo2KHR const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    CopyBufferToImageInfo2KHR(
      VULKAN_HPP_NAMESPACE::Buffer      srcBuffer_,
      VULKAN_HPP_NAMESPACE::Image       dstImage_,
      VULKAN_HPP_NAMESPACE::ImageLayout dstImageLayout_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::BufferImageCopy2KHR> const & regions_ )
      : srcBuffer( srcBuffer_ )
      , dstImage( dstImage_ )
      , dstImageLayout( dstImageLayout_ )
      , regionCount( static_cast<uint32_t>( regions_.size() ) )
      , pRegions( regions_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 CopyBufferToImageInfo2KHR &
                            operator=( CopyBufferToImageInfo2KHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    CopyBufferToImageInfo2KHR & operator=( VkCopyBufferToImageInfo2KHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::CopyBufferToImageInfo2KHR const *>( &rhs );
      return *this;
    }

    CopyBufferToImageInfo2KHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    CopyBufferToImageInfo2KHR & setSrcBuffer( VULKAN_HPP_NAMESPACE::Buffer srcBuffer_ ) VULKAN_HPP_NOEXCEPT
    {
      srcBuffer = srcBuffer_;
      return *this;
    }

    CopyBufferToImageInfo2KHR & setDstImage( VULKAN_HPP_NAMESPACE::Image dstImage_ ) VULKAN_HPP_NOEXCEPT
    {
      dstImage = dstImage_;
      return *this;
    }

    CopyBufferToImageInfo2KHR &
      setDstImageLayout( VULKAN_HPP_NAMESPACE::ImageLayout dstImageLayout_ ) VULKAN_HPP_NOEXCEPT
    {
      dstImageLayout = dstImageLayout_;
      return *this;
    }

    CopyBufferToImageInfo2KHR & setRegionCount( uint32_t regionCount_ ) VULKAN_HPP_NOEXCEPT
    {
      regionCount = regionCount_;
      return *this;
    }

    CopyBufferToImageInfo2KHR &
      setPRegions( const VULKAN_HPP_NAMESPACE::BufferImageCopy2KHR * pRegions_ ) VULKAN_HPP_NOEXCEPT
    {
      pRegions = pRegions_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    CopyBufferToImageInfo2KHR & setRegions(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::BufferImageCopy2KHR> const & regions_ )
      VULKAN_HPP_NOEXCEPT
    {
      regionCount = static_cast<uint32_t>( regions_.size() );
      pRegions    = regions_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkCopyBufferToImageInfo2KHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkCopyBufferToImageInfo2KHR *>( this );
    }

    operator VkCopyBufferToImageInfo2KHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkCopyBufferToImageInfo2KHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( CopyBufferToImageInfo2KHR const & ) const = default;
#else
    bool operator==( CopyBufferToImageInfo2KHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( srcBuffer == rhs.srcBuffer ) &&
             ( dstImage == rhs.dstImage ) && ( dstImageLayout == rhs.dstImageLayout ) &&
             ( regionCount == rhs.regionCount ) && ( pRegions == rhs.pRegions );
    }

    bool operator!=( CopyBufferToImageInfo2KHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType               sType          = StructureType::eCopyBufferToImageInfo2KHR;
    const void *                                      pNext          = {};
    VULKAN_HPP_NAMESPACE::Buffer                      srcBuffer      = {};
    VULKAN_HPP_NAMESPACE::Image                       dstImage       = {};
    VULKAN_HPP_NAMESPACE::ImageLayout                 dstImageLayout = VULKAN_HPP_NAMESPACE::ImageLayout::eUndefined;
    uint32_t                                          regionCount    = {};
    const VULKAN_HPP_NAMESPACE::BufferImageCopy2KHR * pRegions       = {};
  };
  static_assert( sizeof( CopyBufferToImageInfo2KHR ) == sizeof( VkCopyBufferToImageInfo2KHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<CopyBufferToImageInfo2KHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eCopyBufferToImageInfo2KHR>
  {
    using Type = CopyBufferToImageInfo2KHR;
  };

  struct CopyCommandTransformInfoQCOM
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eCopyCommandTransformInfoQCOM;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      CopyCommandTransformInfoQCOM( VULKAN_HPP_NAMESPACE::SurfaceTransformFlagBitsKHR transform_ =
                                      VULKAN_HPP_NAMESPACE::SurfaceTransformFlagBitsKHR::eIdentity ) VULKAN_HPP_NOEXCEPT
      : transform( transform_ )
    {}

    VULKAN_HPP_CONSTEXPR
      CopyCommandTransformInfoQCOM( CopyCommandTransformInfoQCOM const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    CopyCommandTransformInfoQCOM( VkCopyCommandTransformInfoQCOM const & rhs ) VULKAN_HPP_NOEXCEPT
      : CopyCommandTransformInfoQCOM( *reinterpret_cast<CopyCommandTransformInfoQCOM const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 CopyCommandTransformInfoQCOM &
                            operator=( CopyCommandTransformInfoQCOM const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    CopyCommandTransformInfoQCOM & operator=( VkCopyCommandTransformInfoQCOM const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::CopyCommandTransformInfoQCOM const *>( &rhs );
      return *this;
    }

    CopyCommandTransformInfoQCOM & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    CopyCommandTransformInfoQCOM &
      setTransform( VULKAN_HPP_NAMESPACE::SurfaceTransformFlagBitsKHR transform_ ) VULKAN_HPP_NOEXCEPT
    {
      transform = transform_;
      return *this;
    }

    operator VkCopyCommandTransformInfoQCOM const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkCopyCommandTransformInfoQCOM *>( this );
    }

    operator VkCopyCommandTransformInfoQCOM &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkCopyCommandTransformInfoQCOM *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( CopyCommandTransformInfoQCOM const & ) const = default;
#else
    bool operator==( CopyCommandTransformInfoQCOM const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( transform == rhs.transform );
    }

    bool operator!=( CopyCommandTransformInfoQCOM const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType               sType = StructureType::eCopyCommandTransformInfoQCOM;
    const void *                                      pNext = {};
    VULKAN_HPP_NAMESPACE::SurfaceTransformFlagBitsKHR transform =
      VULKAN_HPP_NAMESPACE::SurfaceTransformFlagBitsKHR::eIdentity;
  };
  static_assert( sizeof( CopyCommandTransformInfoQCOM ) == sizeof( VkCopyCommandTransformInfoQCOM ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<CopyCommandTransformInfoQCOM>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eCopyCommandTransformInfoQCOM>
  {
    using Type = CopyCommandTransformInfoQCOM;
  };

  struct CopyDescriptorSet
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eCopyDescriptorSet;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR CopyDescriptorSet( VULKAN_HPP_NAMESPACE::DescriptorSet srcSet_          = {},
                                            uint32_t                            srcBinding_      = {},
                                            uint32_t                            srcArrayElement_ = {},
                                            VULKAN_HPP_NAMESPACE::DescriptorSet dstSet_          = {},
                                            uint32_t                            dstBinding_      = {},
                                            uint32_t                            dstArrayElement_ = {},
                                            uint32_t descriptorCount_ = {} ) VULKAN_HPP_NOEXCEPT
      : srcSet( srcSet_ )
      , srcBinding( srcBinding_ )
      , srcArrayElement( srcArrayElement_ )
      , dstSet( dstSet_ )
      , dstBinding( dstBinding_ )
      , dstArrayElement( dstArrayElement_ )
      , descriptorCount( descriptorCount_ )
    {}

    VULKAN_HPP_CONSTEXPR CopyDescriptorSet( CopyDescriptorSet const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    CopyDescriptorSet( VkCopyDescriptorSet const & rhs ) VULKAN_HPP_NOEXCEPT
      : CopyDescriptorSet( *reinterpret_cast<CopyDescriptorSet const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 CopyDescriptorSet &
                            operator=( CopyDescriptorSet const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    CopyDescriptorSet & operator=( VkCopyDescriptorSet const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::CopyDescriptorSet const *>( &rhs );
      return *this;
    }

    CopyDescriptorSet & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    CopyDescriptorSet & setSrcSet( VULKAN_HPP_NAMESPACE::DescriptorSet srcSet_ ) VULKAN_HPP_NOEXCEPT
    {
      srcSet = srcSet_;
      return *this;
    }

    CopyDescriptorSet & setSrcBinding( uint32_t srcBinding_ ) VULKAN_HPP_NOEXCEPT
    {
      srcBinding = srcBinding_;
      return *this;
    }

    CopyDescriptorSet & setSrcArrayElement( uint32_t srcArrayElement_ ) VULKAN_HPP_NOEXCEPT
    {
      srcArrayElement = srcArrayElement_;
      return *this;
    }

    CopyDescriptorSet & setDstSet( VULKAN_HPP_NAMESPACE::DescriptorSet dstSet_ ) VULKAN_HPP_NOEXCEPT
    {
      dstSet = dstSet_;
      return *this;
    }

    CopyDescriptorSet & setDstBinding( uint32_t dstBinding_ ) VULKAN_HPP_NOEXCEPT
    {
      dstBinding = dstBinding_;
      return *this;
    }

    CopyDescriptorSet & setDstArrayElement( uint32_t dstArrayElement_ ) VULKAN_HPP_NOEXCEPT
    {
      dstArrayElement = dstArrayElement_;
      return *this;
    }

    CopyDescriptorSet & setDescriptorCount( uint32_t descriptorCount_ ) VULKAN_HPP_NOEXCEPT
    {
      descriptorCount = descriptorCount_;
      return *this;
    }

    operator VkCopyDescriptorSet const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkCopyDescriptorSet *>( this );
    }

    operator VkCopyDescriptorSet &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkCopyDescriptorSet *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( CopyDescriptorSet const & ) const = default;
#else
    bool operator==( CopyDescriptorSet const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( srcSet == rhs.srcSet ) &&
             ( srcBinding == rhs.srcBinding ) && ( srcArrayElement == rhs.srcArrayElement ) &&
             ( dstSet == rhs.dstSet ) && ( dstBinding == rhs.dstBinding ) &&
             ( dstArrayElement == rhs.dstArrayElement ) && ( descriptorCount == rhs.descriptorCount );
    }

    bool operator!=( CopyDescriptorSet const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType           = StructureType::eCopyDescriptorSet;
    const void *                        pNext           = {};
    VULKAN_HPP_NAMESPACE::DescriptorSet srcSet          = {};
    uint32_t                            srcBinding      = {};
    uint32_t                            srcArrayElement = {};
    VULKAN_HPP_NAMESPACE::DescriptorSet dstSet          = {};
    uint32_t                            dstBinding      = {};
    uint32_t                            dstArrayElement = {};
    uint32_t                            descriptorCount = {};
  };
  static_assert( sizeof( CopyDescriptorSet ) == sizeof( VkCopyDescriptorSet ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<CopyDescriptorSet>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eCopyDescriptorSet>
  {
    using Type = CopyDescriptorSet;
  };

  struct ImageCopy2KHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eImageCopy2KHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ImageCopy2KHR( VULKAN_HPP_NAMESPACE::ImageSubresourceLayers srcSubresource_ = {},
                                        VULKAN_HPP_NAMESPACE::Offset3D               srcOffset_      = {},
                                        VULKAN_HPP_NAMESPACE::ImageSubresourceLayers dstSubresource_ = {},
                                        VULKAN_HPP_NAMESPACE::Offset3D               dstOffset_      = {},
                                        VULKAN_HPP_NAMESPACE::Extent3D               extent_ = {} ) VULKAN_HPP_NOEXCEPT
      : srcSubresource( srcSubresource_ )
      , srcOffset( srcOffset_ )
      , dstSubresource( dstSubresource_ )
      , dstOffset( dstOffset_ )
      , extent( extent_ )
    {}

    VULKAN_HPP_CONSTEXPR ImageCopy2KHR( ImageCopy2KHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImageCopy2KHR( VkImageCopy2KHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : ImageCopy2KHR( *reinterpret_cast<ImageCopy2KHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ImageCopy2KHR & operator=( ImageCopy2KHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImageCopy2KHR & operator=( VkImageCopy2KHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ImageCopy2KHR const *>( &rhs );
      return *this;
    }

    ImageCopy2KHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ImageCopy2KHR &
      setSrcSubresource( VULKAN_HPP_NAMESPACE::ImageSubresourceLayers const & srcSubresource_ ) VULKAN_HPP_NOEXCEPT
    {
      srcSubresource = srcSubresource_;
      return *this;
    }

    ImageCopy2KHR & setSrcOffset( VULKAN_HPP_NAMESPACE::Offset3D const & srcOffset_ ) VULKAN_HPP_NOEXCEPT
    {
      srcOffset = srcOffset_;
      return *this;
    }

    ImageCopy2KHR &
      setDstSubresource( VULKAN_HPP_NAMESPACE::ImageSubresourceLayers const & dstSubresource_ ) VULKAN_HPP_NOEXCEPT
    {
      dstSubresource = dstSubresource_;
      return *this;
    }

    ImageCopy2KHR & setDstOffset( VULKAN_HPP_NAMESPACE::Offset3D const & dstOffset_ ) VULKAN_HPP_NOEXCEPT
    {
      dstOffset = dstOffset_;
      return *this;
    }

    ImageCopy2KHR & setExtent( VULKAN_HPP_NAMESPACE::Extent3D const & extent_ ) VULKAN_HPP_NOEXCEPT
    {
      extent = extent_;
      return *this;
    }

    operator VkImageCopy2KHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkImageCopy2KHR *>( this );
    }

    operator VkImageCopy2KHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkImageCopy2KHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ImageCopy2KHR const & ) const = default;
#else
    bool operator==( ImageCopy2KHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( srcSubresource == rhs.srcSubresource ) &&
             ( srcOffset == rhs.srcOffset ) && ( dstSubresource == rhs.dstSubresource ) &&
             ( dstOffset == rhs.dstOffset ) && ( extent == rhs.extent );
    }

    bool operator!=( ImageCopy2KHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType          sType          = StructureType::eImageCopy2KHR;
    const void *                                 pNext          = {};
    VULKAN_HPP_NAMESPACE::ImageSubresourceLayers srcSubresource = {};
    VULKAN_HPP_NAMESPACE::Offset3D               srcOffset      = {};
    VULKAN_HPP_NAMESPACE::ImageSubresourceLayers dstSubresource = {};
    VULKAN_HPP_NAMESPACE::Offset3D               dstOffset      = {};
    VULKAN_HPP_NAMESPACE::Extent3D               extent         = {};
  };
  static_assert( sizeof( ImageCopy2KHR ) == sizeof( VkImageCopy2KHR ), "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ImageCopy2KHR>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eImageCopy2KHR>
  {
    using Type = ImageCopy2KHR;
  };

  struct CopyImageInfo2KHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eCopyImageInfo2KHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR CopyImageInfo2KHR(
      VULKAN_HPP_NAMESPACE::Image                 srcImage_       = {},
      VULKAN_HPP_NAMESPACE::ImageLayout           srcImageLayout_ = VULKAN_HPP_NAMESPACE::ImageLayout::eUndefined,
      VULKAN_HPP_NAMESPACE::Image                 dstImage_       = {},
      VULKAN_HPP_NAMESPACE::ImageLayout           dstImageLayout_ = VULKAN_HPP_NAMESPACE::ImageLayout::eUndefined,
      uint32_t                                    regionCount_    = {},
      const VULKAN_HPP_NAMESPACE::ImageCopy2KHR * pRegions_       = {} ) VULKAN_HPP_NOEXCEPT
      : srcImage( srcImage_ )
      , srcImageLayout( srcImageLayout_ )
      , dstImage( dstImage_ )
      , dstImageLayout( dstImageLayout_ )
      , regionCount( regionCount_ )
      , pRegions( pRegions_ )
    {}

    VULKAN_HPP_CONSTEXPR CopyImageInfo2KHR( CopyImageInfo2KHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    CopyImageInfo2KHR( VkCopyImageInfo2KHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : CopyImageInfo2KHR( *reinterpret_cast<CopyImageInfo2KHR const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    CopyImageInfo2KHR(
      VULKAN_HPP_NAMESPACE::Image                                                                      srcImage_,
      VULKAN_HPP_NAMESPACE::ImageLayout                                                                srcImageLayout_,
      VULKAN_HPP_NAMESPACE::Image                                                                      dstImage_,
      VULKAN_HPP_NAMESPACE::ImageLayout                                                                dstImageLayout_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::ImageCopy2KHR> const & regions_ )
      : srcImage( srcImage_ )
      , srcImageLayout( srcImageLayout_ )
      , dstImage( dstImage_ )
      , dstImageLayout( dstImageLayout_ )
      , regionCount( static_cast<uint32_t>( regions_.size() ) )
      , pRegions( regions_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 CopyImageInfo2KHR &
                            operator=( CopyImageInfo2KHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    CopyImageInfo2KHR & operator=( VkCopyImageInfo2KHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::CopyImageInfo2KHR const *>( &rhs );
      return *this;
    }

    CopyImageInfo2KHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    CopyImageInfo2KHR & setSrcImage( VULKAN_HPP_NAMESPACE::Image srcImage_ ) VULKAN_HPP_NOEXCEPT
    {
      srcImage = srcImage_;
      return *this;
    }

    CopyImageInfo2KHR & setSrcImageLayout( VULKAN_HPP_NAMESPACE::ImageLayout srcImageLayout_ ) VULKAN_HPP_NOEXCEPT
    {
      srcImageLayout = srcImageLayout_;
      return *this;
    }

    CopyImageInfo2KHR & setDstImage( VULKAN_HPP_NAMESPACE::Image dstImage_ ) VULKAN_HPP_NOEXCEPT
    {
      dstImage = dstImage_;
      return *this;
    }

    CopyImageInfo2KHR & setDstImageLayout( VULKAN_HPP_NAMESPACE::ImageLayout dstImageLayout_ ) VULKAN_HPP_NOEXCEPT
    {
      dstImageLayout = dstImageLayout_;
      return *this;
    }

    CopyImageInfo2KHR & setRegionCount( uint32_t regionCount_ ) VULKAN_HPP_NOEXCEPT
    {
      regionCount = regionCount_;
      return *this;
    }

    CopyImageInfo2KHR & setPRegions( const VULKAN_HPP_NAMESPACE::ImageCopy2KHR * pRegions_ ) VULKAN_HPP_NOEXCEPT
    {
      pRegions = pRegions_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    CopyImageInfo2KHR & setRegions(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::ImageCopy2KHR> const & regions_ )
      VULKAN_HPP_NOEXCEPT
    {
      regionCount = static_cast<uint32_t>( regions_.size() );
      pRegions    = regions_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkCopyImageInfo2KHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkCopyImageInfo2KHR *>( this );
    }

    operator VkCopyImageInfo2KHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkCopyImageInfo2KHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( CopyImageInfo2KHR const & ) const = default;
#else
    bool operator==( CopyImageInfo2KHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( srcImage == rhs.srcImage ) &&
             ( srcImageLayout == rhs.srcImageLayout ) && ( dstImage == rhs.dstImage ) &&
             ( dstImageLayout == rhs.dstImageLayout ) && ( regionCount == rhs.regionCount ) &&
             ( pRegions == rhs.pRegions );
    }

    bool operator!=( CopyImageInfo2KHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType         sType          = StructureType::eCopyImageInfo2KHR;
    const void *                                pNext          = {};
    VULKAN_HPP_NAMESPACE::Image                 srcImage       = {};
    VULKAN_HPP_NAMESPACE::ImageLayout           srcImageLayout = VULKAN_HPP_NAMESPACE::ImageLayout::eUndefined;
    VULKAN_HPP_NAMESPACE::Image                 dstImage       = {};
    VULKAN_HPP_NAMESPACE::ImageLayout           dstImageLayout = VULKAN_HPP_NAMESPACE::ImageLayout::eUndefined;
    uint32_t                                    regionCount    = {};
    const VULKAN_HPP_NAMESPACE::ImageCopy2KHR * pRegions       = {};
  };
  static_assert( sizeof( CopyImageInfo2KHR ) == sizeof( VkCopyImageInfo2KHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<CopyImageInfo2KHR>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eCopyImageInfo2KHR>
  {
    using Type = CopyImageInfo2KHR;
  };

  struct CopyImageToBufferInfo2KHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eCopyImageToBufferInfo2KHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR CopyImageToBufferInfo2KHR(
      VULKAN_HPP_NAMESPACE::Image                       srcImage_       = {},
      VULKAN_HPP_NAMESPACE::ImageLayout                 srcImageLayout_ = VULKAN_HPP_NAMESPACE::ImageLayout::eUndefined,
      VULKAN_HPP_NAMESPACE::Buffer                      dstBuffer_      = {},
      uint32_t                                          regionCount_    = {},
      const VULKAN_HPP_NAMESPACE::BufferImageCopy2KHR * pRegions_       = {} ) VULKAN_HPP_NOEXCEPT
      : srcImage( srcImage_ )
      , srcImageLayout( srcImageLayout_ )
      , dstBuffer( dstBuffer_ )
      , regionCount( regionCount_ )
      , pRegions( pRegions_ )
    {}

    VULKAN_HPP_CONSTEXPR
      CopyImageToBufferInfo2KHR( CopyImageToBufferInfo2KHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    CopyImageToBufferInfo2KHR( VkCopyImageToBufferInfo2KHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : CopyImageToBufferInfo2KHR( *reinterpret_cast<CopyImageToBufferInfo2KHR const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    CopyImageToBufferInfo2KHR(
      VULKAN_HPP_NAMESPACE::Image       srcImage_,
      VULKAN_HPP_NAMESPACE::ImageLayout srcImageLayout_,
      VULKAN_HPP_NAMESPACE::Buffer      dstBuffer_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::BufferImageCopy2KHR> const & regions_ )
      : srcImage( srcImage_ )
      , srcImageLayout( srcImageLayout_ )
      , dstBuffer( dstBuffer_ )
      , regionCount( static_cast<uint32_t>( regions_.size() ) )
      , pRegions( regions_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 CopyImageToBufferInfo2KHR &
                            operator=( CopyImageToBufferInfo2KHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    CopyImageToBufferInfo2KHR & operator=( VkCopyImageToBufferInfo2KHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::CopyImageToBufferInfo2KHR const *>( &rhs );
      return *this;
    }

    CopyImageToBufferInfo2KHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    CopyImageToBufferInfo2KHR & setSrcImage( VULKAN_HPP_NAMESPACE::Image srcImage_ ) VULKAN_HPP_NOEXCEPT
    {
      srcImage = srcImage_;
      return *this;
    }

    CopyImageToBufferInfo2KHR &
      setSrcImageLayout( VULKAN_HPP_NAMESPACE::ImageLayout srcImageLayout_ ) VULKAN_HPP_NOEXCEPT
    {
      srcImageLayout = srcImageLayout_;
      return *this;
    }

    CopyImageToBufferInfo2KHR & setDstBuffer( VULKAN_HPP_NAMESPACE::Buffer dstBuffer_ ) VULKAN_HPP_NOEXCEPT
    {
      dstBuffer = dstBuffer_;
      return *this;
    }

    CopyImageToBufferInfo2KHR & setRegionCount( uint32_t regionCount_ ) VULKAN_HPP_NOEXCEPT
    {
      regionCount = regionCount_;
      return *this;
    }

    CopyImageToBufferInfo2KHR &
      setPRegions( const VULKAN_HPP_NAMESPACE::BufferImageCopy2KHR * pRegions_ ) VULKAN_HPP_NOEXCEPT
    {
      pRegions = pRegions_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    CopyImageToBufferInfo2KHR & setRegions(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::BufferImageCopy2KHR> const & regions_ )
      VULKAN_HPP_NOEXCEPT
    {
      regionCount = static_cast<uint32_t>( regions_.size() );
      pRegions    = regions_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkCopyImageToBufferInfo2KHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkCopyImageToBufferInfo2KHR *>( this );
    }

    operator VkCopyImageToBufferInfo2KHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkCopyImageToBufferInfo2KHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( CopyImageToBufferInfo2KHR const & ) const = default;
#else
    bool operator==( CopyImageToBufferInfo2KHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( srcImage == rhs.srcImage ) &&
             ( srcImageLayout == rhs.srcImageLayout ) && ( dstBuffer == rhs.dstBuffer ) &&
             ( regionCount == rhs.regionCount ) && ( pRegions == rhs.pRegions );
    }

    bool operator!=( CopyImageToBufferInfo2KHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType               sType          = StructureType::eCopyImageToBufferInfo2KHR;
    const void *                                      pNext          = {};
    VULKAN_HPP_NAMESPACE::Image                       srcImage       = {};
    VULKAN_HPP_NAMESPACE::ImageLayout                 srcImageLayout = VULKAN_HPP_NAMESPACE::ImageLayout::eUndefined;
    VULKAN_HPP_NAMESPACE::Buffer                      dstBuffer      = {};
    uint32_t                                          regionCount    = {};
    const VULKAN_HPP_NAMESPACE::BufferImageCopy2KHR * pRegions       = {};
  };
  static_assert( sizeof( CopyImageToBufferInfo2KHR ) == sizeof( VkCopyImageToBufferInfo2KHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<CopyImageToBufferInfo2KHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eCopyImageToBufferInfo2KHR>
  {
    using Type = CopyImageToBufferInfo2KHR;
  };

  struct CopyMemoryToAccelerationStructureInfoKHR
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eCopyMemoryToAccelerationStructureInfoKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    CopyMemoryToAccelerationStructureInfoKHR( VULKAN_HPP_NAMESPACE::DeviceOrHostAddressConstKHR      src_ = {},
                                              VULKAN_HPP_NAMESPACE::AccelerationStructureKHR         dst_ = {},
                                              VULKAN_HPP_NAMESPACE::CopyAccelerationStructureModeKHR mode_ =
                                                VULKAN_HPP_NAMESPACE::CopyAccelerationStructureModeKHR::eClone )
      VULKAN_HPP_NOEXCEPT
      : src( src_ )
      , dst( dst_ )
      , mode( mode_ )
    {}

    CopyMemoryToAccelerationStructureInfoKHR( CopyMemoryToAccelerationStructureInfoKHR const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    CopyMemoryToAccelerationStructureInfoKHR( VkCopyMemoryToAccelerationStructureInfoKHR const & rhs )
      VULKAN_HPP_NOEXCEPT
      : CopyMemoryToAccelerationStructureInfoKHR(
          *reinterpret_cast<CopyMemoryToAccelerationStructureInfoKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    CopyMemoryToAccelerationStructureInfoKHR &
      operator=( CopyMemoryToAccelerationStructureInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    CopyMemoryToAccelerationStructureInfoKHR &
      operator=( VkCopyMemoryToAccelerationStructureInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::CopyMemoryToAccelerationStructureInfoKHR const *>( &rhs );
      return *this;
    }

    CopyMemoryToAccelerationStructureInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    CopyMemoryToAccelerationStructureInfoKHR &
      setSrc( VULKAN_HPP_NAMESPACE::DeviceOrHostAddressConstKHR const & src_ ) VULKAN_HPP_NOEXCEPT
    {
      src = src_;
      return *this;
    }

    CopyMemoryToAccelerationStructureInfoKHR &
      setDst( VULKAN_HPP_NAMESPACE::AccelerationStructureKHR dst_ ) VULKAN_HPP_NOEXCEPT
    {
      dst = dst_;
      return *this;
    }

    CopyMemoryToAccelerationStructureInfoKHR &
      setMode( VULKAN_HPP_NAMESPACE::CopyAccelerationStructureModeKHR mode_ ) VULKAN_HPP_NOEXCEPT
    {
      mode = mode_;
      return *this;
    }

    operator VkCopyMemoryToAccelerationStructureInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkCopyMemoryToAccelerationStructureInfoKHR *>( this );
    }

    operator VkCopyMemoryToAccelerationStructureInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkCopyMemoryToAccelerationStructureInfoKHR *>( this );
    }

  public:
    VULKAN_HPP_NAMESPACE::StructureType               sType = StructureType::eCopyMemoryToAccelerationStructureInfoKHR;
    const void *                                      pNext = {};
    VULKAN_HPP_NAMESPACE::DeviceOrHostAddressConstKHR src   = {};
    VULKAN_HPP_NAMESPACE::AccelerationStructureKHR    dst   = {};
    VULKAN_HPP_NAMESPACE::CopyAccelerationStructureModeKHR mode =
      VULKAN_HPP_NAMESPACE::CopyAccelerationStructureModeKHR::eClone;
  };
  static_assert( sizeof( CopyMemoryToAccelerationStructureInfoKHR ) ==
                   sizeof( VkCopyMemoryToAccelerationStructureInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<CopyMemoryToAccelerationStructureInfoKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eCopyMemoryToAccelerationStructureInfoKHR>
  {
    using Type = CopyMemoryToAccelerationStructureInfoKHR;
  };

  struct CuFunctionCreateInfoNVX
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eCuFunctionCreateInfoNVX;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR CuFunctionCreateInfoNVX( VULKAN_HPP_NAMESPACE::CuModuleNVX module_ = {},
                                                  const char *                      pName_  = {} ) VULKAN_HPP_NOEXCEPT
      : module( module_ )
      , pName( pName_ )
    {}

    VULKAN_HPP_CONSTEXPR CuFunctionCreateInfoNVX( CuFunctionCreateInfoNVX const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    CuFunctionCreateInfoNVX( VkCuFunctionCreateInfoNVX const & rhs ) VULKAN_HPP_NOEXCEPT
      : CuFunctionCreateInfoNVX( *reinterpret_cast<CuFunctionCreateInfoNVX const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 CuFunctionCreateInfoNVX &
                            operator=( CuFunctionCreateInfoNVX const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    CuFunctionCreateInfoNVX & operator=( VkCuFunctionCreateInfoNVX const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::CuFunctionCreateInfoNVX const *>( &rhs );
      return *this;
    }

    CuFunctionCreateInfoNVX & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    CuFunctionCreateInfoNVX & setModule( VULKAN_HPP_NAMESPACE::CuModuleNVX module_ ) VULKAN_HPP_NOEXCEPT
    {
      module = module_;
      return *this;
    }

    CuFunctionCreateInfoNVX & setPName( const char * pName_ ) VULKAN_HPP_NOEXCEPT
    {
      pName = pName_;
      return *this;
    }

    operator VkCuFunctionCreateInfoNVX const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkCuFunctionCreateInfoNVX *>( this );
    }

    operator VkCuFunctionCreateInfoNVX &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkCuFunctionCreateInfoNVX *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( CuFunctionCreateInfoNVX const & ) const = default;
#else
    bool operator==( CuFunctionCreateInfoNVX const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( module == rhs.module ) && ( pName == rhs.pName );
    }

    bool operator!=( CuFunctionCreateInfoNVX const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType  = StructureType::eCuFunctionCreateInfoNVX;
    const void *                        pNext  = {};
    VULKAN_HPP_NAMESPACE::CuModuleNVX   module = {};
    const char *                        pName  = {};
  };
  static_assert( sizeof( CuFunctionCreateInfoNVX ) == sizeof( VkCuFunctionCreateInfoNVX ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<CuFunctionCreateInfoNVX>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eCuFunctionCreateInfoNVX>
  {
    using Type = CuFunctionCreateInfoNVX;
  };

  struct CuLaunchInfoNVX
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eCuLaunchInfoNVX;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR CuLaunchInfoNVX( VULKAN_HPP_NAMESPACE::CuFunctionNVX function_       = {},
                                          uint32_t                            gridDimX_       = {},
                                          uint32_t                            gridDimY_       = {},
                                          uint32_t                            gridDimZ_       = {},
                                          uint32_t                            blockDimX_      = {},
                                          uint32_t                            blockDimY_      = {},
                                          uint32_t                            blockDimZ_      = {},
                                          uint32_t                            sharedMemBytes_ = {},
                                          size_t                              paramCount_     = {},
                                          const void * const *                pParams_        = {},
                                          size_t                              extraCount_     = {},
                                          const void * const *                pExtras_        = {} ) VULKAN_HPP_NOEXCEPT
      : function( function_ )
      , gridDimX( gridDimX_ )
      , gridDimY( gridDimY_ )
      , gridDimZ( gridDimZ_ )
      , blockDimX( blockDimX_ )
      , blockDimY( blockDimY_ )
      , blockDimZ( blockDimZ_ )
      , sharedMemBytes( sharedMemBytes_ )
      , paramCount( paramCount_ )
      , pParams( pParams_ )
      , extraCount( extraCount_ )
      , pExtras( pExtras_ )
    {}

    VULKAN_HPP_CONSTEXPR CuLaunchInfoNVX( CuLaunchInfoNVX const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    CuLaunchInfoNVX( VkCuLaunchInfoNVX const & rhs ) VULKAN_HPP_NOEXCEPT
      : CuLaunchInfoNVX( *reinterpret_cast<CuLaunchInfoNVX const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 CuLaunchInfoNVX & operator=( CuLaunchInfoNVX const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    CuLaunchInfoNVX & operator=( VkCuLaunchInfoNVX const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::CuLaunchInfoNVX const *>( &rhs );
      return *this;
    }

    CuLaunchInfoNVX & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    CuLaunchInfoNVX & setFunction( VULKAN_HPP_NAMESPACE::CuFunctionNVX function_ ) VULKAN_HPP_NOEXCEPT
    {
      function = function_;
      return *this;
    }

    CuLaunchInfoNVX & setGridDimX( uint32_t gridDimX_ ) VULKAN_HPP_NOEXCEPT
    {
      gridDimX = gridDimX_;
      return *this;
    }

    CuLaunchInfoNVX & setGridDimY( uint32_t gridDimY_ ) VULKAN_HPP_NOEXCEPT
    {
      gridDimY = gridDimY_;
      return *this;
    }

    CuLaunchInfoNVX & setGridDimZ( uint32_t gridDimZ_ ) VULKAN_HPP_NOEXCEPT
    {
      gridDimZ = gridDimZ_;
      return *this;
    }

    CuLaunchInfoNVX & setBlockDimX( uint32_t blockDimX_ ) VULKAN_HPP_NOEXCEPT
    {
      blockDimX = blockDimX_;
      return *this;
    }

    CuLaunchInfoNVX & setBlockDimY( uint32_t blockDimY_ ) VULKAN_HPP_NOEXCEPT
    {
      blockDimY = blockDimY_;
      return *this;
    }

    CuLaunchInfoNVX & setBlockDimZ( uint32_t blockDimZ_ ) VULKAN_HPP_NOEXCEPT
    {
      blockDimZ = blockDimZ_;
      return *this;
    }

    CuLaunchInfoNVX & setSharedMemBytes( uint32_t sharedMemBytes_ ) VULKAN_HPP_NOEXCEPT
    {
      sharedMemBytes = sharedMemBytes_;
      return *this;
    }

    CuLaunchInfoNVX & setParamCount( size_t paramCount_ ) VULKAN_HPP_NOEXCEPT
    {
      paramCount = paramCount_;
      return *this;
    }

    CuLaunchInfoNVX & setPParams( const void * const * pParams_ ) VULKAN_HPP_NOEXCEPT
    {
      pParams = pParams_;
      return *this;
    }

    CuLaunchInfoNVX & setExtraCount( size_t extraCount_ ) VULKAN_HPP_NOEXCEPT
    {
      extraCount = extraCount_;
      return *this;
    }

    CuLaunchInfoNVX & setPExtras( const void * const * pExtras_ ) VULKAN_HPP_NOEXCEPT
    {
      pExtras = pExtras_;
      return *this;
    }

    operator VkCuLaunchInfoNVX const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkCuLaunchInfoNVX *>( this );
    }

    operator VkCuLaunchInfoNVX &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkCuLaunchInfoNVX *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( CuLaunchInfoNVX const & ) const = default;
#else
    bool operator==( CuLaunchInfoNVX const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( function == rhs.function ) &&
             ( gridDimX == rhs.gridDimX ) && ( gridDimY == rhs.gridDimY ) && ( gridDimZ == rhs.gridDimZ ) &&
             ( blockDimX == rhs.blockDimX ) && ( blockDimY == rhs.blockDimY ) && ( blockDimZ == rhs.blockDimZ ) &&
             ( sharedMemBytes == rhs.sharedMemBytes ) && ( paramCount == rhs.paramCount ) &&
             ( pParams == rhs.pParams ) && ( extraCount == rhs.extraCount ) && ( pExtras == rhs.pExtras );
    }

    bool operator!=( CuLaunchInfoNVX const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType          = StructureType::eCuLaunchInfoNVX;
    const void *                        pNext          = {};
    VULKAN_HPP_NAMESPACE::CuFunctionNVX function       = {};
    uint32_t                            gridDimX       = {};
    uint32_t                            gridDimY       = {};
    uint32_t                            gridDimZ       = {};
    uint32_t                            blockDimX      = {};
    uint32_t                            blockDimY      = {};
    uint32_t                            blockDimZ      = {};
    uint32_t                            sharedMemBytes = {};
    size_t                              paramCount     = {};
    const void * const *                pParams        = {};
    size_t                              extraCount     = {};
    const void * const *                pExtras        = {};
  };
  static_assert( sizeof( CuLaunchInfoNVX ) == sizeof( VkCuLaunchInfoNVX ), "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<CuLaunchInfoNVX>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eCuLaunchInfoNVX>
  {
    using Type = CuLaunchInfoNVX;
  };

  struct CuModuleCreateInfoNVX
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eCuModuleCreateInfoNVX;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR CuModuleCreateInfoNVX( size_t dataSize_ = {}, const void * pData_ = {} ) VULKAN_HPP_NOEXCEPT
      : dataSize( dataSize_ )
      , pData( pData_ )
    {}

    VULKAN_HPP_CONSTEXPR CuModuleCreateInfoNVX( CuModuleCreateInfoNVX const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    CuModuleCreateInfoNVX( VkCuModuleCreateInfoNVX const & rhs ) VULKAN_HPP_NOEXCEPT
      : CuModuleCreateInfoNVX( *reinterpret_cast<CuModuleCreateInfoNVX const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 CuModuleCreateInfoNVX &
                            operator=( CuModuleCreateInfoNVX const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    CuModuleCreateInfoNVX & operator=( VkCuModuleCreateInfoNVX const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::CuModuleCreateInfoNVX const *>( &rhs );
      return *this;
    }

    CuModuleCreateInfoNVX & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    CuModuleCreateInfoNVX & setDataSize( size_t dataSize_ ) VULKAN_HPP_NOEXCEPT
    {
      dataSize = dataSize_;
      return *this;
    }

    CuModuleCreateInfoNVX & setPData( const void * pData_ ) VULKAN_HPP_NOEXCEPT
    {
      pData = pData_;
      return *this;
    }

    operator VkCuModuleCreateInfoNVX const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkCuModuleCreateInfoNVX *>( this );
    }

    operator VkCuModuleCreateInfoNVX &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkCuModuleCreateInfoNVX *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( CuModuleCreateInfoNVX const & ) const = default;
#else
    bool operator==( CuModuleCreateInfoNVX const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( dataSize == rhs.dataSize ) && ( pData == rhs.pData );
    }

    bool operator!=( CuModuleCreateInfoNVX const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType    = StructureType::eCuModuleCreateInfoNVX;
    const void *                        pNext    = {};
    size_t                              dataSize = {};
    const void *                        pData    = {};
  };
  static_assert( sizeof( CuModuleCreateInfoNVX ) == sizeof( VkCuModuleCreateInfoNVX ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<CuModuleCreateInfoNVX>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eCuModuleCreateInfoNVX>
  {
    using Type = CuModuleCreateInfoNVX;
  };

#if defined( VK_USE_PLATFORM_WIN32_KHR )
  struct D3D12FenceSubmitInfoKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eD3D12FenceSubmitInfoKHR;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR D3D12FenceSubmitInfoKHR( uint32_t         waitSemaphoreValuesCount_   = {},
                                                  const uint64_t * pWaitSemaphoreValues_       = {},
                                                  uint32_t         signalSemaphoreValuesCount_ = {},
                                                  const uint64_t * pSignalSemaphoreValues_ = {} ) VULKAN_HPP_NOEXCEPT
      : waitSemaphoreValuesCount( waitSemaphoreValuesCount_ )
      , pWaitSemaphoreValues( pWaitSemaphoreValues_ )
      , signalSemaphoreValuesCount( signalSemaphoreValuesCount_ )
      , pSignalSemaphoreValues( pSignalSemaphoreValues_ )
    {}

    VULKAN_HPP_CONSTEXPR D3D12FenceSubmitInfoKHR( D3D12FenceSubmitInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    D3D12FenceSubmitInfoKHR( VkD3D12FenceSubmitInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : D3D12FenceSubmitInfoKHR( *reinterpret_cast<D3D12FenceSubmitInfoKHR const *>( &rhs ) )
    {}

#    if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    D3D12FenceSubmitInfoKHR(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint64_t> const & waitSemaphoreValues_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint64_t> const & signalSemaphoreValues_ = {} )
      : waitSemaphoreValuesCount( static_cast<uint32_t>( waitSemaphoreValues_.size() ) )
      , pWaitSemaphoreValues( waitSemaphoreValues_.data() )
      , signalSemaphoreValuesCount( static_cast<uint32_t>( signalSemaphoreValues_.size() ) )
      , pSignalSemaphoreValues( signalSemaphoreValues_.data() )
    {}
#    endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#  endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 D3D12FenceSubmitInfoKHR &
                            operator=( D3D12FenceSubmitInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    D3D12FenceSubmitInfoKHR & operator=( VkD3D12FenceSubmitInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::D3D12FenceSubmitInfoKHR const *>( &rhs );
      return *this;
    }

    D3D12FenceSubmitInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    D3D12FenceSubmitInfoKHR & setWaitSemaphoreValuesCount( uint32_t waitSemaphoreValuesCount_ ) VULKAN_HPP_NOEXCEPT
    {
      waitSemaphoreValuesCount = waitSemaphoreValuesCount_;
      return *this;
    }

    D3D12FenceSubmitInfoKHR & setPWaitSemaphoreValues( const uint64_t * pWaitSemaphoreValues_ ) VULKAN_HPP_NOEXCEPT
    {
      pWaitSemaphoreValues = pWaitSemaphoreValues_;
      return *this;
    }

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    D3D12FenceSubmitInfoKHR & setWaitSemaphoreValues(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint64_t> const & waitSemaphoreValues_ ) VULKAN_HPP_NOEXCEPT
    {
      waitSemaphoreValuesCount = static_cast<uint32_t>( waitSemaphoreValues_.size() );
      pWaitSemaphoreValues     = waitSemaphoreValues_.data();
      return *this;
    }
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    D3D12FenceSubmitInfoKHR & setSignalSemaphoreValuesCount( uint32_t signalSemaphoreValuesCount_ ) VULKAN_HPP_NOEXCEPT
    {
      signalSemaphoreValuesCount = signalSemaphoreValuesCount_;
      return *this;
    }

    D3D12FenceSubmitInfoKHR & setPSignalSemaphoreValues( const uint64_t * pSignalSemaphoreValues_ ) VULKAN_HPP_NOEXCEPT
    {
      pSignalSemaphoreValues = pSignalSemaphoreValues_;
      return *this;
    }

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    D3D12FenceSubmitInfoKHR & setSignalSemaphoreValues(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint64_t> const & signalSemaphoreValues_ ) VULKAN_HPP_NOEXCEPT
    {
      signalSemaphoreValuesCount = static_cast<uint32_t>( signalSemaphoreValues_.size() );
      pSignalSemaphoreValues     = signalSemaphoreValues_.data();
      return *this;
    }
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkD3D12FenceSubmitInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkD3D12FenceSubmitInfoKHR *>( this );
    }

    operator VkD3D12FenceSubmitInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkD3D12FenceSubmitInfoKHR *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( D3D12FenceSubmitInfoKHR const & ) const = default;
#  else
    bool operator==( D3D12FenceSubmitInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( waitSemaphoreValuesCount == rhs.waitSemaphoreValuesCount ) &&
             ( pWaitSemaphoreValues == rhs.pWaitSemaphoreValues ) &&
             ( signalSemaphoreValuesCount == rhs.signalSemaphoreValuesCount ) &&
             ( pSignalSemaphoreValues == rhs.pSignalSemaphoreValues );
    }

    bool operator!=( D3D12FenceSubmitInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType                      = StructureType::eD3D12FenceSubmitInfoKHR;
    const void *                        pNext                      = {};
    uint32_t                            waitSemaphoreValuesCount   = {};
    const uint64_t *                    pWaitSemaphoreValues       = {};
    uint32_t                            signalSemaphoreValuesCount = {};
    const uint64_t *                    pSignalSemaphoreValues     = {};
  };
  static_assert( sizeof( D3D12FenceSubmitInfoKHR ) == sizeof( VkD3D12FenceSubmitInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<D3D12FenceSubmitInfoKHR>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eD3D12FenceSubmitInfoKHR>
  {
    using Type = D3D12FenceSubmitInfoKHR;
  };
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

  struct DebugMarkerMarkerInfoEXT
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eDebugMarkerMarkerInfoEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR_14 DebugMarkerMarkerInfoEXT( const char *                 pMarkerName_ = {},
                                                      std::array<float, 4> const & color_ = {} ) VULKAN_HPP_NOEXCEPT
      : pMarkerName( pMarkerName_ )
      , color( color_ )
    {}

    VULKAN_HPP_CONSTEXPR_14
      DebugMarkerMarkerInfoEXT( DebugMarkerMarkerInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DebugMarkerMarkerInfoEXT( VkDebugMarkerMarkerInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : DebugMarkerMarkerInfoEXT( *reinterpret_cast<DebugMarkerMarkerInfoEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DebugMarkerMarkerInfoEXT &
                            operator=( DebugMarkerMarkerInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DebugMarkerMarkerInfoEXT & operator=( VkDebugMarkerMarkerInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DebugMarkerMarkerInfoEXT const *>( &rhs );
      return *this;
    }

    DebugMarkerMarkerInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    DebugMarkerMarkerInfoEXT & setPMarkerName( const char * pMarkerName_ ) VULKAN_HPP_NOEXCEPT
    {
      pMarkerName = pMarkerName_;
      return *this;
    }

    DebugMarkerMarkerInfoEXT & setColor( std::array<float, 4> color_ ) VULKAN_HPP_NOEXCEPT
    {
      color = color_;
      return *this;
    }

    operator VkDebugMarkerMarkerInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDebugMarkerMarkerInfoEXT *>( this );
    }

    operator VkDebugMarkerMarkerInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDebugMarkerMarkerInfoEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DebugMarkerMarkerInfoEXT const & ) const = default;
#else
    bool operator==( DebugMarkerMarkerInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( pMarkerName == rhs.pMarkerName ) &&
             ( color == rhs.color );
    }

    bool operator!=( DebugMarkerMarkerInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType            sType       = StructureType::eDebugMarkerMarkerInfoEXT;
    const void *                                   pNext       = {};
    const char *                                   pMarkerName = {};
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<float, 4> color       = {};
  };
  static_assert( sizeof( DebugMarkerMarkerInfoEXT ) == sizeof( VkDebugMarkerMarkerInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DebugMarkerMarkerInfoEXT>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDebugMarkerMarkerInfoEXT>
  {
    using Type = DebugMarkerMarkerInfoEXT;
  };

  struct DebugMarkerObjectNameInfoEXT
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eDebugMarkerObjectNameInfoEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR DebugMarkerObjectNameInfoEXT( VULKAN_HPP_NAMESPACE::DebugReportObjectTypeEXT objectType_ =
                                                         VULKAN_HPP_NAMESPACE::DebugReportObjectTypeEXT::eUnknown,
                                                       uint64_t     object_      = {},
                                                       const char * pObjectName_ = {} ) VULKAN_HPP_NOEXCEPT
      : objectType( objectType_ )
      , object( object_ )
      , pObjectName( pObjectName_ )
    {}

    VULKAN_HPP_CONSTEXPR
      DebugMarkerObjectNameInfoEXT( DebugMarkerObjectNameInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DebugMarkerObjectNameInfoEXT( VkDebugMarkerObjectNameInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : DebugMarkerObjectNameInfoEXT( *reinterpret_cast<DebugMarkerObjectNameInfoEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DebugMarkerObjectNameInfoEXT &
                            operator=( DebugMarkerObjectNameInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DebugMarkerObjectNameInfoEXT & operator=( VkDebugMarkerObjectNameInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DebugMarkerObjectNameInfoEXT const *>( &rhs );
      return *this;
    }

    DebugMarkerObjectNameInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    DebugMarkerObjectNameInfoEXT &
      setObjectType( VULKAN_HPP_NAMESPACE::DebugReportObjectTypeEXT objectType_ ) VULKAN_HPP_NOEXCEPT
    {
      objectType = objectType_;
      return *this;
    }

    DebugMarkerObjectNameInfoEXT & setObject( uint64_t object_ ) VULKAN_HPP_NOEXCEPT
    {
      object = object_;
      return *this;
    }

    DebugMarkerObjectNameInfoEXT & setPObjectName( const char * pObjectName_ ) VULKAN_HPP_NOEXCEPT
    {
      pObjectName = pObjectName_;
      return *this;
    }

    operator VkDebugMarkerObjectNameInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDebugMarkerObjectNameInfoEXT *>( this );
    }

    operator VkDebugMarkerObjectNameInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDebugMarkerObjectNameInfoEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DebugMarkerObjectNameInfoEXT const & ) const = default;
#else
    bool operator==( DebugMarkerObjectNameInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( objectType == rhs.objectType ) &&
             ( object == rhs.object ) && ( pObjectName == rhs.pObjectName );
    }

    bool operator!=( DebugMarkerObjectNameInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType            sType = StructureType::eDebugMarkerObjectNameInfoEXT;
    const void *                                   pNext = {};
    VULKAN_HPP_NAMESPACE::DebugReportObjectTypeEXT objectType =
      VULKAN_HPP_NAMESPACE::DebugReportObjectTypeEXT::eUnknown;
    uint64_t     object      = {};
    const char * pObjectName = {};
  };
  static_assert( sizeof( DebugMarkerObjectNameInfoEXT ) == sizeof( VkDebugMarkerObjectNameInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DebugMarkerObjectNameInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDebugMarkerObjectNameInfoEXT>
  {
    using Type = DebugMarkerObjectNameInfoEXT;
  };

  struct DebugMarkerObjectTagInfoEXT
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eDebugMarkerObjectTagInfoEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR DebugMarkerObjectTagInfoEXT( VULKAN_HPP_NAMESPACE::DebugReportObjectTypeEXT objectType_ =
                                                        VULKAN_HPP_NAMESPACE::DebugReportObjectTypeEXT::eUnknown,
                                                      uint64_t     object_  = {},
                                                      uint64_t     tagName_ = {},
                                                      size_t       tagSize_ = {},
                                                      const void * pTag_    = {} ) VULKAN_HPP_NOEXCEPT
      : objectType( objectType_ )
      , object( object_ )
      , tagName( tagName_ )
      , tagSize( tagSize_ )
      , pTag( pTag_ )
    {}

    VULKAN_HPP_CONSTEXPR
      DebugMarkerObjectTagInfoEXT( DebugMarkerObjectTagInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DebugMarkerObjectTagInfoEXT( VkDebugMarkerObjectTagInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : DebugMarkerObjectTagInfoEXT( *reinterpret_cast<DebugMarkerObjectTagInfoEXT const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    template <typename T>
    DebugMarkerObjectTagInfoEXT( VULKAN_HPP_NAMESPACE::DebugReportObjectTypeEXT                 objectType_,
                                 uint64_t                                                       object_,
                                 uint64_t                                                       tagName_,
                                 VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const T> const & tag_ )
      : objectType( objectType_ )
      , object( object_ )
      , tagName( tagName_ )
      , tagSize( tag_.size() * sizeof( T ) )
      , pTag( tag_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DebugMarkerObjectTagInfoEXT &
                            operator=( DebugMarkerObjectTagInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DebugMarkerObjectTagInfoEXT & operator=( VkDebugMarkerObjectTagInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DebugMarkerObjectTagInfoEXT const *>( &rhs );
      return *this;
    }

    DebugMarkerObjectTagInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    DebugMarkerObjectTagInfoEXT &
      setObjectType( VULKAN_HPP_NAMESPACE::DebugReportObjectTypeEXT objectType_ ) VULKAN_HPP_NOEXCEPT
    {
      objectType = objectType_;
      return *this;
    }

    DebugMarkerObjectTagInfoEXT & setObject( uint64_t object_ ) VULKAN_HPP_NOEXCEPT
    {
      object = object_;
      return *this;
    }

    DebugMarkerObjectTagInfoEXT & setTagName( uint64_t tagName_ ) VULKAN_HPP_NOEXCEPT
    {
      tagName = tagName_;
      return *this;
    }

    DebugMarkerObjectTagInfoEXT & setTagSize( size_t tagSize_ ) VULKAN_HPP_NOEXCEPT
    {
      tagSize = tagSize_;
      return *this;
    }

    DebugMarkerObjectTagInfoEXT & setPTag( const void * pTag_ ) VULKAN_HPP_NOEXCEPT
    {
      pTag = pTag_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    template <typename T>
    DebugMarkerObjectTagInfoEXT &
      setTag( VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const T> const & tag_ ) VULKAN_HPP_NOEXCEPT
    {
      tagSize = tag_.size() * sizeof( T );
      pTag    = tag_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkDebugMarkerObjectTagInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDebugMarkerObjectTagInfoEXT *>( this );
    }

    operator VkDebugMarkerObjectTagInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDebugMarkerObjectTagInfoEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DebugMarkerObjectTagInfoEXT const & ) const = default;
#else
    bool operator==( DebugMarkerObjectTagInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( objectType == rhs.objectType ) &&
             ( object == rhs.object ) && ( tagName == rhs.tagName ) && ( tagSize == rhs.tagSize ) &&
             ( pTag == rhs.pTag );
    }

    bool operator!=( DebugMarkerObjectTagInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType            sType = StructureType::eDebugMarkerObjectTagInfoEXT;
    const void *                                   pNext = {};
    VULKAN_HPP_NAMESPACE::DebugReportObjectTypeEXT objectType =
      VULKAN_HPP_NAMESPACE::DebugReportObjectTypeEXT::eUnknown;
    uint64_t     object  = {};
    uint64_t     tagName = {};
    size_t       tagSize = {};
    const void * pTag    = {};
  };
  static_assert( sizeof( DebugMarkerObjectTagInfoEXT ) == sizeof( VkDebugMarkerObjectTagInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DebugMarkerObjectTagInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDebugMarkerObjectTagInfoEXT>
  {
    using Type = DebugMarkerObjectTagInfoEXT;
  };

  struct DebugReportCallbackCreateInfoEXT
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eDebugReportCallbackCreateInfoEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR DebugReportCallbackCreateInfoEXT( VULKAN_HPP_NAMESPACE::DebugReportFlagsEXT flags_       = {},
                                                           PFN_vkDebugReportCallbackEXT              pfnCallback_ = {},
                                                           void * pUserData_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , pfnCallback( pfnCallback_ )
      , pUserData( pUserData_ )
    {}

    VULKAN_HPP_CONSTEXPR
      DebugReportCallbackCreateInfoEXT( DebugReportCallbackCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DebugReportCallbackCreateInfoEXT( VkDebugReportCallbackCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : DebugReportCallbackCreateInfoEXT( *reinterpret_cast<DebugReportCallbackCreateInfoEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DebugReportCallbackCreateInfoEXT &
                            operator=( DebugReportCallbackCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DebugReportCallbackCreateInfoEXT & operator=( VkDebugReportCallbackCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DebugReportCallbackCreateInfoEXT const *>( &rhs );
      return *this;
    }

    DebugReportCallbackCreateInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    DebugReportCallbackCreateInfoEXT & setFlags( VULKAN_HPP_NAMESPACE::DebugReportFlagsEXT flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    DebugReportCallbackCreateInfoEXT & setPfnCallback( PFN_vkDebugReportCallbackEXT pfnCallback_ ) VULKAN_HPP_NOEXCEPT
    {
      pfnCallback = pfnCallback_;
      return *this;
    }

    DebugReportCallbackCreateInfoEXT & setPUserData( void * pUserData_ ) VULKAN_HPP_NOEXCEPT
    {
      pUserData = pUserData_;
      return *this;
    }

    operator VkDebugReportCallbackCreateInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDebugReportCallbackCreateInfoEXT *>( this );
    }

    operator VkDebugReportCallbackCreateInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDebugReportCallbackCreateInfoEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DebugReportCallbackCreateInfoEXT const & ) const = default;
#else
    bool operator==( DebugReportCallbackCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( pfnCallback == rhs.pfnCallback ) && ( pUserData == rhs.pUserData );
    }

    bool operator!=( DebugReportCallbackCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType       sType       = StructureType::eDebugReportCallbackCreateInfoEXT;
    const void *                              pNext       = {};
    VULKAN_HPP_NAMESPACE::DebugReportFlagsEXT flags       = {};
    PFN_vkDebugReportCallbackEXT              pfnCallback = {};
    void *                                    pUserData   = {};
  };
  static_assert( sizeof( DebugReportCallbackCreateInfoEXT ) == sizeof( VkDebugReportCallbackCreateInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DebugReportCallbackCreateInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDebugReportCallbackCreateInfoEXT>
  {
    using Type = DebugReportCallbackCreateInfoEXT;
  };

  struct DebugUtilsLabelEXT
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eDebugUtilsLabelEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR_14 DebugUtilsLabelEXT( const char *                 pLabelName_ = {},
                                                std::array<float, 4> const & color_      = {} ) VULKAN_HPP_NOEXCEPT
      : pLabelName( pLabelName_ )
      , color( color_ )
    {}

    VULKAN_HPP_CONSTEXPR_14 DebugUtilsLabelEXT( DebugUtilsLabelEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DebugUtilsLabelEXT( VkDebugUtilsLabelEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : DebugUtilsLabelEXT( *reinterpret_cast<DebugUtilsLabelEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DebugUtilsLabelEXT &
                            operator=( DebugUtilsLabelEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DebugUtilsLabelEXT & operator=( VkDebugUtilsLabelEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DebugUtilsLabelEXT const *>( &rhs );
      return *this;
    }

    DebugUtilsLabelEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    DebugUtilsLabelEXT & setPLabelName( const char * pLabelName_ ) VULKAN_HPP_NOEXCEPT
    {
      pLabelName = pLabelName_;
      return *this;
    }

    DebugUtilsLabelEXT & setColor( std::array<float, 4> color_ ) VULKAN_HPP_NOEXCEPT
    {
      color = color_;
      return *this;
    }

    operator VkDebugUtilsLabelEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDebugUtilsLabelEXT *>( this );
    }

    operator VkDebugUtilsLabelEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDebugUtilsLabelEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DebugUtilsLabelEXT const & ) const = default;
#else
    bool operator==( DebugUtilsLabelEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( pLabelName == rhs.pLabelName ) &&
             ( color == rhs.color );
    }

    bool operator!=( DebugUtilsLabelEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType            sType      = StructureType::eDebugUtilsLabelEXT;
    const void *                                   pNext      = {};
    const char *                                   pLabelName = {};
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<float, 4> color      = {};
  };
  static_assert( sizeof( DebugUtilsLabelEXT ) == sizeof( VkDebugUtilsLabelEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DebugUtilsLabelEXT>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDebugUtilsLabelEXT>
  {
    using Type = DebugUtilsLabelEXT;
  };

  struct DebugUtilsObjectNameInfoEXT
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eDebugUtilsObjectNameInfoEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR DebugUtilsObjectNameInfoEXT(
      VULKAN_HPP_NAMESPACE::ObjectType objectType_   = VULKAN_HPP_NAMESPACE::ObjectType::eUnknown,
      uint64_t                         objectHandle_ = {},
      const char *                     pObjectName_  = {} ) VULKAN_HPP_NOEXCEPT
      : objectType( objectType_ )
      , objectHandle( objectHandle_ )
      , pObjectName( pObjectName_ )
    {}

    VULKAN_HPP_CONSTEXPR
      DebugUtilsObjectNameInfoEXT( DebugUtilsObjectNameInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DebugUtilsObjectNameInfoEXT( VkDebugUtilsObjectNameInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : DebugUtilsObjectNameInfoEXT( *reinterpret_cast<DebugUtilsObjectNameInfoEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DebugUtilsObjectNameInfoEXT &
                            operator=( DebugUtilsObjectNameInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DebugUtilsObjectNameInfoEXT & operator=( VkDebugUtilsObjectNameInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DebugUtilsObjectNameInfoEXT const *>( &rhs );
      return *this;
    }

    DebugUtilsObjectNameInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    DebugUtilsObjectNameInfoEXT & setObjectType( VULKAN_HPP_NAMESPACE::ObjectType objectType_ ) VULKAN_HPP_NOEXCEPT
    {
      objectType = objectType_;
      return *this;
    }

    DebugUtilsObjectNameInfoEXT & setObjectHandle( uint64_t objectHandle_ ) VULKAN_HPP_NOEXCEPT
    {
      objectHandle = objectHandle_;
      return *this;
    }

    DebugUtilsObjectNameInfoEXT & setPObjectName( const char * pObjectName_ ) VULKAN_HPP_NOEXCEPT
    {
      pObjectName = pObjectName_;
      return *this;
    }

    operator VkDebugUtilsObjectNameInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDebugUtilsObjectNameInfoEXT *>( this );
    }

    operator VkDebugUtilsObjectNameInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDebugUtilsObjectNameInfoEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DebugUtilsObjectNameInfoEXT const & ) const = default;
#else
    bool operator==( DebugUtilsObjectNameInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( objectType == rhs.objectType ) &&
             ( objectHandle == rhs.objectHandle ) && ( pObjectName == rhs.pObjectName );
    }

    bool operator!=( DebugUtilsObjectNameInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType        = StructureType::eDebugUtilsObjectNameInfoEXT;
    const void *                        pNext        = {};
    VULKAN_HPP_NAMESPACE::ObjectType    objectType   = VULKAN_HPP_NAMESPACE::ObjectType::eUnknown;
    uint64_t                            objectHandle = {};
    const char *                        pObjectName  = {};
  };
  static_assert( sizeof( DebugUtilsObjectNameInfoEXT ) == sizeof( VkDebugUtilsObjectNameInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DebugUtilsObjectNameInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDebugUtilsObjectNameInfoEXT>
  {
    using Type = DebugUtilsObjectNameInfoEXT;
  };

  struct DebugUtilsMessengerCallbackDataEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eDebugUtilsMessengerCallbackDataEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR_14 DebugUtilsMessengerCallbackDataEXT(
      VULKAN_HPP_NAMESPACE::DebugUtilsMessengerCallbackDataFlagsEXT flags_            = {},
      const char *                                                  pMessageIdName_   = {},
      int32_t                                                       messageIdNumber_  = {},
      const char *                                                  pMessage_         = {},
      uint32_t                                                      queueLabelCount_  = {},
      const VULKAN_HPP_NAMESPACE::DebugUtilsLabelEXT *              pQueueLabels_     = {},
      uint32_t                                                      cmdBufLabelCount_ = {},
      const VULKAN_HPP_NAMESPACE::DebugUtilsLabelEXT *              pCmdBufLabels_    = {},
      uint32_t                                                      objectCount_      = {},
      const VULKAN_HPP_NAMESPACE::DebugUtilsObjectNameInfoEXT *     pObjects_         = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , pMessageIdName( pMessageIdName_ )
      , messageIdNumber( messageIdNumber_ )
      , pMessage( pMessage_ )
      , queueLabelCount( queueLabelCount_ )
      , pQueueLabels( pQueueLabels_ )
      , cmdBufLabelCount( cmdBufLabelCount_ )
      , pCmdBufLabels( pCmdBufLabels_ )
      , objectCount( objectCount_ )
      , pObjects( pObjects_ )
    {}

    VULKAN_HPP_CONSTEXPR_14 DebugUtilsMessengerCallbackDataEXT( DebugUtilsMessengerCallbackDataEXT const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    DebugUtilsMessengerCallbackDataEXT( VkDebugUtilsMessengerCallbackDataEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : DebugUtilsMessengerCallbackDataEXT( *reinterpret_cast<DebugUtilsMessengerCallbackDataEXT const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    DebugUtilsMessengerCallbackDataEXT(
      VULKAN_HPP_NAMESPACE::DebugUtilsMessengerCallbackDataFlagsEXT flags_,
      const char *                                                  pMessageIdName_,
      int32_t                                                       messageIdNumber_,
      const char *                                                  pMessage_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::DebugUtilsLabelEXT> const &
        queueLabels_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::DebugUtilsLabelEXT> const &
        cmdBufLabels_ = {},
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::DebugUtilsObjectNameInfoEXT> const &
        objects_ = {} )
      : flags( flags_ )
      , pMessageIdName( pMessageIdName_ )
      , messageIdNumber( messageIdNumber_ )
      , pMessage( pMessage_ )
      , queueLabelCount( static_cast<uint32_t>( queueLabels_.size() ) )
      , pQueueLabels( queueLabels_.data() )
      , cmdBufLabelCount( static_cast<uint32_t>( cmdBufLabels_.size() ) )
      , pCmdBufLabels( cmdBufLabels_.data() )
      , objectCount( static_cast<uint32_t>( objects_.size() ) )
      , pObjects( objects_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DebugUtilsMessengerCallbackDataEXT &
                            operator=( DebugUtilsMessengerCallbackDataEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DebugUtilsMessengerCallbackDataEXT &
      operator=( VkDebugUtilsMessengerCallbackDataEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DebugUtilsMessengerCallbackDataEXT const *>( &rhs );
      return *this;
    }

    DebugUtilsMessengerCallbackDataEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    DebugUtilsMessengerCallbackDataEXT &
      setFlags( VULKAN_HPP_NAMESPACE::DebugUtilsMessengerCallbackDataFlagsEXT flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    DebugUtilsMessengerCallbackDataEXT & setPMessageIdName( const char * pMessageIdName_ ) VULKAN_HPP_NOEXCEPT
    {
      pMessageIdName = pMessageIdName_;
      return *this;
    }

    DebugUtilsMessengerCallbackDataEXT & setMessageIdNumber( int32_t messageIdNumber_ ) VULKAN_HPP_NOEXCEPT
    {
      messageIdNumber = messageIdNumber_;
      return *this;
    }

    DebugUtilsMessengerCallbackDataEXT & setPMessage( const char * pMessage_ ) VULKAN_HPP_NOEXCEPT
    {
      pMessage = pMessage_;
      return *this;
    }

    DebugUtilsMessengerCallbackDataEXT & setQueueLabelCount( uint32_t queueLabelCount_ ) VULKAN_HPP_NOEXCEPT
    {
      queueLabelCount = queueLabelCount_;
      return *this;
    }

    DebugUtilsMessengerCallbackDataEXT &
      setPQueueLabels( const VULKAN_HPP_NAMESPACE::DebugUtilsLabelEXT * pQueueLabels_ ) VULKAN_HPP_NOEXCEPT
    {
      pQueueLabels = pQueueLabels_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    DebugUtilsMessengerCallbackDataEXT & setQueueLabels(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::DebugUtilsLabelEXT> const &
        queueLabels_ ) VULKAN_HPP_NOEXCEPT
    {
      queueLabelCount = static_cast<uint32_t>( queueLabels_.size() );
      pQueueLabels    = queueLabels_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    DebugUtilsMessengerCallbackDataEXT & setCmdBufLabelCount( uint32_t cmdBufLabelCount_ ) VULKAN_HPP_NOEXCEPT
    {
      cmdBufLabelCount = cmdBufLabelCount_;
      return *this;
    }

    DebugUtilsMessengerCallbackDataEXT &
      setPCmdBufLabels( const VULKAN_HPP_NAMESPACE::DebugUtilsLabelEXT * pCmdBufLabels_ ) VULKAN_HPP_NOEXCEPT
    {
      pCmdBufLabels = pCmdBufLabels_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    DebugUtilsMessengerCallbackDataEXT & setCmdBufLabels(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::DebugUtilsLabelEXT> const &
        cmdBufLabels_ ) VULKAN_HPP_NOEXCEPT
    {
      cmdBufLabelCount = static_cast<uint32_t>( cmdBufLabels_.size() );
      pCmdBufLabels    = cmdBufLabels_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    DebugUtilsMessengerCallbackDataEXT & setObjectCount( uint32_t objectCount_ ) VULKAN_HPP_NOEXCEPT
    {
      objectCount = objectCount_;
      return *this;
    }

    DebugUtilsMessengerCallbackDataEXT &
      setPObjects( const VULKAN_HPP_NAMESPACE::DebugUtilsObjectNameInfoEXT * pObjects_ ) VULKAN_HPP_NOEXCEPT
    {
      pObjects = pObjects_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    DebugUtilsMessengerCallbackDataEXT & setObjects(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::DebugUtilsObjectNameInfoEXT> const &
        objects_ ) VULKAN_HPP_NOEXCEPT
    {
      objectCount = static_cast<uint32_t>( objects_.size() );
      pObjects    = objects_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkDebugUtilsMessengerCallbackDataEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDebugUtilsMessengerCallbackDataEXT *>( this );
    }

    operator VkDebugUtilsMessengerCallbackDataEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDebugUtilsMessengerCallbackDataEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DebugUtilsMessengerCallbackDataEXT const & ) const = default;
#else
    bool operator==( DebugUtilsMessengerCallbackDataEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( pMessageIdName == rhs.pMessageIdName ) && ( messageIdNumber == rhs.messageIdNumber ) &&
             ( pMessage == rhs.pMessage ) && ( queueLabelCount == rhs.queueLabelCount ) &&
             ( pQueueLabels == rhs.pQueueLabels ) && ( cmdBufLabelCount == rhs.cmdBufLabelCount ) &&
             ( pCmdBufLabels == rhs.pCmdBufLabels ) && ( objectCount == rhs.objectCount ) &&
             ( pObjects == rhs.pObjects );
    }

    bool operator!=( DebugUtilsMessengerCallbackDataEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::eDebugUtilsMessengerCallbackDataEXT;
    const void *                        pNext = {};
    VULKAN_HPP_NAMESPACE::DebugUtilsMessengerCallbackDataFlagsEXT flags            = {};
    const char *                                                  pMessageIdName   = {};
    int32_t                                                       messageIdNumber  = {};
    const char *                                                  pMessage         = {};
    uint32_t                                                      queueLabelCount  = {};
    const VULKAN_HPP_NAMESPACE::DebugUtilsLabelEXT *              pQueueLabels     = {};
    uint32_t                                                      cmdBufLabelCount = {};
    const VULKAN_HPP_NAMESPACE::DebugUtilsLabelEXT *              pCmdBufLabels    = {};
    uint32_t                                                      objectCount      = {};
    const VULKAN_HPP_NAMESPACE::DebugUtilsObjectNameInfoEXT *     pObjects         = {};
  };
  static_assert( sizeof( DebugUtilsMessengerCallbackDataEXT ) == sizeof( VkDebugUtilsMessengerCallbackDataEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DebugUtilsMessengerCallbackDataEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDebugUtilsMessengerCallbackDataEXT>
  {
    using Type = DebugUtilsMessengerCallbackDataEXT;
  };

  struct DebugUtilsMessengerCreateInfoEXT
  {
    static const bool                    allowDuplicate              = true;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eDebugUtilsMessengerCreateInfoEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      DebugUtilsMessengerCreateInfoEXT( VULKAN_HPP_NAMESPACE::DebugUtilsMessengerCreateFlagsEXT flags_           = {},
                                        VULKAN_HPP_NAMESPACE::DebugUtilsMessageSeverityFlagsEXT messageSeverity_ = {},
                                        VULKAN_HPP_NAMESPACE::DebugUtilsMessageTypeFlagsEXT     messageType_     = {},
                                        PFN_vkDebugUtilsMessengerCallbackEXT                    pfnUserCallback_ = {},
                                        void * pUserData_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , messageSeverity( messageSeverity_ )
      , messageType( messageType_ )
      , pfnUserCallback( pfnUserCallback_ )
      , pUserData( pUserData_ )
    {}

    VULKAN_HPP_CONSTEXPR
      DebugUtilsMessengerCreateInfoEXT( DebugUtilsMessengerCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DebugUtilsMessengerCreateInfoEXT( VkDebugUtilsMessengerCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : DebugUtilsMessengerCreateInfoEXT( *reinterpret_cast<DebugUtilsMessengerCreateInfoEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DebugUtilsMessengerCreateInfoEXT &
                            operator=( DebugUtilsMessengerCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DebugUtilsMessengerCreateInfoEXT & operator=( VkDebugUtilsMessengerCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DebugUtilsMessengerCreateInfoEXT const *>( &rhs );
      return *this;
    }

    DebugUtilsMessengerCreateInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    DebugUtilsMessengerCreateInfoEXT &
      setFlags( VULKAN_HPP_NAMESPACE::DebugUtilsMessengerCreateFlagsEXT flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    DebugUtilsMessengerCreateInfoEXT &
      setMessageSeverity( VULKAN_HPP_NAMESPACE::DebugUtilsMessageSeverityFlagsEXT messageSeverity_ ) VULKAN_HPP_NOEXCEPT
    {
      messageSeverity = messageSeverity_;
      return *this;
    }

    DebugUtilsMessengerCreateInfoEXT &
      setMessageType( VULKAN_HPP_NAMESPACE::DebugUtilsMessageTypeFlagsEXT messageType_ ) VULKAN_HPP_NOEXCEPT
    {
      messageType = messageType_;
      return *this;
    }

    DebugUtilsMessengerCreateInfoEXT &
      setPfnUserCallback( PFN_vkDebugUtilsMessengerCallbackEXT pfnUserCallback_ ) VULKAN_HPP_NOEXCEPT
    {
      pfnUserCallback = pfnUserCallback_;
      return *this;
    }

    DebugUtilsMessengerCreateInfoEXT & setPUserData( void * pUserData_ ) VULKAN_HPP_NOEXCEPT
    {
      pUserData = pUserData_;
      return *this;
    }

    operator VkDebugUtilsMessengerCreateInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDebugUtilsMessengerCreateInfoEXT *>( this );
    }

    operator VkDebugUtilsMessengerCreateInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDebugUtilsMessengerCreateInfoEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DebugUtilsMessengerCreateInfoEXT const & ) const = default;
#else
    bool operator==( DebugUtilsMessengerCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( messageSeverity == rhs.messageSeverity ) && ( messageType == rhs.messageType ) &&
             ( pfnUserCallback == rhs.pfnUserCallback ) && ( pUserData == rhs.pUserData );
    }

    bool operator!=( DebugUtilsMessengerCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                     sType = StructureType::eDebugUtilsMessengerCreateInfoEXT;
    const void *                                            pNext = {};
    VULKAN_HPP_NAMESPACE::DebugUtilsMessengerCreateFlagsEXT flags = {};
    VULKAN_HPP_NAMESPACE::DebugUtilsMessageSeverityFlagsEXT messageSeverity = {};
    VULKAN_HPP_NAMESPACE::DebugUtilsMessageTypeFlagsEXT     messageType     = {};
    PFN_vkDebugUtilsMessengerCallbackEXT                    pfnUserCallback = {};
    void *                                                  pUserData       = {};
  };
  static_assert( sizeof( DebugUtilsMessengerCreateInfoEXT ) == sizeof( VkDebugUtilsMessengerCreateInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DebugUtilsMessengerCreateInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDebugUtilsMessengerCreateInfoEXT>
  {
    using Type = DebugUtilsMessengerCreateInfoEXT;
  };

  struct DebugUtilsObjectTagInfoEXT
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eDebugUtilsObjectTagInfoEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR DebugUtilsObjectTagInfoEXT(
      VULKAN_HPP_NAMESPACE::ObjectType objectType_   = VULKAN_HPP_NAMESPACE::ObjectType::eUnknown,
      uint64_t                         objectHandle_ = {},
      uint64_t                         tagName_      = {},
      size_t                           tagSize_      = {},
      const void *                     pTag_         = {} ) VULKAN_HPP_NOEXCEPT
      : objectType( objectType_ )
      , objectHandle( objectHandle_ )
      , tagName( tagName_ )
      , tagSize( tagSize_ )
      , pTag( pTag_ )
    {}

    VULKAN_HPP_CONSTEXPR
      DebugUtilsObjectTagInfoEXT( DebugUtilsObjectTagInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DebugUtilsObjectTagInfoEXT( VkDebugUtilsObjectTagInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : DebugUtilsObjectTagInfoEXT( *reinterpret_cast<DebugUtilsObjectTagInfoEXT const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    template <typename T>
    DebugUtilsObjectTagInfoEXT( VULKAN_HPP_NAMESPACE::ObjectType                               objectType_,
                                uint64_t                                                       objectHandle_,
                                uint64_t                                                       tagName_,
                                VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const T> const & tag_ )
      : objectType( objectType_ )
      , objectHandle( objectHandle_ )
      , tagName( tagName_ )
      , tagSize( tag_.size() * sizeof( T ) )
      , pTag( tag_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DebugUtilsObjectTagInfoEXT &
                            operator=( DebugUtilsObjectTagInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DebugUtilsObjectTagInfoEXT & operator=( VkDebugUtilsObjectTagInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DebugUtilsObjectTagInfoEXT const *>( &rhs );
      return *this;
    }

    DebugUtilsObjectTagInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    DebugUtilsObjectTagInfoEXT & setObjectType( VULKAN_HPP_NAMESPACE::ObjectType objectType_ ) VULKAN_HPP_NOEXCEPT
    {
      objectType = objectType_;
      return *this;
    }

    DebugUtilsObjectTagInfoEXT & setObjectHandle( uint64_t objectHandle_ ) VULKAN_HPP_NOEXCEPT
    {
      objectHandle = objectHandle_;
      return *this;
    }

    DebugUtilsObjectTagInfoEXT & setTagName( uint64_t tagName_ ) VULKAN_HPP_NOEXCEPT
    {
      tagName = tagName_;
      return *this;
    }

    DebugUtilsObjectTagInfoEXT & setTagSize( size_t tagSize_ ) VULKAN_HPP_NOEXCEPT
    {
      tagSize = tagSize_;
      return *this;
    }

    DebugUtilsObjectTagInfoEXT & setPTag( const void * pTag_ ) VULKAN_HPP_NOEXCEPT
    {
      pTag = pTag_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    template <typename T>
    DebugUtilsObjectTagInfoEXT &
      setTag( VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const T> const & tag_ ) VULKAN_HPP_NOEXCEPT
    {
      tagSize = tag_.size() * sizeof( T );
      pTag    = tag_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkDebugUtilsObjectTagInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDebugUtilsObjectTagInfoEXT *>( this );
    }

    operator VkDebugUtilsObjectTagInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDebugUtilsObjectTagInfoEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DebugUtilsObjectTagInfoEXT const & ) const = default;
#else
    bool operator==( DebugUtilsObjectTagInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( objectType == rhs.objectType ) &&
             ( objectHandle == rhs.objectHandle ) && ( tagName == rhs.tagName ) && ( tagSize == rhs.tagSize ) &&
             ( pTag == rhs.pTag );
    }

    bool operator!=( DebugUtilsObjectTagInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType        = StructureType::eDebugUtilsObjectTagInfoEXT;
    const void *                        pNext        = {};
    VULKAN_HPP_NAMESPACE::ObjectType    objectType   = VULKAN_HPP_NAMESPACE::ObjectType::eUnknown;
    uint64_t                            objectHandle = {};
    uint64_t                            tagName      = {};
    size_t                              tagSize      = {};
    const void *                        pTag         = {};
  };
  static_assert( sizeof( DebugUtilsObjectTagInfoEXT ) == sizeof( VkDebugUtilsObjectTagInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DebugUtilsObjectTagInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDebugUtilsObjectTagInfoEXT>
  {
    using Type = DebugUtilsObjectTagInfoEXT;
  };

  struct DedicatedAllocationBufferCreateInfoNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eDedicatedAllocationBufferCreateInfoNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR DedicatedAllocationBufferCreateInfoNV( VULKAN_HPP_NAMESPACE::Bool32 dedicatedAllocation_ = {} )
      VULKAN_HPP_NOEXCEPT : dedicatedAllocation( dedicatedAllocation_ )
    {}

    VULKAN_HPP_CONSTEXPR DedicatedAllocationBufferCreateInfoNV( DedicatedAllocationBufferCreateInfoNV const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    DedicatedAllocationBufferCreateInfoNV( VkDedicatedAllocationBufferCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
      : DedicatedAllocationBufferCreateInfoNV(
          *reinterpret_cast<DedicatedAllocationBufferCreateInfoNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DedicatedAllocationBufferCreateInfoNV &
                            operator=( DedicatedAllocationBufferCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DedicatedAllocationBufferCreateInfoNV &
      operator=( VkDedicatedAllocationBufferCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DedicatedAllocationBufferCreateInfoNV const *>( &rhs );
      return *this;
    }

    DedicatedAllocationBufferCreateInfoNV & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    DedicatedAllocationBufferCreateInfoNV &
      setDedicatedAllocation( VULKAN_HPP_NAMESPACE::Bool32 dedicatedAllocation_ ) VULKAN_HPP_NOEXCEPT
    {
      dedicatedAllocation = dedicatedAllocation_;
      return *this;
    }

    operator VkDedicatedAllocationBufferCreateInfoNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDedicatedAllocationBufferCreateInfoNV *>( this );
    }

    operator VkDedicatedAllocationBufferCreateInfoNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDedicatedAllocationBufferCreateInfoNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DedicatedAllocationBufferCreateInfoNV const & ) const = default;
#else
    bool operator==( DedicatedAllocationBufferCreateInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( dedicatedAllocation == rhs.dedicatedAllocation );
    }

    bool operator!=( DedicatedAllocationBufferCreateInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType               = StructureType::eDedicatedAllocationBufferCreateInfoNV;
    const void *                        pNext               = {};
    VULKAN_HPP_NAMESPACE::Bool32        dedicatedAllocation = {};
  };
  static_assert( sizeof( DedicatedAllocationBufferCreateInfoNV ) == sizeof( VkDedicatedAllocationBufferCreateInfoNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DedicatedAllocationBufferCreateInfoNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDedicatedAllocationBufferCreateInfoNV>
  {
    using Type = DedicatedAllocationBufferCreateInfoNV;
  };

  struct DedicatedAllocationImageCreateInfoNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eDedicatedAllocationImageCreateInfoNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      DedicatedAllocationImageCreateInfoNV( VULKAN_HPP_NAMESPACE::Bool32 dedicatedAllocation_ = {} ) VULKAN_HPP_NOEXCEPT
      : dedicatedAllocation( dedicatedAllocation_ )
    {}

    VULKAN_HPP_CONSTEXPR DedicatedAllocationImageCreateInfoNV( DedicatedAllocationImageCreateInfoNV const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    DedicatedAllocationImageCreateInfoNV( VkDedicatedAllocationImageCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
      : DedicatedAllocationImageCreateInfoNV( *reinterpret_cast<DedicatedAllocationImageCreateInfoNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DedicatedAllocationImageCreateInfoNV &
                            operator=( DedicatedAllocationImageCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DedicatedAllocationImageCreateInfoNV &
      operator=( VkDedicatedAllocationImageCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DedicatedAllocationImageCreateInfoNV const *>( &rhs );
      return *this;
    }

    DedicatedAllocationImageCreateInfoNV & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    DedicatedAllocationImageCreateInfoNV &
      setDedicatedAllocation( VULKAN_HPP_NAMESPACE::Bool32 dedicatedAllocation_ ) VULKAN_HPP_NOEXCEPT
    {
      dedicatedAllocation = dedicatedAllocation_;
      return *this;
    }

    operator VkDedicatedAllocationImageCreateInfoNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDedicatedAllocationImageCreateInfoNV *>( this );
    }

    operator VkDedicatedAllocationImageCreateInfoNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDedicatedAllocationImageCreateInfoNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DedicatedAllocationImageCreateInfoNV const & ) const = default;
#else
    bool operator==( DedicatedAllocationImageCreateInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( dedicatedAllocation == rhs.dedicatedAllocation );
    }

    bool operator!=( DedicatedAllocationImageCreateInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType               = StructureType::eDedicatedAllocationImageCreateInfoNV;
    const void *                        pNext               = {};
    VULKAN_HPP_NAMESPACE::Bool32        dedicatedAllocation = {};
  };
  static_assert( sizeof( DedicatedAllocationImageCreateInfoNV ) == sizeof( VkDedicatedAllocationImageCreateInfoNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DedicatedAllocationImageCreateInfoNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDedicatedAllocationImageCreateInfoNV>
  {
    using Type = DedicatedAllocationImageCreateInfoNV;
  };

  struct DedicatedAllocationMemoryAllocateInfoNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eDedicatedAllocationMemoryAllocateInfoNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      DedicatedAllocationMemoryAllocateInfoNV( VULKAN_HPP_NAMESPACE::Image  image_  = {},
                                               VULKAN_HPP_NAMESPACE::Buffer buffer_ = {} ) VULKAN_HPP_NOEXCEPT
      : image( image_ )
      , buffer( buffer_ )
    {}

    VULKAN_HPP_CONSTEXPR DedicatedAllocationMemoryAllocateInfoNV( DedicatedAllocationMemoryAllocateInfoNV const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    DedicatedAllocationMemoryAllocateInfoNV( VkDedicatedAllocationMemoryAllocateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
      : DedicatedAllocationMemoryAllocateInfoNV(
          *reinterpret_cast<DedicatedAllocationMemoryAllocateInfoNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DedicatedAllocationMemoryAllocateInfoNV &
                            operator=( DedicatedAllocationMemoryAllocateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DedicatedAllocationMemoryAllocateInfoNV &
      operator=( VkDedicatedAllocationMemoryAllocateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DedicatedAllocationMemoryAllocateInfoNV const *>( &rhs );
      return *this;
    }

    DedicatedAllocationMemoryAllocateInfoNV & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    DedicatedAllocationMemoryAllocateInfoNV & setImage( VULKAN_HPP_NAMESPACE::Image image_ ) VULKAN_HPP_NOEXCEPT
    {
      image = image_;
      return *this;
    }

    DedicatedAllocationMemoryAllocateInfoNV & setBuffer( VULKAN_HPP_NAMESPACE::Buffer buffer_ ) VULKAN_HPP_NOEXCEPT
    {
      buffer = buffer_;
      return *this;
    }

    operator VkDedicatedAllocationMemoryAllocateInfoNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDedicatedAllocationMemoryAllocateInfoNV *>( this );
    }

    operator VkDedicatedAllocationMemoryAllocateInfoNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDedicatedAllocationMemoryAllocateInfoNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DedicatedAllocationMemoryAllocateInfoNV const & ) const = default;
#else
    bool operator==( DedicatedAllocationMemoryAllocateInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( image == rhs.image ) && ( buffer == rhs.buffer );
    }

    bool operator!=( DedicatedAllocationMemoryAllocateInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType  = StructureType::eDedicatedAllocationMemoryAllocateInfoNV;
    const void *                        pNext  = {};
    VULKAN_HPP_NAMESPACE::Image         image  = {};
    VULKAN_HPP_NAMESPACE::Buffer        buffer = {};
  };
  static_assert( sizeof( DedicatedAllocationMemoryAllocateInfoNV ) ==
                   sizeof( VkDedicatedAllocationMemoryAllocateInfoNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DedicatedAllocationMemoryAllocateInfoNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDedicatedAllocationMemoryAllocateInfoNV>
  {
    using Type = DedicatedAllocationMemoryAllocateInfoNV;
  };

  struct MemoryBarrier2KHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eMemoryBarrier2KHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      MemoryBarrier2KHR( VULKAN_HPP_NAMESPACE::PipelineStageFlags2KHR srcStageMask_  = {},
                         VULKAN_HPP_NAMESPACE::AccessFlags2KHR        srcAccessMask_ = {},
                         VULKAN_HPP_NAMESPACE::PipelineStageFlags2KHR dstStageMask_  = {},
                         VULKAN_HPP_NAMESPACE::AccessFlags2KHR        dstAccessMask_ = {} ) VULKAN_HPP_NOEXCEPT
      : srcStageMask( srcStageMask_ )
      , srcAccessMask( srcAccessMask_ )
      , dstStageMask( dstStageMask_ )
      , dstAccessMask( dstAccessMask_ )
    {}

    VULKAN_HPP_CONSTEXPR MemoryBarrier2KHR( MemoryBarrier2KHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MemoryBarrier2KHR( VkMemoryBarrier2KHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : MemoryBarrier2KHR( *reinterpret_cast<MemoryBarrier2KHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 MemoryBarrier2KHR &
                            operator=( MemoryBarrier2KHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MemoryBarrier2KHR & operator=( VkMemoryBarrier2KHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::MemoryBarrier2KHR const *>( &rhs );
      return *this;
    }

    MemoryBarrier2KHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    MemoryBarrier2KHR &
      setSrcStageMask( VULKAN_HPP_NAMESPACE::PipelineStageFlags2KHR srcStageMask_ ) VULKAN_HPP_NOEXCEPT
    {
      srcStageMask = srcStageMask_;
      return *this;
    }

    MemoryBarrier2KHR & setSrcAccessMask( VULKAN_HPP_NAMESPACE::AccessFlags2KHR srcAccessMask_ ) VULKAN_HPP_NOEXCEPT
    {
      srcAccessMask = srcAccessMask_;
      return *this;
    }

    MemoryBarrier2KHR &
      setDstStageMask( VULKAN_HPP_NAMESPACE::PipelineStageFlags2KHR dstStageMask_ ) VULKAN_HPP_NOEXCEPT
    {
      dstStageMask = dstStageMask_;
      return *this;
    }

    MemoryBarrier2KHR & setDstAccessMask( VULKAN_HPP_NAMESPACE::AccessFlags2KHR dstAccessMask_ ) VULKAN_HPP_NOEXCEPT
    {
      dstAccessMask = dstAccessMask_;
      return *this;
    }

    operator VkMemoryBarrier2KHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkMemoryBarrier2KHR *>( this );
    }

    operator VkMemoryBarrier2KHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkMemoryBarrier2KHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( MemoryBarrier2KHR const & ) const = default;
#else
    bool operator==( MemoryBarrier2KHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( srcStageMask == rhs.srcStageMask ) &&
             ( srcAccessMask == rhs.srcAccessMask ) && ( dstStageMask == rhs.dstStageMask ) &&
             ( dstAccessMask == rhs.dstAccessMask );
    }

    bool operator!=( MemoryBarrier2KHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType          sType         = StructureType::eMemoryBarrier2KHR;
    const void *                                 pNext         = {};
    VULKAN_HPP_NAMESPACE::PipelineStageFlags2KHR srcStageMask  = {};
    VULKAN_HPP_NAMESPACE::AccessFlags2KHR        srcAccessMask = {};
    VULKAN_HPP_NAMESPACE::PipelineStageFlags2KHR dstStageMask  = {};
    VULKAN_HPP_NAMESPACE::AccessFlags2KHR        dstAccessMask = {};
  };
  static_assert( sizeof( MemoryBarrier2KHR ) == sizeof( VkMemoryBarrier2KHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<MemoryBarrier2KHR>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eMemoryBarrier2KHR>
  {
    using Type = MemoryBarrier2KHR;
  };

  struct ImageSubresourceRange
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ImageSubresourceRange( VULKAN_HPP_NAMESPACE::ImageAspectFlags aspectMask_     = {},
                                                uint32_t                               baseMipLevel_   = {},
                                                uint32_t                               levelCount_     = {},
                                                uint32_t                               baseArrayLayer_ = {},
                                                uint32_t layerCount_ = {} ) VULKAN_HPP_NOEXCEPT
      : aspectMask( aspectMask_ )
      , baseMipLevel( baseMipLevel_ )
      , levelCount( levelCount_ )
      , baseArrayLayer( baseArrayLayer_ )
      , layerCount( layerCount_ )
    {}

    VULKAN_HPP_CONSTEXPR ImageSubresourceRange( ImageSubresourceRange const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImageSubresourceRange( VkImageSubresourceRange const & rhs ) VULKAN_HPP_NOEXCEPT
      : ImageSubresourceRange( *reinterpret_cast<ImageSubresourceRange const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ImageSubresourceRange &
                            operator=( ImageSubresourceRange const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImageSubresourceRange & operator=( VkImageSubresourceRange const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ImageSubresourceRange const *>( &rhs );
      return *this;
    }

    ImageSubresourceRange & setAspectMask( VULKAN_HPP_NAMESPACE::ImageAspectFlags aspectMask_ ) VULKAN_HPP_NOEXCEPT
    {
      aspectMask = aspectMask_;
      return *this;
    }

    ImageSubresourceRange & setBaseMipLevel( uint32_t baseMipLevel_ ) VULKAN_HPP_NOEXCEPT
    {
      baseMipLevel = baseMipLevel_;
      return *this;
    }

    ImageSubresourceRange & setLevelCount( uint32_t levelCount_ ) VULKAN_HPP_NOEXCEPT
    {
      levelCount = levelCount_;
      return *this;
    }

    ImageSubresourceRange & setBaseArrayLayer( uint32_t baseArrayLayer_ ) VULKAN_HPP_NOEXCEPT
    {
      baseArrayLayer = baseArrayLayer_;
      return *this;
    }

    ImageSubresourceRange & setLayerCount( uint32_t layerCount_ ) VULKAN_HPP_NOEXCEPT
    {
      layerCount = layerCount_;
      return *this;
    }

    operator VkImageSubresourceRange const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkImageSubresourceRange *>( this );
    }

    operator VkImageSubresourceRange &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkImageSubresourceRange *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ImageSubresourceRange const & ) const = default;
#else
    bool operator==( ImageSubresourceRange const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( aspectMask == rhs.aspectMask ) && ( baseMipLevel == rhs.baseMipLevel ) &&
             ( levelCount == rhs.levelCount ) && ( baseArrayLayer == rhs.baseArrayLayer ) &&
             ( layerCount == rhs.layerCount );
    }

    bool operator!=( ImageSubresourceRange const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::ImageAspectFlags aspectMask     = {};
    uint32_t                               baseMipLevel   = {};
    uint32_t                               levelCount     = {};
    uint32_t                               baseArrayLayer = {};
    uint32_t                               layerCount     = {};
  };
  static_assert( sizeof( ImageSubresourceRange ) == sizeof( VkImageSubresourceRange ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ImageSubresourceRange>::value, "struct wrapper is not a standard layout!" );

  struct ImageMemoryBarrier2KHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eImageMemoryBarrier2KHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ImageMemoryBarrier2KHR(
      VULKAN_HPP_NAMESPACE::PipelineStageFlags2KHR srcStageMask_        = {},
      VULKAN_HPP_NAMESPACE::AccessFlags2KHR        srcAccessMask_       = {},
      VULKAN_HPP_NAMESPACE::PipelineStageFlags2KHR dstStageMask_        = {},
      VULKAN_HPP_NAMESPACE::AccessFlags2KHR        dstAccessMask_       = {},
      VULKAN_HPP_NAMESPACE::ImageLayout            oldLayout_           = VULKAN_HPP_NAMESPACE::ImageLayout::eUndefined,
      VULKAN_HPP_NAMESPACE::ImageLayout            newLayout_           = VULKAN_HPP_NAMESPACE::ImageLayout::eUndefined,
      uint32_t                                     srcQueueFamilyIndex_ = {},
      uint32_t                                     dstQueueFamilyIndex_ = {},
      VULKAN_HPP_NAMESPACE::Image                  image_               = {},
      VULKAN_HPP_NAMESPACE::ImageSubresourceRange  subresourceRange_    = {} ) VULKAN_HPP_NOEXCEPT
      : srcStageMask( srcStageMask_ )
      , srcAccessMask( srcAccessMask_ )
      , dstStageMask( dstStageMask_ )
      , dstAccessMask( dstAccessMask_ )
      , oldLayout( oldLayout_ )
      , newLayout( newLayout_ )
      , srcQueueFamilyIndex( srcQueueFamilyIndex_ )
      , dstQueueFamilyIndex( dstQueueFamilyIndex_ )
      , image( image_ )
      , subresourceRange( subresourceRange_ )
    {}

    VULKAN_HPP_CONSTEXPR ImageMemoryBarrier2KHR( ImageMemoryBarrier2KHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImageMemoryBarrier2KHR( VkImageMemoryBarrier2KHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : ImageMemoryBarrier2KHR( *reinterpret_cast<ImageMemoryBarrier2KHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ImageMemoryBarrier2KHR &
                            operator=( ImageMemoryBarrier2KHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImageMemoryBarrier2KHR & operator=( VkImageMemoryBarrier2KHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ImageMemoryBarrier2KHR const *>( &rhs );
      return *this;
    }

    ImageMemoryBarrier2KHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ImageMemoryBarrier2KHR &
      setSrcStageMask( VULKAN_HPP_NAMESPACE::PipelineStageFlags2KHR srcStageMask_ ) VULKAN_HPP_NOEXCEPT
    {
      srcStageMask = srcStageMask_;
      return *this;
    }

    ImageMemoryBarrier2KHR &
      setSrcAccessMask( VULKAN_HPP_NAMESPACE::AccessFlags2KHR srcAccessMask_ ) VULKAN_HPP_NOEXCEPT
    {
      srcAccessMask = srcAccessMask_;
      return *this;
    }

    ImageMemoryBarrier2KHR &
      setDstStageMask( VULKAN_HPP_NAMESPACE::PipelineStageFlags2KHR dstStageMask_ ) VULKAN_HPP_NOEXCEPT
    {
      dstStageMask = dstStageMask_;
      return *this;
    }

    ImageMemoryBarrier2KHR &
      setDstAccessMask( VULKAN_HPP_NAMESPACE::AccessFlags2KHR dstAccessMask_ ) VULKAN_HPP_NOEXCEPT
    {
      dstAccessMask = dstAccessMask_;
      return *this;
    }

    ImageMemoryBarrier2KHR & setOldLayout( VULKAN_HPP_NAMESPACE::ImageLayout oldLayout_ ) VULKAN_HPP_NOEXCEPT
    {
      oldLayout = oldLayout_;
      return *this;
    }

    ImageMemoryBarrier2KHR & setNewLayout( VULKAN_HPP_NAMESPACE::ImageLayout newLayout_ ) VULKAN_HPP_NOEXCEPT
    {
      newLayout = newLayout_;
      return *this;
    }

    ImageMemoryBarrier2KHR & setSrcQueueFamilyIndex( uint32_t srcQueueFamilyIndex_ ) VULKAN_HPP_NOEXCEPT
    {
      srcQueueFamilyIndex = srcQueueFamilyIndex_;
      return *this;
    }

    ImageMemoryBarrier2KHR & setDstQueueFamilyIndex( uint32_t dstQueueFamilyIndex_ ) VULKAN_HPP_NOEXCEPT
    {
      dstQueueFamilyIndex = dstQueueFamilyIndex_;
      return *this;
    }

    ImageMemoryBarrier2KHR & setImage( VULKAN_HPP_NAMESPACE::Image image_ ) VULKAN_HPP_NOEXCEPT
    {
      image = image_;
      return *this;
    }

    ImageMemoryBarrier2KHR &
      setSubresourceRange( VULKAN_HPP_NAMESPACE::ImageSubresourceRange const & subresourceRange_ ) VULKAN_HPP_NOEXCEPT
    {
      subresourceRange = subresourceRange_;
      return *this;
    }

    operator VkImageMemoryBarrier2KHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkImageMemoryBarrier2KHR *>( this );
    }

    operator VkImageMemoryBarrier2KHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkImageMemoryBarrier2KHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ImageMemoryBarrier2KHR const & ) const = default;
#else
    bool operator==( ImageMemoryBarrier2KHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( srcStageMask == rhs.srcStageMask ) &&
             ( srcAccessMask == rhs.srcAccessMask ) && ( dstStageMask == rhs.dstStageMask ) &&
             ( dstAccessMask == rhs.dstAccessMask ) && ( oldLayout == rhs.oldLayout ) &&
             ( newLayout == rhs.newLayout ) && ( srcQueueFamilyIndex == rhs.srcQueueFamilyIndex ) &&
             ( dstQueueFamilyIndex == rhs.dstQueueFamilyIndex ) && ( image == rhs.image ) &&
             ( subresourceRange == rhs.subresourceRange );
    }

    bool operator!=( ImageMemoryBarrier2KHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType          sType               = StructureType::eImageMemoryBarrier2KHR;
    const void *                                 pNext               = {};
    VULKAN_HPP_NAMESPACE::PipelineStageFlags2KHR srcStageMask        = {};
    VULKAN_HPP_NAMESPACE::AccessFlags2KHR        srcAccessMask       = {};
    VULKAN_HPP_NAMESPACE::PipelineStageFlags2KHR dstStageMask        = {};
    VULKAN_HPP_NAMESPACE::AccessFlags2KHR        dstAccessMask       = {};
    VULKAN_HPP_NAMESPACE::ImageLayout            oldLayout           = VULKAN_HPP_NAMESPACE::ImageLayout::eUndefined;
    VULKAN_HPP_NAMESPACE::ImageLayout            newLayout           = VULKAN_HPP_NAMESPACE::ImageLayout::eUndefined;
    uint32_t                                     srcQueueFamilyIndex = {};
    uint32_t                                     dstQueueFamilyIndex = {};
    VULKAN_HPP_NAMESPACE::Image                  image               = {};
    VULKAN_HPP_NAMESPACE::ImageSubresourceRange  subresourceRange    = {};
  };
  static_assert( sizeof( ImageMemoryBarrier2KHR ) == sizeof( VkImageMemoryBarrier2KHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ImageMemoryBarrier2KHR>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eImageMemoryBarrier2KHR>
  {
    using Type = ImageMemoryBarrier2KHR;
  };

  struct DependencyInfoKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eDependencyInfoKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR DependencyInfoKHR(
      VULKAN_HPP_NAMESPACE::DependencyFlags                 dependencyFlags_          = {},
      uint32_t                                              memoryBarrierCount_       = {},
      const VULKAN_HPP_NAMESPACE::MemoryBarrier2KHR *       pMemoryBarriers_          = {},
      uint32_t                                              bufferMemoryBarrierCount_ = {},
      const VULKAN_HPP_NAMESPACE::BufferMemoryBarrier2KHR * pBufferMemoryBarriers_    = {},
      uint32_t                                              imageMemoryBarrierCount_  = {},
      const VULKAN_HPP_NAMESPACE::ImageMemoryBarrier2KHR *  pImageMemoryBarriers_     = {} ) VULKAN_HPP_NOEXCEPT
      : dependencyFlags( dependencyFlags_ )
      , memoryBarrierCount( memoryBarrierCount_ )
      , pMemoryBarriers( pMemoryBarriers_ )
      , bufferMemoryBarrierCount( bufferMemoryBarrierCount_ )
      , pBufferMemoryBarriers( pBufferMemoryBarriers_ )
      , imageMemoryBarrierCount( imageMemoryBarrierCount_ )
      , pImageMemoryBarriers( pImageMemoryBarriers_ )
    {}

    VULKAN_HPP_CONSTEXPR DependencyInfoKHR( DependencyInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DependencyInfoKHR( VkDependencyInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : DependencyInfoKHR( *reinterpret_cast<DependencyInfoKHR const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    DependencyInfoKHR(
      VULKAN_HPP_NAMESPACE::DependencyFlags dependencyFlags_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::MemoryBarrier2KHR> const &
        memoryBarriers_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::BufferMemoryBarrier2KHR> const &
        bufferMemoryBarriers_ = {},
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::ImageMemoryBarrier2KHR> const &
        imageMemoryBarriers_ = {} )
      : dependencyFlags( dependencyFlags_ )
      , memoryBarrierCount( static_cast<uint32_t>( memoryBarriers_.size() ) )
      , pMemoryBarriers( memoryBarriers_.data() )
      , bufferMemoryBarrierCount( static_cast<uint32_t>( bufferMemoryBarriers_.size() ) )
      , pBufferMemoryBarriers( bufferMemoryBarriers_.data() )
      , imageMemoryBarrierCount( static_cast<uint32_t>( imageMemoryBarriers_.size() ) )
      , pImageMemoryBarriers( imageMemoryBarriers_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DependencyInfoKHR &
                            operator=( DependencyInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DependencyInfoKHR & operator=( VkDependencyInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DependencyInfoKHR const *>( &rhs );
      return *this;
    }

    DependencyInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    DependencyInfoKHR & setDependencyFlags( VULKAN_HPP_NAMESPACE::DependencyFlags dependencyFlags_ ) VULKAN_HPP_NOEXCEPT
    {
      dependencyFlags = dependencyFlags_;
      return *this;
    }

    DependencyInfoKHR & setMemoryBarrierCount( uint32_t memoryBarrierCount_ ) VULKAN_HPP_NOEXCEPT
    {
      memoryBarrierCount = memoryBarrierCount_;
      return *this;
    }

    DependencyInfoKHR &
      setPMemoryBarriers( const VULKAN_HPP_NAMESPACE::MemoryBarrier2KHR * pMemoryBarriers_ ) VULKAN_HPP_NOEXCEPT
    {
      pMemoryBarriers = pMemoryBarriers_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    DependencyInfoKHR & setMemoryBarriers(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::MemoryBarrier2KHR> const &
        memoryBarriers_ ) VULKAN_HPP_NOEXCEPT
    {
      memoryBarrierCount = static_cast<uint32_t>( memoryBarriers_.size() );
      pMemoryBarriers    = memoryBarriers_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    DependencyInfoKHR & setBufferMemoryBarrierCount( uint32_t bufferMemoryBarrierCount_ ) VULKAN_HPP_NOEXCEPT
    {
      bufferMemoryBarrierCount = bufferMemoryBarrierCount_;
      return *this;
    }

    DependencyInfoKHR & setPBufferMemoryBarriers(
      const VULKAN_HPP_NAMESPACE::BufferMemoryBarrier2KHR * pBufferMemoryBarriers_ ) VULKAN_HPP_NOEXCEPT
    {
      pBufferMemoryBarriers = pBufferMemoryBarriers_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    DependencyInfoKHR & setBufferMemoryBarriers(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::BufferMemoryBarrier2KHR> const &
        bufferMemoryBarriers_ ) VULKAN_HPP_NOEXCEPT
    {
      bufferMemoryBarrierCount = static_cast<uint32_t>( bufferMemoryBarriers_.size() );
      pBufferMemoryBarriers    = bufferMemoryBarriers_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    DependencyInfoKHR & setImageMemoryBarrierCount( uint32_t imageMemoryBarrierCount_ ) VULKAN_HPP_NOEXCEPT
    {
      imageMemoryBarrierCount = imageMemoryBarrierCount_;
      return *this;
    }

    DependencyInfoKHR & setPImageMemoryBarriers(
      const VULKAN_HPP_NAMESPACE::ImageMemoryBarrier2KHR * pImageMemoryBarriers_ ) VULKAN_HPP_NOEXCEPT
    {
      pImageMemoryBarriers = pImageMemoryBarriers_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    DependencyInfoKHR & setImageMemoryBarriers(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::ImageMemoryBarrier2KHR> const &
        imageMemoryBarriers_ ) VULKAN_HPP_NOEXCEPT
    {
      imageMemoryBarrierCount = static_cast<uint32_t>( imageMemoryBarriers_.size() );
      pImageMemoryBarriers    = imageMemoryBarriers_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkDependencyInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDependencyInfoKHR *>( this );
    }

    operator VkDependencyInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDependencyInfoKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DependencyInfoKHR const & ) const = default;
#else
    bool operator==( DependencyInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( dependencyFlags == rhs.dependencyFlags ) &&
             ( memoryBarrierCount == rhs.memoryBarrierCount ) && ( pMemoryBarriers == rhs.pMemoryBarriers ) &&
             ( bufferMemoryBarrierCount == rhs.bufferMemoryBarrierCount ) &&
             ( pBufferMemoryBarriers == rhs.pBufferMemoryBarriers ) &&
             ( imageMemoryBarrierCount == rhs.imageMemoryBarrierCount ) &&
             ( pImageMemoryBarriers == rhs.pImageMemoryBarriers );
    }

    bool operator!=( DependencyInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                   sType                    = StructureType::eDependencyInfoKHR;
    const void *                                          pNext                    = {};
    VULKAN_HPP_NAMESPACE::DependencyFlags                 dependencyFlags          = {};
    uint32_t                                              memoryBarrierCount       = {};
    const VULKAN_HPP_NAMESPACE::MemoryBarrier2KHR *       pMemoryBarriers          = {};
    uint32_t                                              bufferMemoryBarrierCount = {};
    const VULKAN_HPP_NAMESPACE::BufferMemoryBarrier2KHR * pBufferMemoryBarriers    = {};
    uint32_t                                              imageMemoryBarrierCount  = {};
    const VULKAN_HPP_NAMESPACE::ImageMemoryBarrier2KHR *  pImageMemoryBarriers     = {};
  };
  static_assert( sizeof( DependencyInfoKHR ) == sizeof( VkDependencyInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DependencyInfoKHR>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDependencyInfoKHR>
  {
    using Type = DependencyInfoKHR;
  };

  struct DescriptorBufferInfo
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR DescriptorBufferInfo( VULKAN_HPP_NAMESPACE::Buffer     buffer_ = {},
                                               VULKAN_HPP_NAMESPACE::DeviceSize offset_ = {},
                                               VULKAN_HPP_NAMESPACE::DeviceSize range_  = {} ) VULKAN_HPP_NOEXCEPT
      : buffer( buffer_ )
      , offset( offset_ )
      , range( range_ )
    {}

    VULKAN_HPP_CONSTEXPR DescriptorBufferInfo( DescriptorBufferInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DescriptorBufferInfo( VkDescriptorBufferInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : DescriptorBufferInfo( *reinterpret_cast<DescriptorBufferInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DescriptorBufferInfo &
                            operator=( DescriptorBufferInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DescriptorBufferInfo & operator=( VkDescriptorBufferInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DescriptorBufferInfo const *>( &rhs );
      return *this;
    }

    DescriptorBufferInfo & setBuffer( VULKAN_HPP_NAMESPACE::Buffer buffer_ ) VULKAN_HPP_NOEXCEPT
    {
      buffer = buffer_;
      return *this;
    }

    DescriptorBufferInfo & setOffset( VULKAN_HPP_NAMESPACE::DeviceSize offset_ ) VULKAN_HPP_NOEXCEPT
    {
      offset = offset_;
      return *this;
    }

    DescriptorBufferInfo & setRange( VULKAN_HPP_NAMESPACE::DeviceSize range_ ) VULKAN_HPP_NOEXCEPT
    {
      range = range_;
      return *this;
    }

    operator VkDescriptorBufferInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDescriptorBufferInfo *>( this );
    }

    operator VkDescriptorBufferInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDescriptorBufferInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DescriptorBufferInfo const & ) const = default;
#else
    bool operator==( DescriptorBufferInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( buffer == rhs.buffer ) && ( offset == rhs.offset ) && ( range == rhs.range );
    }

    bool operator!=( DescriptorBufferInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::Buffer     buffer = {};
    VULKAN_HPP_NAMESPACE::DeviceSize offset = {};
    VULKAN_HPP_NAMESPACE::DeviceSize range  = {};
  };
  static_assert( sizeof( DescriptorBufferInfo ) == sizeof( VkDescriptorBufferInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DescriptorBufferInfo>::value, "struct wrapper is not a standard layout!" );

  struct DescriptorImageInfo
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR DescriptorImageInfo( VULKAN_HPP_NAMESPACE::Sampler     sampler_   = {},
                                              VULKAN_HPP_NAMESPACE::ImageView   imageView_ = {},
                                              VULKAN_HPP_NAMESPACE::ImageLayout imageLayout_ =
                                                VULKAN_HPP_NAMESPACE::ImageLayout::eUndefined ) VULKAN_HPP_NOEXCEPT
      : sampler( sampler_ )
      , imageView( imageView_ )
      , imageLayout( imageLayout_ )
    {}

    VULKAN_HPP_CONSTEXPR DescriptorImageInfo( DescriptorImageInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DescriptorImageInfo( VkDescriptorImageInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : DescriptorImageInfo( *reinterpret_cast<DescriptorImageInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DescriptorImageInfo &
                            operator=( DescriptorImageInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DescriptorImageInfo & operator=( VkDescriptorImageInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DescriptorImageInfo const *>( &rhs );
      return *this;
    }

    DescriptorImageInfo & setSampler( VULKAN_HPP_NAMESPACE::Sampler sampler_ ) VULKAN_HPP_NOEXCEPT
    {
      sampler = sampler_;
      return *this;
    }

    DescriptorImageInfo & setImageView( VULKAN_HPP_NAMESPACE::ImageView imageView_ ) VULKAN_HPP_NOEXCEPT
    {
      imageView = imageView_;
      return *this;
    }

    DescriptorImageInfo & setImageLayout( VULKAN_HPP_NAMESPACE::ImageLayout imageLayout_ ) VULKAN_HPP_NOEXCEPT
    {
      imageLayout = imageLayout_;
      return *this;
    }

    operator VkDescriptorImageInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDescriptorImageInfo *>( this );
    }

    operator VkDescriptorImageInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDescriptorImageInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DescriptorImageInfo const & ) const = default;
#else
    bool operator==( DescriptorImageInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sampler == rhs.sampler ) && ( imageView == rhs.imageView ) && ( imageLayout == rhs.imageLayout );
    }

    bool operator!=( DescriptorImageInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::Sampler     sampler     = {};
    VULKAN_HPP_NAMESPACE::ImageView   imageView   = {};
    VULKAN_HPP_NAMESPACE::ImageLayout imageLayout = VULKAN_HPP_NAMESPACE::ImageLayout::eUndefined;
  };
  static_assert( sizeof( DescriptorImageInfo ) == sizeof( VkDescriptorImageInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DescriptorImageInfo>::value, "struct wrapper is not a standard layout!" );

  struct DescriptorPoolSize
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      DescriptorPoolSize( VULKAN_HPP_NAMESPACE::DescriptorType type_ = VULKAN_HPP_NAMESPACE::DescriptorType::eSampler,
                          uint32_t                             descriptorCount_ = {} ) VULKAN_HPP_NOEXCEPT
      : type( type_ )
      , descriptorCount( descriptorCount_ )
    {}

    VULKAN_HPP_CONSTEXPR DescriptorPoolSize( DescriptorPoolSize const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DescriptorPoolSize( VkDescriptorPoolSize const & rhs ) VULKAN_HPP_NOEXCEPT
      : DescriptorPoolSize( *reinterpret_cast<DescriptorPoolSize const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DescriptorPoolSize &
                            operator=( DescriptorPoolSize const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DescriptorPoolSize & operator=( VkDescriptorPoolSize const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DescriptorPoolSize const *>( &rhs );
      return *this;
    }

    DescriptorPoolSize & setType( VULKAN_HPP_NAMESPACE::DescriptorType type_ ) VULKAN_HPP_NOEXCEPT
    {
      type = type_;
      return *this;
    }

    DescriptorPoolSize & setDescriptorCount( uint32_t descriptorCount_ ) VULKAN_HPP_NOEXCEPT
    {
      descriptorCount = descriptorCount_;
      return *this;
    }

    operator VkDescriptorPoolSize const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDescriptorPoolSize *>( this );
    }

    operator VkDescriptorPoolSize &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDescriptorPoolSize *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DescriptorPoolSize const & ) const = default;
#else
    bool operator==( DescriptorPoolSize const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( type == rhs.type ) && ( descriptorCount == rhs.descriptorCount );
    }

    bool operator!=( DescriptorPoolSize const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::DescriptorType type            = VULKAN_HPP_NAMESPACE::DescriptorType::eSampler;
    uint32_t                             descriptorCount = {};
  };
  static_assert( sizeof( DescriptorPoolSize ) == sizeof( VkDescriptorPoolSize ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DescriptorPoolSize>::value, "struct wrapper is not a standard layout!" );

  struct DescriptorPoolCreateInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eDescriptorPoolCreateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      DescriptorPoolCreateInfo( VULKAN_HPP_NAMESPACE::DescriptorPoolCreateFlags  flags_         = {},
                                uint32_t                                         maxSets_       = {},
                                uint32_t                                         poolSizeCount_ = {},
                                const VULKAN_HPP_NAMESPACE::DescriptorPoolSize * pPoolSizes_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , maxSets( maxSets_ )
      , poolSizeCount( poolSizeCount_ )
      , pPoolSizes( pPoolSizes_ )
    {}

    VULKAN_HPP_CONSTEXPR DescriptorPoolCreateInfo( DescriptorPoolCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DescriptorPoolCreateInfo( VkDescriptorPoolCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : DescriptorPoolCreateInfo( *reinterpret_cast<DescriptorPoolCreateInfo const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    DescriptorPoolCreateInfo(
      VULKAN_HPP_NAMESPACE::DescriptorPoolCreateFlags                                                       flags_,
      uint32_t                                                                                              maxSets_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::DescriptorPoolSize> const & poolSizes_ )
      : flags( flags_ )
      , maxSets( maxSets_ )
      , poolSizeCount( static_cast<uint32_t>( poolSizes_.size() ) )
      , pPoolSizes( poolSizes_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DescriptorPoolCreateInfo &
                            operator=( DescriptorPoolCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DescriptorPoolCreateInfo & operator=( VkDescriptorPoolCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DescriptorPoolCreateInfo const *>( &rhs );
      return *this;
    }

    DescriptorPoolCreateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    DescriptorPoolCreateInfo & setFlags( VULKAN_HPP_NAMESPACE::DescriptorPoolCreateFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    DescriptorPoolCreateInfo & setMaxSets( uint32_t maxSets_ ) VULKAN_HPP_NOEXCEPT
    {
      maxSets = maxSets_;
      return *this;
    }

    DescriptorPoolCreateInfo & setPoolSizeCount( uint32_t poolSizeCount_ ) VULKAN_HPP_NOEXCEPT
    {
      poolSizeCount = poolSizeCount_;
      return *this;
    }

    DescriptorPoolCreateInfo &
      setPPoolSizes( const VULKAN_HPP_NAMESPACE::DescriptorPoolSize * pPoolSizes_ ) VULKAN_HPP_NOEXCEPT
    {
      pPoolSizes = pPoolSizes_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    DescriptorPoolCreateInfo & setPoolSizes(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::DescriptorPoolSize> const & poolSizes_ )
      VULKAN_HPP_NOEXCEPT
    {
      poolSizeCount = static_cast<uint32_t>( poolSizes_.size() );
      pPoolSizes    = poolSizes_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkDescriptorPoolCreateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDescriptorPoolCreateInfo *>( this );
    }

    operator VkDescriptorPoolCreateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDescriptorPoolCreateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DescriptorPoolCreateInfo const & ) const = default;
#else
    bool operator==( DescriptorPoolCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) && ( maxSets == rhs.maxSets ) &&
             ( poolSizeCount == rhs.poolSizeCount ) && ( pPoolSizes == rhs.pPoolSizes );
    }

    bool operator!=( DescriptorPoolCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType              sType         = StructureType::eDescriptorPoolCreateInfo;
    const void *                                     pNext         = {};
    VULKAN_HPP_NAMESPACE::DescriptorPoolCreateFlags  flags         = {};
    uint32_t                                         maxSets       = {};
    uint32_t                                         poolSizeCount = {};
    const VULKAN_HPP_NAMESPACE::DescriptorPoolSize * pPoolSizes    = {};
  };
  static_assert( sizeof( DescriptorPoolCreateInfo ) == sizeof( VkDescriptorPoolCreateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DescriptorPoolCreateInfo>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDescriptorPoolCreateInfo>
  {
    using Type = DescriptorPoolCreateInfo;
  };

  struct DescriptorPoolInlineUniformBlockCreateInfoEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eDescriptorPoolInlineUniformBlockCreateInfoEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      DescriptorPoolInlineUniformBlockCreateInfoEXT( uint32_t maxInlineUniformBlockBindings_ = {} ) VULKAN_HPP_NOEXCEPT
      : maxInlineUniformBlockBindings( maxInlineUniformBlockBindings_ )
    {}

    VULKAN_HPP_CONSTEXPR DescriptorPoolInlineUniformBlockCreateInfoEXT(
      DescriptorPoolInlineUniformBlockCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DescriptorPoolInlineUniformBlockCreateInfoEXT( VkDescriptorPoolInlineUniformBlockCreateInfoEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : DescriptorPoolInlineUniformBlockCreateInfoEXT(
          *reinterpret_cast<DescriptorPoolInlineUniformBlockCreateInfoEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DescriptorPoolInlineUniformBlockCreateInfoEXT &
                            operator=( DescriptorPoolInlineUniformBlockCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DescriptorPoolInlineUniformBlockCreateInfoEXT &
      operator=( VkDescriptorPoolInlineUniformBlockCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DescriptorPoolInlineUniformBlockCreateInfoEXT const *>( &rhs );
      return *this;
    }

    DescriptorPoolInlineUniformBlockCreateInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    DescriptorPoolInlineUniformBlockCreateInfoEXT &
      setMaxInlineUniformBlockBindings( uint32_t maxInlineUniformBlockBindings_ ) VULKAN_HPP_NOEXCEPT
    {
      maxInlineUniformBlockBindings = maxInlineUniformBlockBindings_;
      return *this;
    }

    operator VkDescriptorPoolInlineUniformBlockCreateInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDescriptorPoolInlineUniformBlockCreateInfoEXT *>( this );
    }

    operator VkDescriptorPoolInlineUniformBlockCreateInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDescriptorPoolInlineUniformBlockCreateInfoEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DescriptorPoolInlineUniformBlockCreateInfoEXT const & ) const = default;
#else
    bool operator==( DescriptorPoolInlineUniformBlockCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( maxInlineUniformBlockBindings == rhs.maxInlineUniformBlockBindings );
    }

    bool operator!=( DescriptorPoolInlineUniformBlockCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::eDescriptorPoolInlineUniformBlockCreateInfoEXT;
    const void *                        pNext = {};
    uint32_t                            maxInlineUniformBlockBindings = {};
  };
  static_assert( sizeof( DescriptorPoolInlineUniformBlockCreateInfoEXT ) ==
                   sizeof( VkDescriptorPoolInlineUniformBlockCreateInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DescriptorPoolInlineUniformBlockCreateInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDescriptorPoolInlineUniformBlockCreateInfoEXT>
  {
    using Type = DescriptorPoolInlineUniformBlockCreateInfoEXT;
  };

  struct DescriptorSetAllocateInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eDescriptorSetAllocateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR DescriptorSetAllocateInfo(
      VULKAN_HPP_NAMESPACE::DescriptorPool              descriptorPool_     = {},
      uint32_t                                          descriptorSetCount_ = {},
      const VULKAN_HPP_NAMESPACE::DescriptorSetLayout * pSetLayouts_        = {} ) VULKAN_HPP_NOEXCEPT
      : descriptorPool( descriptorPool_ )
      , descriptorSetCount( descriptorSetCount_ )
      , pSetLayouts( pSetLayouts_ )
    {}

    VULKAN_HPP_CONSTEXPR
      DescriptorSetAllocateInfo( DescriptorSetAllocateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DescriptorSetAllocateInfo( VkDescriptorSetAllocateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : DescriptorSetAllocateInfo( *reinterpret_cast<DescriptorSetAllocateInfo const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    DescriptorSetAllocateInfo(
      VULKAN_HPP_NAMESPACE::DescriptorPool descriptorPool_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::DescriptorSetLayout> const &
        setLayouts_ )
      : descriptorPool( descriptorPool_ )
      , descriptorSetCount( static_cast<uint32_t>( setLayouts_.size() ) )
      , pSetLayouts( setLayouts_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DescriptorSetAllocateInfo &
                            operator=( DescriptorSetAllocateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DescriptorSetAllocateInfo & operator=( VkDescriptorSetAllocateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DescriptorSetAllocateInfo const *>( &rhs );
      return *this;
    }

    DescriptorSetAllocateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    DescriptorSetAllocateInfo &
      setDescriptorPool( VULKAN_HPP_NAMESPACE::DescriptorPool descriptorPool_ ) VULKAN_HPP_NOEXCEPT
    {
      descriptorPool = descriptorPool_;
      return *this;
    }

    DescriptorSetAllocateInfo & setDescriptorSetCount( uint32_t descriptorSetCount_ ) VULKAN_HPP_NOEXCEPT
    {
      descriptorSetCount = descriptorSetCount_;
      return *this;
    }

    DescriptorSetAllocateInfo &
      setPSetLayouts( const VULKAN_HPP_NAMESPACE::DescriptorSetLayout * pSetLayouts_ ) VULKAN_HPP_NOEXCEPT
    {
      pSetLayouts = pSetLayouts_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    DescriptorSetAllocateInfo & setSetLayouts(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::DescriptorSetLayout> const &
        setLayouts_ ) VULKAN_HPP_NOEXCEPT
    {
      descriptorSetCount = static_cast<uint32_t>( setLayouts_.size() );
      pSetLayouts        = setLayouts_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkDescriptorSetAllocateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDescriptorSetAllocateInfo *>( this );
    }

    operator VkDescriptorSetAllocateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDescriptorSetAllocateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DescriptorSetAllocateInfo const & ) const = default;
#else
    bool operator==( DescriptorSetAllocateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( descriptorPool == rhs.descriptorPool ) &&
             ( descriptorSetCount == rhs.descriptorSetCount ) && ( pSetLayouts == rhs.pSetLayouts );
    }

    bool operator!=( DescriptorSetAllocateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType               sType              = StructureType::eDescriptorSetAllocateInfo;
    const void *                                      pNext              = {};
    VULKAN_HPP_NAMESPACE::DescriptorPool              descriptorPool     = {};
    uint32_t                                          descriptorSetCount = {};
    const VULKAN_HPP_NAMESPACE::DescriptorSetLayout * pSetLayouts        = {};
  };
  static_assert( sizeof( DescriptorSetAllocateInfo ) == sizeof( VkDescriptorSetAllocateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DescriptorSetAllocateInfo>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDescriptorSetAllocateInfo>
  {
    using Type = DescriptorSetAllocateInfo;
  };

  struct DescriptorSetLayoutBinding
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR DescriptorSetLayoutBinding(
      uint32_t                               binding_            = {},
      VULKAN_HPP_NAMESPACE::DescriptorType   descriptorType_     = VULKAN_HPP_NAMESPACE::DescriptorType::eSampler,
      uint32_t                               descriptorCount_    = {},
      VULKAN_HPP_NAMESPACE::ShaderStageFlags stageFlags_         = {},
      const VULKAN_HPP_NAMESPACE::Sampler *  pImmutableSamplers_ = {} ) VULKAN_HPP_NOEXCEPT
      : binding( binding_ )
      , descriptorType( descriptorType_ )
      , descriptorCount( descriptorCount_ )
      , stageFlags( stageFlags_ )
      , pImmutableSamplers( pImmutableSamplers_ )
    {}

    VULKAN_HPP_CONSTEXPR
      DescriptorSetLayoutBinding( DescriptorSetLayoutBinding const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DescriptorSetLayoutBinding( VkDescriptorSetLayoutBinding const & rhs ) VULKAN_HPP_NOEXCEPT
      : DescriptorSetLayoutBinding( *reinterpret_cast<DescriptorSetLayoutBinding const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    DescriptorSetLayoutBinding(
      uint32_t                                                                                   binding_,
      VULKAN_HPP_NAMESPACE::DescriptorType                                                       descriptorType_,
      VULKAN_HPP_NAMESPACE::ShaderStageFlags                                                     stageFlags_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::Sampler> const & immutableSamplers_ )
      : binding( binding_ )
      , descriptorType( descriptorType_ )
      , descriptorCount( static_cast<uint32_t>( immutableSamplers_.size() ) )
      , stageFlags( stageFlags_ )
      , pImmutableSamplers( immutableSamplers_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DescriptorSetLayoutBinding &
                            operator=( DescriptorSetLayoutBinding const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DescriptorSetLayoutBinding & operator=( VkDescriptorSetLayoutBinding const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DescriptorSetLayoutBinding const *>( &rhs );
      return *this;
    }

    DescriptorSetLayoutBinding & setBinding( uint32_t binding_ ) VULKAN_HPP_NOEXCEPT
    {
      binding = binding_;
      return *this;
    }

    DescriptorSetLayoutBinding &
      setDescriptorType( VULKAN_HPP_NAMESPACE::DescriptorType descriptorType_ ) VULKAN_HPP_NOEXCEPT
    {
      descriptorType = descriptorType_;
      return *this;
    }

    DescriptorSetLayoutBinding & setDescriptorCount( uint32_t descriptorCount_ ) VULKAN_HPP_NOEXCEPT
    {
      descriptorCount = descriptorCount_;
      return *this;
    }

    DescriptorSetLayoutBinding & setStageFlags( VULKAN_HPP_NAMESPACE::ShaderStageFlags stageFlags_ ) VULKAN_HPP_NOEXCEPT
    {
      stageFlags = stageFlags_;
      return *this;
    }

    DescriptorSetLayoutBinding &
      setPImmutableSamplers( const VULKAN_HPP_NAMESPACE::Sampler * pImmutableSamplers_ ) VULKAN_HPP_NOEXCEPT
    {
      pImmutableSamplers = pImmutableSamplers_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    DescriptorSetLayoutBinding & setImmutableSamplers(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::Sampler> const & immutableSamplers_ )
      VULKAN_HPP_NOEXCEPT
    {
      descriptorCount    = static_cast<uint32_t>( immutableSamplers_.size() );
      pImmutableSamplers = immutableSamplers_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkDescriptorSetLayoutBinding const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDescriptorSetLayoutBinding *>( this );
    }

    operator VkDescriptorSetLayoutBinding &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDescriptorSetLayoutBinding *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DescriptorSetLayoutBinding const & ) const = default;
#else
    bool operator==( DescriptorSetLayoutBinding const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( binding == rhs.binding ) && ( descriptorType == rhs.descriptorType ) &&
             ( descriptorCount == rhs.descriptorCount ) && ( stageFlags == rhs.stageFlags ) &&
             ( pImmutableSamplers == rhs.pImmutableSamplers );
    }

    bool operator!=( DescriptorSetLayoutBinding const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    uint32_t                               binding            = {};
    VULKAN_HPP_NAMESPACE::DescriptorType   descriptorType     = VULKAN_HPP_NAMESPACE::DescriptorType::eSampler;
    uint32_t                               descriptorCount    = {};
    VULKAN_HPP_NAMESPACE::ShaderStageFlags stageFlags         = {};
    const VULKAN_HPP_NAMESPACE::Sampler *  pImmutableSamplers = {};
  };
  static_assert( sizeof( DescriptorSetLayoutBinding ) == sizeof( VkDescriptorSetLayoutBinding ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DescriptorSetLayoutBinding>::value,
                 "struct wrapper is not a standard layout!" );

  struct DescriptorSetLayoutBindingFlagsCreateInfo
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eDescriptorSetLayoutBindingFlagsCreateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR DescriptorSetLayoutBindingFlagsCreateInfo(
      uint32_t                                             bindingCount_  = {},
      const VULKAN_HPP_NAMESPACE::DescriptorBindingFlags * pBindingFlags_ = {} ) VULKAN_HPP_NOEXCEPT
      : bindingCount( bindingCount_ )
      , pBindingFlags( pBindingFlags_ )
    {}

    VULKAN_HPP_CONSTEXPR DescriptorSetLayoutBindingFlagsCreateInfo(
      DescriptorSetLayoutBindingFlagsCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DescriptorSetLayoutBindingFlagsCreateInfo( VkDescriptorSetLayoutBindingFlagsCreateInfo const & rhs )
      VULKAN_HPP_NOEXCEPT
      : DescriptorSetLayoutBindingFlagsCreateInfo(
          *reinterpret_cast<DescriptorSetLayoutBindingFlagsCreateInfo const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    DescriptorSetLayoutBindingFlagsCreateInfo(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::DescriptorBindingFlags> const &
        bindingFlags_ )
      : bindingCount( static_cast<uint32_t>( bindingFlags_.size() ) ), pBindingFlags( bindingFlags_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DescriptorSetLayoutBindingFlagsCreateInfo &
                            operator=( DescriptorSetLayoutBindingFlagsCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DescriptorSetLayoutBindingFlagsCreateInfo &
      operator=( VkDescriptorSetLayoutBindingFlagsCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DescriptorSetLayoutBindingFlagsCreateInfo const *>( &rhs );
      return *this;
    }

    DescriptorSetLayoutBindingFlagsCreateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    DescriptorSetLayoutBindingFlagsCreateInfo & setBindingCount( uint32_t bindingCount_ ) VULKAN_HPP_NOEXCEPT
    {
      bindingCount = bindingCount_;
      return *this;
    }

    DescriptorSetLayoutBindingFlagsCreateInfo &
      setPBindingFlags( const VULKAN_HPP_NAMESPACE::DescriptorBindingFlags * pBindingFlags_ ) VULKAN_HPP_NOEXCEPT
    {
      pBindingFlags = pBindingFlags_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    DescriptorSetLayoutBindingFlagsCreateInfo & setBindingFlags(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::DescriptorBindingFlags> const &
        bindingFlags_ ) VULKAN_HPP_NOEXCEPT
    {
      bindingCount  = static_cast<uint32_t>( bindingFlags_.size() );
      pBindingFlags = bindingFlags_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkDescriptorSetLayoutBindingFlagsCreateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDescriptorSetLayoutBindingFlagsCreateInfo *>( this );
    }

    operator VkDescriptorSetLayoutBindingFlagsCreateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDescriptorSetLayoutBindingFlagsCreateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DescriptorSetLayoutBindingFlagsCreateInfo const & ) const = default;
#else
    bool operator==( DescriptorSetLayoutBindingFlagsCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( bindingCount == rhs.bindingCount ) &&
             ( pBindingFlags == rhs.pBindingFlags );
    }

    bool operator!=( DescriptorSetLayoutBindingFlagsCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType        = StructureType::eDescriptorSetLayoutBindingFlagsCreateInfo;
    const void *                        pNext        = {};
    uint32_t                            bindingCount = {};
    const VULKAN_HPP_NAMESPACE::DescriptorBindingFlags * pBindingFlags = {};
  };
  static_assert( sizeof( DescriptorSetLayoutBindingFlagsCreateInfo ) ==
                   sizeof( VkDescriptorSetLayoutBindingFlagsCreateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DescriptorSetLayoutBindingFlagsCreateInfo>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDescriptorSetLayoutBindingFlagsCreateInfo>
  {
    using Type = DescriptorSetLayoutBindingFlagsCreateInfo;
  };
  using DescriptorSetLayoutBindingFlagsCreateInfoEXT = DescriptorSetLayoutBindingFlagsCreateInfo;

  struct DescriptorSetLayoutCreateInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eDescriptorSetLayoutCreateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR DescriptorSetLayoutCreateInfo(
      VULKAN_HPP_NAMESPACE::DescriptorSetLayoutCreateFlags     flags_        = {},
      uint32_t                                                 bindingCount_ = {},
      const VULKAN_HPP_NAMESPACE::DescriptorSetLayoutBinding * pBindings_    = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , bindingCount( bindingCount_ )
      , pBindings( pBindings_ )
    {}

    VULKAN_HPP_CONSTEXPR
      DescriptorSetLayoutCreateInfo( DescriptorSetLayoutCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DescriptorSetLayoutCreateInfo( VkDescriptorSetLayoutCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : DescriptorSetLayoutCreateInfo( *reinterpret_cast<DescriptorSetLayoutCreateInfo const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    DescriptorSetLayoutCreateInfo(
      VULKAN_HPP_NAMESPACE::DescriptorSetLayoutCreateFlags flags_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::DescriptorSetLayoutBinding> const &
        bindings_ )
      : flags( flags_ ), bindingCount( static_cast<uint32_t>( bindings_.size() ) ), pBindings( bindings_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DescriptorSetLayoutCreateInfo &
                            operator=( DescriptorSetLayoutCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DescriptorSetLayoutCreateInfo & operator=( VkDescriptorSetLayoutCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DescriptorSetLayoutCreateInfo const *>( &rhs );
      return *this;
    }

    DescriptorSetLayoutCreateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    DescriptorSetLayoutCreateInfo &
      setFlags( VULKAN_HPP_NAMESPACE::DescriptorSetLayoutCreateFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    DescriptorSetLayoutCreateInfo & setBindingCount( uint32_t bindingCount_ ) VULKAN_HPP_NOEXCEPT
    {
      bindingCount = bindingCount_;
      return *this;
    }

    DescriptorSetLayoutCreateInfo &
      setPBindings( const VULKAN_HPP_NAMESPACE::DescriptorSetLayoutBinding * pBindings_ ) VULKAN_HPP_NOEXCEPT
    {
      pBindings = pBindings_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    DescriptorSetLayoutCreateInfo & setBindings(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::DescriptorSetLayoutBinding> const &
        bindings_ ) VULKAN_HPP_NOEXCEPT
    {
      bindingCount = static_cast<uint32_t>( bindings_.size() );
      pBindings    = bindings_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkDescriptorSetLayoutCreateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDescriptorSetLayoutCreateInfo *>( this );
    }

    operator VkDescriptorSetLayoutCreateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDescriptorSetLayoutCreateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DescriptorSetLayoutCreateInfo const & ) const = default;
#else
    bool operator==( DescriptorSetLayoutCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( bindingCount == rhs.bindingCount ) && ( pBindings == rhs.pBindings );
    }

    bool operator!=( DescriptorSetLayoutCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                      sType = StructureType::eDescriptorSetLayoutCreateInfo;
    const void *                                             pNext = {};
    VULKAN_HPP_NAMESPACE::DescriptorSetLayoutCreateFlags     flags = {};
    uint32_t                                                 bindingCount = {};
    const VULKAN_HPP_NAMESPACE::DescriptorSetLayoutBinding * pBindings    = {};
  };
  static_assert( sizeof( DescriptorSetLayoutCreateInfo ) == sizeof( VkDescriptorSetLayoutCreateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DescriptorSetLayoutCreateInfo>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDescriptorSetLayoutCreateInfo>
  {
    using Type = DescriptorSetLayoutCreateInfo;
  };

  struct DescriptorSetLayoutSupport
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eDescriptorSetLayoutSupport;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR DescriptorSetLayoutSupport( VULKAN_HPP_NAMESPACE::Bool32 supported_ = {} ) VULKAN_HPP_NOEXCEPT
      : supported( supported_ )
    {}

    VULKAN_HPP_CONSTEXPR
      DescriptorSetLayoutSupport( DescriptorSetLayoutSupport const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DescriptorSetLayoutSupport( VkDescriptorSetLayoutSupport const & rhs ) VULKAN_HPP_NOEXCEPT
      : DescriptorSetLayoutSupport( *reinterpret_cast<DescriptorSetLayoutSupport const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DescriptorSetLayoutSupport &
                            operator=( DescriptorSetLayoutSupport const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DescriptorSetLayoutSupport & operator=( VkDescriptorSetLayoutSupport const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DescriptorSetLayoutSupport const *>( &rhs );
      return *this;
    }

    operator VkDescriptorSetLayoutSupport const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDescriptorSetLayoutSupport *>( this );
    }

    operator VkDescriptorSetLayoutSupport &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDescriptorSetLayoutSupport *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DescriptorSetLayoutSupport const & ) const = default;
#else
    bool operator==( DescriptorSetLayoutSupport const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( supported == rhs.supported );
    }

    bool operator!=( DescriptorSetLayoutSupport const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType     = StructureType::eDescriptorSetLayoutSupport;
    void *                              pNext     = {};
    VULKAN_HPP_NAMESPACE::Bool32        supported = {};
  };
  static_assert( sizeof( DescriptorSetLayoutSupport ) == sizeof( VkDescriptorSetLayoutSupport ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DescriptorSetLayoutSupport>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDescriptorSetLayoutSupport>
  {
    using Type = DescriptorSetLayoutSupport;
  };
  using DescriptorSetLayoutSupportKHR = DescriptorSetLayoutSupport;

  struct DescriptorSetVariableDescriptorCountAllocateInfo
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eDescriptorSetVariableDescriptorCountAllocateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      DescriptorSetVariableDescriptorCountAllocateInfo( uint32_t         descriptorSetCount_ = {},
                                                        const uint32_t * pDescriptorCounts_  = {} ) VULKAN_HPP_NOEXCEPT
      : descriptorSetCount( descriptorSetCount_ )
      , pDescriptorCounts( pDescriptorCounts_ )
    {}

    VULKAN_HPP_CONSTEXPR DescriptorSetVariableDescriptorCountAllocateInfo(
      DescriptorSetVariableDescriptorCountAllocateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DescriptorSetVariableDescriptorCountAllocateInfo( VkDescriptorSetVariableDescriptorCountAllocateInfo const & rhs )
      VULKAN_HPP_NOEXCEPT
      : DescriptorSetVariableDescriptorCountAllocateInfo(
          *reinterpret_cast<DescriptorSetVariableDescriptorCountAllocateInfo const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    DescriptorSetVariableDescriptorCountAllocateInfo(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const & descriptorCounts_ )
      : descriptorSetCount( static_cast<uint32_t>( descriptorCounts_.size() ) )
      , pDescriptorCounts( descriptorCounts_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DescriptorSetVariableDescriptorCountAllocateInfo &
                            operator=( DescriptorSetVariableDescriptorCountAllocateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DescriptorSetVariableDescriptorCountAllocateInfo &
      operator=( VkDescriptorSetVariableDescriptorCountAllocateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DescriptorSetVariableDescriptorCountAllocateInfo const *>( &rhs );
      return *this;
    }

    DescriptorSetVariableDescriptorCountAllocateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    DescriptorSetVariableDescriptorCountAllocateInfo &
      setDescriptorSetCount( uint32_t descriptorSetCount_ ) VULKAN_HPP_NOEXCEPT
    {
      descriptorSetCount = descriptorSetCount_;
      return *this;
    }

    DescriptorSetVariableDescriptorCountAllocateInfo &
      setPDescriptorCounts( const uint32_t * pDescriptorCounts_ ) VULKAN_HPP_NOEXCEPT
    {
      pDescriptorCounts = pDescriptorCounts_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    DescriptorSetVariableDescriptorCountAllocateInfo & setDescriptorCounts(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const & descriptorCounts_ ) VULKAN_HPP_NOEXCEPT
    {
      descriptorSetCount = static_cast<uint32_t>( descriptorCounts_.size() );
      pDescriptorCounts  = descriptorCounts_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkDescriptorSetVariableDescriptorCountAllocateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDescriptorSetVariableDescriptorCountAllocateInfo *>( this );
    }

    operator VkDescriptorSetVariableDescriptorCountAllocateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDescriptorSetVariableDescriptorCountAllocateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DescriptorSetVariableDescriptorCountAllocateInfo const & ) const = default;
#else
    bool operator==( DescriptorSetVariableDescriptorCountAllocateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( descriptorSetCount == rhs.descriptorSetCount ) &&
             ( pDescriptorCounts == rhs.pDescriptorCounts );
    }

    bool operator!=( DescriptorSetVariableDescriptorCountAllocateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::eDescriptorSetVariableDescriptorCountAllocateInfo;
    const void *                        pNext = {};
    uint32_t                            descriptorSetCount = {};
    const uint32_t *                    pDescriptorCounts  = {};
  };
  static_assert( sizeof( DescriptorSetVariableDescriptorCountAllocateInfo ) ==
                   sizeof( VkDescriptorSetVariableDescriptorCountAllocateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DescriptorSetVariableDescriptorCountAllocateInfo>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDescriptorSetVariableDescriptorCountAllocateInfo>
  {
    using Type = DescriptorSetVariableDescriptorCountAllocateInfo;
  };
  using DescriptorSetVariableDescriptorCountAllocateInfoEXT = DescriptorSetVariableDescriptorCountAllocateInfo;

  struct DescriptorSetVariableDescriptorCountLayoutSupport
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eDescriptorSetVariableDescriptorCountLayoutSupport;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      DescriptorSetVariableDescriptorCountLayoutSupport( uint32_t maxVariableDescriptorCount_ = {} ) VULKAN_HPP_NOEXCEPT
      : maxVariableDescriptorCount( maxVariableDescriptorCount_ )
    {}

    VULKAN_HPP_CONSTEXPR DescriptorSetVariableDescriptorCountLayoutSupport(
      DescriptorSetVariableDescriptorCountLayoutSupport const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DescriptorSetVariableDescriptorCountLayoutSupport( VkDescriptorSetVariableDescriptorCountLayoutSupport const & rhs )
      VULKAN_HPP_NOEXCEPT
      : DescriptorSetVariableDescriptorCountLayoutSupport(
          *reinterpret_cast<DescriptorSetVariableDescriptorCountLayoutSupport const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DescriptorSetVariableDescriptorCountLayoutSupport &
                            operator=( DescriptorSetVariableDescriptorCountLayoutSupport const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DescriptorSetVariableDescriptorCountLayoutSupport &
      operator=( VkDescriptorSetVariableDescriptorCountLayoutSupport const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this =
        *reinterpret_cast<VULKAN_HPP_NAMESPACE::DescriptorSetVariableDescriptorCountLayoutSupport const *>( &rhs );
      return *this;
    }

    operator VkDescriptorSetVariableDescriptorCountLayoutSupport const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDescriptorSetVariableDescriptorCountLayoutSupport *>( this );
    }

    operator VkDescriptorSetVariableDescriptorCountLayoutSupport &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDescriptorSetVariableDescriptorCountLayoutSupport *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DescriptorSetVariableDescriptorCountLayoutSupport const & ) const = default;
#else
    bool operator==( DescriptorSetVariableDescriptorCountLayoutSupport const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( maxVariableDescriptorCount == rhs.maxVariableDescriptorCount );
    }

    bool operator!=( DescriptorSetVariableDescriptorCountLayoutSupport const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::eDescriptorSetVariableDescriptorCountLayoutSupport;
    void *                              pNext = {};
    uint32_t                            maxVariableDescriptorCount = {};
  };
  static_assert( sizeof( DescriptorSetVariableDescriptorCountLayoutSupport ) ==
                   sizeof( VkDescriptorSetVariableDescriptorCountLayoutSupport ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DescriptorSetVariableDescriptorCountLayoutSupport>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDescriptorSetVariableDescriptorCountLayoutSupport>
  {
    using Type = DescriptorSetVariableDescriptorCountLayoutSupport;
  };
  using DescriptorSetVariableDescriptorCountLayoutSupportEXT = DescriptorSetVariableDescriptorCountLayoutSupport;

  struct DescriptorUpdateTemplateEntry
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR DescriptorUpdateTemplateEntry(
      uint32_t                             dstBinding_      = {},
      uint32_t                             dstArrayElement_ = {},
      uint32_t                             descriptorCount_ = {},
      VULKAN_HPP_NAMESPACE::DescriptorType descriptorType_  = VULKAN_HPP_NAMESPACE::DescriptorType::eSampler,
      size_t                               offset_          = {},
      size_t                               stride_          = {} ) VULKAN_HPP_NOEXCEPT
      : dstBinding( dstBinding_ )
      , dstArrayElement( dstArrayElement_ )
      , descriptorCount( descriptorCount_ )
      , descriptorType( descriptorType_ )
      , offset( offset_ )
      , stride( stride_ )
    {}

    VULKAN_HPP_CONSTEXPR
      DescriptorUpdateTemplateEntry( DescriptorUpdateTemplateEntry const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DescriptorUpdateTemplateEntry( VkDescriptorUpdateTemplateEntry const & rhs ) VULKAN_HPP_NOEXCEPT
      : DescriptorUpdateTemplateEntry( *reinterpret_cast<DescriptorUpdateTemplateEntry const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DescriptorUpdateTemplateEntry &
                            operator=( DescriptorUpdateTemplateEntry const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DescriptorUpdateTemplateEntry & operator=( VkDescriptorUpdateTemplateEntry const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DescriptorUpdateTemplateEntry const *>( &rhs );
      return *this;
    }

    DescriptorUpdateTemplateEntry & setDstBinding( uint32_t dstBinding_ ) VULKAN_HPP_NOEXCEPT
    {
      dstBinding = dstBinding_;
      return *this;
    }

    DescriptorUpdateTemplateEntry & setDstArrayElement( uint32_t dstArrayElement_ ) VULKAN_HPP_NOEXCEPT
    {
      dstArrayElement = dstArrayElement_;
      return *this;
    }

    DescriptorUpdateTemplateEntry & setDescriptorCount( uint32_t descriptorCount_ ) VULKAN_HPP_NOEXCEPT
    {
      descriptorCount = descriptorCount_;
      return *this;
    }

    DescriptorUpdateTemplateEntry &
      setDescriptorType( VULKAN_HPP_NAMESPACE::DescriptorType descriptorType_ ) VULKAN_HPP_NOEXCEPT
    {
      descriptorType = descriptorType_;
      return *this;
    }

    DescriptorUpdateTemplateEntry & setOffset( size_t offset_ ) VULKAN_HPP_NOEXCEPT
    {
      offset = offset_;
      return *this;
    }

    DescriptorUpdateTemplateEntry & setStride( size_t stride_ ) VULKAN_HPP_NOEXCEPT
    {
      stride = stride_;
      return *this;
    }

    operator VkDescriptorUpdateTemplateEntry const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDescriptorUpdateTemplateEntry *>( this );
    }

    operator VkDescriptorUpdateTemplateEntry &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDescriptorUpdateTemplateEntry *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DescriptorUpdateTemplateEntry const & ) const = default;
#else
    bool operator==( DescriptorUpdateTemplateEntry const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( dstBinding == rhs.dstBinding ) && ( dstArrayElement == rhs.dstArrayElement ) &&
             ( descriptorCount == rhs.descriptorCount ) && ( descriptorType == rhs.descriptorType ) &&
             ( offset == rhs.offset ) && ( stride == rhs.stride );
    }

    bool operator!=( DescriptorUpdateTemplateEntry const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    uint32_t                             dstBinding      = {};
    uint32_t                             dstArrayElement = {};
    uint32_t                             descriptorCount = {};
    VULKAN_HPP_NAMESPACE::DescriptorType descriptorType  = VULKAN_HPP_NAMESPACE::DescriptorType::eSampler;
    size_t                               offset          = {};
    size_t                               stride          = {};
  };
  static_assert( sizeof( DescriptorUpdateTemplateEntry ) == sizeof( VkDescriptorUpdateTemplateEntry ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DescriptorUpdateTemplateEntry>::value,
                 "struct wrapper is not a standard layout!" );
  using DescriptorUpdateTemplateEntryKHR = DescriptorUpdateTemplateEntry;

  struct DescriptorUpdateTemplateCreateInfo
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eDescriptorUpdateTemplateCreateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR DescriptorUpdateTemplateCreateInfo(
      VULKAN_HPP_NAMESPACE::DescriptorUpdateTemplateCreateFlags   flags_                      = {},
      uint32_t                                                    descriptorUpdateEntryCount_ = {},
      const VULKAN_HPP_NAMESPACE::DescriptorUpdateTemplateEntry * pDescriptorUpdateEntries_   = {},
      VULKAN_HPP_NAMESPACE::DescriptorUpdateTemplateType          templateType_ =
        VULKAN_HPP_NAMESPACE::DescriptorUpdateTemplateType::eDescriptorSet,
      VULKAN_HPP_NAMESPACE::DescriptorSetLayout descriptorSetLayout_ = {},
      VULKAN_HPP_NAMESPACE::PipelineBindPoint   pipelineBindPoint_ = VULKAN_HPP_NAMESPACE::PipelineBindPoint::eGraphics,
      VULKAN_HPP_NAMESPACE::PipelineLayout      pipelineLayout_    = {},
      uint32_t                                  set_               = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , descriptorUpdateEntryCount( descriptorUpdateEntryCount_ )
      , pDescriptorUpdateEntries( pDescriptorUpdateEntries_ )
      , templateType( templateType_ )
      , descriptorSetLayout( descriptorSetLayout_ )
      , pipelineBindPoint( pipelineBindPoint_ )
      , pipelineLayout( pipelineLayout_ )
      , set( set_ )
    {}

    VULKAN_HPP_CONSTEXPR DescriptorUpdateTemplateCreateInfo( DescriptorUpdateTemplateCreateInfo const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    DescriptorUpdateTemplateCreateInfo( VkDescriptorUpdateTemplateCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : DescriptorUpdateTemplateCreateInfo( *reinterpret_cast<DescriptorUpdateTemplateCreateInfo const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    DescriptorUpdateTemplateCreateInfo(
      VULKAN_HPP_NAMESPACE::DescriptorUpdateTemplateCreateFlags flags_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::DescriptorUpdateTemplateEntry> const &
                                                         descriptorUpdateEntries_,
      VULKAN_HPP_NAMESPACE::DescriptorUpdateTemplateType templateType_ =
        VULKAN_HPP_NAMESPACE::DescriptorUpdateTemplateType::eDescriptorSet,
      VULKAN_HPP_NAMESPACE::DescriptorSetLayout descriptorSetLayout_ = {},
      VULKAN_HPP_NAMESPACE::PipelineBindPoint   pipelineBindPoint_ = VULKAN_HPP_NAMESPACE::PipelineBindPoint::eGraphics,
      VULKAN_HPP_NAMESPACE::PipelineLayout      pipelineLayout_    = {},
      uint32_t                                  set_               = {} )
      : flags( flags_ )
      , descriptorUpdateEntryCount( static_cast<uint32_t>( descriptorUpdateEntries_.size() ) )
      , pDescriptorUpdateEntries( descriptorUpdateEntries_.data() )
      , templateType( templateType_ )
      , descriptorSetLayout( descriptorSetLayout_ )
      , pipelineBindPoint( pipelineBindPoint_ )
      , pipelineLayout( pipelineLayout_ )
      , set( set_ )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DescriptorUpdateTemplateCreateInfo &
                            operator=( DescriptorUpdateTemplateCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DescriptorUpdateTemplateCreateInfo &
      operator=( VkDescriptorUpdateTemplateCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DescriptorUpdateTemplateCreateInfo const *>( &rhs );
      return *this;
    }

    DescriptorUpdateTemplateCreateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    DescriptorUpdateTemplateCreateInfo &
      setFlags( VULKAN_HPP_NAMESPACE::DescriptorUpdateTemplateCreateFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    DescriptorUpdateTemplateCreateInfo &
      setDescriptorUpdateEntryCount( uint32_t descriptorUpdateEntryCount_ ) VULKAN_HPP_NOEXCEPT
    {
      descriptorUpdateEntryCount = descriptorUpdateEntryCount_;
      return *this;
    }

    DescriptorUpdateTemplateCreateInfo & setPDescriptorUpdateEntries(
      const VULKAN_HPP_NAMESPACE::DescriptorUpdateTemplateEntry * pDescriptorUpdateEntries_ ) VULKAN_HPP_NOEXCEPT
    {
      pDescriptorUpdateEntries = pDescriptorUpdateEntries_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    DescriptorUpdateTemplateCreateInfo & setDescriptorUpdateEntries(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::DescriptorUpdateTemplateEntry> const &
        descriptorUpdateEntries_ ) VULKAN_HPP_NOEXCEPT
    {
      descriptorUpdateEntryCount = static_cast<uint32_t>( descriptorUpdateEntries_.size() );
      pDescriptorUpdateEntries   = descriptorUpdateEntries_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    DescriptorUpdateTemplateCreateInfo &
      setTemplateType( VULKAN_HPP_NAMESPACE::DescriptorUpdateTemplateType templateType_ ) VULKAN_HPP_NOEXCEPT
    {
      templateType = templateType_;
      return *this;
    }

    DescriptorUpdateTemplateCreateInfo &
      setDescriptorSetLayout( VULKAN_HPP_NAMESPACE::DescriptorSetLayout descriptorSetLayout_ ) VULKAN_HPP_NOEXCEPT
    {
      descriptorSetLayout = descriptorSetLayout_;
      return *this;
    }

    DescriptorUpdateTemplateCreateInfo &
      setPipelineBindPoint( VULKAN_HPP_NAMESPACE::PipelineBindPoint pipelineBindPoint_ ) VULKAN_HPP_NOEXCEPT
    {
      pipelineBindPoint = pipelineBindPoint_;
      return *this;
    }

    DescriptorUpdateTemplateCreateInfo &
      setPipelineLayout( VULKAN_HPP_NAMESPACE::PipelineLayout pipelineLayout_ ) VULKAN_HPP_NOEXCEPT
    {
      pipelineLayout = pipelineLayout_;
      return *this;
    }

    DescriptorUpdateTemplateCreateInfo & setSet( uint32_t set_ ) VULKAN_HPP_NOEXCEPT
    {
      set = set_;
      return *this;
    }

    operator VkDescriptorUpdateTemplateCreateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDescriptorUpdateTemplateCreateInfo *>( this );
    }

    operator VkDescriptorUpdateTemplateCreateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDescriptorUpdateTemplateCreateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DescriptorUpdateTemplateCreateInfo const & ) const = default;
#else
    bool operator==( DescriptorUpdateTemplateCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( descriptorUpdateEntryCount == rhs.descriptorUpdateEntryCount ) &&
             ( pDescriptorUpdateEntries == rhs.pDescriptorUpdateEntries ) && ( templateType == rhs.templateType ) &&
             ( descriptorSetLayout == rhs.descriptorSetLayout ) && ( pipelineBindPoint == rhs.pipelineBindPoint ) &&
             ( pipelineLayout == rhs.pipelineLayout ) && ( set == rhs.set );
    }

    bool operator!=( DescriptorUpdateTemplateCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::eDescriptorUpdateTemplateCreateInfo;
    const void *                        pNext = {};
    VULKAN_HPP_NAMESPACE::DescriptorUpdateTemplateCreateFlags   flags                      = {};
    uint32_t                                                    descriptorUpdateEntryCount = {};
    const VULKAN_HPP_NAMESPACE::DescriptorUpdateTemplateEntry * pDescriptorUpdateEntries   = {};
    VULKAN_HPP_NAMESPACE::DescriptorUpdateTemplateType          templateType =
      VULKAN_HPP_NAMESPACE::DescriptorUpdateTemplateType::eDescriptorSet;
    VULKAN_HPP_NAMESPACE::DescriptorSetLayout descriptorSetLayout = {};
    VULKAN_HPP_NAMESPACE::PipelineBindPoint   pipelineBindPoint   = VULKAN_HPP_NAMESPACE::PipelineBindPoint::eGraphics;
    VULKAN_HPP_NAMESPACE::PipelineLayout      pipelineLayout      = {};
    uint32_t                                  set                 = {};
  };
  static_assert( sizeof( DescriptorUpdateTemplateCreateInfo ) == sizeof( VkDescriptorUpdateTemplateCreateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DescriptorUpdateTemplateCreateInfo>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDescriptorUpdateTemplateCreateInfo>
  {
    using Type = DescriptorUpdateTemplateCreateInfo;
  };
  using DescriptorUpdateTemplateCreateInfoKHR = DescriptorUpdateTemplateCreateInfo;

  struct DeviceQueueCreateInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eDeviceQueueCreateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR DeviceQueueCreateInfo( VULKAN_HPP_NAMESPACE::DeviceQueueCreateFlags flags_            = {},
                                                uint32_t                                     queueFamilyIndex_ = {},
                                                uint32_t                                     queueCount_       = {},
                                                const float * pQueuePriorities_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , queueFamilyIndex( queueFamilyIndex_ )
      , queueCount( queueCount_ )
      , pQueuePriorities( pQueuePriorities_ )
    {}

    VULKAN_HPP_CONSTEXPR DeviceQueueCreateInfo( DeviceQueueCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DeviceQueueCreateInfo( VkDeviceQueueCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : DeviceQueueCreateInfo( *reinterpret_cast<DeviceQueueCreateInfo const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    DeviceQueueCreateInfo( VULKAN_HPP_NAMESPACE::DeviceQueueCreateFlags                       flags_,
                           uint32_t                                                           queueFamilyIndex_,
                           VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const float> const & queuePriorities_ )
      : flags( flags_ )
      , queueFamilyIndex( queueFamilyIndex_ )
      , queueCount( static_cast<uint32_t>( queuePriorities_.size() ) )
      , pQueuePriorities( queuePriorities_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DeviceQueueCreateInfo &
                            operator=( DeviceQueueCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DeviceQueueCreateInfo & operator=( VkDeviceQueueCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DeviceQueueCreateInfo const *>( &rhs );
      return *this;
    }

    DeviceQueueCreateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    DeviceQueueCreateInfo & setFlags( VULKAN_HPP_NAMESPACE::DeviceQueueCreateFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    DeviceQueueCreateInfo & setQueueFamilyIndex( uint32_t queueFamilyIndex_ ) VULKAN_HPP_NOEXCEPT
    {
      queueFamilyIndex = queueFamilyIndex_;
      return *this;
    }

    DeviceQueueCreateInfo & setQueueCount( uint32_t queueCount_ ) VULKAN_HPP_NOEXCEPT
    {
      queueCount = queueCount_;
      return *this;
    }

    DeviceQueueCreateInfo & setPQueuePriorities( const float * pQueuePriorities_ ) VULKAN_HPP_NOEXCEPT
    {
      pQueuePriorities = pQueuePriorities_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    DeviceQueueCreateInfo & setQueuePriorities(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const float> const & queuePriorities_ ) VULKAN_HPP_NOEXCEPT
    {
      queueCount       = static_cast<uint32_t>( queuePriorities_.size() );
      pQueuePriorities = queuePriorities_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkDeviceQueueCreateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDeviceQueueCreateInfo *>( this );
    }

    operator VkDeviceQueueCreateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDeviceQueueCreateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DeviceQueueCreateInfo const & ) const = default;
#else
    bool operator==( DeviceQueueCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( queueFamilyIndex == rhs.queueFamilyIndex ) && ( queueCount == rhs.queueCount ) &&
             ( pQueuePriorities == rhs.pQueuePriorities );
    }

    bool operator!=( DeviceQueueCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType          sType            = StructureType::eDeviceQueueCreateInfo;
    const void *                                 pNext            = {};
    VULKAN_HPP_NAMESPACE::DeviceQueueCreateFlags flags            = {};
    uint32_t                                     queueFamilyIndex = {};
    uint32_t                                     queueCount       = {};
    const float *                                pQueuePriorities = {};
  };
  static_assert( sizeof( DeviceQueueCreateInfo ) == sizeof( VkDeviceQueueCreateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DeviceQueueCreateInfo>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDeviceQueueCreateInfo>
  {
    using Type = DeviceQueueCreateInfo;
  };

  struct PhysicalDeviceFeatures
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      PhysicalDeviceFeatures( VULKAN_HPP_NAMESPACE::Bool32 robustBufferAccess_                      = {},
                              VULKAN_HPP_NAMESPACE::Bool32 fullDrawIndexUint32_                     = {},
                              VULKAN_HPP_NAMESPACE::Bool32 imageCubeArray_                          = {},
                              VULKAN_HPP_NAMESPACE::Bool32 independentBlend_                        = {},
                              VULKAN_HPP_NAMESPACE::Bool32 geometryShader_                          = {},
                              VULKAN_HPP_NAMESPACE::Bool32 tessellationShader_                      = {},
                              VULKAN_HPP_NAMESPACE::Bool32 sampleRateShading_                       = {},
                              VULKAN_HPP_NAMESPACE::Bool32 dualSrcBlend_                            = {},
                              VULKAN_HPP_NAMESPACE::Bool32 logicOp_                                 = {},
                              VULKAN_HPP_NAMESPACE::Bool32 multiDrawIndirect_                       = {},
                              VULKAN_HPP_NAMESPACE::Bool32 drawIndirectFirstInstance_               = {},
                              VULKAN_HPP_NAMESPACE::Bool32 depthClamp_                              = {},
                              VULKAN_HPP_NAMESPACE::Bool32 depthBiasClamp_                          = {},
                              VULKAN_HPP_NAMESPACE::Bool32 fillModeNonSolid_                        = {},
                              VULKAN_HPP_NAMESPACE::Bool32 depthBounds_                             = {},
                              VULKAN_HPP_NAMESPACE::Bool32 wideLines_                               = {},
                              VULKAN_HPP_NAMESPACE::Bool32 largePoints_                             = {},
                              VULKAN_HPP_NAMESPACE::Bool32 alphaToOne_                              = {},
                              VULKAN_HPP_NAMESPACE::Bool32 multiViewport_                           = {},
                              VULKAN_HPP_NAMESPACE::Bool32 samplerAnisotropy_                       = {},
                              VULKAN_HPP_NAMESPACE::Bool32 textureCompressionETC2_                  = {},
                              VULKAN_HPP_NAMESPACE::Bool32 textureCompressionASTC_LDR_              = {},
                              VULKAN_HPP_NAMESPACE::Bool32 textureCompressionBC_                    = {},
                              VULKAN_HPP_NAMESPACE::Bool32 occlusionQueryPrecise_                   = {},
                              VULKAN_HPP_NAMESPACE::Bool32 pipelineStatisticsQuery_                 = {},
                              VULKAN_HPP_NAMESPACE::Bool32 vertexPipelineStoresAndAtomics_          = {},
                              VULKAN_HPP_NAMESPACE::Bool32 fragmentStoresAndAtomics_                = {},
                              VULKAN_HPP_NAMESPACE::Bool32 shaderTessellationAndGeometryPointSize_  = {},
                              VULKAN_HPP_NAMESPACE::Bool32 shaderImageGatherExtended_               = {},
                              VULKAN_HPP_NAMESPACE::Bool32 shaderStorageImageExtendedFormats_       = {},
                              VULKAN_HPP_NAMESPACE::Bool32 shaderStorageImageMultisample_           = {},
                              VULKAN_HPP_NAMESPACE::Bool32 shaderStorageImageReadWithoutFormat_     = {},
                              VULKAN_HPP_NAMESPACE::Bool32 shaderStorageImageWriteWithoutFormat_    = {},
                              VULKAN_HPP_NAMESPACE::Bool32 shaderUniformBufferArrayDynamicIndexing_ = {},
                              VULKAN_HPP_NAMESPACE::Bool32 shaderSampledImageArrayDynamicIndexing_  = {},
                              VULKAN_HPP_NAMESPACE::Bool32 shaderStorageBufferArrayDynamicIndexing_ = {},
                              VULKAN_HPP_NAMESPACE::Bool32 shaderStorageImageArrayDynamicIndexing_  = {},
                              VULKAN_HPP_NAMESPACE::Bool32 shaderClipDistance_                      = {},
                              VULKAN_HPP_NAMESPACE::Bool32 shaderCullDistance_                      = {},
                              VULKAN_HPP_NAMESPACE::Bool32 shaderFloat64_                           = {},
                              VULKAN_HPP_NAMESPACE::Bool32 shaderInt64_                             = {},
                              VULKAN_HPP_NAMESPACE::Bool32 shaderInt16_                             = {},
                              VULKAN_HPP_NAMESPACE::Bool32 shaderResourceResidency_                 = {},
                              VULKAN_HPP_NAMESPACE::Bool32 shaderResourceMinLod_                    = {},
                              VULKAN_HPP_NAMESPACE::Bool32 sparseBinding_                           = {},
                              VULKAN_HPP_NAMESPACE::Bool32 sparseResidencyBuffer_                   = {},
                              VULKAN_HPP_NAMESPACE::Bool32 sparseResidencyImage2D_                  = {},
                              VULKAN_HPP_NAMESPACE::Bool32 sparseResidencyImage3D_                  = {},
                              VULKAN_HPP_NAMESPACE::Bool32 sparseResidency2Samples_                 = {},
                              VULKAN_HPP_NAMESPACE::Bool32 sparseResidency4Samples_                 = {},
                              VULKAN_HPP_NAMESPACE::Bool32 sparseResidency8Samples_                 = {},
                              VULKAN_HPP_NAMESPACE::Bool32 sparseResidency16Samples_                = {},
                              VULKAN_HPP_NAMESPACE::Bool32 sparseResidencyAliased_                  = {},
                              VULKAN_HPP_NAMESPACE::Bool32 variableMultisampleRate_                 = {},
                              VULKAN_HPP_NAMESPACE::Bool32 inheritedQueries_ = {} ) VULKAN_HPP_NOEXCEPT
      : robustBufferAccess( robustBufferAccess_ )
      , fullDrawIndexUint32( fullDrawIndexUint32_ )
      , imageCubeArray( imageCubeArray_ )
      , independentBlend( independentBlend_ )
      , geometryShader( geometryShader_ )
      , tessellationShader( tessellationShader_ )
      , sampleRateShading( sampleRateShading_ )
      , dualSrcBlend( dualSrcBlend_ )
      , logicOp( logicOp_ )
      , multiDrawIndirect( multiDrawIndirect_ )
      , drawIndirectFirstInstance( drawIndirectFirstInstance_ )
      , depthClamp( depthClamp_ )
      , depthBiasClamp( depthBiasClamp_ )
      , fillModeNonSolid( fillModeNonSolid_ )
      , depthBounds( depthBounds_ )
      , wideLines( wideLines_ )
      , largePoints( largePoints_ )
      , alphaToOne( alphaToOne_ )
      , multiViewport( multiViewport_ )
      , samplerAnisotropy( samplerAnisotropy_ )
      , textureCompressionETC2( textureCompressionETC2_ )
      , textureCompressionASTC_LDR( textureCompressionASTC_LDR_ )
      , textureCompressionBC( textureCompressionBC_ )
      , occlusionQueryPrecise( occlusionQueryPrecise_ )
      , pipelineStatisticsQuery( pipelineStatisticsQuery_ )
      , vertexPipelineStoresAndAtomics( vertexPipelineStoresAndAtomics_ )
      , fragmentStoresAndAtomics( fragmentStoresAndAtomics_ )
      , shaderTessellationAndGeometryPointSize( shaderTessellationAndGeometryPointSize_ )
      , shaderImageGatherExtended( shaderImageGatherExtended_ )
      , shaderStorageImageExtendedFormats( shaderStorageImageExtendedFormats_ )
      , shaderStorageImageMultisample( shaderStorageImageMultisample_ )
      , shaderStorageImageReadWithoutFormat( shaderStorageImageReadWithoutFormat_ )
      , shaderStorageImageWriteWithoutFormat( shaderStorageImageWriteWithoutFormat_ )
      , shaderUniformBufferArrayDynamicIndexing( shaderUniformBufferArrayDynamicIndexing_ )
      , shaderSampledImageArrayDynamicIndexing( shaderSampledImageArrayDynamicIndexing_ )
      , shaderStorageBufferArrayDynamicIndexing( shaderStorageBufferArrayDynamicIndexing_ )
      , shaderStorageImageArrayDynamicIndexing( shaderStorageImageArrayDynamicIndexing_ )
      , shaderClipDistance( shaderClipDistance_ )
      , shaderCullDistance( shaderCullDistance_ )
      , shaderFloat64( shaderFloat64_ )
      , shaderInt64( shaderInt64_ )
      , shaderInt16( shaderInt16_ )
      , shaderResourceResidency( shaderResourceResidency_ )
      , shaderResourceMinLod( shaderResourceMinLod_ )
      , sparseBinding( sparseBinding_ )
      , sparseResidencyBuffer( sparseResidencyBuffer_ )
      , sparseResidencyImage2D( sparseResidencyImage2D_ )
      , sparseResidencyImage3D( sparseResidencyImage3D_ )
      , sparseResidency2Samples( sparseResidency2Samples_ )
      , sparseResidency4Samples( sparseResidency4Samples_ )
      , sparseResidency8Samples( sparseResidency8Samples_ )
      , sparseResidency16Samples( sparseResidency16Samples_ )
      , sparseResidencyAliased( sparseResidencyAliased_ )
      , variableMultisampleRate( variableMultisampleRate_ )
      , inheritedQueries( inheritedQueries_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceFeatures( PhysicalDeviceFeatures const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceFeatures( VkPhysicalDeviceFeatures const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceFeatures( *reinterpret_cast<PhysicalDeviceFeatures const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceFeatures &
                            operator=( PhysicalDeviceFeatures const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceFeatures & operator=( VkPhysicalDeviceFeatures const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceFeatures const *>( &rhs );
      return *this;
    }

    PhysicalDeviceFeatures &
      setRobustBufferAccess( VULKAN_HPP_NAMESPACE::Bool32 robustBufferAccess_ ) VULKAN_HPP_NOEXCEPT
    {
      robustBufferAccess = robustBufferAccess_;
      return *this;
    }

    PhysicalDeviceFeatures &
      setFullDrawIndexUint32( VULKAN_HPP_NAMESPACE::Bool32 fullDrawIndexUint32_ ) VULKAN_HPP_NOEXCEPT
    {
      fullDrawIndexUint32 = fullDrawIndexUint32_;
      return *this;
    }

    PhysicalDeviceFeatures & setImageCubeArray( VULKAN_HPP_NAMESPACE::Bool32 imageCubeArray_ ) VULKAN_HPP_NOEXCEPT
    {
      imageCubeArray = imageCubeArray_;
      return *this;
    }

    PhysicalDeviceFeatures & setIndependentBlend( VULKAN_HPP_NAMESPACE::Bool32 independentBlend_ ) VULKAN_HPP_NOEXCEPT
    {
      independentBlend = independentBlend_;
      return *this;
    }

    PhysicalDeviceFeatures & setGeometryShader( VULKAN_HPP_NAMESPACE::Bool32 geometryShader_ ) VULKAN_HPP_NOEXCEPT
    {
      geometryShader = geometryShader_;
      return *this;
    }

    PhysicalDeviceFeatures &
      setTessellationShader( VULKAN_HPP_NAMESPACE::Bool32 tessellationShader_ ) VULKAN_HPP_NOEXCEPT
    {
      tessellationShader = tessellationShader_;
      return *this;
    }

    PhysicalDeviceFeatures & setSampleRateShading( VULKAN_HPP_NAMESPACE::Bool32 sampleRateShading_ ) VULKAN_HPP_NOEXCEPT
    {
      sampleRateShading = sampleRateShading_;
      return *this;
    }

    PhysicalDeviceFeatures & setDualSrcBlend( VULKAN_HPP_NAMESPACE::Bool32 dualSrcBlend_ ) VULKAN_HPP_NOEXCEPT
    {
      dualSrcBlend = dualSrcBlend_;
      return *this;
    }

    PhysicalDeviceFeatures & setLogicOp( VULKAN_HPP_NAMESPACE::Bool32 logicOp_ ) VULKAN_HPP_NOEXCEPT
    {
      logicOp = logicOp_;
      return *this;
    }

    PhysicalDeviceFeatures & setMultiDrawIndirect( VULKAN_HPP_NAMESPACE::Bool32 multiDrawIndirect_ ) VULKAN_HPP_NOEXCEPT
    {
      multiDrawIndirect = multiDrawIndirect_;
      return *this;
    }

    PhysicalDeviceFeatures &
      setDrawIndirectFirstInstance( VULKAN_HPP_NAMESPACE::Bool32 drawIndirectFirstInstance_ ) VULKAN_HPP_NOEXCEPT
    {
      drawIndirectFirstInstance = drawIndirectFirstInstance_;
      return *this;
    }

    PhysicalDeviceFeatures & setDepthClamp( VULKAN_HPP_NAMESPACE::Bool32 depthClamp_ ) VULKAN_HPP_NOEXCEPT
    {
      depthClamp = depthClamp_;
      return *this;
    }

    PhysicalDeviceFeatures & setDepthBiasClamp( VULKAN_HPP_NAMESPACE::Bool32 depthBiasClamp_ ) VULKAN_HPP_NOEXCEPT
    {
      depthBiasClamp = depthBiasClamp_;
      return *this;
    }

    PhysicalDeviceFeatures & setFillModeNonSolid( VULKAN_HPP_NAMESPACE::Bool32 fillModeNonSolid_ ) VULKAN_HPP_NOEXCEPT
    {
      fillModeNonSolid = fillModeNonSolid_;
      return *this;
    }

    PhysicalDeviceFeatures & setDepthBounds( VULKAN_HPP_NAMESPACE::Bool32 depthBounds_ ) VULKAN_HPP_NOEXCEPT
    {
      depthBounds = depthBounds_;
      return *this;
    }

    PhysicalDeviceFeatures & setWideLines( VULKAN_HPP_NAMESPACE::Bool32 wideLines_ ) VULKAN_HPP_NOEXCEPT
    {
      wideLines = wideLines_;
      return *this;
    }

    PhysicalDeviceFeatures & setLargePoints( VULKAN_HPP_NAMESPACE::Bool32 largePoints_ ) VULKAN_HPP_NOEXCEPT
    {
      largePoints = largePoints_;
      return *this;
    }

    PhysicalDeviceFeatures & setAlphaToOne( VULKAN_HPP_NAMESPACE::Bool32 alphaToOne_ ) VULKAN_HPP_NOEXCEPT
    {
      alphaToOne = alphaToOne_;
      return *this;
    }

    PhysicalDeviceFeatures & setMultiViewport( VULKAN_HPP_NAMESPACE::Bool32 multiViewport_ ) VULKAN_HPP_NOEXCEPT
    {
      multiViewport = multiViewport_;
      return *this;
    }

    PhysicalDeviceFeatures & setSamplerAnisotropy( VULKAN_HPP_NAMESPACE::Bool32 samplerAnisotropy_ ) VULKAN_HPP_NOEXCEPT
    {
      samplerAnisotropy = samplerAnisotropy_;
      return *this;
    }

    PhysicalDeviceFeatures &
      setTextureCompressionETC2( VULKAN_HPP_NAMESPACE::Bool32 textureCompressionETC2_ ) VULKAN_HPP_NOEXCEPT
    {
      textureCompressionETC2 = textureCompressionETC2_;
      return *this;
    }

    PhysicalDeviceFeatures &
      setTextureCompressionASTC_LDR( VULKAN_HPP_NAMESPACE::Bool32 textureCompressionASTC_LDR_ ) VULKAN_HPP_NOEXCEPT
    {
      textureCompressionASTC_LDR = textureCompressionASTC_LDR_;
      return *this;
    }

    PhysicalDeviceFeatures &
      setTextureCompressionBC( VULKAN_HPP_NAMESPACE::Bool32 textureCompressionBC_ ) VULKAN_HPP_NOEXCEPT
    {
      textureCompressionBC = textureCompressionBC_;
      return *this;
    }

    PhysicalDeviceFeatures &
      setOcclusionQueryPrecise( VULKAN_HPP_NAMESPACE::Bool32 occlusionQueryPrecise_ ) VULKAN_HPP_NOEXCEPT
    {
      occlusionQueryPrecise = occlusionQueryPrecise_;
      return *this;
    }

    PhysicalDeviceFeatures &
      setPipelineStatisticsQuery( VULKAN_HPP_NAMESPACE::Bool32 pipelineStatisticsQuery_ ) VULKAN_HPP_NOEXCEPT
    {
      pipelineStatisticsQuery = pipelineStatisticsQuery_;
      return *this;
    }

    PhysicalDeviceFeatures & setVertexPipelineStoresAndAtomics(
      VULKAN_HPP_NAMESPACE::Bool32 vertexPipelineStoresAndAtomics_ ) VULKAN_HPP_NOEXCEPT
    {
      vertexPipelineStoresAndAtomics = vertexPipelineStoresAndAtomics_;
      return *this;
    }

    PhysicalDeviceFeatures &
      setFragmentStoresAndAtomics( VULKAN_HPP_NAMESPACE::Bool32 fragmentStoresAndAtomics_ ) VULKAN_HPP_NOEXCEPT
    {
      fragmentStoresAndAtomics = fragmentStoresAndAtomics_;
      return *this;
    }

    PhysicalDeviceFeatures & setShaderTessellationAndGeometryPointSize(
      VULKAN_HPP_NAMESPACE::Bool32 shaderTessellationAndGeometryPointSize_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderTessellationAndGeometryPointSize = shaderTessellationAndGeometryPointSize_;
      return *this;
    }

    PhysicalDeviceFeatures &
      setShaderImageGatherExtended( VULKAN_HPP_NAMESPACE::Bool32 shaderImageGatherExtended_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderImageGatherExtended = shaderImageGatherExtended_;
      return *this;
    }

    PhysicalDeviceFeatures & setShaderStorageImageExtendedFormats(
      VULKAN_HPP_NAMESPACE::Bool32 shaderStorageImageExtendedFormats_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderStorageImageExtendedFormats = shaderStorageImageExtendedFormats_;
      return *this;
    }

    PhysicalDeviceFeatures & setShaderStorageImageMultisample(
      VULKAN_HPP_NAMESPACE::Bool32 shaderStorageImageMultisample_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderStorageImageMultisample = shaderStorageImageMultisample_;
      return *this;
    }

    PhysicalDeviceFeatures & setShaderStorageImageReadWithoutFormat(
      VULKAN_HPP_NAMESPACE::Bool32 shaderStorageImageReadWithoutFormat_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderStorageImageReadWithoutFormat = shaderStorageImageReadWithoutFormat_;
      return *this;
    }

    PhysicalDeviceFeatures & setShaderStorageImageWriteWithoutFormat(
      VULKAN_HPP_NAMESPACE::Bool32 shaderStorageImageWriteWithoutFormat_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderStorageImageWriteWithoutFormat = shaderStorageImageWriteWithoutFormat_;
      return *this;
    }

    PhysicalDeviceFeatures & setShaderUniformBufferArrayDynamicIndexing(
      VULKAN_HPP_NAMESPACE::Bool32 shaderUniformBufferArrayDynamicIndexing_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderUniformBufferArrayDynamicIndexing = shaderUniformBufferArrayDynamicIndexing_;
      return *this;
    }

    PhysicalDeviceFeatures & setShaderSampledImageArrayDynamicIndexing(
      VULKAN_HPP_NAMESPACE::Bool32 shaderSampledImageArrayDynamicIndexing_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderSampledImageArrayDynamicIndexing = shaderSampledImageArrayDynamicIndexing_;
      return *this;
    }

    PhysicalDeviceFeatures & setShaderStorageBufferArrayDynamicIndexing(
      VULKAN_HPP_NAMESPACE::Bool32 shaderStorageBufferArrayDynamicIndexing_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderStorageBufferArrayDynamicIndexing = shaderStorageBufferArrayDynamicIndexing_;
      return *this;
    }

    PhysicalDeviceFeatures & setShaderStorageImageArrayDynamicIndexing(
      VULKAN_HPP_NAMESPACE::Bool32 shaderStorageImageArrayDynamicIndexing_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderStorageImageArrayDynamicIndexing = shaderStorageImageArrayDynamicIndexing_;
      return *this;
    }

    PhysicalDeviceFeatures &
      setShaderClipDistance( VULKAN_HPP_NAMESPACE::Bool32 shaderClipDistance_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderClipDistance = shaderClipDistance_;
      return *this;
    }

    PhysicalDeviceFeatures &
      setShaderCullDistance( VULKAN_HPP_NAMESPACE::Bool32 shaderCullDistance_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderCullDistance = shaderCullDistance_;
      return *this;
    }

    PhysicalDeviceFeatures & setShaderFloat64( VULKAN_HPP_NAMESPACE::Bool32 shaderFloat64_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderFloat64 = shaderFloat64_;
      return *this;
    }

    PhysicalDeviceFeatures & setShaderInt64( VULKAN_HPP_NAMESPACE::Bool32 shaderInt64_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderInt64 = shaderInt64_;
      return *this;
    }

    PhysicalDeviceFeatures & setShaderInt16( VULKAN_HPP_NAMESPACE::Bool32 shaderInt16_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderInt16 = shaderInt16_;
      return *this;
    }

    PhysicalDeviceFeatures &
      setShaderResourceResidency( VULKAN_HPP_NAMESPACE::Bool32 shaderResourceResidency_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderResourceResidency = shaderResourceResidency_;
      return *this;
    }

    PhysicalDeviceFeatures &
      setShaderResourceMinLod( VULKAN_HPP_NAMESPACE::Bool32 shaderResourceMinLod_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderResourceMinLod = shaderResourceMinLod_;
      return *this;
    }

    PhysicalDeviceFeatures & setSparseBinding( VULKAN_HPP_NAMESPACE::Bool32 sparseBinding_ ) VULKAN_HPP_NOEXCEPT
    {
      sparseBinding = sparseBinding_;
      return *this;
    }

    PhysicalDeviceFeatures &
      setSparseResidencyBuffer( VULKAN_HPP_NAMESPACE::Bool32 sparseResidencyBuffer_ ) VULKAN_HPP_NOEXCEPT
    {
      sparseResidencyBuffer = sparseResidencyBuffer_;
      return *this;
    }

    PhysicalDeviceFeatures &
      setSparseResidencyImage2D( VULKAN_HPP_NAMESPACE::Bool32 sparseResidencyImage2D_ ) VULKAN_HPP_NOEXCEPT
    {
      sparseResidencyImage2D = sparseResidencyImage2D_;
      return *this;
    }

    PhysicalDeviceFeatures &
      setSparseResidencyImage3D( VULKAN_HPP_NAMESPACE::Bool32 sparseResidencyImage3D_ ) VULKAN_HPP_NOEXCEPT
    {
      sparseResidencyImage3D = sparseResidencyImage3D_;
      return *this;
    }

    PhysicalDeviceFeatures &
      setSparseResidency2Samples( VULKAN_HPP_NAMESPACE::Bool32 sparseResidency2Samples_ ) VULKAN_HPP_NOEXCEPT
    {
      sparseResidency2Samples = sparseResidency2Samples_;
      return *this;
    }

    PhysicalDeviceFeatures &
      setSparseResidency4Samples( VULKAN_HPP_NAMESPACE::Bool32 sparseResidency4Samples_ ) VULKAN_HPP_NOEXCEPT
    {
      sparseResidency4Samples = sparseResidency4Samples_;
      return *this;
    }

    PhysicalDeviceFeatures &
      setSparseResidency8Samples( VULKAN_HPP_NAMESPACE::Bool32 sparseResidency8Samples_ ) VULKAN_HPP_NOEXCEPT
    {
      sparseResidency8Samples = sparseResidency8Samples_;
      return *this;
    }

    PhysicalDeviceFeatures &
      setSparseResidency16Samples( VULKAN_HPP_NAMESPACE::Bool32 sparseResidency16Samples_ ) VULKAN_HPP_NOEXCEPT
    {
      sparseResidency16Samples = sparseResidency16Samples_;
      return *this;
    }

    PhysicalDeviceFeatures &
      setSparseResidencyAliased( VULKAN_HPP_NAMESPACE::Bool32 sparseResidencyAliased_ ) VULKAN_HPP_NOEXCEPT
    {
      sparseResidencyAliased = sparseResidencyAliased_;
      return *this;
    }

    PhysicalDeviceFeatures &
      setVariableMultisampleRate( VULKAN_HPP_NAMESPACE::Bool32 variableMultisampleRate_ ) VULKAN_HPP_NOEXCEPT
    {
      variableMultisampleRate = variableMultisampleRate_;
      return *this;
    }

    PhysicalDeviceFeatures & setInheritedQueries( VULKAN_HPP_NAMESPACE::Bool32 inheritedQueries_ ) VULKAN_HPP_NOEXCEPT
    {
      inheritedQueries = inheritedQueries_;
      return *this;
    }

    operator VkPhysicalDeviceFeatures const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceFeatures *>( this );
    }

    operator VkPhysicalDeviceFeatures &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceFeatures *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceFeatures const & ) const = default;
#else
    bool operator==( PhysicalDeviceFeatures const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( robustBufferAccess == rhs.robustBufferAccess ) && ( fullDrawIndexUint32 == rhs.fullDrawIndexUint32 ) &&
             ( imageCubeArray == rhs.imageCubeArray ) && ( independentBlend == rhs.independentBlend ) &&
             ( geometryShader == rhs.geometryShader ) && ( tessellationShader == rhs.tessellationShader ) &&
             ( sampleRateShading == rhs.sampleRateShading ) && ( dualSrcBlend == rhs.dualSrcBlend ) &&
             ( logicOp == rhs.logicOp ) && ( multiDrawIndirect == rhs.multiDrawIndirect ) &&
             ( drawIndirectFirstInstance == rhs.drawIndirectFirstInstance ) && ( depthClamp == rhs.depthClamp ) &&
             ( depthBiasClamp == rhs.depthBiasClamp ) && ( fillModeNonSolid == rhs.fillModeNonSolid ) &&
             ( depthBounds == rhs.depthBounds ) && ( wideLines == rhs.wideLines ) &&
             ( largePoints == rhs.largePoints ) && ( alphaToOne == rhs.alphaToOne ) &&
             ( multiViewport == rhs.multiViewport ) && ( samplerAnisotropy == rhs.samplerAnisotropy ) &&
             ( textureCompressionETC2 == rhs.textureCompressionETC2 ) &&
             ( textureCompressionASTC_LDR == rhs.textureCompressionASTC_LDR ) &&
             ( textureCompressionBC == rhs.textureCompressionBC ) &&
             ( occlusionQueryPrecise == rhs.occlusionQueryPrecise ) &&
             ( pipelineStatisticsQuery == rhs.pipelineStatisticsQuery ) &&
             ( vertexPipelineStoresAndAtomics == rhs.vertexPipelineStoresAndAtomics ) &&
             ( fragmentStoresAndAtomics == rhs.fragmentStoresAndAtomics ) &&
             ( shaderTessellationAndGeometryPointSize == rhs.shaderTessellationAndGeometryPointSize ) &&
             ( shaderImageGatherExtended == rhs.shaderImageGatherExtended ) &&
             ( shaderStorageImageExtendedFormats == rhs.shaderStorageImageExtendedFormats ) &&
             ( shaderStorageImageMultisample == rhs.shaderStorageImageMultisample ) &&
             ( shaderStorageImageReadWithoutFormat == rhs.shaderStorageImageReadWithoutFormat ) &&
             ( shaderStorageImageWriteWithoutFormat == rhs.shaderStorageImageWriteWithoutFormat ) &&
             ( shaderUniformBufferArrayDynamicIndexing == rhs.shaderUniformBufferArrayDynamicIndexing ) &&
             ( shaderSampledImageArrayDynamicIndexing == rhs.shaderSampledImageArrayDynamicIndexing ) &&
             ( shaderStorageBufferArrayDynamicIndexing == rhs.shaderStorageBufferArrayDynamicIndexing ) &&
             ( shaderStorageImageArrayDynamicIndexing == rhs.shaderStorageImageArrayDynamicIndexing ) &&
             ( shaderClipDistance == rhs.shaderClipDistance ) && ( shaderCullDistance == rhs.shaderCullDistance ) &&
             ( shaderFloat64 == rhs.shaderFloat64 ) && ( shaderInt64 == rhs.shaderInt64 ) &&
             ( shaderInt16 == rhs.shaderInt16 ) && ( shaderResourceResidency == rhs.shaderResourceResidency ) &&
             ( shaderResourceMinLod == rhs.shaderResourceMinLod ) && ( sparseBinding == rhs.sparseBinding ) &&
             ( sparseResidencyBuffer == rhs.sparseResidencyBuffer ) &&
             ( sparseResidencyImage2D == rhs.sparseResidencyImage2D ) &&
             ( sparseResidencyImage3D == rhs.sparseResidencyImage3D ) &&
             ( sparseResidency2Samples == rhs.sparseResidency2Samples ) &&
             ( sparseResidency4Samples == rhs.sparseResidency4Samples ) &&
             ( sparseResidency8Samples == rhs.sparseResidency8Samples ) &&
             ( sparseResidency16Samples == rhs.sparseResidency16Samples ) &&
             ( sparseResidencyAliased == rhs.sparseResidencyAliased ) &&
             ( variableMultisampleRate == rhs.variableMultisampleRate ) && ( inheritedQueries == rhs.inheritedQueries );
    }

    bool operator!=( PhysicalDeviceFeatures const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::Bool32 robustBufferAccess                      = {};
    VULKAN_HPP_NAMESPACE::Bool32 fullDrawIndexUint32                     = {};
    VULKAN_HPP_NAMESPACE::Bool32 imageCubeArray                          = {};
    VULKAN_HPP_NAMESPACE::Bool32 independentBlend                        = {};
    VULKAN_HPP_NAMESPACE::Bool32 geometryShader                          = {};
    VULKAN_HPP_NAMESPACE::Bool32 tessellationShader                      = {};
    VULKAN_HPP_NAMESPACE::Bool32 sampleRateShading                       = {};
    VULKAN_HPP_NAMESPACE::Bool32 dualSrcBlend                            = {};
    VULKAN_HPP_NAMESPACE::Bool32 logicOp                                 = {};
    VULKAN_HPP_NAMESPACE::Bool32 multiDrawIndirect                       = {};
    VULKAN_HPP_NAMESPACE::Bool32 drawIndirectFirstInstance               = {};
    VULKAN_HPP_NAMESPACE::Bool32 depthClamp                              = {};
    VULKAN_HPP_NAMESPACE::Bool32 depthBiasClamp                          = {};
    VULKAN_HPP_NAMESPACE::Bool32 fillModeNonSolid                        = {};
    VULKAN_HPP_NAMESPACE::Bool32 depthBounds                             = {};
    VULKAN_HPP_NAMESPACE::Bool32 wideLines                               = {};
    VULKAN_HPP_NAMESPACE::Bool32 largePoints                             = {};
    VULKAN_HPP_NAMESPACE::Bool32 alphaToOne                              = {};
    VULKAN_HPP_NAMESPACE::Bool32 multiViewport                           = {};
    VULKAN_HPP_NAMESPACE::Bool32 samplerAnisotropy                       = {};
    VULKAN_HPP_NAMESPACE::Bool32 textureCompressionETC2                  = {};
    VULKAN_HPP_NAMESPACE::Bool32 textureCompressionASTC_LDR              = {};
    VULKAN_HPP_NAMESPACE::Bool32 textureCompressionBC                    = {};
    VULKAN_HPP_NAMESPACE::Bool32 occlusionQueryPrecise                   = {};
    VULKAN_HPP_NAMESPACE::Bool32 pipelineStatisticsQuery                 = {};
    VULKAN_HPP_NAMESPACE::Bool32 vertexPipelineStoresAndAtomics          = {};
    VULKAN_HPP_NAMESPACE::Bool32 fragmentStoresAndAtomics                = {};
    VULKAN_HPP_NAMESPACE::Bool32 shaderTessellationAndGeometryPointSize  = {};
    VULKAN_HPP_NAMESPACE::Bool32 shaderImageGatherExtended               = {};
    VULKAN_HPP_NAMESPACE::Bool32 shaderStorageImageExtendedFormats       = {};
    VULKAN_HPP_NAMESPACE::Bool32 shaderStorageImageMultisample           = {};
    VULKAN_HPP_NAMESPACE::Bool32 shaderStorageImageReadWithoutFormat     = {};
    VULKAN_HPP_NAMESPACE::Bool32 shaderStorageImageWriteWithoutFormat    = {};
    VULKAN_HPP_NAMESPACE::Bool32 shaderUniformBufferArrayDynamicIndexing = {};
    VULKAN_HPP_NAMESPACE::Bool32 shaderSampledImageArrayDynamicIndexing  = {};
    VULKAN_HPP_NAMESPACE::Bool32 shaderStorageBufferArrayDynamicIndexing = {};
    VULKAN_HPP_NAMESPACE::Bool32 shaderStorageImageArrayDynamicIndexing  = {};
    VULKAN_HPP_NAMESPACE::Bool32 shaderClipDistance                      = {};
    VULKAN_HPP_NAMESPACE::Bool32 shaderCullDistance                      = {};
    VULKAN_HPP_NAMESPACE::Bool32 shaderFloat64                           = {};
    VULKAN_HPP_NAMESPACE::Bool32 shaderInt64                             = {};
    VULKAN_HPP_NAMESPACE::Bool32 shaderInt16                             = {};
    VULKAN_HPP_NAMESPACE::Bool32 shaderResourceResidency                 = {};
    VULKAN_HPP_NAMESPACE::Bool32 shaderResourceMinLod                    = {};
    VULKAN_HPP_NAMESPACE::Bool32 sparseBinding                           = {};
    VULKAN_HPP_NAMESPACE::Bool32 sparseResidencyBuffer                   = {};
    VULKAN_HPP_NAMESPACE::Bool32 sparseResidencyImage2D                  = {};
    VULKAN_HPP_NAMESPACE::Bool32 sparseResidencyImage3D                  = {};
    VULKAN_HPP_NAMESPACE::Bool32 sparseResidency2Samples                 = {};
    VULKAN_HPP_NAMESPACE::Bool32 sparseResidency4Samples                 = {};
    VULKAN_HPP_NAMESPACE::Bool32 sparseResidency8Samples                 = {};
    VULKAN_HPP_NAMESPACE::Bool32 sparseResidency16Samples                = {};
    VULKAN_HPP_NAMESPACE::Bool32 sparseResidencyAliased                  = {};
    VULKAN_HPP_NAMESPACE::Bool32 variableMultisampleRate                 = {};
    VULKAN_HPP_NAMESPACE::Bool32 inheritedQueries                        = {};
  };
  static_assert( sizeof( PhysicalDeviceFeatures ) == sizeof( VkPhysicalDeviceFeatures ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceFeatures>::value, "struct wrapper is not a standard layout!" );

  struct DeviceCreateInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eDeviceCreateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR DeviceCreateInfo( VULKAN_HPP_NAMESPACE::DeviceCreateFlags flags_                         = {},
                                           uint32_t                                queueCreateInfoCount_          = {},
                                           const VULKAN_HPP_NAMESPACE::DeviceQueueCreateInfo * pQueueCreateInfos_ = {},
                                           uint32_t                                            enabledLayerCount_ = {},
                                           const char * const * ppEnabledLayerNames_                              = {},
                                           uint32_t             enabledExtensionCount_                            = {},
                                           const char * const * ppEnabledExtensionNames_                          = {},
                                           const VULKAN_HPP_NAMESPACE::PhysicalDeviceFeatures * pEnabledFeatures_ = {} )
      VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , queueCreateInfoCount( queueCreateInfoCount_ )
      , pQueueCreateInfos( pQueueCreateInfos_ )
      , enabledLayerCount( enabledLayerCount_ )
      , ppEnabledLayerNames( ppEnabledLayerNames_ )
      , enabledExtensionCount( enabledExtensionCount_ )
      , ppEnabledExtensionNames( ppEnabledExtensionNames_ )
      , pEnabledFeatures( pEnabledFeatures_ )
    {}

    VULKAN_HPP_CONSTEXPR DeviceCreateInfo( DeviceCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DeviceCreateInfo( VkDeviceCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : DeviceCreateInfo( *reinterpret_cast<DeviceCreateInfo const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    DeviceCreateInfo(
      VULKAN_HPP_NAMESPACE::DeviceCreateFlags flags_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::DeviceQueueCreateInfo> const &
                                                                                queueCreateInfos_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const char * const> const & pEnabledLayerNames_     = {},
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const char * const> const & pEnabledExtensionNames_ = {},
      const VULKAN_HPP_NAMESPACE::PhysicalDeviceFeatures *                      pEnabledFeatures_       = {} )
      : flags( flags_ )
      , queueCreateInfoCount( static_cast<uint32_t>( queueCreateInfos_.size() ) )
      , pQueueCreateInfos( queueCreateInfos_.data() )
      , enabledLayerCount( static_cast<uint32_t>( pEnabledLayerNames_.size() ) )
      , ppEnabledLayerNames( pEnabledLayerNames_.data() )
      , enabledExtensionCount( static_cast<uint32_t>( pEnabledExtensionNames_.size() ) )
      , ppEnabledExtensionNames( pEnabledExtensionNames_.data() )
      , pEnabledFeatures( pEnabledFeatures_ )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DeviceCreateInfo & operator=( DeviceCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DeviceCreateInfo & operator=( VkDeviceCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DeviceCreateInfo const *>( &rhs );
      return *this;
    }

    DeviceCreateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    DeviceCreateInfo & setFlags( VULKAN_HPP_NAMESPACE::DeviceCreateFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    DeviceCreateInfo & setQueueCreateInfoCount( uint32_t queueCreateInfoCount_ ) VULKAN_HPP_NOEXCEPT
    {
      queueCreateInfoCount = queueCreateInfoCount_;
      return *this;
    }

    DeviceCreateInfo &
      setPQueueCreateInfos( const VULKAN_HPP_NAMESPACE::DeviceQueueCreateInfo * pQueueCreateInfos_ ) VULKAN_HPP_NOEXCEPT
    {
      pQueueCreateInfos = pQueueCreateInfos_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    DeviceCreateInfo & setQueueCreateInfos(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::DeviceQueueCreateInfo> const &
        queueCreateInfos_ ) VULKAN_HPP_NOEXCEPT
    {
      queueCreateInfoCount = static_cast<uint32_t>( queueCreateInfos_.size() );
      pQueueCreateInfos    = queueCreateInfos_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    DeviceCreateInfo & setEnabledLayerCount( uint32_t enabledLayerCount_ ) VULKAN_HPP_NOEXCEPT
    {
      enabledLayerCount = enabledLayerCount_;
      return *this;
    }

    DeviceCreateInfo & setPpEnabledLayerNames( const char * const * ppEnabledLayerNames_ ) VULKAN_HPP_NOEXCEPT
    {
      ppEnabledLayerNames = ppEnabledLayerNames_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    DeviceCreateInfo & setPEnabledLayerNames( VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const char * const> const &
                                                pEnabledLayerNames_ ) VULKAN_HPP_NOEXCEPT
    {
      enabledLayerCount   = static_cast<uint32_t>( pEnabledLayerNames_.size() );
      ppEnabledLayerNames = pEnabledLayerNames_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    DeviceCreateInfo & setEnabledExtensionCount( uint32_t enabledExtensionCount_ ) VULKAN_HPP_NOEXCEPT
    {
      enabledExtensionCount = enabledExtensionCount_;
      return *this;
    }

    DeviceCreateInfo & setPpEnabledExtensionNames( const char * const * ppEnabledExtensionNames_ ) VULKAN_HPP_NOEXCEPT
    {
      ppEnabledExtensionNames = ppEnabledExtensionNames_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    DeviceCreateInfo & setPEnabledExtensionNames(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const char * const> const & pEnabledExtensionNames_ )
      VULKAN_HPP_NOEXCEPT
    {
      enabledExtensionCount   = static_cast<uint32_t>( pEnabledExtensionNames_.size() );
      ppEnabledExtensionNames = pEnabledExtensionNames_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    DeviceCreateInfo &
      setPEnabledFeatures( const VULKAN_HPP_NAMESPACE::PhysicalDeviceFeatures * pEnabledFeatures_ ) VULKAN_HPP_NOEXCEPT
    {
      pEnabledFeatures = pEnabledFeatures_;
      return *this;
    }

    operator VkDeviceCreateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDeviceCreateInfo *>( this );
    }

    operator VkDeviceCreateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDeviceCreateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DeviceCreateInfo const & ) const = default;
#else
    bool operator==( DeviceCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( queueCreateInfoCount == rhs.queueCreateInfoCount ) && ( pQueueCreateInfos == rhs.pQueueCreateInfos ) &&
             ( enabledLayerCount == rhs.enabledLayerCount ) && ( ppEnabledLayerNames == rhs.ppEnabledLayerNames ) &&
             ( enabledExtensionCount == rhs.enabledExtensionCount ) &&
             ( ppEnabledExtensionNames == rhs.ppEnabledExtensionNames ) && ( pEnabledFeatures == rhs.pEnabledFeatures );
    }

    bool operator!=( DeviceCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                  sType                   = StructureType::eDeviceCreateInfo;
    const void *                                         pNext                   = {};
    VULKAN_HPP_NAMESPACE::DeviceCreateFlags              flags                   = {};
    uint32_t                                             queueCreateInfoCount    = {};
    const VULKAN_HPP_NAMESPACE::DeviceQueueCreateInfo *  pQueueCreateInfos       = {};
    uint32_t                                             enabledLayerCount       = {};
    const char * const *                                 ppEnabledLayerNames     = {};
    uint32_t                                             enabledExtensionCount   = {};
    const char * const *                                 ppEnabledExtensionNames = {};
    const VULKAN_HPP_NAMESPACE::PhysicalDeviceFeatures * pEnabledFeatures        = {};
  };
  static_assert( sizeof( DeviceCreateInfo ) == sizeof( VkDeviceCreateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DeviceCreateInfo>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDeviceCreateInfo>
  {
    using Type = DeviceCreateInfo;
  };

  struct DeviceDeviceMemoryReportCreateInfoEXT
  {
    static const bool                    allowDuplicate = true;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eDeviceDeviceMemoryReportCreateInfoEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      DeviceDeviceMemoryReportCreateInfoEXT( VULKAN_HPP_NAMESPACE::DeviceMemoryReportFlagsEXT flags_           = {},
                                             PFN_vkDeviceMemoryReportCallbackEXT              pfnUserCallback_ = {},
                                             void * pUserData_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , pfnUserCallback( pfnUserCallback_ )
      , pUserData( pUserData_ )
    {}

    VULKAN_HPP_CONSTEXPR DeviceDeviceMemoryReportCreateInfoEXT( DeviceDeviceMemoryReportCreateInfoEXT const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    DeviceDeviceMemoryReportCreateInfoEXT( VkDeviceDeviceMemoryReportCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : DeviceDeviceMemoryReportCreateInfoEXT(
          *reinterpret_cast<DeviceDeviceMemoryReportCreateInfoEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DeviceDeviceMemoryReportCreateInfoEXT &
                            operator=( DeviceDeviceMemoryReportCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DeviceDeviceMemoryReportCreateInfoEXT &
      operator=( VkDeviceDeviceMemoryReportCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DeviceDeviceMemoryReportCreateInfoEXT const *>( &rhs );
      return *this;
    }

    DeviceDeviceMemoryReportCreateInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    DeviceDeviceMemoryReportCreateInfoEXT &
      setFlags( VULKAN_HPP_NAMESPACE::DeviceMemoryReportFlagsEXT flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    DeviceDeviceMemoryReportCreateInfoEXT &
      setPfnUserCallback( PFN_vkDeviceMemoryReportCallbackEXT pfnUserCallback_ ) VULKAN_HPP_NOEXCEPT
    {
      pfnUserCallback = pfnUserCallback_;
      return *this;
    }

    DeviceDeviceMemoryReportCreateInfoEXT & setPUserData( void * pUserData_ ) VULKAN_HPP_NOEXCEPT
    {
      pUserData = pUserData_;
      return *this;
    }

    operator VkDeviceDeviceMemoryReportCreateInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDeviceDeviceMemoryReportCreateInfoEXT *>( this );
    }

    operator VkDeviceDeviceMemoryReportCreateInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDeviceDeviceMemoryReportCreateInfoEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DeviceDeviceMemoryReportCreateInfoEXT const & ) const = default;
#else
    bool operator==( DeviceDeviceMemoryReportCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( pfnUserCallback == rhs.pfnUserCallback ) && ( pUserData == rhs.pUserData );
    }

    bool operator!=( DeviceDeviceMemoryReportCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType              sType = StructureType::eDeviceDeviceMemoryReportCreateInfoEXT;
    const void *                                     pNext = {};
    VULKAN_HPP_NAMESPACE::DeviceMemoryReportFlagsEXT flags = {};
    PFN_vkDeviceMemoryReportCallbackEXT              pfnUserCallback = {};
    void *                                           pUserData       = {};
  };
  static_assert( sizeof( DeviceDeviceMemoryReportCreateInfoEXT ) == sizeof( VkDeviceDeviceMemoryReportCreateInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DeviceDeviceMemoryReportCreateInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDeviceDeviceMemoryReportCreateInfoEXT>
  {
    using Type = DeviceDeviceMemoryReportCreateInfoEXT;
  };

  struct DeviceDiagnosticsConfigCreateInfoNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eDeviceDiagnosticsConfigCreateInfoNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR DeviceDiagnosticsConfigCreateInfoNV(
      VULKAN_HPP_NAMESPACE::DeviceDiagnosticsConfigFlagsNV flags_ = {} ) VULKAN_HPP_NOEXCEPT : flags( flags_ )
    {}

    VULKAN_HPP_CONSTEXPR DeviceDiagnosticsConfigCreateInfoNV( DeviceDiagnosticsConfigCreateInfoNV const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    DeviceDiagnosticsConfigCreateInfoNV( VkDeviceDiagnosticsConfigCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
      : DeviceDiagnosticsConfigCreateInfoNV( *reinterpret_cast<DeviceDiagnosticsConfigCreateInfoNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DeviceDiagnosticsConfigCreateInfoNV &
                            operator=( DeviceDiagnosticsConfigCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DeviceDiagnosticsConfigCreateInfoNV &
      operator=( VkDeviceDiagnosticsConfigCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DeviceDiagnosticsConfigCreateInfoNV const *>( &rhs );
      return *this;
    }

    DeviceDiagnosticsConfigCreateInfoNV & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    DeviceDiagnosticsConfigCreateInfoNV &
      setFlags( VULKAN_HPP_NAMESPACE::DeviceDiagnosticsConfigFlagsNV flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    operator VkDeviceDiagnosticsConfigCreateInfoNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDeviceDiagnosticsConfigCreateInfoNV *>( this );
    }

    operator VkDeviceDiagnosticsConfigCreateInfoNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDeviceDiagnosticsConfigCreateInfoNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DeviceDiagnosticsConfigCreateInfoNV const & ) const = default;
#else
    bool operator==( DeviceDiagnosticsConfigCreateInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags );
    }

    bool operator!=( DeviceDiagnosticsConfigCreateInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                  sType = StructureType::eDeviceDiagnosticsConfigCreateInfoNV;
    const void *                                         pNext = {};
    VULKAN_HPP_NAMESPACE::DeviceDiagnosticsConfigFlagsNV flags = {};
  };
  static_assert( sizeof( DeviceDiagnosticsConfigCreateInfoNV ) == sizeof( VkDeviceDiagnosticsConfigCreateInfoNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DeviceDiagnosticsConfigCreateInfoNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDeviceDiagnosticsConfigCreateInfoNV>
  {
    using Type = DeviceDiagnosticsConfigCreateInfoNV;
  };

  struct DeviceEventInfoEXT
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eDeviceEventInfoEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      DeviceEventInfoEXT( VULKAN_HPP_NAMESPACE::DeviceEventTypeEXT deviceEvent_ =
                            VULKAN_HPP_NAMESPACE::DeviceEventTypeEXT::eDisplayHotplug ) VULKAN_HPP_NOEXCEPT
      : deviceEvent( deviceEvent_ )
    {}

    VULKAN_HPP_CONSTEXPR DeviceEventInfoEXT( DeviceEventInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DeviceEventInfoEXT( VkDeviceEventInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : DeviceEventInfoEXT( *reinterpret_cast<DeviceEventInfoEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DeviceEventInfoEXT &
                            operator=( DeviceEventInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DeviceEventInfoEXT & operator=( VkDeviceEventInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DeviceEventInfoEXT const *>( &rhs );
      return *this;
    }

    DeviceEventInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    DeviceEventInfoEXT & setDeviceEvent( VULKAN_HPP_NAMESPACE::DeviceEventTypeEXT deviceEvent_ ) VULKAN_HPP_NOEXCEPT
    {
      deviceEvent = deviceEvent_;
      return *this;
    }

    operator VkDeviceEventInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDeviceEventInfoEXT *>( this );
    }

    operator VkDeviceEventInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDeviceEventInfoEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DeviceEventInfoEXT const & ) const = default;
#else
    bool operator==( DeviceEventInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( deviceEvent == rhs.deviceEvent );
    }

    bool operator!=( DeviceEventInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType      sType       = StructureType::eDeviceEventInfoEXT;
    const void *                             pNext       = {};
    VULKAN_HPP_NAMESPACE::DeviceEventTypeEXT deviceEvent = VULKAN_HPP_NAMESPACE::DeviceEventTypeEXT::eDisplayHotplug;
  };
  static_assert( sizeof( DeviceEventInfoEXT ) == sizeof( VkDeviceEventInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DeviceEventInfoEXT>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDeviceEventInfoEXT>
  {
    using Type = DeviceEventInfoEXT;
  };

  struct DeviceGroupBindSparseInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eDeviceGroupBindSparseInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR DeviceGroupBindSparseInfo( uint32_t resourceDeviceIndex_ = {},
                                                    uint32_t memoryDeviceIndex_   = {} ) VULKAN_HPP_NOEXCEPT
      : resourceDeviceIndex( resourceDeviceIndex_ )
      , memoryDeviceIndex( memoryDeviceIndex_ )
    {}

    VULKAN_HPP_CONSTEXPR
      DeviceGroupBindSparseInfo( DeviceGroupBindSparseInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DeviceGroupBindSparseInfo( VkDeviceGroupBindSparseInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : DeviceGroupBindSparseInfo( *reinterpret_cast<DeviceGroupBindSparseInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DeviceGroupBindSparseInfo &
                            operator=( DeviceGroupBindSparseInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DeviceGroupBindSparseInfo & operator=( VkDeviceGroupBindSparseInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DeviceGroupBindSparseInfo const *>( &rhs );
      return *this;
    }

    DeviceGroupBindSparseInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    DeviceGroupBindSparseInfo & setResourceDeviceIndex( uint32_t resourceDeviceIndex_ ) VULKAN_HPP_NOEXCEPT
    {
      resourceDeviceIndex = resourceDeviceIndex_;
      return *this;
    }

    DeviceGroupBindSparseInfo & setMemoryDeviceIndex( uint32_t memoryDeviceIndex_ ) VULKAN_HPP_NOEXCEPT
    {
      memoryDeviceIndex = memoryDeviceIndex_;
      return *this;
    }

    operator VkDeviceGroupBindSparseInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDeviceGroupBindSparseInfo *>( this );
    }

    operator VkDeviceGroupBindSparseInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDeviceGroupBindSparseInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DeviceGroupBindSparseInfo const & ) const = default;
#else
    bool operator==( DeviceGroupBindSparseInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( resourceDeviceIndex == rhs.resourceDeviceIndex ) &&
             ( memoryDeviceIndex == rhs.memoryDeviceIndex );
    }

    bool operator!=( DeviceGroupBindSparseInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType               = StructureType::eDeviceGroupBindSparseInfo;
    const void *                        pNext               = {};
    uint32_t                            resourceDeviceIndex = {};
    uint32_t                            memoryDeviceIndex   = {};
  };
  static_assert( sizeof( DeviceGroupBindSparseInfo ) == sizeof( VkDeviceGroupBindSparseInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DeviceGroupBindSparseInfo>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDeviceGroupBindSparseInfo>
  {
    using Type = DeviceGroupBindSparseInfo;
  };
  using DeviceGroupBindSparseInfoKHR = DeviceGroupBindSparseInfo;

  struct DeviceGroupCommandBufferBeginInfo
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eDeviceGroupCommandBufferBeginInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR DeviceGroupCommandBufferBeginInfo( uint32_t deviceMask_ = {} ) VULKAN_HPP_NOEXCEPT
      : deviceMask( deviceMask_ )
    {}

    VULKAN_HPP_CONSTEXPR
      DeviceGroupCommandBufferBeginInfo( DeviceGroupCommandBufferBeginInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DeviceGroupCommandBufferBeginInfo( VkDeviceGroupCommandBufferBeginInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : DeviceGroupCommandBufferBeginInfo( *reinterpret_cast<DeviceGroupCommandBufferBeginInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DeviceGroupCommandBufferBeginInfo &
                            operator=( DeviceGroupCommandBufferBeginInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DeviceGroupCommandBufferBeginInfo & operator=( VkDeviceGroupCommandBufferBeginInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DeviceGroupCommandBufferBeginInfo const *>( &rhs );
      return *this;
    }

    DeviceGroupCommandBufferBeginInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    DeviceGroupCommandBufferBeginInfo & setDeviceMask( uint32_t deviceMask_ ) VULKAN_HPP_NOEXCEPT
    {
      deviceMask = deviceMask_;
      return *this;
    }

    operator VkDeviceGroupCommandBufferBeginInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDeviceGroupCommandBufferBeginInfo *>( this );
    }

    operator VkDeviceGroupCommandBufferBeginInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDeviceGroupCommandBufferBeginInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DeviceGroupCommandBufferBeginInfo const & ) const = default;
#else
    bool operator==( DeviceGroupCommandBufferBeginInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( deviceMask == rhs.deviceMask );
    }

    bool operator!=( DeviceGroupCommandBufferBeginInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType      = StructureType::eDeviceGroupCommandBufferBeginInfo;
    const void *                        pNext      = {};
    uint32_t                            deviceMask = {};
  };
  static_assert( sizeof( DeviceGroupCommandBufferBeginInfo ) == sizeof( VkDeviceGroupCommandBufferBeginInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DeviceGroupCommandBufferBeginInfo>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDeviceGroupCommandBufferBeginInfo>
  {
    using Type = DeviceGroupCommandBufferBeginInfo;
  };
  using DeviceGroupCommandBufferBeginInfoKHR = DeviceGroupCommandBufferBeginInfo;

  struct DeviceGroupDeviceCreateInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eDeviceGroupDeviceCreateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR DeviceGroupDeviceCreateInfo(
      uint32_t                                     physicalDeviceCount_ = {},
      const VULKAN_HPP_NAMESPACE::PhysicalDevice * pPhysicalDevices_    = {} ) VULKAN_HPP_NOEXCEPT
      : physicalDeviceCount( physicalDeviceCount_ )
      , pPhysicalDevices( pPhysicalDevices_ )
    {}

    VULKAN_HPP_CONSTEXPR
      DeviceGroupDeviceCreateInfo( DeviceGroupDeviceCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DeviceGroupDeviceCreateInfo( VkDeviceGroupDeviceCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : DeviceGroupDeviceCreateInfo( *reinterpret_cast<DeviceGroupDeviceCreateInfo const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    DeviceGroupDeviceCreateInfo(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::PhysicalDevice> const &
        physicalDevices_ )
      : physicalDeviceCount( static_cast<uint32_t>( physicalDevices_.size() ) )
      , pPhysicalDevices( physicalDevices_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DeviceGroupDeviceCreateInfo &
                            operator=( DeviceGroupDeviceCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DeviceGroupDeviceCreateInfo & operator=( VkDeviceGroupDeviceCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DeviceGroupDeviceCreateInfo const *>( &rhs );
      return *this;
    }

    DeviceGroupDeviceCreateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    DeviceGroupDeviceCreateInfo & setPhysicalDeviceCount( uint32_t physicalDeviceCount_ ) VULKAN_HPP_NOEXCEPT
    {
      physicalDeviceCount = physicalDeviceCount_;
      return *this;
    }

    DeviceGroupDeviceCreateInfo &
      setPPhysicalDevices( const VULKAN_HPP_NAMESPACE::PhysicalDevice * pPhysicalDevices_ ) VULKAN_HPP_NOEXCEPT
    {
      pPhysicalDevices = pPhysicalDevices_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    DeviceGroupDeviceCreateInfo & setPhysicalDevices(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::PhysicalDevice> const &
        physicalDevices_ ) VULKAN_HPP_NOEXCEPT
    {
      physicalDeviceCount = static_cast<uint32_t>( physicalDevices_.size() );
      pPhysicalDevices    = physicalDevices_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkDeviceGroupDeviceCreateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDeviceGroupDeviceCreateInfo *>( this );
    }

    operator VkDeviceGroupDeviceCreateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDeviceGroupDeviceCreateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DeviceGroupDeviceCreateInfo const & ) const = default;
#else
    bool operator==( DeviceGroupDeviceCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( physicalDeviceCount == rhs.physicalDeviceCount ) &&
             ( pPhysicalDevices == rhs.pPhysicalDevices );
    }

    bool operator!=( DeviceGroupDeviceCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType          sType               = StructureType::eDeviceGroupDeviceCreateInfo;
    const void *                                 pNext               = {};
    uint32_t                                     physicalDeviceCount = {};
    const VULKAN_HPP_NAMESPACE::PhysicalDevice * pPhysicalDevices    = {};
  };
  static_assert( sizeof( DeviceGroupDeviceCreateInfo ) == sizeof( VkDeviceGroupDeviceCreateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DeviceGroupDeviceCreateInfo>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDeviceGroupDeviceCreateInfo>
  {
    using Type = DeviceGroupDeviceCreateInfo;
  };
  using DeviceGroupDeviceCreateInfoKHR = DeviceGroupDeviceCreateInfo;

  struct DeviceGroupPresentCapabilitiesKHR
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eDeviceGroupPresentCapabilitiesKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR_14 DeviceGroupPresentCapabilitiesKHR(
      std::array<uint32_t, VK_MAX_DEVICE_GROUP_SIZE> const & presentMask_ = {},
      VULKAN_HPP_NAMESPACE::DeviceGroupPresentModeFlagsKHR   modes_       = {} ) VULKAN_HPP_NOEXCEPT
      : presentMask( presentMask_ )
      , modes( modes_ )
    {}

    VULKAN_HPP_CONSTEXPR_14
      DeviceGroupPresentCapabilitiesKHR( DeviceGroupPresentCapabilitiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DeviceGroupPresentCapabilitiesKHR( VkDeviceGroupPresentCapabilitiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : DeviceGroupPresentCapabilitiesKHR( *reinterpret_cast<DeviceGroupPresentCapabilitiesKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DeviceGroupPresentCapabilitiesKHR &
                            operator=( DeviceGroupPresentCapabilitiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DeviceGroupPresentCapabilitiesKHR & operator=( VkDeviceGroupPresentCapabilitiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DeviceGroupPresentCapabilitiesKHR const *>( &rhs );
      return *this;
    }

    operator VkDeviceGroupPresentCapabilitiesKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDeviceGroupPresentCapabilitiesKHR *>( this );
    }

    operator VkDeviceGroupPresentCapabilitiesKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDeviceGroupPresentCapabilitiesKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DeviceGroupPresentCapabilitiesKHR const & ) const = default;
#else
    bool operator==( DeviceGroupPresentCapabilitiesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( presentMask == rhs.presentMask ) &&
             ( modes == rhs.modes );
    }

    bool operator!=( DeviceGroupPresentCapabilitiesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::eDeviceGroupPresentCapabilitiesKHR;
    const void *                        pNext = {};
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<uint32_t, VK_MAX_DEVICE_GROUP_SIZE> presentMask = {};
    VULKAN_HPP_NAMESPACE::DeviceGroupPresentModeFlagsKHR                     modes       = {};
  };
  static_assert( sizeof( DeviceGroupPresentCapabilitiesKHR ) == sizeof( VkDeviceGroupPresentCapabilitiesKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DeviceGroupPresentCapabilitiesKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDeviceGroupPresentCapabilitiesKHR>
  {
    using Type = DeviceGroupPresentCapabilitiesKHR;
  };

  struct DeviceGroupPresentInfoKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eDeviceGroupPresentInfoKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      DeviceGroupPresentInfoKHR( uint32_t                                                swapchainCount_ = {},
                                 const uint32_t *                                        pDeviceMasks_   = {},
                                 VULKAN_HPP_NAMESPACE::DeviceGroupPresentModeFlagBitsKHR mode_ =
                                   VULKAN_HPP_NAMESPACE::DeviceGroupPresentModeFlagBitsKHR::eLocal ) VULKAN_HPP_NOEXCEPT
      : swapchainCount( swapchainCount_ )
      , pDeviceMasks( pDeviceMasks_ )
      , mode( mode_ )
    {}

    VULKAN_HPP_CONSTEXPR
      DeviceGroupPresentInfoKHR( DeviceGroupPresentInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DeviceGroupPresentInfoKHR( VkDeviceGroupPresentInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : DeviceGroupPresentInfoKHR( *reinterpret_cast<DeviceGroupPresentInfoKHR const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    DeviceGroupPresentInfoKHR( VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const & deviceMasks_,
                               VULKAN_HPP_NAMESPACE::DeviceGroupPresentModeFlagBitsKHR               mode_ =
                                 VULKAN_HPP_NAMESPACE::DeviceGroupPresentModeFlagBitsKHR::eLocal )
      : swapchainCount( static_cast<uint32_t>( deviceMasks_.size() ) )
      , pDeviceMasks( deviceMasks_.data() )
      , mode( mode_ )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DeviceGroupPresentInfoKHR &
                            operator=( DeviceGroupPresentInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DeviceGroupPresentInfoKHR & operator=( VkDeviceGroupPresentInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DeviceGroupPresentInfoKHR const *>( &rhs );
      return *this;
    }

    DeviceGroupPresentInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    DeviceGroupPresentInfoKHR & setSwapchainCount( uint32_t swapchainCount_ ) VULKAN_HPP_NOEXCEPT
    {
      swapchainCount = swapchainCount_;
      return *this;
    }

    DeviceGroupPresentInfoKHR & setPDeviceMasks( const uint32_t * pDeviceMasks_ ) VULKAN_HPP_NOEXCEPT
    {
      pDeviceMasks = pDeviceMasks_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    DeviceGroupPresentInfoKHR & setDeviceMasks(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const & deviceMasks_ ) VULKAN_HPP_NOEXCEPT
    {
      swapchainCount = static_cast<uint32_t>( deviceMasks_.size() );
      pDeviceMasks   = deviceMasks_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    DeviceGroupPresentInfoKHR &
      setMode( VULKAN_HPP_NAMESPACE::DeviceGroupPresentModeFlagBitsKHR mode_ ) VULKAN_HPP_NOEXCEPT
    {
      mode = mode_;
      return *this;
    }

    operator VkDeviceGroupPresentInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDeviceGroupPresentInfoKHR *>( this );
    }

    operator VkDeviceGroupPresentInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDeviceGroupPresentInfoKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DeviceGroupPresentInfoKHR const & ) const = default;
#else
    bool operator==( DeviceGroupPresentInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( swapchainCount == rhs.swapchainCount ) &&
             ( pDeviceMasks == rhs.pDeviceMasks ) && ( mode == rhs.mode );
    }

    bool operator!=( DeviceGroupPresentInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                     sType          = StructureType::eDeviceGroupPresentInfoKHR;
    const void *                                            pNext          = {};
    uint32_t                                                swapchainCount = {};
    const uint32_t *                                        pDeviceMasks   = {};
    VULKAN_HPP_NAMESPACE::DeviceGroupPresentModeFlagBitsKHR mode =
      VULKAN_HPP_NAMESPACE::DeviceGroupPresentModeFlagBitsKHR::eLocal;
  };
  static_assert( sizeof( DeviceGroupPresentInfoKHR ) == sizeof( VkDeviceGroupPresentInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DeviceGroupPresentInfoKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDeviceGroupPresentInfoKHR>
  {
    using Type = DeviceGroupPresentInfoKHR;
  };

  struct DeviceGroupRenderPassBeginInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eDeviceGroupRenderPassBeginInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR DeviceGroupRenderPassBeginInfo( uint32_t deviceMask_                                     = {},
                                                         uint32_t deviceRenderAreaCount_                          = {},
                                                         const VULKAN_HPP_NAMESPACE::Rect2D * pDeviceRenderAreas_ = {} )
      VULKAN_HPP_NOEXCEPT
      : deviceMask( deviceMask_ )
      , deviceRenderAreaCount( deviceRenderAreaCount_ )
      , pDeviceRenderAreas( pDeviceRenderAreas_ )
    {}

    VULKAN_HPP_CONSTEXPR
      DeviceGroupRenderPassBeginInfo( DeviceGroupRenderPassBeginInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DeviceGroupRenderPassBeginInfo( VkDeviceGroupRenderPassBeginInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : DeviceGroupRenderPassBeginInfo( *reinterpret_cast<DeviceGroupRenderPassBeginInfo const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    DeviceGroupRenderPassBeginInfo(
      uint32_t                                                                                  deviceMask_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::Rect2D> const & deviceRenderAreas_ )
      : deviceMask( deviceMask_ )
      , deviceRenderAreaCount( static_cast<uint32_t>( deviceRenderAreas_.size() ) )
      , pDeviceRenderAreas( deviceRenderAreas_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DeviceGroupRenderPassBeginInfo &
                            operator=( DeviceGroupRenderPassBeginInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DeviceGroupRenderPassBeginInfo & operator=( VkDeviceGroupRenderPassBeginInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DeviceGroupRenderPassBeginInfo const *>( &rhs );
      return *this;
    }

    DeviceGroupRenderPassBeginInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    DeviceGroupRenderPassBeginInfo & setDeviceMask( uint32_t deviceMask_ ) VULKAN_HPP_NOEXCEPT
    {
      deviceMask = deviceMask_;
      return *this;
    }

    DeviceGroupRenderPassBeginInfo & setDeviceRenderAreaCount( uint32_t deviceRenderAreaCount_ ) VULKAN_HPP_NOEXCEPT
    {
      deviceRenderAreaCount = deviceRenderAreaCount_;
      return *this;
    }

    DeviceGroupRenderPassBeginInfo &
      setPDeviceRenderAreas( const VULKAN_HPP_NAMESPACE::Rect2D * pDeviceRenderAreas_ ) VULKAN_HPP_NOEXCEPT
    {
      pDeviceRenderAreas = pDeviceRenderAreas_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    DeviceGroupRenderPassBeginInfo & setDeviceRenderAreas(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::Rect2D> const & deviceRenderAreas_ )
      VULKAN_HPP_NOEXCEPT
    {
      deviceRenderAreaCount = static_cast<uint32_t>( deviceRenderAreas_.size() );
      pDeviceRenderAreas    = deviceRenderAreas_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkDeviceGroupRenderPassBeginInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDeviceGroupRenderPassBeginInfo *>( this );
    }

    operator VkDeviceGroupRenderPassBeginInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDeviceGroupRenderPassBeginInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DeviceGroupRenderPassBeginInfo const & ) const = default;
#else
    bool operator==( DeviceGroupRenderPassBeginInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( deviceMask == rhs.deviceMask ) &&
             ( deviceRenderAreaCount == rhs.deviceRenderAreaCount ) && ( pDeviceRenderAreas == rhs.pDeviceRenderAreas );
    }

    bool operator!=( DeviceGroupRenderPassBeginInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType  sType                 = StructureType::eDeviceGroupRenderPassBeginInfo;
    const void *                         pNext                 = {};
    uint32_t                             deviceMask            = {};
    uint32_t                             deviceRenderAreaCount = {};
    const VULKAN_HPP_NAMESPACE::Rect2D * pDeviceRenderAreas    = {};
  };
  static_assert( sizeof( DeviceGroupRenderPassBeginInfo ) == sizeof( VkDeviceGroupRenderPassBeginInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DeviceGroupRenderPassBeginInfo>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDeviceGroupRenderPassBeginInfo>
  {
    using Type = DeviceGroupRenderPassBeginInfo;
  };
  using DeviceGroupRenderPassBeginInfoKHR = DeviceGroupRenderPassBeginInfo;

  struct DeviceGroupSubmitInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eDeviceGroupSubmitInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      DeviceGroupSubmitInfo( uint32_t         waitSemaphoreCount_            = {},
                             const uint32_t * pWaitSemaphoreDeviceIndices_   = {},
                             uint32_t         commandBufferCount_            = {},
                             const uint32_t * pCommandBufferDeviceMasks_     = {},
                             uint32_t         signalSemaphoreCount_          = {},
                             const uint32_t * pSignalSemaphoreDeviceIndices_ = {} ) VULKAN_HPP_NOEXCEPT
      : waitSemaphoreCount( waitSemaphoreCount_ )
      , pWaitSemaphoreDeviceIndices( pWaitSemaphoreDeviceIndices_ )
      , commandBufferCount( commandBufferCount_ )
      , pCommandBufferDeviceMasks( pCommandBufferDeviceMasks_ )
      , signalSemaphoreCount( signalSemaphoreCount_ )
      , pSignalSemaphoreDeviceIndices( pSignalSemaphoreDeviceIndices_ )
    {}

    VULKAN_HPP_CONSTEXPR DeviceGroupSubmitInfo( DeviceGroupSubmitInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DeviceGroupSubmitInfo( VkDeviceGroupSubmitInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : DeviceGroupSubmitInfo( *reinterpret_cast<DeviceGroupSubmitInfo const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    DeviceGroupSubmitInfo(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const & waitSemaphoreDeviceIndices_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const & commandBufferDeviceMasks_     = {},
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const & signalSemaphoreDeviceIndices_ = {} )
      : waitSemaphoreCount( static_cast<uint32_t>( waitSemaphoreDeviceIndices_.size() ) )
      , pWaitSemaphoreDeviceIndices( waitSemaphoreDeviceIndices_.data() )
      , commandBufferCount( static_cast<uint32_t>( commandBufferDeviceMasks_.size() ) )
      , pCommandBufferDeviceMasks( commandBufferDeviceMasks_.data() )
      , signalSemaphoreCount( static_cast<uint32_t>( signalSemaphoreDeviceIndices_.size() ) )
      , pSignalSemaphoreDeviceIndices( signalSemaphoreDeviceIndices_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DeviceGroupSubmitInfo &
                            operator=( DeviceGroupSubmitInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DeviceGroupSubmitInfo & operator=( VkDeviceGroupSubmitInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DeviceGroupSubmitInfo const *>( &rhs );
      return *this;
    }

    DeviceGroupSubmitInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    DeviceGroupSubmitInfo & setWaitSemaphoreCount( uint32_t waitSemaphoreCount_ ) VULKAN_HPP_NOEXCEPT
    {
      waitSemaphoreCount = waitSemaphoreCount_;
      return *this;
    }

    DeviceGroupSubmitInfo &
      setPWaitSemaphoreDeviceIndices( const uint32_t * pWaitSemaphoreDeviceIndices_ ) VULKAN_HPP_NOEXCEPT
    {
      pWaitSemaphoreDeviceIndices = pWaitSemaphoreDeviceIndices_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    DeviceGroupSubmitInfo & setWaitSemaphoreDeviceIndices(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const & waitSemaphoreDeviceIndices_ )
      VULKAN_HPP_NOEXCEPT
    {
      waitSemaphoreCount          = static_cast<uint32_t>( waitSemaphoreDeviceIndices_.size() );
      pWaitSemaphoreDeviceIndices = waitSemaphoreDeviceIndices_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    DeviceGroupSubmitInfo & setCommandBufferCount( uint32_t commandBufferCount_ ) VULKAN_HPP_NOEXCEPT
    {
      commandBufferCount = commandBufferCount_;
      return *this;
    }

    DeviceGroupSubmitInfo &
      setPCommandBufferDeviceMasks( const uint32_t * pCommandBufferDeviceMasks_ ) VULKAN_HPP_NOEXCEPT
    {
      pCommandBufferDeviceMasks = pCommandBufferDeviceMasks_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    DeviceGroupSubmitInfo & setCommandBufferDeviceMasks(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const & commandBufferDeviceMasks_ )
      VULKAN_HPP_NOEXCEPT
    {
      commandBufferCount        = static_cast<uint32_t>( commandBufferDeviceMasks_.size() );
      pCommandBufferDeviceMasks = commandBufferDeviceMasks_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    DeviceGroupSubmitInfo & setSignalSemaphoreCount( uint32_t signalSemaphoreCount_ ) VULKAN_HPP_NOEXCEPT
    {
      signalSemaphoreCount = signalSemaphoreCount_;
      return *this;
    }

    DeviceGroupSubmitInfo &
      setPSignalSemaphoreDeviceIndices( const uint32_t * pSignalSemaphoreDeviceIndices_ ) VULKAN_HPP_NOEXCEPT
    {
      pSignalSemaphoreDeviceIndices = pSignalSemaphoreDeviceIndices_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    DeviceGroupSubmitInfo & setSignalSemaphoreDeviceIndices(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const & signalSemaphoreDeviceIndices_ )
      VULKAN_HPP_NOEXCEPT
    {
      signalSemaphoreCount          = static_cast<uint32_t>( signalSemaphoreDeviceIndices_.size() );
      pSignalSemaphoreDeviceIndices = signalSemaphoreDeviceIndices_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkDeviceGroupSubmitInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDeviceGroupSubmitInfo *>( this );
    }

    operator VkDeviceGroupSubmitInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDeviceGroupSubmitInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DeviceGroupSubmitInfo const & ) const = default;
#else
    bool operator==( DeviceGroupSubmitInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( waitSemaphoreCount == rhs.waitSemaphoreCount ) &&
             ( pWaitSemaphoreDeviceIndices == rhs.pWaitSemaphoreDeviceIndices ) &&
             ( commandBufferCount == rhs.commandBufferCount ) &&
             ( pCommandBufferDeviceMasks == rhs.pCommandBufferDeviceMasks ) &&
             ( signalSemaphoreCount == rhs.signalSemaphoreCount ) &&
             ( pSignalSemaphoreDeviceIndices == rhs.pSignalSemaphoreDeviceIndices );
    }

    bool operator!=( DeviceGroupSubmitInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType                         = StructureType::eDeviceGroupSubmitInfo;
    const void *                        pNext                         = {};
    uint32_t                            waitSemaphoreCount            = {};
    const uint32_t *                    pWaitSemaphoreDeviceIndices   = {};
    uint32_t                            commandBufferCount            = {};
    const uint32_t *                    pCommandBufferDeviceMasks     = {};
    uint32_t                            signalSemaphoreCount          = {};
    const uint32_t *                    pSignalSemaphoreDeviceIndices = {};
  };
  static_assert( sizeof( DeviceGroupSubmitInfo ) == sizeof( VkDeviceGroupSubmitInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DeviceGroupSubmitInfo>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDeviceGroupSubmitInfo>
  {
    using Type = DeviceGroupSubmitInfo;
  };
  using DeviceGroupSubmitInfoKHR = DeviceGroupSubmitInfo;

  struct DeviceGroupSwapchainCreateInfoKHR
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eDeviceGroupSwapchainCreateInfoKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR DeviceGroupSwapchainCreateInfoKHR(
      VULKAN_HPP_NAMESPACE::DeviceGroupPresentModeFlagsKHR modes_ = {} ) VULKAN_HPP_NOEXCEPT : modes( modes_ )
    {}

    VULKAN_HPP_CONSTEXPR
      DeviceGroupSwapchainCreateInfoKHR( DeviceGroupSwapchainCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DeviceGroupSwapchainCreateInfoKHR( VkDeviceGroupSwapchainCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : DeviceGroupSwapchainCreateInfoKHR( *reinterpret_cast<DeviceGroupSwapchainCreateInfoKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DeviceGroupSwapchainCreateInfoKHR &
                            operator=( DeviceGroupSwapchainCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DeviceGroupSwapchainCreateInfoKHR & operator=( VkDeviceGroupSwapchainCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DeviceGroupSwapchainCreateInfoKHR const *>( &rhs );
      return *this;
    }

    DeviceGroupSwapchainCreateInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    DeviceGroupSwapchainCreateInfoKHR &
      setModes( VULKAN_HPP_NAMESPACE::DeviceGroupPresentModeFlagsKHR modes_ ) VULKAN_HPP_NOEXCEPT
    {
      modes = modes_;
      return *this;
    }

    operator VkDeviceGroupSwapchainCreateInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDeviceGroupSwapchainCreateInfoKHR *>( this );
    }

    operator VkDeviceGroupSwapchainCreateInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDeviceGroupSwapchainCreateInfoKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DeviceGroupSwapchainCreateInfoKHR const & ) const = default;
#else
    bool operator==( DeviceGroupSwapchainCreateInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( modes == rhs.modes );
    }

    bool operator!=( DeviceGroupSwapchainCreateInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                  sType = StructureType::eDeviceGroupSwapchainCreateInfoKHR;
    const void *                                         pNext = {};
    VULKAN_HPP_NAMESPACE::DeviceGroupPresentModeFlagsKHR modes = {};
  };
  static_assert( sizeof( DeviceGroupSwapchainCreateInfoKHR ) == sizeof( VkDeviceGroupSwapchainCreateInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DeviceGroupSwapchainCreateInfoKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDeviceGroupSwapchainCreateInfoKHR>
  {
    using Type = DeviceGroupSwapchainCreateInfoKHR;
  };

  struct DeviceMemoryOpaqueCaptureAddressInfo
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eDeviceMemoryOpaqueCaptureAddressInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      DeviceMemoryOpaqueCaptureAddressInfo( VULKAN_HPP_NAMESPACE::DeviceMemory memory_ = {} ) VULKAN_HPP_NOEXCEPT
      : memory( memory_ )
    {}

    VULKAN_HPP_CONSTEXPR DeviceMemoryOpaqueCaptureAddressInfo( DeviceMemoryOpaqueCaptureAddressInfo const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    DeviceMemoryOpaqueCaptureAddressInfo( VkDeviceMemoryOpaqueCaptureAddressInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : DeviceMemoryOpaqueCaptureAddressInfo( *reinterpret_cast<DeviceMemoryOpaqueCaptureAddressInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DeviceMemoryOpaqueCaptureAddressInfo &
                            operator=( DeviceMemoryOpaqueCaptureAddressInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DeviceMemoryOpaqueCaptureAddressInfo &
      operator=( VkDeviceMemoryOpaqueCaptureAddressInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DeviceMemoryOpaqueCaptureAddressInfo const *>( &rhs );
      return *this;
    }

    DeviceMemoryOpaqueCaptureAddressInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    DeviceMemoryOpaqueCaptureAddressInfo & setMemory( VULKAN_HPP_NAMESPACE::DeviceMemory memory_ ) VULKAN_HPP_NOEXCEPT
    {
      memory = memory_;
      return *this;
    }

    operator VkDeviceMemoryOpaqueCaptureAddressInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDeviceMemoryOpaqueCaptureAddressInfo *>( this );
    }

    operator VkDeviceMemoryOpaqueCaptureAddressInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDeviceMemoryOpaqueCaptureAddressInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DeviceMemoryOpaqueCaptureAddressInfo const & ) const = default;
#else
    bool operator==( DeviceMemoryOpaqueCaptureAddressInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( memory == rhs.memory );
    }

    bool operator!=( DeviceMemoryOpaqueCaptureAddressInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType  = StructureType::eDeviceMemoryOpaqueCaptureAddressInfo;
    const void *                        pNext  = {};
    VULKAN_HPP_NAMESPACE::DeviceMemory  memory = {};
  };
  static_assert( sizeof( DeviceMemoryOpaqueCaptureAddressInfo ) == sizeof( VkDeviceMemoryOpaqueCaptureAddressInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DeviceMemoryOpaqueCaptureAddressInfo>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDeviceMemoryOpaqueCaptureAddressInfo>
  {
    using Type = DeviceMemoryOpaqueCaptureAddressInfo;
  };
  using DeviceMemoryOpaqueCaptureAddressInfoKHR = DeviceMemoryOpaqueCaptureAddressInfo;

  struct DeviceMemoryOverallocationCreateInfoAMD
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eDeviceMemoryOverallocationCreateInfoAMD;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR DeviceMemoryOverallocationCreateInfoAMD(
      VULKAN_HPP_NAMESPACE::MemoryOverallocationBehaviorAMD overallocationBehavior_ =
        VULKAN_HPP_NAMESPACE::MemoryOverallocationBehaviorAMD::eDefault ) VULKAN_HPP_NOEXCEPT
      : overallocationBehavior( overallocationBehavior_ )
    {}

    VULKAN_HPP_CONSTEXPR DeviceMemoryOverallocationCreateInfoAMD( DeviceMemoryOverallocationCreateInfoAMD const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    DeviceMemoryOverallocationCreateInfoAMD( VkDeviceMemoryOverallocationCreateInfoAMD const & rhs ) VULKAN_HPP_NOEXCEPT
      : DeviceMemoryOverallocationCreateInfoAMD(
          *reinterpret_cast<DeviceMemoryOverallocationCreateInfoAMD const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DeviceMemoryOverallocationCreateInfoAMD &
                            operator=( DeviceMemoryOverallocationCreateInfoAMD const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DeviceMemoryOverallocationCreateInfoAMD &
      operator=( VkDeviceMemoryOverallocationCreateInfoAMD const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DeviceMemoryOverallocationCreateInfoAMD const *>( &rhs );
      return *this;
    }

    DeviceMemoryOverallocationCreateInfoAMD & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    DeviceMemoryOverallocationCreateInfoAMD & setOverallocationBehavior(
      VULKAN_HPP_NAMESPACE::MemoryOverallocationBehaviorAMD overallocationBehavior_ ) VULKAN_HPP_NOEXCEPT
    {
      overallocationBehavior = overallocationBehavior_;
      return *this;
    }

    operator VkDeviceMemoryOverallocationCreateInfoAMD const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDeviceMemoryOverallocationCreateInfoAMD *>( this );
    }

    operator VkDeviceMemoryOverallocationCreateInfoAMD &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDeviceMemoryOverallocationCreateInfoAMD *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DeviceMemoryOverallocationCreateInfoAMD const & ) const = default;
#else
    bool operator==( DeviceMemoryOverallocationCreateInfoAMD const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( overallocationBehavior == rhs.overallocationBehavior );
    }

    bool operator!=( DeviceMemoryOverallocationCreateInfoAMD const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::eDeviceMemoryOverallocationCreateInfoAMD;
    const void *                        pNext = {};
    VULKAN_HPP_NAMESPACE::MemoryOverallocationBehaviorAMD overallocationBehavior =
      VULKAN_HPP_NAMESPACE::MemoryOverallocationBehaviorAMD::eDefault;
  };
  static_assert( sizeof( DeviceMemoryOverallocationCreateInfoAMD ) ==
                   sizeof( VkDeviceMemoryOverallocationCreateInfoAMD ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DeviceMemoryOverallocationCreateInfoAMD>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDeviceMemoryOverallocationCreateInfoAMD>
  {
    using Type = DeviceMemoryOverallocationCreateInfoAMD;
  };

  struct DeviceMemoryReportCallbackDataEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eDeviceMemoryReportCallbackDataEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR DeviceMemoryReportCallbackDataEXT(
      VULKAN_HPP_NAMESPACE::DeviceMemoryReportFlagsEXT     flags_ = {},
      VULKAN_HPP_NAMESPACE::DeviceMemoryReportEventTypeEXT type_ =
        VULKAN_HPP_NAMESPACE::DeviceMemoryReportEventTypeEXT::eAllocate,
      uint64_t                         memoryObjectId_ = {},
      VULKAN_HPP_NAMESPACE::DeviceSize size_           = {},
      VULKAN_HPP_NAMESPACE::ObjectType objectType_     = VULKAN_HPP_NAMESPACE::ObjectType::eUnknown,
      uint64_t                         objectHandle_   = {},
      uint32_t                         heapIndex_      = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , type( type_ )
      , memoryObjectId( memoryObjectId_ )
      , size( size_ )
      , objectType( objectType_ )
      , objectHandle( objectHandle_ )
      , heapIndex( heapIndex_ )
    {}

    VULKAN_HPP_CONSTEXPR
      DeviceMemoryReportCallbackDataEXT( DeviceMemoryReportCallbackDataEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DeviceMemoryReportCallbackDataEXT( VkDeviceMemoryReportCallbackDataEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : DeviceMemoryReportCallbackDataEXT( *reinterpret_cast<DeviceMemoryReportCallbackDataEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DeviceMemoryReportCallbackDataEXT &
                            operator=( DeviceMemoryReportCallbackDataEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DeviceMemoryReportCallbackDataEXT & operator=( VkDeviceMemoryReportCallbackDataEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DeviceMemoryReportCallbackDataEXT const *>( &rhs );
      return *this;
    }

    operator VkDeviceMemoryReportCallbackDataEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDeviceMemoryReportCallbackDataEXT *>( this );
    }

    operator VkDeviceMemoryReportCallbackDataEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDeviceMemoryReportCallbackDataEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DeviceMemoryReportCallbackDataEXT const & ) const = default;
#else
    bool operator==( DeviceMemoryReportCallbackDataEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) && ( type == rhs.type ) &&
             ( memoryObjectId == rhs.memoryObjectId ) && ( size == rhs.size ) && ( objectType == rhs.objectType ) &&
             ( objectHandle == rhs.objectHandle ) && ( heapIndex == rhs.heapIndex );
    }

    bool operator!=( DeviceMemoryReportCallbackDataEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                  sType = StructureType::eDeviceMemoryReportCallbackDataEXT;
    const void *                                         pNext = {};
    VULKAN_HPP_NAMESPACE::DeviceMemoryReportFlagsEXT     flags = {};
    VULKAN_HPP_NAMESPACE::DeviceMemoryReportEventTypeEXT type =
      VULKAN_HPP_NAMESPACE::DeviceMemoryReportEventTypeEXT::eAllocate;
    uint64_t                         memoryObjectId = {};
    VULKAN_HPP_NAMESPACE::DeviceSize size           = {};
    VULKAN_HPP_NAMESPACE::ObjectType objectType     = VULKAN_HPP_NAMESPACE::ObjectType::eUnknown;
    uint64_t                         objectHandle   = {};
    uint32_t                         heapIndex      = {};
  };
  static_assert( sizeof( DeviceMemoryReportCallbackDataEXT ) == sizeof( VkDeviceMemoryReportCallbackDataEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DeviceMemoryReportCallbackDataEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDeviceMemoryReportCallbackDataEXT>
  {
    using Type = DeviceMemoryReportCallbackDataEXT;
  };

  struct DevicePrivateDataCreateInfoEXT
  {
    static const bool                    allowDuplicate              = true;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eDevicePrivateDataCreateInfoEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      DevicePrivateDataCreateInfoEXT( uint32_t privateDataSlotRequestCount_ = {} ) VULKAN_HPP_NOEXCEPT
      : privateDataSlotRequestCount( privateDataSlotRequestCount_ )
    {}

    VULKAN_HPP_CONSTEXPR
      DevicePrivateDataCreateInfoEXT( DevicePrivateDataCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DevicePrivateDataCreateInfoEXT( VkDevicePrivateDataCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : DevicePrivateDataCreateInfoEXT( *reinterpret_cast<DevicePrivateDataCreateInfoEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DevicePrivateDataCreateInfoEXT &
                            operator=( DevicePrivateDataCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DevicePrivateDataCreateInfoEXT & operator=( VkDevicePrivateDataCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DevicePrivateDataCreateInfoEXT const *>( &rhs );
      return *this;
    }

    DevicePrivateDataCreateInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    DevicePrivateDataCreateInfoEXT &
      setPrivateDataSlotRequestCount( uint32_t privateDataSlotRequestCount_ ) VULKAN_HPP_NOEXCEPT
    {
      privateDataSlotRequestCount = privateDataSlotRequestCount_;
      return *this;
    }

    operator VkDevicePrivateDataCreateInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDevicePrivateDataCreateInfoEXT *>( this );
    }

    operator VkDevicePrivateDataCreateInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDevicePrivateDataCreateInfoEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DevicePrivateDataCreateInfoEXT const & ) const = default;
#else
    bool operator==( DevicePrivateDataCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( privateDataSlotRequestCount == rhs.privateDataSlotRequestCount );
    }

    bool operator!=( DevicePrivateDataCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType                       = StructureType::eDevicePrivateDataCreateInfoEXT;
    const void *                        pNext                       = {};
    uint32_t                            privateDataSlotRequestCount = {};
  };
  static_assert( sizeof( DevicePrivateDataCreateInfoEXT ) == sizeof( VkDevicePrivateDataCreateInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DevicePrivateDataCreateInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDevicePrivateDataCreateInfoEXT>
  {
    using Type = DevicePrivateDataCreateInfoEXT;
  };

  struct DeviceQueueGlobalPriorityCreateInfoEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eDeviceQueueGlobalPriorityCreateInfoEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      DeviceQueueGlobalPriorityCreateInfoEXT( VULKAN_HPP_NAMESPACE::QueueGlobalPriorityEXT globalPriority_ =
                                                VULKAN_HPP_NAMESPACE::QueueGlobalPriorityEXT::eLow ) VULKAN_HPP_NOEXCEPT
      : globalPriority( globalPriority_ )
    {}

    VULKAN_HPP_CONSTEXPR DeviceQueueGlobalPriorityCreateInfoEXT( DeviceQueueGlobalPriorityCreateInfoEXT const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    DeviceQueueGlobalPriorityCreateInfoEXT( VkDeviceQueueGlobalPriorityCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : DeviceQueueGlobalPriorityCreateInfoEXT(
          *reinterpret_cast<DeviceQueueGlobalPriorityCreateInfoEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DeviceQueueGlobalPriorityCreateInfoEXT &
                            operator=( DeviceQueueGlobalPriorityCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DeviceQueueGlobalPriorityCreateInfoEXT &
      operator=( VkDeviceQueueGlobalPriorityCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DeviceQueueGlobalPriorityCreateInfoEXT const *>( &rhs );
      return *this;
    }

    DeviceQueueGlobalPriorityCreateInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    DeviceQueueGlobalPriorityCreateInfoEXT &
      setGlobalPriority( VULKAN_HPP_NAMESPACE::QueueGlobalPriorityEXT globalPriority_ ) VULKAN_HPP_NOEXCEPT
    {
      globalPriority = globalPriority_;
      return *this;
    }

    operator VkDeviceQueueGlobalPriorityCreateInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDeviceQueueGlobalPriorityCreateInfoEXT *>( this );
    }

    operator VkDeviceQueueGlobalPriorityCreateInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDeviceQueueGlobalPriorityCreateInfoEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DeviceQueueGlobalPriorityCreateInfoEXT const & ) const = default;
#else
    bool operator==( DeviceQueueGlobalPriorityCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( globalPriority == rhs.globalPriority );
    }

    bool operator!=( DeviceQueueGlobalPriorityCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType          sType = StructureType::eDeviceQueueGlobalPriorityCreateInfoEXT;
    const void *                                 pNext = {};
    VULKAN_HPP_NAMESPACE::QueueGlobalPriorityEXT globalPriority = VULKAN_HPP_NAMESPACE::QueueGlobalPriorityEXT::eLow;
  };
  static_assert( sizeof( DeviceQueueGlobalPriorityCreateInfoEXT ) == sizeof( VkDeviceQueueGlobalPriorityCreateInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DeviceQueueGlobalPriorityCreateInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDeviceQueueGlobalPriorityCreateInfoEXT>
  {
    using Type = DeviceQueueGlobalPriorityCreateInfoEXT;
  };

  struct DeviceQueueInfo2
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eDeviceQueueInfo2;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR DeviceQueueInfo2( VULKAN_HPP_NAMESPACE::DeviceQueueCreateFlags flags_            = {},
                                           uint32_t                                     queueFamilyIndex_ = {},
                                           uint32_t queueIndex_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , queueFamilyIndex( queueFamilyIndex_ )
      , queueIndex( queueIndex_ )
    {}

    VULKAN_HPP_CONSTEXPR DeviceQueueInfo2( DeviceQueueInfo2 const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DeviceQueueInfo2( VkDeviceQueueInfo2 const & rhs ) VULKAN_HPP_NOEXCEPT
      : DeviceQueueInfo2( *reinterpret_cast<DeviceQueueInfo2 const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DeviceQueueInfo2 & operator=( DeviceQueueInfo2 const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DeviceQueueInfo2 & operator=( VkDeviceQueueInfo2 const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DeviceQueueInfo2 const *>( &rhs );
      return *this;
    }

    DeviceQueueInfo2 & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    DeviceQueueInfo2 & setFlags( VULKAN_HPP_NAMESPACE::DeviceQueueCreateFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    DeviceQueueInfo2 & setQueueFamilyIndex( uint32_t queueFamilyIndex_ ) VULKAN_HPP_NOEXCEPT
    {
      queueFamilyIndex = queueFamilyIndex_;
      return *this;
    }

    DeviceQueueInfo2 & setQueueIndex( uint32_t queueIndex_ ) VULKAN_HPP_NOEXCEPT
    {
      queueIndex = queueIndex_;
      return *this;
    }

    operator VkDeviceQueueInfo2 const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDeviceQueueInfo2 *>( this );
    }

    operator VkDeviceQueueInfo2 &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDeviceQueueInfo2 *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DeviceQueueInfo2 const & ) const = default;
#else
    bool operator==( DeviceQueueInfo2 const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( queueFamilyIndex == rhs.queueFamilyIndex ) && ( queueIndex == rhs.queueIndex );
    }

    bool operator!=( DeviceQueueInfo2 const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType          sType            = StructureType::eDeviceQueueInfo2;
    const void *                                 pNext            = {};
    VULKAN_HPP_NAMESPACE::DeviceQueueCreateFlags flags            = {};
    uint32_t                                     queueFamilyIndex = {};
    uint32_t                                     queueIndex       = {};
  };
  static_assert( sizeof( DeviceQueueInfo2 ) == sizeof( VkDeviceQueueInfo2 ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DeviceQueueInfo2>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDeviceQueueInfo2>
  {
    using Type = DeviceQueueInfo2;
  };

#if defined( VK_USE_PLATFORM_DIRECTFB_EXT )
  struct DirectFBSurfaceCreateInfoEXT
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eDirectfbSurfaceCreateInfoEXT;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR DirectFBSurfaceCreateInfoEXT( VULKAN_HPP_NAMESPACE::DirectFBSurfaceCreateFlagsEXT flags_ = {},
                                                       IDirectFB *                                         dfb_   = {},
                                                       IDirectFBSurface * surface_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , dfb( dfb_ )
      , surface( surface_ )
    {}

    VULKAN_HPP_CONSTEXPR
      DirectFBSurfaceCreateInfoEXT( DirectFBSurfaceCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DirectFBSurfaceCreateInfoEXT( VkDirectFBSurfaceCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : DirectFBSurfaceCreateInfoEXT( *reinterpret_cast<DirectFBSurfaceCreateInfoEXT const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DirectFBSurfaceCreateInfoEXT &
                            operator=( DirectFBSurfaceCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DirectFBSurfaceCreateInfoEXT & operator=( VkDirectFBSurfaceCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DirectFBSurfaceCreateInfoEXT const *>( &rhs );
      return *this;
    }

    DirectFBSurfaceCreateInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    DirectFBSurfaceCreateInfoEXT &
      setFlags( VULKAN_HPP_NAMESPACE::DirectFBSurfaceCreateFlagsEXT flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    DirectFBSurfaceCreateInfoEXT & setDfb( IDirectFB * dfb_ ) VULKAN_HPP_NOEXCEPT
    {
      dfb = dfb_;
      return *this;
    }

    DirectFBSurfaceCreateInfoEXT & setSurface( IDirectFBSurface * surface_ ) VULKAN_HPP_NOEXCEPT
    {
      surface = surface_;
      return *this;
    }

    operator VkDirectFBSurfaceCreateInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDirectFBSurfaceCreateInfoEXT *>( this );
    }

    operator VkDirectFBSurfaceCreateInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDirectFBSurfaceCreateInfoEXT *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DirectFBSurfaceCreateInfoEXT const & ) const = default;
#  else
    bool operator==( DirectFBSurfaceCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) && ( dfb == rhs.dfb ) &&
             ( surface == rhs.surface );
    }

    bool operator!=( DirectFBSurfaceCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                 sType   = StructureType::eDirectfbSurfaceCreateInfoEXT;
    const void *                                        pNext   = {};
    VULKAN_HPP_NAMESPACE::DirectFBSurfaceCreateFlagsEXT flags   = {};
    IDirectFB *                                         dfb     = {};
    IDirectFBSurface *                                  surface = {};
  };
  static_assert( sizeof( DirectFBSurfaceCreateInfoEXT ) == sizeof( VkDirectFBSurfaceCreateInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DirectFBSurfaceCreateInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDirectfbSurfaceCreateInfoEXT>
  {
    using Type = DirectFBSurfaceCreateInfoEXT;
  };
#endif /*VK_USE_PLATFORM_DIRECTFB_EXT*/

  struct DispatchIndirectCommand
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      DispatchIndirectCommand( uint32_t x_ = {}, uint32_t y_ = {}, uint32_t z_ = {} ) VULKAN_HPP_NOEXCEPT
      : x( x_ )
      , y( y_ )
      , z( z_ )
    {}

    VULKAN_HPP_CONSTEXPR DispatchIndirectCommand( DispatchIndirectCommand const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DispatchIndirectCommand( VkDispatchIndirectCommand const & rhs ) VULKAN_HPP_NOEXCEPT
      : DispatchIndirectCommand( *reinterpret_cast<DispatchIndirectCommand const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DispatchIndirectCommand &
                            operator=( DispatchIndirectCommand const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DispatchIndirectCommand & operator=( VkDispatchIndirectCommand const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DispatchIndirectCommand const *>( &rhs );
      return *this;
    }

    DispatchIndirectCommand & setX( uint32_t x_ ) VULKAN_HPP_NOEXCEPT
    {
      x = x_;
      return *this;
    }

    DispatchIndirectCommand & setY( uint32_t y_ ) VULKAN_HPP_NOEXCEPT
    {
      y = y_;
      return *this;
    }

    DispatchIndirectCommand & setZ( uint32_t z_ ) VULKAN_HPP_NOEXCEPT
    {
      z = z_;
      return *this;
    }

    operator VkDispatchIndirectCommand const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDispatchIndirectCommand *>( this );
    }

    operator VkDispatchIndirectCommand &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDispatchIndirectCommand *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DispatchIndirectCommand const & ) const = default;
#else
    bool operator==( DispatchIndirectCommand const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( x == rhs.x ) && ( y == rhs.y ) && ( z == rhs.z );
    }

    bool operator!=( DispatchIndirectCommand const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    uint32_t x = {};
    uint32_t y = {};
    uint32_t z = {};
  };
  static_assert( sizeof( DispatchIndirectCommand ) == sizeof( VkDispatchIndirectCommand ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DispatchIndirectCommand>::value, "struct wrapper is not a standard layout!" );

  struct DisplayEventInfoEXT
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eDisplayEventInfoEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      DisplayEventInfoEXT( VULKAN_HPP_NAMESPACE::DisplayEventTypeEXT displayEvent_ =
                             VULKAN_HPP_NAMESPACE::DisplayEventTypeEXT::eFirstPixelOut ) VULKAN_HPP_NOEXCEPT
      : displayEvent( displayEvent_ )
    {}

    VULKAN_HPP_CONSTEXPR DisplayEventInfoEXT( DisplayEventInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DisplayEventInfoEXT( VkDisplayEventInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : DisplayEventInfoEXT( *reinterpret_cast<DisplayEventInfoEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DisplayEventInfoEXT &
                            operator=( DisplayEventInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DisplayEventInfoEXT & operator=( VkDisplayEventInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DisplayEventInfoEXT const *>( &rhs );
      return *this;
    }

    DisplayEventInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    DisplayEventInfoEXT & setDisplayEvent( VULKAN_HPP_NAMESPACE::DisplayEventTypeEXT displayEvent_ ) VULKAN_HPP_NOEXCEPT
    {
      displayEvent = displayEvent_;
      return *this;
    }

    operator VkDisplayEventInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDisplayEventInfoEXT *>( this );
    }

    operator VkDisplayEventInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDisplayEventInfoEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DisplayEventInfoEXT const & ) const = default;
#else
    bool operator==( DisplayEventInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( displayEvent == rhs.displayEvent );
    }

    bool operator!=( DisplayEventInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType       sType        = StructureType::eDisplayEventInfoEXT;
    const void *                              pNext        = {};
    VULKAN_HPP_NAMESPACE::DisplayEventTypeEXT displayEvent = VULKAN_HPP_NAMESPACE::DisplayEventTypeEXT::eFirstPixelOut;
  };
  static_assert( sizeof( DisplayEventInfoEXT ) == sizeof( VkDisplayEventInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DisplayEventInfoEXT>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDisplayEventInfoEXT>
  {
    using Type = DisplayEventInfoEXT;
  };

  struct DisplayModeParametersKHR
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR DisplayModeParametersKHR( VULKAN_HPP_NAMESPACE::Extent2D visibleRegion_ = {},
                                                   uint32_t refreshRate_ = {} ) VULKAN_HPP_NOEXCEPT
      : visibleRegion( visibleRegion_ )
      , refreshRate( refreshRate_ )
    {}

    VULKAN_HPP_CONSTEXPR DisplayModeParametersKHR( DisplayModeParametersKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DisplayModeParametersKHR( VkDisplayModeParametersKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : DisplayModeParametersKHR( *reinterpret_cast<DisplayModeParametersKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DisplayModeParametersKHR &
                            operator=( DisplayModeParametersKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DisplayModeParametersKHR & operator=( VkDisplayModeParametersKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DisplayModeParametersKHR const *>( &rhs );
      return *this;
    }

    DisplayModeParametersKHR &
      setVisibleRegion( VULKAN_HPP_NAMESPACE::Extent2D const & visibleRegion_ ) VULKAN_HPP_NOEXCEPT
    {
      visibleRegion = visibleRegion_;
      return *this;
    }

    DisplayModeParametersKHR & setRefreshRate( uint32_t refreshRate_ ) VULKAN_HPP_NOEXCEPT
    {
      refreshRate = refreshRate_;
      return *this;
    }

    operator VkDisplayModeParametersKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDisplayModeParametersKHR *>( this );
    }

    operator VkDisplayModeParametersKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDisplayModeParametersKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DisplayModeParametersKHR const & ) const = default;
#else
    bool operator==( DisplayModeParametersKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( visibleRegion == rhs.visibleRegion ) && ( refreshRate == rhs.refreshRate );
    }

    bool operator!=( DisplayModeParametersKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::Extent2D visibleRegion = {};
    uint32_t                       refreshRate   = {};
  };
  static_assert( sizeof( DisplayModeParametersKHR ) == sizeof( VkDisplayModeParametersKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DisplayModeParametersKHR>::value, "struct wrapper is not a standard layout!" );

  struct DisplayModeCreateInfoKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eDisplayModeCreateInfoKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      DisplayModeCreateInfoKHR( VULKAN_HPP_NAMESPACE::DisplayModeCreateFlagsKHR flags_      = {},
                                VULKAN_HPP_NAMESPACE::DisplayModeParametersKHR  parameters_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , parameters( parameters_ )
    {}

    VULKAN_HPP_CONSTEXPR DisplayModeCreateInfoKHR( DisplayModeCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DisplayModeCreateInfoKHR( VkDisplayModeCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : DisplayModeCreateInfoKHR( *reinterpret_cast<DisplayModeCreateInfoKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DisplayModeCreateInfoKHR &
                            operator=( DisplayModeCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DisplayModeCreateInfoKHR & operator=( VkDisplayModeCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DisplayModeCreateInfoKHR const *>( &rhs );
      return *this;
    }

    DisplayModeCreateInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    DisplayModeCreateInfoKHR & setFlags( VULKAN_HPP_NAMESPACE::DisplayModeCreateFlagsKHR flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    DisplayModeCreateInfoKHR &
      setParameters( VULKAN_HPP_NAMESPACE::DisplayModeParametersKHR const & parameters_ ) VULKAN_HPP_NOEXCEPT
    {
      parameters = parameters_;
      return *this;
    }

    operator VkDisplayModeCreateInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDisplayModeCreateInfoKHR *>( this );
    }

    operator VkDisplayModeCreateInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDisplayModeCreateInfoKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DisplayModeCreateInfoKHR const & ) const = default;
#else
    bool operator==( DisplayModeCreateInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( parameters == rhs.parameters );
    }

    bool operator!=( DisplayModeCreateInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType             sType      = StructureType::eDisplayModeCreateInfoKHR;
    const void *                                    pNext      = {};
    VULKAN_HPP_NAMESPACE::DisplayModeCreateFlagsKHR flags      = {};
    VULKAN_HPP_NAMESPACE::DisplayModeParametersKHR  parameters = {};
  };
  static_assert( sizeof( DisplayModeCreateInfoKHR ) == sizeof( VkDisplayModeCreateInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DisplayModeCreateInfoKHR>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDisplayModeCreateInfoKHR>
  {
    using Type = DisplayModeCreateInfoKHR;
  };

  struct DisplayModePropertiesKHR
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      DisplayModePropertiesKHR( VULKAN_HPP_NAMESPACE::DisplayModeKHR           displayMode_ = {},
                                VULKAN_HPP_NAMESPACE::DisplayModeParametersKHR parameters_  = {} ) VULKAN_HPP_NOEXCEPT
      : displayMode( displayMode_ )
      , parameters( parameters_ )
    {}

    VULKAN_HPP_CONSTEXPR DisplayModePropertiesKHR( DisplayModePropertiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DisplayModePropertiesKHR( VkDisplayModePropertiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : DisplayModePropertiesKHR( *reinterpret_cast<DisplayModePropertiesKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DisplayModePropertiesKHR &
                            operator=( DisplayModePropertiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DisplayModePropertiesKHR & operator=( VkDisplayModePropertiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DisplayModePropertiesKHR const *>( &rhs );
      return *this;
    }

    operator VkDisplayModePropertiesKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDisplayModePropertiesKHR *>( this );
    }

    operator VkDisplayModePropertiesKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDisplayModePropertiesKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DisplayModePropertiesKHR const & ) const = default;
#else
    bool operator==( DisplayModePropertiesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( displayMode == rhs.displayMode ) && ( parameters == rhs.parameters );
    }

    bool operator!=( DisplayModePropertiesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::DisplayModeKHR           displayMode = {};
    VULKAN_HPP_NAMESPACE::DisplayModeParametersKHR parameters  = {};
  };
  static_assert( sizeof( DisplayModePropertiesKHR ) == sizeof( VkDisplayModePropertiesKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DisplayModePropertiesKHR>::value, "struct wrapper is not a standard layout!" );

  struct DisplayModeProperties2KHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eDisplayModeProperties2KHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR DisplayModeProperties2KHR(
      VULKAN_HPP_NAMESPACE::DisplayModePropertiesKHR displayModeProperties_ = {} ) VULKAN_HPP_NOEXCEPT
      : displayModeProperties( displayModeProperties_ )
    {}

    VULKAN_HPP_CONSTEXPR
      DisplayModeProperties2KHR( DisplayModeProperties2KHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DisplayModeProperties2KHR( VkDisplayModeProperties2KHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : DisplayModeProperties2KHR( *reinterpret_cast<DisplayModeProperties2KHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DisplayModeProperties2KHR &
                            operator=( DisplayModeProperties2KHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DisplayModeProperties2KHR & operator=( VkDisplayModeProperties2KHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DisplayModeProperties2KHR const *>( &rhs );
      return *this;
    }

    operator VkDisplayModeProperties2KHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDisplayModeProperties2KHR *>( this );
    }

    operator VkDisplayModeProperties2KHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDisplayModeProperties2KHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DisplayModeProperties2KHR const & ) const = default;
#else
    bool operator==( DisplayModeProperties2KHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( displayModeProperties == rhs.displayModeProperties );
    }

    bool operator!=( DisplayModeProperties2KHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType            sType                 = StructureType::eDisplayModeProperties2KHR;
    void *                                         pNext                 = {};
    VULKAN_HPP_NAMESPACE::DisplayModePropertiesKHR displayModeProperties = {};
  };
  static_assert( sizeof( DisplayModeProperties2KHR ) == sizeof( VkDisplayModeProperties2KHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DisplayModeProperties2KHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDisplayModeProperties2KHR>
  {
    using Type = DisplayModeProperties2KHR;
  };

  struct DisplayNativeHdrSurfaceCapabilitiesAMD
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eDisplayNativeHdrSurfaceCapabilitiesAMD;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR DisplayNativeHdrSurfaceCapabilitiesAMD(
      VULKAN_HPP_NAMESPACE::Bool32 localDimmingSupport_ = {} ) VULKAN_HPP_NOEXCEPT
      : localDimmingSupport( localDimmingSupport_ )
    {}

    VULKAN_HPP_CONSTEXPR DisplayNativeHdrSurfaceCapabilitiesAMD( DisplayNativeHdrSurfaceCapabilitiesAMD const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    DisplayNativeHdrSurfaceCapabilitiesAMD( VkDisplayNativeHdrSurfaceCapabilitiesAMD const & rhs ) VULKAN_HPP_NOEXCEPT
      : DisplayNativeHdrSurfaceCapabilitiesAMD(
          *reinterpret_cast<DisplayNativeHdrSurfaceCapabilitiesAMD const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DisplayNativeHdrSurfaceCapabilitiesAMD &
                            operator=( DisplayNativeHdrSurfaceCapabilitiesAMD const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DisplayNativeHdrSurfaceCapabilitiesAMD &
      operator=( VkDisplayNativeHdrSurfaceCapabilitiesAMD const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DisplayNativeHdrSurfaceCapabilitiesAMD const *>( &rhs );
      return *this;
    }

    operator VkDisplayNativeHdrSurfaceCapabilitiesAMD const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDisplayNativeHdrSurfaceCapabilitiesAMD *>( this );
    }

    operator VkDisplayNativeHdrSurfaceCapabilitiesAMD &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDisplayNativeHdrSurfaceCapabilitiesAMD *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DisplayNativeHdrSurfaceCapabilitiesAMD const & ) const = default;
#else
    bool operator==( DisplayNativeHdrSurfaceCapabilitiesAMD const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( localDimmingSupport == rhs.localDimmingSupport );
    }

    bool operator!=( DisplayNativeHdrSurfaceCapabilitiesAMD const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType               = StructureType::eDisplayNativeHdrSurfaceCapabilitiesAMD;
    void *                              pNext               = {};
    VULKAN_HPP_NAMESPACE::Bool32        localDimmingSupport = {};
  };
  static_assert( sizeof( DisplayNativeHdrSurfaceCapabilitiesAMD ) == sizeof( VkDisplayNativeHdrSurfaceCapabilitiesAMD ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DisplayNativeHdrSurfaceCapabilitiesAMD>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDisplayNativeHdrSurfaceCapabilitiesAMD>
  {
    using Type = DisplayNativeHdrSurfaceCapabilitiesAMD;
  };

  struct DisplayPlaneCapabilitiesKHR
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      DisplayPlaneCapabilitiesKHR( VULKAN_HPP_NAMESPACE::DisplayPlaneAlphaFlagsKHR supportedAlpha_ = {},
                                   VULKAN_HPP_NAMESPACE::Offset2D                  minSrcPosition_ = {},
                                   VULKAN_HPP_NAMESPACE::Offset2D                  maxSrcPosition_ = {},
                                   VULKAN_HPP_NAMESPACE::Extent2D                  minSrcExtent_   = {},
                                   VULKAN_HPP_NAMESPACE::Extent2D                  maxSrcExtent_   = {},
                                   VULKAN_HPP_NAMESPACE::Offset2D                  minDstPosition_ = {},
                                   VULKAN_HPP_NAMESPACE::Offset2D                  maxDstPosition_ = {},
                                   VULKAN_HPP_NAMESPACE::Extent2D                  minDstExtent_   = {},
                                   VULKAN_HPP_NAMESPACE::Extent2D maxDstExtent_ = {} ) VULKAN_HPP_NOEXCEPT
      : supportedAlpha( supportedAlpha_ )
      , minSrcPosition( minSrcPosition_ )
      , maxSrcPosition( maxSrcPosition_ )
      , minSrcExtent( minSrcExtent_ )
      , maxSrcExtent( maxSrcExtent_ )
      , minDstPosition( minDstPosition_ )
      , maxDstPosition( maxDstPosition_ )
      , minDstExtent( minDstExtent_ )
      , maxDstExtent( maxDstExtent_ )
    {}

    VULKAN_HPP_CONSTEXPR
      DisplayPlaneCapabilitiesKHR( DisplayPlaneCapabilitiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DisplayPlaneCapabilitiesKHR( VkDisplayPlaneCapabilitiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : DisplayPlaneCapabilitiesKHR( *reinterpret_cast<DisplayPlaneCapabilitiesKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DisplayPlaneCapabilitiesKHR &
                            operator=( DisplayPlaneCapabilitiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DisplayPlaneCapabilitiesKHR & operator=( VkDisplayPlaneCapabilitiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DisplayPlaneCapabilitiesKHR const *>( &rhs );
      return *this;
    }

    operator VkDisplayPlaneCapabilitiesKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDisplayPlaneCapabilitiesKHR *>( this );
    }

    operator VkDisplayPlaneCapabilitiesKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDisplayPlaneCapabilitiesKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DisplayPlaneCapabilitiesKHR const & ) const = default;
#else
    bool operator==( DisplayPlaneCapabilitiesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( supportedAlpha == rhs.supportedAlpha ) && ( minSrcPosition == rhs.minSrcPosition ) &&
             ( maxSrcPosition == rhs.maxSrcPosition ) && ( minSrcExtent == rhs.minSrcExtent ) &&
             ( maxSrcExtent == rhs.maxSrcExtent ) && ( minDstPosition == rhs.minDstPosition ) &&
             ( maxDstPosition == rhs.maxDstPosition ) && ( minDstExtent == rhs.minDstExtent ) &&
             ( maxDstExtent == rhs.maxDstExtent );
    }

    bool operator!=( DisplayPlaneCapabilitiesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::DisplayPlaneAlphaFlagsKHR supportedAlpha = {};
    VULKAN_HPP_NAMESPACE::Offset2D                  minSrcPosition = {};
    VULKAN_HPP_NAMESPACE::Offset2D                  maxSrcPosition = {};
    VULKAN_HPP_NAMESPACE::Extent2D                  minSrcExtent   = {};
    VULKAN_HPP_NAMESPACE::Extent2D                  maxSrcExtent   = {};
    VULKAN_HPP_NAMESPACE::Offset2D                  minDstPosition = {};
    VULKAN_HPP_NAMESPACE::Offset2D                  maxDstPosition = {};
    VULKAN_HPP_NAMESPACE::Extent2D                  minDstExtent   = {};
    VULKAN_HPP_NAMESPACE::Extent2D                  maxDstExtent   = {};
  };
  static_assert( sizeof( DisplayPlaneCapabilitiesKHR ) == sizeof( VkDisplayPlaneCapabilitiesKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DisplayPlaneCapabilitiesKHR>::value,
                 "struct wrapper is not a standard layout!" );

  struct DisplayPlaneCapabilities2KHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eDisplayPlaneCapabilities2KHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR DisplayPlaneCapabilities2KHR(
      VULKAN_HPP_NAMESPACE::DisplayPlaneCapabilitiesKHR capabilities_ = {} ) VULKAN_HPP_NOEXCEPT
      : capabilities( capabilities_ )
    {}

    VULKAN_HPP_CONSTEXPR
      DisplayPlaneCapabilities2KHR( DisplayPlaneCapabilities2KHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DisplayPlaneCapabilities2KHR( VkDisplayPlaneCapabilities2KHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : DisplayPlaneCapabilities2KHR( *reinterpret_cast<DisplayPlaneCapabilities2KHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DisplayPlaneCapabilities2KHR &
                            operator=( DisplayPlaneCapabilities2KHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DisplayPlaneCapabilities2KHR & operator=( VkDisplayPlaneCapabilities2KHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DisplayPlaneCapabilities2KHR const *>( &rhs );
      return *this;
    }

    operator VkDisplayPlaneCapabilities2KHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDisplayPlaneCapabilities2KHR *>( this );
    }

    operator VkDisplayPlaneCapabilities2KHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDisplayPlaneCapabilities2KHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DisplayPlaneCapabilities2KHR const & ) const = default;
#else
    bool operator==( DisplayPlaneCapabilities2KHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( capabilities == rhs.capabilities );
    }

    bool operator!=( DisplayPlaneCapabilities2KHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType               sType        = StructureType::eDisplayPlaneCapabilities2KHR;
    void *                                            pNext        = {};
    VULKAN_HPP_NAMESPACE::DisplayPlaneCapabilitiesKHR capabilities = {};
  };
  static_assert( sizeof( DisplayPlaneCapabilities2KHR ) == sizeof( VkDisplayPlaneCapabilities2KHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DisplayPlaneCapabilities2KHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDisplayPlaneCapabilities2KHR>
  {
    using Type = DisplayPlaneCapabilities2KHR;
  };

  struct DisplayPlaneInfo2KHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eDisplayPlaneInfo2KHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR DisplayPlaneInfo2KHR( VULKAN_HPP_NAMESPACE::DisplayModeKHR mode_ = {},
                                               uint32_t planeIndex_                       = {} ) VULKAN_HPP_NOEXCEPT
      : mode( mode_ )
      , planeIndex( planeIndex_ )
    {}

    VULKAN_HPP_CONSTEXPR DisplayPlaneInfo2KHR( DisplayPlaneInfo2KHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DisplayPlaneInfo2KHR( VkDisplayPlaneInfo2KHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : DisplayPlaneInfo2KHR( *reinterpret_cast<DisplayPlaneInfo2KHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DisplayPlaneInfo2KHR &
                            operator=( DisplayPlaneInfo2KHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DisplayPlaneInfo2KHR & operator=( VkDisplayPlaneInfo2KHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DisplayPlaneInfo2KHR const *>( &rhs );
      return *this;
    }

    DisplayPlaneInfo2KHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    DisplayPlaneInfo2KHR & setMode( VULKAN_HPP_NAMESPACE::DisplayModeKHR mode_ ) VULKAN_HPP_NOEXCEPT
    {
      mode = mode_;
      return *this;
    }

    DisplayPlaneInfo2KHR & setPlaneIndex( uint32_t planeIndex_ ) VULKAN_HPP_NOEXCEPT
    {
      planeIndex = planeIndex_;
      return *this;
    }

    operator VkDisplayPlaneInfo2KHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDisplayPlaneInfo2KHR *>( this );
    }

    operator VkDisplayPlaneInfo2KHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDisplayPlaneInfo2KHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DisplayPlaneInfo2KHR const & ) const = default;
#else
    bool operator==( DisplayPlaneInfo2KHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( mode == rhs.mode ) &&
             ( planeIndex == rhs.planeIndex );
    }

    bool operator!=( DisplayPlaneInfo2KHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType  sType      = StructureType::eDisplayPlaneInfo2KHR;
    const void *                         pNext      = {};
    VULKAN_HPP_NAMESPACE::DisplayModeKHR mode       = {};
    uint32_t                             planeIndex = {};
  };
  static_assert( sizeof( DisplayPlaneInfo2KHR ) == sizeof( VkDisplayPlaneInfo2KHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DisplayPlaneInfo2KHR>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDisplayPlaneInfo2KHR>
  {
    using Type = DisplayPlaneInfo2KHR;
  };

  struct DisplayPlanePropertiesKHR
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR DisplayPlanePropertiesKHR( VULKAN_HPP_NAMESPACE::DisplayKHR currentDisplay_ = {},
                                                    uint32_t currentStackIndex_ = {} ) VULKAN_HPP_NOEXCEPT
      : currentDisplay( currentDisplay_ )
      , currentStackIndex( currentStackIndex_ )
    {}

    VULKAN_HPP_CONSTEXPR
      DisplayPlanePropertiesKHR( DisplayPlanePropertiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DisplayPlanePropertiesKHR( VkDisplayPlanePropertiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : DisplayPlanePropertiesKHR( *reinterpret_cast<DisplayPlanePropertiesKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DisplayPlanePropertiesKHR &
                            operator=( DisplayPlanePropertiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DisplayPlanePropertiesKHR & operator=( VkDisplayPlanePropertiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DisplayPlanePropertiesKHR const *>( &rhs );
      return *this;
    }

    operator VkDisplayPlanePropertiesKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDisplayPlanePropertiesKHR *>( this );
    }

    operator VkDisplayPlanePropertiesKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDisplayPlanePropertiesKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DisplayPlanePropertiesKHR const & ) const = default;
#else
    bool operator==( DisplayPlanePropertiesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( currentDisplay == rhs.currentDisplay ) && ( currentStackIndex == rhs.currentStackIndex );
    }

    bool operator!=( DisplayPlanePropertiesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::DisplayKHR currentDisplay    = {};
    uint32_t                         currentStackIndex = {};
  };
  static_assert( sizeof( DisplayPlanePropertiesKHR ) == sizeof( VkDisplayPlanePropertiesKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DisplayPlanePropertiesKHR>::value,
                 "struct wrapper is not a standard layout!" );

  struct DisplayPlaneProperties2KHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eDisplayPlaneProperties2KHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR DisplayPlaneProperties2KHR(
      VULKAN_HPP_NAMESPACE::DisplayPlanePropertiesKHR displayPlaneProperties_ = {} ) VULKAN_HPP_NOEXCEPT
      : displayPlaneProperties( displayPlaneProperties_ )
    {}

    VULKAN_HPP_CONSTEXPR
      DisplayPlaneProperties2KHR( DisplayPlaneProperties2KHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DisplayPlaneProperties2KHR( VkDisplayPlaneProperties2KHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : DisplayPlaneProperties2KHR( *reinterpret_cast<DisplayPlaneProperties2KHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DisplayPlaneProperties2KHR &
                            operator=( DisplayPlaneProperties2KHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DisplayPlaneProperties2KHR & operator=( VkDisplayPlaneProperties2KHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DisplayPlaneProperties2KHR const *>( &rhs );
      return *this;
    }

    operator VkDisplayPlaneProperties2KHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDisplayPlaneProperties2KHR *>( this );
    }

    operator VkDisplayPlaneProperties2KHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDisplayPlaneProperties2KHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DisplayPlaneProperties2KHR const & ) const = default;
#else
    bool operator==( DisplayPlaneProperties2KHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( displayPlaneProperties == rhs.displayPlaneProperties );
    }

    bool operator!=( DisplayPlaneProperties2KHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType             sType                  = StructureType::eDisplayPlaneProperties2KHR;
    void *                                          pNext                  = {};
    VULKAN_HPP_NAMESPACE::DisplayPlanePropertiesKHR displayPlaneProperties = {};
  };
  static_assert( sizeof( DisplayPlaneProperties2KHR ) == sizeof( VkDisplayPlaneProperties2KHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DisplayPlaneProperties2KHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDisplayPlaneProperties2KHR>
  {
    using Type = DisplayPlaneProperties2KHR;
  };

  struct DisplayPowerInfoEXT
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eDisplayPowerInfoEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR DisplayPowerInfoEXT( VULKAN_HPP_NAMESPACE::DisplayPowerStateEXT powerState_ =
                                                VULKAN_HPP_NAMESPACE::DisplayPowerStateEXT::eOff ) VULKAN_HPP_NOEXCEPT
      : powerState( powerState_ )
    {}

    VULKAN_HPP_CONSTEXPR DisplayPowerInfoEXT( DisplayPowerInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DisplayPowerInfoEXT( VkDisplayPowerInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : DisplayPowerInfoEXT( *reinterpret_cast<DisplayPowerInfoEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DisplayPowerInfoEXT &
                            operator=( DisplayPowerInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DisplayPowerInfoEXT & operator=( VkDisplayPowerInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DisplayPowerInfoEXT const *>( &rhs );
      return *this;
    }

    DisplayPowerInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    DisplayPowerInfoEXT & setPowerState( VULKAN_HPP_NAMESPACE::DisplayPowerStateEXT powerState_ ) VULKAN_HPP_NOEXCEPT
    {
      powerState = powerState_;
      return *this;
    }

    operator VkDisplayPowerInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDisplayPowerInfoEXT *>( this );
    }

    operator VkDisplayPowerInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDisplayPowerInfoEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DisplayPowerInfoEXT const & ) const = default;
#else
    bool operator==( DisplayPowerInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( powerState == rhs.powerState );
    }

    bool operator!=( DisplayPowerInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType        sType      = StructureType::eDisplayPowerInfoEXT;
    const void *                               pNext      = {};
    VULKAN_HPP_NAMESPACE::DisplayPowerStateEXT powerState = VULKAN_HPP_NAMESPACE::DisplayPowerStateEXT::eOff;
  };
  static_assert( sizeof( DisplayPowerInfoEXT ) == sizeof( VkDisplayPowerInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DisplayPowerInfoEXT>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDisplayPowerInfoEXT>
  {
    using Type = DisplayPowerInfoEXT;
  };

  struct DisplayPresentInfoKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eDisplayPresentInfoKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR DisplayPresentInfoKHR( VULKAN_HPP_NAMESPACE::Rect2D srcRect_    = {},
                                                VULKAN_HPP_NAMESPACE::Rect2D dstRect_    = {},
                                                VULKAN_HPP_NAMESPACE::Bool32 persistent_ = {} ) VULKAN_HPP_NOEXCEPT
      : srcRect( srcRect_ )
      , dstRect( dstRect_ )
      , persistent( persistent_ )
    {}

    VULKAN_HPP_CONSTEXPR DisplayPresentInfoKHR( DisplayPresentInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DisplayPresentInfoKHR( VkDisplayPresentInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : DisplayPresentInfoKHR( *reinterpret_cast<DisplayPresentInfoKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DisplayPresentInfoKHR &
                            operator=( DisplayPresentInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DisplayPresentInfoKHR & operator=( VkDisplayPresentInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DisplayPresentInfoKHR const *>( &rhs );
      return *this;
    }

    DisplayPresentInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    DisplayPresentInfoKHR & setSrcRect( VULKAN_HPP_NAMESPACE::Rect2D const & srcRect_ ) VULKAN_HPP_NOEXCEPT
    {
      srcRect = srcRect_;
      return *this;
    }

    DisplayPresentInfoKHR & setDstRect( VULKAN_HPP_NAMESPACE::Rect2D const & dstRect_ ) VULKAN_HPP_NOEXCEPT
    {
      dstRect = dstRect_;
      return *this;
    }

    DisplayPresentInfoKHR & setPersistent( VULKAN_HPP_NAMESPACE::Bool32 persistent_ ) VULKAN_HPP_NOEXCEPT
    {
      persistent = persistent_;
      return *this;
    }

    operator VkDisplayPresentInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDisplayPresentInfoKHR *>( this );
    }

    operator VkDisplayPresentInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDisplayPresentInfoKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DisplayPresentInfoKHR const & ) const = default;
#else
    bool operator==( DisplayPresentInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( srcRect == rhs.srcRect ) &&
             ( dstRect == rhs.dstRect ) && ( persistent == rhs.persistent );
    }

    bool operator!=( DisplayPresentInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType      = StructureType::eDisplayPresentInfoKHR;
    const void *                        pNext      = {};
    VULKAN_HPP_NAMESPACE::Rect2D        srcRect    = {};
    VULKAN_HPP_NAMESPACE::Rect2D        dstRect    = {};
    VULKAN_HPP_NAMESPACE::Bool32        persistent = {};
  };
  static_assert( sizeof( DisplayPresentInfoKHR ) == sizeof( VkDisplayPresentInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DisplayPresentInfoKHR>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDisplayPresentInfoKHR>
  {
    using Type = DisplayPresentInfoKHR;
  };

  struct DisplayPropertiesKHR
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      DisplayPropertiesKHR( VULKAN_HPP_NAMESPACE::DisplayKHR               display_              = {},
                            const char *                                   displayName_          = {},
                            VULKAN_HPP_NAMESPACE::Extent2D                 physicalDimensions_   = {},
                            VULKAN_HPP_NAMESPACE::Extent2D                 physicalResolution_   = {},
                            VULKAN_HPP_NAMESPACE::SurfaceTransformFlagsKHR supportedTransforms_  = {},
                            VULKAN_HPP_NAMESPACE::Bool32                   planeReorderPossible_ = {},
                            VULKAN_HPP_NAMESPACE::Bool32                   persistentContent_ = {} ) VULKAN_HPP_NOEXCEPT
      : display( display_ )
      , displayName( displayName_ )
      , physicalDimensions( physicalDimensions_ )
      , physicalResolution( physicalResolution_ )
      , supportedTransforms( supportedTransforms_ )
      , planeReorderPossible( planeReorderPossible_ )
      , persistentContent( persistentContent_ )
    {}

    VULKAN_HPP_CONSTEXPR DisplayPropertiesKHR( DisplayPropertiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DisplayPropertiesKHR( VkDisplayPropertiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : DisplayPropertiesKHR( *reinterpret_cast<DisplayPropertiesKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DisplayPropertiesKHR &
                            operator=( DisplayPropertiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DisplayPropertiesKHR & operator=( VkDisplayPropertiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DisplayPropertiesKHR const *>( &rhs );
      return *this;
    }

    operator VkDisplayPropertiesKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDisplayPropertiesKHR *>( this );
    }

    operator VkDisplayPropertiesKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDisplayPropertiesKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DisplayPropertiesKHR const & ) const = default;
#else
    bool operator==( DisplayPropertiesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( display == rhs.display ) && ( displayName == rhs.displayName ) &&
             ( physicalDimensions == rhs.physicalDimensions ) && ( physicalResolution == rhs.physicalResolution ) &&
             ( supportedTransforms == rhs.supportedTransforms ) &&
             ( planeReorderPossible == rhs.planeReorderPossible ) && ( persistentContent == rhs.persistentContent );
    }

    bool operator!=( DisplayPropertiesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::DisplayKHR               display              = {};
    const char *                                   displayName          = {};
    VULKAN_HPP_NAMESPACE::Extent2D                 physicalDimensions   = {};
    VULKAN_HPP_NAMESPACE::Extent2D                 physicalResolution   = {};
    VULKAN_HPP_NAMESPACE::SurfaceTransformFlagsKHR supportedTransforms  = {};
    VULKAN_HPP_NAMESPACE::Bool32                   planeReorderPossible = {};
    VULKAN_HPP_NAMESPACE::Bool32                   persistentContent    = {};
  };
  static_assert( sizeof( DisplayPropertiesKHR ) == sizeof( VkDisplayPropertiesKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DisplayPropertiesKHR>::value, "struct wrapper is not a standard layout!" );

  struct DisplayProperties2KHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eDisplayProperties2KHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      DisplayProperties2KHR( VULKAN_HPP_NAMESPACE::DisplayPropertiesKHR displayProperties_ = {} ) VULKAN_HPP_NOEXCEPT
      : displayProperties( displayProperties_ )
    {}

    VULKAN_HPP_CONSTEXPR DisplayProperties2KHR( DisplayProperties2KHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DisplayProperties2KHR( VkDisplayProperties2KHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : DisplayProperties2KHR( *reinterpret_cast<DisplayProperties2KHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DisplayProperties2KHR &
                            operator=( DisplayProperties2KHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DisplayProperties2KHR & operator=( VkDisplayProperties2KHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DisplayProperties2KHR const *>( &rhs );
      return *this;
    }

    operator VkDisplayProperties2KHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDisplayProperties2KHR *>( this );
    }

    operator VkDisplayProperties2KHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDisplayProperties2KHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DisplayProperties2KHR const & ) const = default;
#else
    bool operator==( DisplayProperties2KHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( displayProperties == rhs.displayProperties );
    }

    bool operator!=( DisplayProperties2KHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType        sType             = StructureType::eDisplayProperties2KHR;
    void *                                     pNext             = {};
    VULKAN_HPP_NAMESPACE::DisplayPropertiesKHR displayProperties = {};
  };
  static_assert( sizeof( DisplayProperties2KHR ) == sizeof( VkDisplayProperties2KHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DisplayProperties2KHR>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDisplayProperties2KHR>
  {
    using Type = DisplayProperties2KHR;
  };

  struct DisplaySurfaceCreateInfoKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eDisplaySurfaceCreateInfoKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      DisplaySurfaceCreateInfoKHR( VULKAN_HPP_NAMESPACE::DisplaySurfaceCreateFlagsKHR flags_           = {},
                                   VULKAN_HPP_NAMESPACE::DisplayModeKHR               displayMode_     = {},
                                   uint32_t                                           planeIndex_      = {},
                                   uint32_t                                           planeStackIndex_ = {},
                                   VULKAN_HPP_NAMESPACE::SurfaceTransformFlagBitsKHR  transform_ =
                                     VULKAN_HPP_NAMESPACE::SurfaceTransformFlagBitsKHR::eIdentity,
                                   float                                              globalAlpha_ = {},
                                   VULKAN_HPP_NAMESPACE::DisplayPlaneAlphaFlagBitsKHR alphaMode_ =
                                     VULKAN_HPP_NAMESPACE::DisplayPlaneAlphaFlagBitsKHR::eOpaque,
                                   VULKAN_HPP_NAMESPACE::Extent2D imageExtent_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , displayMode( displayMode_ )
      , planeIndex( planeIndex_ )
      , planeStackIndex( planeStackIndex_ )
      , transform( transform_ )
      , globalAlpha( globalAlpha_ )
      , alphaMode( alphaMode_ )
      , imageExtent( imageExtent_ )
    {}

    VULKAN_HPP_CONSTEXPR
      DisplaySurfaceCreateInfoKHR( DisplaySurfaceCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DisplaySurfaceCreateInfoKHR( VkDisplaySurfaceCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : DisplaySurfaceCreateInfoKHR( *reinterpret_cast<DisplaySurfaceCreateInfoKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DisplaySurfaceCreateInfoKHR &
                            operator=( DisplaySurfaceCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DisplaySurfaceCreateInfoKHR & operator=( VkDisplaySurfaceCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DisplaySurfaceCreateInfoKHR const *>( &rhs );
      return *this;
    }

    DisplaySurfaceCreateInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    DisplaySurfaceCreateInfoKHR &
      setFlags( VULKAN_HPP_NAMESPACE::DisplaySurfaceCreateFlagsKHR flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    DisplaySurfaceCreateInfoKHR &
      setDisplayMode( VULKAN_HPP_NAMESPACE::DisplayModeKHR displayMode_ ) VULKAN_HPP_NOEXCEPT
    {
      displayMode = displayMode_;
      return *this;
    }

    DisplaySurfaceCreateInfoKHR & setPlaneIndex( uint32_t planeIndex_ ) VULKAN_HPP_NOEXCEPT
    {
      planeIndex = planeIndex_;
      return *this;
    }

    DisplaySurfaceCreateInfoKHR & setPlaneStackIndex( uint32_t planeStackIndex_ ) VULKAN_HPP_NOEXCEPT
    {
      planeStackIndex = planeStackIndex_;
      return *this;
    }

    DisplaySurfaceCreateInfoKHR &
      setTransform( VULKAN_HPP_NAMESPACE::SurfaceTransformFlagBitsKHR transform_ ) VULKAN_HPP_NOEXCEPT
    {
      transform = transform_;
      return *this;
    }

    DisplaySurfaceCreateInfoKHR & setGlobalAlpha( float globalAlpha_ ) VULKAN_HPP_NOEXCEPT
    {
      globalAlpha = globalAlpha_;
      return *this;
    }

    DisplaySurfaceCreateInfoKHR &
      setAlphaMode( VULKAN_HPP_NAMESPACE::DisplayPlaneAlphaFlagBitsKHR alphaMode_ ) VULKAN_HPP_NOEXCEPT
    {
      alphaMode = alphaMode_;
      return *this;
    }

    DisplaySurfaceCreateInfoKHR &
      setImageExtent( VULKAN_HPP_NAMESPACE::Extent2D const & imageExtent_ ) VULKAN_HPP_NOEXCEPT
    {
      imageExtent = imageExtent_;
      return *this;
    }

    operator VkDisplaySurfaceCreateInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDisplaySurfaceCreateInfoKHR *>( this );
    }

    operator VkDisplaySurfaceCreateInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDisplaySurfaceCreateInfoKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DisplaySurfaceCreateInfoKHR const & ) const = default;
#else
    bool operator==( DisplaySurfaceCreateInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( displayMode == rhs.displayMode ) && ( planeIndex == rhs.planeIndex ) &&
             ( planeStackIndex == rhs.planeStackIndex ) && ( transform == rhs.transform ) &&
             ( globalAlpha == rhs.globalAlpha ) && ( alphaMode == rhs.alphaMode ) && ( imageExtent == rhs.imageExtent );
    }

    bool operator!=( DisplaySurfaceCreateInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                sType           = StructureType::eDisplaySurfaceCreateInfoKHR;
    const void *                                       pNext           = {};
    VULKAN_HPP_NAMESPACE::DisplaySurfaceCreateFlagsKHR flags           = {};
    VULKAN_HPP_NAMESPACE::DisplayModeKHR               displayMode     = {};
    uint32_t                                           planeIndex      = {};
    uint32_t                                           planeStackIndex = {};
    VULKAN_HPP_NAMESPACE::SurfaceTransformFlagBitsKHR  transform =
      VULKAN_HPP_NAMESPACE::SurfaceTransformFlagBitsKHR::eIdentity;
    float                                              globalAlpha = {};
    VULKAN_HPP_NAMESPACE::DisplayPlaneAlphaFlagBitsKHR alphaMode =
      VULKAN_HPP_NAMESPACE::DisplayPlaneAlphaFlagBitsKHR::eOpaque;
    VULKAN_HPP_NAMESPACE::Extent2D imageExtent = {};
  };
  static_assert( sizeof( DisplaySurfaceCreateInfoKHR ) == sizeof( VkDisplaySurfaceCreateInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DisplaySurfaceCreateInfoKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDisplaySurfaceCreateInfoKHR>
  {
    using Type = DisplaySurfaceCreateInfoKHR;
  };

  struct DrawIndexedIndirectCommand
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR DrawIndexedIndirectCommand( uint32_t indexCount_    = {},
                                                     uint32_t instanceCount_ = {},
                                                     uint32_t firstIndex_    = {},
                                                     int32_t  vertexOffset_  = {},
                                                     uint32_t firstInstance_ = {} ) VULKAN_HPP_NOEXCEPT
      : indexCount( indexCount_ )
      , instanceCount( instanceCount_ )
      , firstIndex( firstIndex_ )
      , vertexOffset( vertexOffset_ )
      , firstInstance( firstInstance_ )
    {}

    VULKAN_HPP_CONSTEXPR
      DrawIndexedIndirectCommand( DrawIndexedIndirectCommand const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DrawIndexedIndirectCommand( VkDrawIndexedIndirectCommand const & rhs ) VULKAN_HPP_NOEXCEPT
      : DrawIndexedIndirectCommand( *reinterpret_cast<DrawIndexedIndirectCommand const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DrawIndexedIndirectCommand &
                            operator=( DrawIndexedIndirectCommand const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DrawIndexedIndirectCommand & operator=( VkDrawIndexedIndirectCommand const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DrawIndexedIndirectCommand const *>( &rhs );
      return *this;
    }

    DrawIndexedIndirectCommand & setIndexCount( uint32_t indexCount_ ) VULKAN_HPP_NOEXCEPT
    {
      indexCount = indexCount_;
      return *this;
    }

    DrawIndexedIndirectCommand & setInstanceCount( uint32_t instanceCount_ ) VULKAN_HPP_NOEXCEPT
    {
      instanceCount = instanceCount_;
      return *this;
    }

    DrawIndexedIndirectCommand & setFirstIndex( uint32_t firstIndex_ ) VULKAN_HPP_NOEXCEPT
    {
      firstIndex = firstIndex_;
      return *this;
    }

    DrawIndexedIndirectCommand & setVertexOffset( int32_t vertexOffset_ ) VULKAN_HPP_NOEXCEPT
    {
      vertexOffset = vertexOffset_;
      return *this;
    }

    DrawIndexedIndirectCommand & setFirstInstance( uint32_t firstInstance_ ) VULKAN_HPP_NOEXCEPT
    {
      firstInstance = firstInstance_;
      return *this;
    }

    operator VkDrawIndexedIndirectCommand const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDrawIndexedIndirectCommand *>( this );
    }

    operator VkDrawIndexedIndirectCommand &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDrawIndexedIndirectCommand *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DrawIndexedIndirectCommand const & ) const = default;
#else
    bool operator==( DrawIndexedIndirectCommand const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( indexCount == rhs.indexCount ) && ( instanceCount == rhs.instanceCount ) &&
             ( firstIndex == rhs.firstIndex ) && ( vertexOffset == rhs.vertexOffset ) &&
             ( firstInstance == rhs.firstInstance );
    }

    bool operator!=( DrawIndexedIndirectCommand const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    uint32_t indexCount    = {};
    uint32_t instanceCount = {};
    uint32_t firstIndex    = {};
    int32_t  vertexOffset  = {};
    uint32_t firstInstance = {};
  };
  static_assert( sizeof( DrawIndexedIndirectCommand ) == sizeof( VkDrawIndexedIndirectCommand ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DrawIndexedIndirectCommand>::value,
                 "struct wrapper is not a standard layout!" );

  struct DrawIndirectCommand
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR DrawIndirectCommand( uint32_t vertexCount_   = {},
                                              uint32_t instanceCount_ = {},
                                              uint32_t firstVertex_   = {},
                                              uint32_t firstInstance_ = {} ) VULKAN_HPP_NOEXCEPT
      : vertexCount( vertexCount_ )
      , instanceCount( instanceCount_ )
      , firstVertex( firstVertex_ )
      , firstInstance( firstInstance_ )
    {}

    VULKAN_HPP_CONSTEXPR DrawIndirectCommand( DrawIndirectCommand const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DrawIndirectCommand( VkDrawIndirectCommand const & rhs ) VULKAN_HPP_NOEXCEPT
      : DrawIndirectCommand( *reinterpret_cast<DrawIndirectCommand const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DrawIndirectCommand &
                            operator=( DrawIndirectCommand const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DrawIndirectCommand & operator=( VkDrawIndirectCommand const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DrawIndirectCommand const *>( &rhs );
      return *this;
    }

    DrawIndirectCommand & setVertexCount( uint32_t vertexCount_ ) VULKAN_HPP_NOEXCEPT
    {
      vertexCount = vertexCount_;
      return *this;
    }

    DrawIndirectCommand & setInstanceCount( uint32_t instanceCount_ ) VULKAN_HPP_NOEXCEPT
    {
      instanceCount = instanceCount_;
      return *this;
    }

    DrawIndirectCommand & setFirstVertex( uint32_t firstVertex_ ) VULKAN_HPP_NOEXCEPT
    {
      firstVertex = firstVertex_;
      return *this;
    }

    DrawIndirectCommand & setFirstInstance( uint32_t firstInstance_ ) VULKAN_HPP_NOEXCEPT
    {
      firstInstance = firstInstance_;
      return *this;
    }

    operator VkDrawIndirectCommand const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDrawIndirectCommand *>( this );
    }

    operator VkDrawIndirectCommand &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDrawIndirectCommand *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DrawIndirectCommand const & ) const = default;
#else
    bool operator==( DrawIndirectCommand const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( vertexCount == rhs.vertexCount ) && ( instanceCount == rhs.instanceCount ) &&
             ( firstVertex == rhs.firstVertex ) && ( firstInstance == rhs.firstInstance );
    }

    bool operator!=( DrawIndirectCommand const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    uint32_t vertexCount   = {};
    uint32_t instanceCount = {};
    uint32_t firstVertex   = {};
    uint32_t firstInstance = {};
  };
  static_assert( sizeof( DrawIndirectCommand ) == sizeof( VkDrawIndirectCommand ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DrawIndirectCommand>::value, "struct wrapper is not a standard layout!" );

  struct DrawMeshTasksIndirectCommandNV
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR DrawMeshTasksIndirectCommandNV( uint32_t taskCount_ = {},
                                                         uint32_t firstTask_ = {} ) VULKAN_HPP_NOEXCEPT
      : taskCount( taskCount_ )
      , firstTask( firstTask_ )
    {}

    VULKAN_HPP_CONSTEXPR
      DrawMeshTasksIndirectCommandNV( DrawMeshTasksIndirectCommandNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DrawMeshTasksIndirectCommandNV( VkDrawMeshTasksIndirectCommandNV const & rhs ) VULKAN_HPP_NOEXCEPT
      : DrawMeshTasksIndirectCommandNV( *reinterpret_cast<DrawMeshTasksIndirectCommandNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DrawMeshTasksIndirectCommandNV &
                            operator=( DrawMeshTasksIndirectCommandNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DrawMeshTasksIndirectCommandNV & operator=( VkDrawMeshTasksIndirectCommandNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DrawMeshTasksIndirectCommandNV const *>( &rhs );
      return *this;
    }

    DrawMeshTasksIndirectCommandNV & setTaskCount( uint32_t taskCount_ ) VULKAN_HPP_NOEXCEPT
    {
      taskCount = taskCount_;
      return *this;
    }

    DrawMeshTasksIndirectCommandNV & setFirstTask( uint32_t firstTask_ ) VULKAN_HPP_NOEXCEPT
    {
      firstTask = firstTask_;
      return *this;
    }

    operator VkDrawMeshTasksIndirectCommandNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDrawMeshTasksIndirectCommandNV *>( this );
    }

    operator VkDrawMeshTasksIndirectCommandNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDrawMeshTasksIndirectCommandNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DrawMeshTasksIndirectCommandNV const & ) const = default;
#else
    bool operator==( DrawMeshTasksIndirectCommandNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( taskCount == rhs.taskCount ) && ( firstTask == rhs.firstTask );
    }

    bool operator!=( DrawMeshTasksIndirectCommandNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    uint32_t taskCount = {};
    uint32_t firstTask = {};
  };
  static_assert( sizeof( DrawMeshTasksIndirectCommandNV ) == sizeof( VkDrawMeshTasksIndirectCommandNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DrawMeshTasksIndirectCommandNV>::value,
                 "struct wrapper is not a standard layout!" );

  struct DrmFormatModifierPropertiesEXT
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR DrmFormatModifierPropertiesEXT(
      uint64_t                                 drmFormatModifier_               = {},
      uint32_t                                 drmFormatModifierPlaneCount_     = {},
      VULKAN_HPP_NAMESPACE::FormatFeatureFlags drmFormatModifierTilingFeatures_ = {} ) VULKAN_HPP_NOEXCEPT
      : drmFormatModifier( drmFormatModifier_ )
      , drmFormatModifierPlaneCount( drmFormatModifierPlaneCount_ )
      , drmFormatModifierTilingFeatures( drmFormatModifierTilingFeatures_ )
    {}

    VULKAN_HPP_CONSTEXPR
      DrmFormatModifierPropertiesEXT( DrmFormatModifierPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DrmFormatModifierPropertiesEXT( VkDrmFormatModifierPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : DrmFormatModifierPropertiesEXT( *reinterpret_cast<DrmFormatModifierPropertiesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DrmFormatModifierPropertiesEXT &
                            operator=( DrmFormatModifierPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DrmFormatModifierPropertiesEXT & operator=( VkDrmFormatModifierPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DrmFormatModifierPropertiesEXT const *>( &rhs );
      return *this;
    }

    operator VkDrmFormatModifierPropertiesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDrmFormatModifierPropertiesEXT *>( this );
    }

    operator VkDrmFormatModifierPropertiesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDrmFormatModifierPropertiesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DrmFormatModifierPropertiesEXT const & ) const = default;
#else
    bool operator==( DrmFormatModifierPropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( drmFormatModifier == rhs.drmFormatModifier ) &&
             ( drmFormatModifierPlaneCount == rhs.drmFormatModifierPlaneCount ) &&
             ( drmFormatModifierTilingFeatures == rhs.drmFormatModifierTilingFeatures );
    }

    bool operator!=( DrmFormatModifierPropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    uint64_t                                 drmFormatModifier               = {};
    uint32_t                                 drmFormatModifierPlaneCount     = {};
    VULKAN_HPP_NAMESPACE::FormatFeatureFlags drmFormatModifierTilingFeatures = {};
  };
  static_assert( sizeof( DrmFormatModifierPropertiesEXT ) == sizeof( VkDrmFormatModifierPropertiesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DrmFormatModifierPropertiesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  struct DrmFormatModifierPropertiesListEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eDrmFormatModifierPropertiesListEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR DrmFormatModifierPropertiesListEXT(
      uint32_t                                               drmFormatModifierCount_       = {},
      VULKAN_HPP_NAMESPACE::DrmFormatModifierPropertiesEXT * pDrmFormatModifierProperties_ = {} ) VULKAN_HPP_NOEXCEPT
      : drmFormatModifierCount( drmFormatModifierCount_ )
      , pDrmFormatModifierProperties( pDrmFormatModifierProperties_ )
    {}

    VULKAN_HPP_CONSTEXPR DrmFormatModifierPropertiesListEXT( DrmFormatModifierPropertiesListEXT const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    DrmFormatModifierPropertiesListEXT( VkDrmFormatModifierPropertiesListEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : DrmFormatModifierPropertiesListEXT( *reinterpret_cast<DrmFormatModifierPropertiesListEXT const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    DrmFormatModifierPropertiesListEXT(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<VULKAN_HPP_NAMESPACE::DrmFormatModifierPropertiesEXT> const &
        drmFormatModifierProperties_ )
      : drmFormatModifierCount( static_cast<uint32_t>( drmFormatModifierProperties_.size() ) )
      , pDrmFormatModifierProperties( drmFormatModifierProperties_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 DrmFormatModifierPropertiesListEXT &
                            operator=( DrmFormatModifierPropertiesListEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    DrmFormatModifierPropertiesListEXT &
      operator=( VkDrmFormatModifierPropertiesListEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::DrmFormatModifierPropertiesListEXT const *>( &rhs );
      return *this;
    }

    operator VkDrmFormatModifierPropertiesListEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkDrmFormatModifierPropertiesListEXT *>( this );
    }

    operator VkDrmFormatModifierPropertiesListEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkDrmFormatModifierPropertiesListEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( DrmFormatModifierPropertiesListEXT const & ) const = default;
#else
    bool operator==( DrmFormatModifierPropertiesListEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( drmFormatModifierCount == rhs.drmFormatModifierCount ) &&
             ( pDrmFormatModifierProperties == rhs.pDrmFormatModifierProperties );
    }

    bool operator!=( DrmFormatModifierPropertiesListEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                    sType = StructureType::eDrmFormatModifierPropertiesListEXT;
    void *                                                 pNext = {};
    uint32_t                                               drmFormatModifierCount       = {};
    VULKAN_HPP_NAMESPACE::DrmFormatModifierPropertiesEXT * pDrmFormatModifierProperties = {};
  };
  static_assert( sizeof( DrmFormatModifierPropertiesListEXT ) == sizeof( VkDrmFormatModifierPropertiesListEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<DrmFormatModifierPropertiesListEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eDrmFormatModifierPropertiesListEXT>
  {
    using Type = DrmFormatModifierPropertiesListEXT;
  };

  struct EventCreateInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eEventCreateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR EventCreateInfo( VULKAN_HPP_NAMESPACE::EventCreateFlags flags_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
    {}

    VULKAN_HPP_CONSTEXPR EventCreateInfo( EventCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    EventCreateInfo( VkEventCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : EventCreateInfo( *reinterpret_cast<EventCreateInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 EventCreateInfo & operator=( EventCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    EventCreateInfo & operator=( VkEventCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::EventCreateInfo const *>( &rhs );
      return *this;
    }

    EventCreateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    EventCreateInfo & setFlags( VULKAN_HPP_NAMESPACE::EventCreateFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    operator VkEventCreateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkEventCreateInfo *>( this );
    }

    operator VkEventCreateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkEventCreateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( EventCreateInfo const & ) const = default;
#else
    bool operator==( EventCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags );
    }

    bool operator!=( EventCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType    sType = StructureType::eEventCreateInfo;
    const void *                           pNext = {};
    VULKAN_HPP_NAMESPACE::EventCreateFlags flags = {};
  };
  static_assert( sizeof( EventCreateInfo ) == sizeof( VkEventCreateInfo ), "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<EventCreateInfo>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eEventCreateInfo>
  {
    using Type = EventCreateInfo;
  };

  struct ExportFenceCreateInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eExportFenceCreateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      ExportFenceCreateInfo( VULKAN_HPP_NAMESPACE::ExternalFenceHandleTypeFlags handleTypes_ = {} ) VULKAN_HPP_NOEXCEPT
      : handleTypes( handleTypes_ )
    {}

    VULKAN_HPP_CONSTEXPR ExportFenceCreateInfo( ExportFenceCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ExportFenceCreateInfo( VkExportFenceCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : ExportFenceCreateInfo( *reinterpret_cast<ExportFenceCreateInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ExportFenceCreateInfo &
                            operator=( ExportFenceCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ExportFenceCreateInfo & operator=( VkExportFenceCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ExportFenceCreateInfo const *>( &rhs );
      return *this;
    }

    ExportFenceCreateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ExportFenceCreateInfo &
      setHandleTypes( VULKAN_HPP_NAMESPACE::ExternalFenceHandleTypeFlags handleTypes_ ) VULKAN_HPP_NOEXCEPT
    {
      handleTypes = handleTypes_;
      return *this;
    }

    operator VkExportFenceCreateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkExportFenceCreateInfo *>( this );
    }

    operator VkExportFenceCreateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkExportFenceCreateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ExportFenceCreateInfo const & ) const = default;
#else
    bool operator==( ExportFenceCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( handleTypes == rhs.handleTypes );
    }

    bool operator!=( ExportFenceCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                sType       = StructureType::eExportFenceCreateInfo;
    const void *                                       pNext       = {};
    VULKAN_HPP_NAMESPACE::ExternalFenceHandleTypeFlags handleTypes = {};
  };
  static_assert( sizeof( ExportFenceCreateInfo ) == sizeof( VkExportFenceCreateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ExportFenceCreateInfo>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eExportFenceCreateInfo>
  {
    using Type = ExportFenceCreateInfo;
  };
  using ExportFenceCreateInfoKHR = ExportFenceCreateInfo;

#if defined( VK_USE_PLATFORM_WIN32_KHR )
  struct ExportFenceWin32HandleInfoKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eExportFenceWin32HandleInfoKHR;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ExportFenceWin32HandleInfoKHR( const SECURITY_ATTRIBUTES * pAttributes_ = {},
                                                        DWORD                       dwAccess_    = {},
                                                        LPCWSTR                     name_ = {} ) VULKAN_HPP_NOEXCEPT
      : pAttributes( pAttributes_ )
      , dwAccess( dwAccess_ )
      , name( name_ )
    {}

    VULKAN_HPP_CONSTEXPR
      ExportFenceWin32HandleInfoKHR( ExportFenceWin32HandleInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ExportFenceWin32HandleInfoKHR( VkExportFenceWin32HandleInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : ExportFenceWin32HandleInfoKHR( *reinterpret_cast<ExportFenceWin32HandleInfoKHR const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ExportFenceWin32HandleInfoKHR &
                            operator=( ExportFenceWin32HandleInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ExportFenceWin32HandleInfoKHR & operator=( VkExportFenceWin32HandleInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ExportFenceWin32HandleInfoKHR const *>( &rhs );
      return *this;
    }

    ExportFenceWin32HandleInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ExportFenceWin32HandleInfoKHR & setPAttributes( const SECURITY_ATTRIBUTES * pAttributes_ ) VULKAN_HPP_NOEXCEPT
    {
      pAttributes = pAttributes_;
      return *this;
    }

    ExportFenceWin32HandleInfoKHR & setDwAccess( DWORD dwAccess_ ) VULKAN_HPP_NOEXCEPT
    {
      dwAccess = dwAccess_;
      return *this;
    }

    ExportFenceWin32HandleInfoKHR & setName( LPCWSTR name_ ) VULKAN_HPP_NOEXCEPT
    {
      name = name_;
      return *this;
    }

    operator VkExportFenceWin32HandleInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkExportFenceWin32HandleInfoKHR *>( this );
    }

    operator VkExportFenceWin32HandleInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkExportFenceWin32HandleInfoKHR *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ExportFenceWin32HandleInfoKHR const & ) const = default;
#  else
    bool operator==( ExportFenceWin32HandleInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( pAttributes == rhs.pAttributes ) &&
             ( dwAccess == rhs.dwAccess ) && ( name == rhs.name );
    }

    bool operator!=( ExportFenceWin32HandleInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType       = StructureType::eExportFenceWin32HandleInfoKHR;
    const void *                        pNext       = {};
    const SECURITY_ATTRIBUTES *         pAttributes = {};
    DWORD                               dwAccess    = {};
    LPCWSTR                             name        = {};
  };
  static_assert( sizeof( ExportFenceWin32HandleInfoKHR ) == sizeof( VkExportFenceWin32HandleInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ExportFenceWin32HandleInfoKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eExportFenceWin32HandleInfoKHR>
  {
    using Type = ExportFenceWin32HandleInfoKHR;
  };
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

  struct ExportMemoryAllocateInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eExportMemoryAllocateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ExportMemoryAllocateInfo(
      VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlags handleTypes_ = {} ) VULKAN_HPP_NOEXCEPT
      : handleTypes( handleTypes_ )
    {}

    VULKAN_HPP_CONSTEXPR ExportMemoryAllocateInfo( ExportMemoryAllocateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ExportMemoryAllocateInfo( VkExportMemoryAllocateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : ExportMemoryAllocateInfo( *reinterpret_cast<ExportMemoryAllocateInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ExportMemoryAllocateInfo &
                            operator=( ExportMemoryAllocateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ExportMemoryAllocateInfo & operator=( VkExportMemoryAllocateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ExportMemoryAllocateInfo const *>( &rhs );
      return *this;
    }

    ExportMemoryAllocateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ExportMemoryAllocateInfo &
      setHandleTypes( VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlags handleTypes_ ) VULKAN_HPP_NOEXCEPT
    {
      handleTypes = handleTypes_;
      return *this;
    }

    operator VkExportMemoryAllocateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkExportMemoryAllocateInfo *>( this );
    }

    operator VkExportMemoryAllocateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkExportMemoryAllocateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ExportMemoryAllocateInfo const & ) const = default;
#else
    bool operator==( ExportMemoryAllocateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( handleTypes == rhs.handleTypes );
    }

    bool operator!=( ExportMemoryAllocateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                 sType       = StructureType::eExportMemoryAllocateInfo;
    const void *                                        pNext       = {};
    VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlags handleTypes = {};
  };
  static_assert( sizeof( ExportMemoryAllocateInfo ) == sizeof( VkExportMemoryAllocateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ExportMemoryAllocateInfo>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eExportMemoryAllocateInfo>
  {
    using Type = ExportMemoryAllocateInfo;
  };
  using ExportMemoryAllocateInfoKHR = ExportMemoryAllocateInfo;

  struct ExportMemoryAllocateInfoNV
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eExportMemoryAllocateInfoNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ExportMemoryAllocateInfoNV(
      VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagsNV handleTypes_ = {} ) VULKAN_HPP_NOEXCEPT
      : handleTypes( handleTypes_ )
    {}

    VULKAN_HPP_CONSTEXPR
      ExportMemoryAllocateInfoNV( ExportMemoryAllocateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ExportMemoryAllocateInfoNV( VkExportMemoryAllocateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
      : ExportMemoryAllocateInfoNV( *reinterpret_cast<ExportMemoryAllocateInfoNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ExportMemoryAllocateInfoNV &
                            operator=( ExportMemoryAllocateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ExportMemoryAllocateInfoNV & operator=( VkExportMemoryAllocateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ExportMemoryAllocateInfoNV const *>( &rhs );
      return *this;
    }

    ExportMemoryAllocateInfoNV & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ExportMemoryAllocateInfoNV &
      setHandleTypes( VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagsNV handleTypes_ ) VULKAN_HPP_NOEXCEPT
    {
      handleTypes = handleTypes_;
      return *this;
    }

    operator VkExportMemoryAllocateInfoNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkExportMemoryAllocateInfoNV *>( this );
    }

    operator VkExportMemoryAllocateInfoNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkExportMemoryAllocateInfoNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ExportMemoryAllocateInfoNV const & ) const = default;
#else
    bool operator==( ExportMemoryAllocateInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( handleTypes == rhs.handleTypes );
    }

    bool operator!=( ExportMemoryAllocateInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                   sType       = StructureType::eExportMemoryAllocateInfoNV;
    const void *                                          pNext       = {};
    VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagsNV handleTypes = {};
  };
  static_assert( sizeof( ExportMemoryAllocateInfoNV ) == sizeof( VkExportMemoryAllocateInfoNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ExportMemoryAllocateInfoNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eExportMemoryAllocateInfoNV>
  {
    using Type = ExportMemoryAllocateInfoNV;
  };

#if defined( VK_USE_PLATFORM_WIN32_KHR )
  struct ExportMemoryWin32HandleInfoKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eExportMemoryWin32HandleInfoKHR;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ExportMemoryWin32HandleInfoKHR( const SECURITY_ATTRIBUTES * pAttributes_ = {},
                                                         DWORD                       dwAccess_    = {},
                                                         LPCWSTR                     name_ = {} ) VULKAN_HPP_NOEXCEPT
      : pAttributes( pAttributes_ )
      , dwAccess( dwAccess_ )
      , name( name_ )
    {}

    VULKAN_HPP_CONSTEXPR
      ExportMemoryWin32HandleInfoKHR( ExportMemoryWin32HandleInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ExportMemoryWin32HandleInfoKHR( VkExportMemoryWin32HandleInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : ExportMemoryWin32HandleInfoKHR( *reinterpret_cast<ExportMemoryWin32HandleInfoKHR const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ExportMemoryWin32HandleInfoKHR &
                            operator=( ExportMemoryWin32HandleInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ExportMemoryWin32HandleInfoKHR & operator=( VkExportMemoryWin32HandleInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ExportMemoryWin32HandleInfoKHR const *>( &rhs );
      return *this;
    }

    ExportMemoryWin32HandleInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ExportMemoryWin32HandleInfoKHR & setPAttributes( const SECURITY_ATTRIBUTES * pAttributes_ ) VULKAN_HPP_NOEXCEPT
    {
      pAttributes = pAttributes_;
      return *this;
    }

    ExportMemoryWin32HandleInfoKHR & setDwAccess( DWORD dwAccess_ ) VULKAN_HPP_NOEXCEPT
    {
      dwAccess = dwAccess_;
      return *this;
    }

    ExportMemoryWin32HandleInfoKHR & setName( LPCWSTR name_ ) VULKAN_HPP_NOEXCEPT
    {
      name = name_;
      return *this;
    }

    operator VkExportMemoryWin32HandleInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkExportMemoryWin32HandleInfoKHR *>( this );
    }

    operator VkExportMemoryWin32HandleInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkExportMemoryWin32HandleInfoKHR *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ExportMemoryWin32HandleInfoKHR const & ) const = default;
#  else
    bool operator==( ExportMemoryWin32HandleInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( pAttributes == rhs.pAttributes ) &&
             ( dwAccess == rhs.dwAccess ) && ( name == rhs.name );
    }

    bool operator!=( ExportMemoryWin32HandleInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType       = StructureType::eExportMemoryWin32HandleInfoKHR;
    const void *                        pNext       = {};
    const SECURITY_ATTRIBUTES *         pAttributes = {};
    DWORD                               dwAccess    = {};
    LPCWSTR                             name        = {};
  };
  static_assert( sizeof( ExportMemoryWin32HandleInfoKHR ) == sizeof( VkExportMemoryWin32HandleInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ExportMemoryWin32HandleInfoKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eExportMemoryWin32HandleInfoKHR>
  {
    using Type = ExportMemoryWin32HandleInfoKHR;
  };
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

#if defined( VK_USE_PLATFORM_WIN32_KHR )
  struct ExportMemoryWin32HandleInfoNV
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eExportMemoryWin32HandleInfoNV;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ExportMemoryWin32HandleInfoNV( const SECURITY_ATTRIBUTES * pAttributes_ = {},
                                                        DWORD                       dwAccess_ = {} ) VULKAN_HPP_NOEXCEPT
      : pAttributes( pAttributes_ )
      , dwAccess( dwAccess_ )
    {}

    VULKAN_HPP_CONSTEXPR
      ExportMemoryWin32HandleInfoNV( ExportMemoryWin32HandleInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ExportMemoryWin32HandleInfoNV( VkExportMemoryWin32HandleInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
      : ExportMemoryWin32HandleInfoNV( *reinterpret_cast<ExportMemoryWin32HandleInfoNV const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ExportMemoryWin32HandleInfoNV &
                            operator=( ExportMemoryWin32HandleInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ExportMemoryWin32HandleInfoNV & operator=( VkExportMemoryWin32HandleInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ExportMemoryWin32HandleInfoNV const *>( &rhs );
      return *this;
    }

    ExportMemoryWin32HandleInfoNV & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ExportMemoryWin32HandleInfoNV & setPAttributes( const SECURITY_ATTRIBUTES * pAttributes_ ) VULKAN_HPP_NOEXCEPT
    {
      pAttributes = pAttributes_;
      return *this;
    }

    ExportMemoryWin32HandleInfoNV & setDwAccess( DWORD dwAccess_ ) VULKAN_HPP_NOEXCEPT
    {
      dwAccess = dwAccess_;
      return *this;
    }

    operator VkExportMemoryWin32HandleInfoNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkExportMemoryWin32HandleInfoNV *>( this );
    }

    operator VkExportMemoryWin32HandleInfoNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkExportMemoryWin32HandleInfoNV *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ExportMemoryWin32HandleInfoNV const & ) const = default;
#  else
    bool operator==( ExportMemoryWin32HandleInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( pAttributes == rhs.pAttributes ) &&
             ( dwAccess == rhs.dwAccess );
    }

    bool operator!=( ExportMemoryWin32HandleInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType       = StructureType::eExportMemoryWin32HandleInfoNV;
    const void *                        pNext       = {};
    const SECURITY_ATTRIBUTES *         pAttributes = {};
    DWORD                               dwAccess    = {};
  };
  static_assert( sizeof( ExportMemoryWin32HandleInfoNV ) == sizeof( VkExportMemoryWin32HandleInfoNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ExportMemoryWin32HandleInfoNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eExportMemoryWin32HandleInfoNV>
  {
    using Type = ExportMemoryWin32HandleInfoNV;
  };
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

  struct ExportSemaphoreCreateInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eExportSemaphoreCreateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ExportSemaphoreCreateInfo(
      VULKAN_HPP_NAMESPACE::ExternalSemaphoreHandleTypeFlags handleTypes_ = {} ) VULKAN_HPP_NOEXCEPT
      : handleTypes( handleTypes_ )
    {}

    VULKAN_HPP_CONSTEXPR
      ExportSemaphoreCreateInfo( ExportSemaphoreCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ExportSemaphoreCreateInfo( VkExportSemaphoreCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : ExportSemaphoreCreateInfo( *reinterpret_cast<ExportSemaphoreCreateInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ExportSemaphoreCreateInfo &
                            operator=( ExportSemaphoreCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ExportSemaphoreCreateInfo & operator=( VkExportSemaphoreCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ExportSemaphoreCreateInfo const *>( &rhs );
      return *this;
    }

    ExportSemaphoreCreateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ExportSemaphoreCreateInfo &
      setHandleTypes( VULKAN_HPP_NAMESPACE::ExternalSemaphoreHandleTypeFlags handleTypes_ ) VULKAN_HPP_NOEXCEPT
    {
      handleTypes = handleTypes_;
      return *this;
    }

    operator VkExportSemaphoreCreateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkExportSemaphoreCreateInfo *>( this );
    }

    operator VkExportSemaphoreCreateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkExportSemaphoreCreateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ExportSemaphoreCreateInfo const & ) const = default;
#else
    bool operator==( ExportSemaphoreCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( handleTypes == rhs.handleTypes );
    }

    bool operator!=( ExportSemaphoreCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                    sType       = StructureType::eExportSemaphoreCreateInfo;
    const void *                                           pNext       = {};
    VULKAN_HPP_NAMESPACE::ExternalSemaphoreHandleTypeFlags handleTypes = {};
  };
  static_assert( sizeof( ExportSemaphoreCreateInfo ) == sizeof( VkExportSemaphoreCreateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ExportSemaphoreCreateInfo>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eExportSemaphoreCreateInfo>
  {
    using Type = ExportSemaphoreCreateInfo;
  };
  using ExportSemaphoreCreateInfoKHR = ExportSemaphoreCreateInfo;

#if defined( VK_USE_PLATFORM_WIN32_KHR )
  struct ExportSemaphoreWin32HandleInfoKHR
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eExportSemaphoreWin32HandleInfoKHR;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ExportSemaphoreWin32HandleInfoKHR( const SECURITY_ATTRIBUTES * pAttributes_ = {},
                                                            DWORD                       dwAccess_    = {},
                                                            LPCWSTR                     name_ = {} ) VULKAN_HPP_NOEXCEPT
      : pAttributes( pAttributes_ )
      , dwAccess( dwAccess_ )
      , name( name_ )
    {}

    VULKAN_HPP_CONSTEXPR
      ExportSemaphoreWin32HandleInfoKHR( ExportSemaphoreWin32HandleInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ExportSemaphoreWin32HandleInfoKHR( VkExportSemaphoreWin32HandleInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : ExportSemaphoreWin32HandleInfoKHR( *reinterpret_cast<ExportSemaphoreWin32HandleInfoKHR const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ExportSemaphoreWin32HandleInfoKHR &
                            operator=( ExportSemaphoreWin32HandleInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ExportSemaphoreWin32HandleInfoKHR & operator=( VkExportSemaphoreWin32HandleInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ExportSemaphoreWin32HandleInfoKHR const *>( &rhs );
      return *this;
    }

    ExportSemaphoreWin32HandleInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ExportSemaphoreWin32HandleInfoKHR & setPAttributes( const SECURITY_ATTRIBUTES * pAttributes_ ) VULKAN_HPP_NOEXCEPT
    {
      pAttributes = pAttributes_;
      return *this;
    }

    ExportSemaphoreWin32HandleInfoKHR & setDwAccess( DWORD dwAccess_ ) VULKAN_HPP_NOEXCEPT
    {
      dwAccess = dwAccess_;
      return *this;
    }

    ExportSemaphoreWin32HandleInfoKHR & setName( LPCWSTR name_ ) VULKAN_HPP_NOEXCEPT
    {
      name = name_;
      return *this;
    }

    operator VkExportSemaphoreWin32HandleInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkExportSemaphoreWin32HandleInfoKHR *>( this );
    }

    operator VkExportSemaphoreWin32HandleInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkExportSemaphoreWin32HandleInfoKHR *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ExportSemaphoreWin32HandleInfoKHR const & ) const = default;
#  else
    bool operator==( ExportSemaphoreWin32HandleInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( pAttributes == rhs.pAttributes ) &&
             ( dwAccess == rhs.dwAccess ) && ( name == rhs.name );
    }

    bool operator!=( ExportSemaphoreWin32HandleInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType       = StructureType::eExportSemaphoreWin32HandleInfoKHR;
    const void *                        pNext       = {};
    const SECURITY_ATTRIBUTES *         pAttributes = {};
    DWORD                               dwAccess    = {};
    LPCWSTR                             name        = {};
  };
  static_assert( sizeof( ExportSemaphoreWin32HandleInfoKHR ) == sizeof( VkExportSemaphoreWin32HandleInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ExportSemaphoreWin32HandleInfoKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eExportSemaphoreWin32HandleInfoKHR>
  {
    using Type = ExportSemaphoreWin32HandleInfoKHR;
  };
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

  struct ExtensionProperties
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR_14
      ExtensionProperties( std::array<char, VK_MAX_EXTENSION_NAME_SIZE> const & extensionName_ = {},
                           uint32_t                                             specVersion_ = {} ) VULKAN_HPP_NOEXCEPT
      : extensionName( extensionName_ )
      , specVersion( specVersion_ )
    {}

    VULKAN_HPP_CONSTEXPR_14 ExtensionProperties( ExtensionProperties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ExtensionProperties( VkExtensionProperties const & rhs ) VULKAN_HPP_NOEXCEPT
      : ExtensionProperties( *reinterpret_cast<ExtensionProperties const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ExtensionProperties &
                            operator=( ExtensionProperties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ExtensionProperties & operator=( VkExtensionProperties const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ExtensionProperties const *>( &rhs );
      return *this;
    }

    operator VkExtensionProperties const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkExtensionProperties *>( this );
    }

    operator VkExtensionProperties &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkExtensionProperties *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ExtensionProperties const & ) const = default;
#else
    bool operator==( ExtensionProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( extensionName == rhs.extensionName ) && ( specVersion == rhs.specVersion );
    }

    bool operator!=( ExtensionProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<char, VK_MAX_EXTENSION_NAME_SIZE> extensionName = {};
    uint32_t                                                               specVersion   = {};
  };
  static_assert( sizeof( ExtensionProperties ) == sizeof( VkExtensionProperties ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ExtensionProperties>::value, "struct wrapper is not a standard layout!" );

  struct ExternalMemoryProperties
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ExternalMemoryProperties(
      VULKAN_HPP_NAMESPACE::ExternalMemoryFeatureFlags    externalMemoryFeatures_        = {},
      VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlags exportFromImportedHandleTypes_ = {},
      VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlags compatibleHandleTypes_         = {} ) VULKAN_HPP_NOEXCEPT
      : externalMemoryFeatures( externalMemoryFeatures_ )
      , exportFromImportedHandleTypes( exportFromImportedHandleTypes_ )
      , compatibleHandleTypes( compatibleHandleTypes_ )
    {}

    VULKAN_HPP_CONSTEXPR ExternalMemoryProperties( ExternalMemoryProperties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ExternalMemoryProperties( VkExternalMemoryProperties const & rhs ) VULKAN_HPP_NOEXCEPT
      : ExternalMemoryProperties( *reinterpret_cast<ExternalMemoryProperties const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ExternalMemoryProperties &
                            operator=( ExternalMemoryProperties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ExternalMemoryProperties & operator=( VkExternalMemoryProperties const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ExternalMemoryProperties const *>( &rhs );
      return *this;
    }

    operator VkExternalMemoryProperties const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkExternalMemoryProperties *>( this );
    }

    operator VkExternalMemoryProperties &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkExternalMemoryProperties *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ExternalMemoryProperties const & ) const = default;
#else
    bool operator==( ExternalMemoryProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( externalMemoryFeatures == rhs.externalMemoryFeatures ) &&
             ( exportFromImportedHandleTypes == rhs.exportFromImportedHandleTypes ) &&
             ( compatibleHandleTypes == rhs.compatibleHandleTypes );
    }

    bool operator!=( ExternalMemoryProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::ExternalMemoryFeatureFlags    externalMemoryFeatures        = {};
    VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlags exportFromImportedHandleTypes = {};
    VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlags compatibleHandleTypes         = {};
  };
  static_assert( sizeof( ExternalMemoryProperties ) == sizeof( VkExternalMemoryProperties ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ExternalMemoryProperties>::value, "struct wrapper is not a standard layout!" );
  using ExternalMemoryPropertiesKHR = ExternalMemoryProperties;

  struct ExternalBufferProperties
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eExternalBufferProperties;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ExternalBufferProperties(
      VULKAN_HPP_NAMESPACE::ExternalMemoryProperties externalMemoryProperties_ = {} ) VULKAN_HPP_NOEXCEPT
      : externalMemoryProperties( externalMemoryProperties_ )
    {}

    VULKAN_HPP_CONSTEXPR ExternalBufferProperties( ExternalBufferProperties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ExternalBufferProperties( VkExternalBufferProperties const & rhs ) VULKAN_HPP_NOEXCEPT
      : ExternalBufferProperties( *reinterpret_cast<ExternalBufferProperties const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ExternalBufferProperties &
                            operator=( ExternalBufferProperties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ExternalBufferProperties & operator=( VkExternalBufferProperties const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ExternalBufferProperties const *>( &rhs );
      return *this;
    }

    operator VkExternalBufferProperties const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkExternalBufferProperties *>( this );
    }

    operator VkExternalBufferProperties &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkExternalBufferProperties *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ExternalBufferProperties const & ) const = default;
#else
    bool operator==( ExternalBufferProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( externalMemoryProperties == rhs.externalMemoryProperties );
    }

    bool operator!=( ExternalBufferProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType            sType                    = StructureType::eExternalBufferProperties;
    void *                                         pNext                    = {};
    VULKAN_HPP_NAMESPACE::ExternalMemoryProperties externalMemoryProperties = {};
  };
  static_assert( sizeof( ExternalBufferProperties ) == sizeof( VkExternalBufferProperties ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ExternalBufferProperties>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eExternalBufferProperties>
  {
    using Type = ExternalBufferProperties;
  };
  using ExternalBufferPropertiesKHR = ExternalBufferProperties;

  struct ExternalFenceProperties
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eExternalFenceProperties;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ExternalFenceProperties(
      VULKAN_HPP_NAMESPACE::ExternalFenceHandleTypeFlags exportFromImportedHandleTypes_ = {},
      VULKAN_HPP_NAMESPACE::ExternalFenceHandleTypeFlags compatibleHandleTypes_         = {},
      VULKAN_HPP_NAMESPACE::ExternalFenceFeatureFlags    externalFenceFeatures_         = {} ) VULKAN_HPP_NOEXCEPT
      : exportFromImportedHandleTypes( exportFromImportedHandleTypes_ )
      , compatibleHandleTypes( compatibleHandleTypes_ )
      , externalFenceFeatures( externalFenceFeatures_ )
    {}

    VULKAN_HPP_CONSTEXPR ExternalFenceProperties( ExternalFenceProperties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ExternalFenceProperties( VkExternalFenceProperties const & rhs ) VULKAN_HPP_NOEXCEPT
      : ExternalFenceProperties( *reinterpret_cast<ExternalFenceProperties const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ExternalFenceProperties &
                            operator=( ExternalFenceProperties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ExternalFenceProperties & operator=( VkExternalFenceProperties const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ExternalFenceProperties const *>( &rhs );
      return *this;
    }

    operator VkExternalFenceProperties const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkExternalFenceProperties *>( this );
    }

    operator VkExternalFenceProperties &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkExternalFenceProperties *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ExternalFenceProperties const & ) const = default;
#else
    bool operator==( ExternalFenceProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( exportFromImportedHandleTypes == rhs.exportFromImportedHandleTypes ) &&
             ( compatibleHandleTypes == rhs.compatibleHandleTypes ) &&
             ( externalFenceFeatures == rhs.externalFenceFeatures );
    }

    bool operator!=( ExternalFenceProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                sType = StructureType::eExternalFenceProperties;
    void *                                             pNext = {};
    VULKAN_HPP_NAMESPACE::ExternalFenceHandleTypeFlags exportFromImportedHandleTypes = {};
    VULKAN_HPP_NAMESPACE::ExternalFenceHandleTypeFlags compatibleHandleTypes         = {};
    VULKAN_HPP_NAMESPACE::ExternalFenceFeatureFlags    externalFenceFeatures         = {};
  };
  static_assert( sizeof( ExternalFenceProperties ) == sizeof( VkExternalFenceProperties ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ExternalFenceProperties>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eExternalFenceProperties>
  {
    using Type = ExternalFenceProperties;
  };
  using ExternalFencePropertiesKHR = ExternalFenceProperties;

#if defined( VK_USE_PLATFORM_ANDROID_KHR )
  struct ExternalFormatANDROID
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eExternalFormatANDROID;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ExternalFormatANDROID( uint64_t externalFormat_ = {} ) VULKAN_HPP_NOEXCEPT
      : externalFormat( externalFormat_ )
    {}

    VULKAN_HPP_CONSTEXPR ExternalFormatANDROID( ExternalFormatANDROID const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ExternalFormatANDROID( VkExternalFormatANDROID const & rhs ) VULKAN_HPP_NOEXCEPT
      : ExternalFormatANDROID( *reinterpret_cast<ExternalFormatANDROID const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ExternalFormatANDROID &
                            operator=( ExternalFormatANDROID const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ExternalFormatANDROID & operator=( VkExternalFormatANDROID const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ExternalFormatANDROID const *>( &rhs );
      return *this;
    }

    ExternalFormatANDROID & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ExternalFormatANDROID & setExternalFormat( uint64_t externalFormat_ ) VULKAN_HPP_NOEXCEPT
    {
      externalFormat = externalFormat_;
      return *this;
    }

    operator VkExternalFormatANDROID const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkExternalFormatANDROID *>( this );
    }

    operator VkExternalFormatANDROID &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkExternalFormatANDROID *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ExternalFormatANDROID const & ) const = default;
#  else
    bool operator==( ExternalFormatANDROID const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( externalFormat == rhs.externalFormat );
    }

    bool operator!=( ExternalFormatANDROID const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType          = StructureType::eExternalFormatANDROID;
    void *                              pNext          = {};
    uint64_t                            externalFormat = {};
  };
  static_assert( sizeof( ExternalFormatANDROID ) == sizeof( VkExternalFormatANDROID ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ExternalFormatANDROID>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eExternalFormatANDROID>
  {
    using Type = ExternalFormatANDROID;
  };
#endif /*VK_USE_PLATFORM_ANDROID_KHR*/

  struct ExternalImageFormatProperties
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eExternalImageFormatProperties;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ExternalImageFormatProperties(
      VULKAN_HPP_NAMESPACE::ExternalMemoryProperties externalMemoryProperties_ = {} ) VULKAN_HPP_NOEXCEPT
      : externalMemoryProperties( externalMemoryProperties_ )
    {}

    VULKAN_HPP_CONSTEXPR
      ExternalImageFormatProperties( ExternalImageFormatProperties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ExternalImageFormatProperties( VkExternalImageFormatProperties const & rhs ) VULKAN_HPP_NOEXCEPT
      : ExternalImageFormatProperties( *reinterpret_cast<ExternalImageFormatProperties const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ExternalImageFormatProperties &
                            operator=( ExternalImageFormatProperties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ExternalImageFormatProperties & operator=( VkExternalImageFormatProperties const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ExternalImageFormatProperties const *>( &rhs );
      return *this;
    }

    operator VkExternalImageFormatProperties const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkExternalImageFormatProperties *>( this );
    }

    operator VkExternalImageFormatProperties &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkExternalImageFormatProperties *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ExternalImageFormatProperties const & ) const = default;
#else
    bool operator==( ExternalImageFormatProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( externalMemoryProperties == rhs.externalMemoryProperties );
    }

    bool operator!=( ExternalImageFormatProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType            sType = StructureType::eExternalImageFormatProperties;
    void *                                         pNext = {};
    VULKAN_HPP_NAMESPACE::ExternalMemoryProperties externalMemoryProperties = {};
  };
  static_assert( sizeof( ExternalImageFormatProperties ) == sizeof( VkExternalImageFormatProperties ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ExternalImageFormatProperties>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eExternalImageFormatProperties>
  {
    using Type = ExternalImageFormatProperties;
  };
  using ExternalImageFormatPropertiesKHR = ExternalImageFormatProperties;

  struct ImageFormatProperties
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      ImageFormatProperties( VULKAN_HPP_NAMESPACE::Extent3D         maxExtent_       = {},
                             uint32_t                               maxMipLevels_    = {},
                             uint32_t                               maxArrayLayers_  = {},
                             VULKAN_HPP_NAMESPACE::SampleCountFlags sampleCounts_    = {},
                             VULKAN_HPP_NAMESPACE::DeviceSize       maxResourceSize_ = {} ) VULKAN_HPP_NOEXCEPT
      : maxExtent( maxExtent_ )
      , maxMipLevels( maxMipLevels_ )
      , maxArrayLayers( maxArrayLayers_ )
      , sampleCounts( sampleCounts_ )
      , maxResourceSize( maxResourceSize_ )
    {}

    VULKAN_HPP_CONSTEXPR ImageFormatProperties( ImageFormatProperties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImageFormatProperties( VkImageFormatProperties const & rhs ) VULKAN_HPP_NOEXCEPT
      : ImageFormatProperties( *reinterpret_cast<ImageFormatProperties const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ImageFormatProperties &
                            operator=( ImageFormatProperties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImageFormatProperties & operator=( VkImageFormatProperties const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ImageFormatProperties const *>( &rhs );
      return *this;
    }

    operator VkImageFormatProperties const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkImageFormatProperties *>( this );
    }

    operator VkImageFormatProperties &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkImageFormatProperties *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ImageFormatProperties const & ) const = default;
#else
    bool operator==( ImageFormatProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( maxExtent == rhs.maxExtent ) && ( maxMipLevels == rhs.maxMipLevels ) &&
             ( maxArrayLayers == rhs.maxArrayLayers ) && ( sampleCounts == rhs.sampleCounts ) &&
             ( maxResourceSize == rhs.maxResourceSize );
    }

    bool operator!=( ImageFormatProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::Extent3D         maxExtent       = {};
    uint32_t                               maxMipLevels    = {};
    uint32_t                               maxArrayLayers  = {};
    VULKAN_HPP_NAMESPACE::SampleCountFlags sampleCounts    = {};
    VULKAN_HPP_NAMESPACE::DeviceSize       maxResourceSize = {};
  };
  static_assert( sizeof( ImageFormatProperties ) == sizeof( VkImageFormatProperties ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ImageFormatProperties>::value, "struct wrapper is not a standard layout!" );

  struct ExternalImageFormatPropertiesNV
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ExternalImageFormatPropertiesNV(
      VULKAN_HPP_NAMESPACE::ImageFormatProperties           imageFormatProperties_         = {},
      VULKAN_HPP_NAMESPACE::ExternalMemoryFeatureFlagsNV    externalMemoryFeatures_        = {},
      VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagsNV exportFromImportedHandleTypes_ = {},
      VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagsNV compatibleHandleTypes_         = {} ) VULKAN_HPP_NOEXCEPT
      : imageFormatProperties( imageFormatProperties_ )
      , externalMemoryFeatures( externalMemoryFeatures_ )
      , exportFromImportedHandleTypes( exportFromImportedHandleTypes_ )
      , compatibleHandleTypes( compatibleHandleTypes_ )
    {}

    VULKAN_HPP_CONSTEXPR
      ExternalImageFormatPropertiesNV( ExternalImageFormatPropertiesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ExternalImageFormatPropertiesNV( VkExternalImageFormatPropertiesNV const & rhs ) VULKAN_HPP_NOEXCEPT
      : ExternalImageFormatPropertiesNV( *reinterpret_cast<ExternalImageFormatPropertiesNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ExternalImageFormatPropertiesNV &
                            operator=( ExternalImageFormatPropertiesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ExternalImageFormatPropertiesNV & operator=( VkExternalImageFormatPropertiesNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ExternalImageFormatPropertiesNV const *>( &rhs );
      return *this;
    }

    operator VkExternalImageFormatPropertiesNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkExternalImageFormatPropertiesNV *>( this );
    }

    operator VkExternalImageFormatPropertiesNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkExternalImageFormatPropertiesNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ExternalImageFormatPropertiesNV const & ) const = default;
#else
    bool operator==( ExternalImageFormatPropertiesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( imageFormatProperties == rhs.imageFormatProperties ) &&
             ( externalMemoryFeatures == rhs.externalMemoryFeatures ) &&
             ( exportFromImportedHandleTypes == rhs.exportFromImportedHandleTypes ) &&
             ( compatibleHandleTypes == rhs.compatibleHandleTypes );
    }

    bool operator!=( ExternalImageFormatPropertiesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::ImageFormatProperties           imageFormatProperties         = {};
    VULKAN_HPP_NAMESPACE::ExternalMemoryFeatureFlagsNV    externalMemoryFeatures        = {};
    VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagsNV exportFromImportedHandleTypes = {};
    VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagsNV compatibleHandleTypes         = {};
  };
  static_assert( sizeof( ExternalImageFormatPropertiesNV ) == sizeof( VkExternalImageFormatPropertiesNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ExternalImageFormatPropertiesNV>::value,
                 "struct wrapper is not a standard layout!" );

  struct ExternalMemoryBufferCreateInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eExternalMemoryBufferCreateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ExternalMemoryBufferCreateInfo(
      VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlags handleTypes_ = {} ) VULKAN_HPP_NOEXCEPT
      : handleTypes( handleTypes_ )
    {}

    VULKAN_HPP_CONSTEXPR
      ExternalMemoryBufferCreateInfo( ExternalMemoryBufferCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ExternalMemoryBufferCreateInfo( VkExternalMemoryBufferCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : ExternalMemoryBufferCreateInfo( *reinterpret_cast<ExternalMemoryBufferCreateInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ExternalMemoryBufferCreateInfo &
                            operator=( ExternalMemoryBufferCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ExternalMemoryBufferCreateInfo & operator=( VkExternalMemoryBufferCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ExternalMemoryBufferCreateInfo const *>( &rhs );
      return *this;
    }

    ExternalMemoryBufferCreateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ExternalMemoryBufferCreateInfo &
      setHandleTypes( VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlags handleTypes_ ) VULKAN_HPP_NOEXCEPT
    {
      handleTypes = handleTypes_;
      return *this;
    }

    operator VkExternalMemoryBufferCreateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkExternalMemoryBufferCreateInfo *>( this );
    }

    operator VkExternalMemoryBufferCreateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkExternalMemoryBufferCreateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ExternalMemoryBufferCreateInfo const & ) const = default;
#else
    bool operator==( ExternalMemoryBufferCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( handleTypes == rhs.handleTypes );
    }

    bool operator!=( ExternalMemoryBufferCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                 sType       = StructureType::eExternalMemoryBufferCreateInfo;
    const void *                                        pNext       = {};
    VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlags handleTypes = {};
  };
  static_assert( sizeof( ExternalMemoryBufferCreateInfo ) == sizeof( VkExternalMemoryBufferCreateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ExternalMemoryBufferCreateInfo>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eExternalMemoryBufferCreateInfo>
  {
    using Type = ExternalMemoryBufferCreateInfo;
  };
  using ExternalMemoryBufferCreateInfoKHR = ExternalMemoryBufferCreateInfo;

  struct ExternalMemoryImageCreateInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eExternalMemoryImageCreateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ExternalMemoryImageCreateInfo(
      VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlags handleTypes_ = {} ) VULKAN_HPP_NOEXCEPT
      : handleTypes( handleTypes_ )
    {}

    VULKAN_HPP_CONSTEXPR
      ExternalMemoryImageCreateInfo( ExternalMemoryImageCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ExternalMemoryImageCreateInfo( VkExternalMemoryImageCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : ExternalMemoryImageCreateInfo( *reinterpret_cast<ExternalMemoryImageCreateInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ExternalMemoryImageCreateInfo &
                            operator=( ExternalMemoryImageCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ExternalMemoryImageCreateInfo & operator=( VkExternalMemoryImageCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ExternalMemoryImageCreateInfo const *>( &rhs );
      return *this;
    }

    ExternalMemoryImageCreateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ExternalMemoryImageCreateInfo &
      setHandleTypes( VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlags handleTypes_ ) VULKAN_HPP_NOEXCEPT
    {
      handleTypes = handleTypes_;
      return *this;
    }

    operator VkExternalMemoryImageCreateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkExternalMemoryImageCreateInfo *>( this );
    }

    operator VkExternalMemoryImageCreateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkExternalMemoryImageCreateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ExternalMemoryImageCreateInfo const & ) const = default;
#else
    bool operator==( ExternalMemoryImageCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( handleTypes == rhs.handleTypes );
    }

    bool operator!=( ExternalMemoryImageCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                 sType       = StructureType::eExternalMemoryImageCreateInfo;
    const void *                                        pNext       = {};
    VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlags handleTypes = {};
  };
  static_assert( sizeof( ExternalMemoryImageCreateInfo ) == sizeof( VkExternalMemoryImageCreateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ExternalMemoryImageCreateInfo>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eExternalMemoryImageCreateInfo>
  {
    using Type = ExternalMemoryImageCreateInfo;
  };
  using ExternalMemoryImageCreateInfoKHR = ExternalMemoryImageCreateInfo;

  struct ExternalMemoryImageCreateInfoNV
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eExternalMemoryImageCreateInfoNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ExternalMemoryImageCreateInfoNV(
      VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagsNV handleTypes_ = {} ) VULKAN_HPP_NOEXCEPT
      : handleTypes( handleTypes_ )
    {}

    VULKAN_HPP_CONSTEXPR
      ExternalMemoryImageCreateInfoNV( ExternalMemoryImageCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ExternalMemoryImageCreateInfoNV( VkExternalMemoryImageCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
      : ExternalMemoryImageCreateInfoNV( *reinterpret_cast<ExternalMemoryImageCreateInfoNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ExternalMemoryImageCreateInfoNV &
                            operator=( ExternalMemoryImageCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ExternalMemoryImageCreateInfoNV & operator=( VkExternalMemoryImageCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ExternalMemoryImageCreateInfoNV const *>( &rhs );
      return *this;
    }

    ExternalMemoryImageCreateInfoNV & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ExternalMemoryImageCreateInfoNV &
      setHandleTypes( VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagsNV handleTypes_ ) VULKAN_HPP_NOEXCEPT
    {
      handleTypes = handleTypes_;
      return *this;
    }

    operator VkExternalMemoryImageCreateInfoNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkExternalMemoryImageCreateInfoNV *>( this );
    }

    operator VkExternalMemoryImageCreateInfoNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkExternalMemoryImageCreateInfoNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ExternalMemoryImageCreateInfoNV const & ) const = default;
#else
    bool operator==( ExternalMemoryImageCreateInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( handleTypes == rhs.handleTypes );
    }

    bool operator!=( ExternalMemoryImageCreateInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                   sType       = StructureType::eExternalMemoryImageCreateInfoNV;
    const void *                                          pNext       = {};
    VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagsNV handleTypes = {};
  };
  static_assert( sizeof( ExternalMemoryImageCreateInfoNV ) == sizeof( VkExternalMemoryImageCreateInfoNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ExternalMemoryImageCreateInfoNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eExternalMemoryImageCreateInfoNV>
  {
    using Type = ExternalMemoryImageCreateInfoNV;
  };

  struct ExternalSemaphoreProperties
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eExternalSemaphoreProperties;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ExternalSemaphoreProperties(
      VULKAN_HPP_NAMESPACE::ExternalSemaphoreHandleTypeFlags exportFromImportedHandleTypes_ = {},
      VULKAN_HPP_NAMESPACE::ExternalSemaphoreHandleTypeFlags compatibleHandleTypes_         = {},
      VULKAN_HPP_NAMESPACE::ExternalSemaphoreFeatureFlags    externalSemaphoreFeatures_     = {} ) VULKAN_HPP_NOEXCEPT
      : exportFromImportedHandleTypes( exportFromImportedHandleTypes_ )
      , compatibleHandleTypes( compatibleHandleTypes_ )
      , externalSemaphoreFeatures( externalSemaphoreFeatures_ )
    {}

    VULKAN_HPP_CONSTEXPR
      ExternalSemaphoreProperties( ExternalSemaphoreProperties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ExternalSemaphoreProperties( VkExternalSemaphoreProperties const & rhs ) VULKAN_HPP_NOEXCEPT
      : ExternalSemaphoreProperties( *reinterpret_cast<ExternalSemaphoreProperties const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ExternalSemaphoreProperties &
                            operator=( ExternalSemaphoreProperties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ExternalSemaphoreProperties & operator=( VkExternalSemaphoreProperties const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ExternalSemaphoreProperties const *>( &rhs );
      return *this;
    }

    operator VkExternalSemaphoreProperties const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkExternalSemaphoreProperties *>( this );
    }

    operator VkExternalSemaphoreProperties &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkExternalSemaphoreProperties *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ExternalSemaphoreProperties const & ) const = default;
#else
    bool operator==( ExternalSemaphoreProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( exportFromImportedHandleTypes == rhs.exportFromImportedHandleTypes ) &&
             ( compatibleHandleTypes == rhs.compatibleHandleTypes ) &&
             ( externalSemaphoreFeatures == rhs.externalSemaphoreFeatures );
    }

    bool operator!=( ExternalSemaphoreProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                    sType = StructureType::eExternalSemaphoreProperties;
    void *                                                 pNext = {};
    VULKAN_HPP_NAMESPACE::ExternalSemaphoreHandleTypeFlags exportFromImportedHandleTypes = {};
    VULKAN_HPP_NAMESPACE::ExternalSemaphoreHandleTypeFlags compatibleHandleTypes         = {};
    VULKAN_HPP_NAMESPACE::ExternalSemaphoreFeatureFlags    externalSemaphoreFeatures     = {};
  };
  static_assert( sizeof( ExternalSemaphoreProperties ) == sizeof( VkExternalSemaphoreProperties ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ExternalSemaphoreProperties>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eExternalSemaphoreProperties>
  {
    using Type = ExternalSemaphoreProperties;
  };
  using ExternalSemaphorePropertiesKHR = ExternalSemaphoreProperties;

  struct FenceCreateInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eFenceCreateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR FenceCreateInfo( VULKAN_HPP_NAMESPACE::FenceCreateFlags flags_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
    {}

    VULKAN_HPP_CONSTEXPR FenceCreateInfo( FenceCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    FenceCreateInfo( VkFenceCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : FenceCreateInfo( *reinterpret_cast<FenceCreateInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 FenceCreateInfo & operator=( FenceCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    FenceCreateInfo & operator=( VkFenceCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::FenceCreateInfo const *>( &rhs );
      return *this;
    }

    FenceCreateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    FenceCreateInfo & setFlags( VULKAN_HPP_NAMESPACE::FenceCreateFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    operator VkFenceCreateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkFenceCreateInfo *>( this );
    }

    operator VkFenceCreateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkFenceCreateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( FenceCreateInfo const & ) const = default;
#else
    bool operator==( FenceCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags );
    }

    bool operator!=( FenceCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType    sType = StructureType::eFenceCreateInfo;
    const void *                           pNext = {};
    VULKAN_HPP_NAMESPACE::FenceCreateFlags flags = {};
  };
  static_assert( sizeof( FenceCreateInfo ) == sizeof( VkFenceCreateInfo ), "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<FenceCreateInfo>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eFenceCreateInfo>
  {
    using Type = FenceCreateInfo;
  };

  struct FenceGetFdInfoKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eFenceGetFdInfoKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      FenceGetFdInfoKHR( VULKAN_HPP_NAMESPACE::Fence                           fence_ = {},
                         VULKAN_HPP_NAMESPACE::ExternalFenceHandleTypeFlagBits handleType_ =
                           VULKAN_HPP_NAMESPACE::ExternalFenceHandleTypeFlagBits::eOpaqueFd ) VULKAN_HPP_NOEXCEPT
      : fence( fence_ )
      , handleType( handleType_ )
    {}

    VULKAN_HPP_CONSTEXPR FenceGetFdInfoKHR( FenceGetFdInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    FenceGetFdInfoKHR( VkFenceGetFdInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : FenceGetFdInfoKHR( *reinterpret_cast<FenceGetFdInfoKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 FenceGetFdInfoKHR &
                            operator=( FenceGetFdInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    FenceGetFdInfoKHR & operator=( VkFenceGetFdInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::FenceGetFdInfoKHR const *>( &rhs );
      return *this;
    }

    FenceGetFdInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    FenceGetFdInfoKHR & setFence( VULKAN_HPP_NAMESPACE::Fence fence_ ) VULKAN_HPP_NOEXCEPT
    {
      fence = fence_;
      return *this;
    }

    FenceGetFdInfoKHR &
      setHandleType( VULKAN_HPP_NAMESPACE::ExternalFenceHandleTypeFlagBits handleType_ ) VULKAN_HPP_NOEXCEPT
    {
      handleType = handleType_;
      return *this;
    }

    operator VkFenceGetFdInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkFenceGetFdInfoKHR *>( this );
    }

    operator VkFenceGetFdInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkFenceGetFdInfoKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( FenceGetFdInfoKHR const & ) const = default;
#else
    bool operator==( FenceGetFdInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( fence == rhs.fence ) &&
             ( handleType == rhs.handleType );
    }

    bool operator!=( FenceGetFdInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                   sType = StructureType::eFenceGetFdInfoKHR;
    const void *                                          pNext = {};
    VULKAN_HPP_NAMESPACE::Fence                           fence = {};
    VULKAN_HPP_NAMESPACE::ExternalFenceHandleTypeFlagBits handleType =
      VULKAN_HPP_NAMESPACE::ExternalFenceHandleTypeFlagBits::eOpaqueFd;
  };
  static_assert( sizeof( FenceGetFdInfoKHR ) == sizeof( VkFenceGetFdInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<FenceGetFdInfoKHR>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eFenceGetFdInfoKHR>
  {
    using Type = FenceGetFdInfoKHR;
  };

#if defined( VK_USE_PLATFORM_WIN32_KHR )
  struct FenceGetWin32HandleInfoKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eFenceGetWin32HandleInfoKHR;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR FenceGetWin32HandleInfoKHR(
      VULKAN_HPP_NAMESPACE::Fence                           fence_ = {},
      VULKAN_HPP_NAMESPACE::ExternalFenceHandleTypeFlagBits handleType_ =
        VULKAN_HPP_NAMESPACE::ExternalFenceHandleTypeFlagBits::eOpaqueFd ) VULKAN_HPP_NOEXCEPT
      : fence( fence_ )
      , handleType( handleType_ )
    {}

    VULKAN_HPP_CONSTEXPR
      FenceGetWin32HandleInfoKHR( FenceGetWin32HandleInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    FenceGetWin32HandleInfoKHR( VkFenceGetWin32HandleInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : FenceGetWin32HandleInfoKHR( *reinterpret_cast<FenceGetWin32HandleInfoKHR const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 FenceGetWin32HandleInfoKHR &
                            operator=( FenceGetWin32HandleInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    FenceGetWin32HandleInfoKHR & operator=( VkFenceGetWin32HandleInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::FenceGetWin32HandleInfoKHR const *>( &rhs );
      return *this;
    }

    FenceGetWin32HandleInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    FenceGetWin32HandleInfoKHR & setFence( VULKAN_HPP_NAMESPACE::Fence fence_ ) VULKAN_HPP_NOEXCEPT
    {
      fence = fence_;
      return *this;
    }

    FenceGetWin32HandleInfoKHR &
      setHandleType( VULKAN_HPP_NAMESPACE::ExternalFenceHandleTypeFlagBits handleType_ ) VULKAN_HPP_NOEXCEPT
    {
      handleType = handleType_;
      return *this;
    }

    operator VkFenceGetWin32HandleInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkFenceGetWin32HandleInfoKHR *>( this );
    }

    operator VkFenceGetWin32HandleInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkFenceGetWin32HandleInfoKHR *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( FenceGetWin32HandleInfoKHR const & ) const = default;
#  else
    bool operator==( FenceGetWin32HandleInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( fence == rhs.fence ) &&
             ( handleType == rhs.handleType );
    }

    bool operator!=( FenceGetWin32HandleInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                   sType = StructureType::eFenceGetWin32HandleInfoKHR;
    const void *                                          pNext = {};
    VULKAN_HPP_NAMESPACE::Fence                           fence = {};
    VULKAN_HPP_NAMESPACE::ExternalFenceHandleTypeFlagBits handleType =
      VULKAN_HPP_NAMESPACE::ExternalFenceHandleTypeFlagBits::eOpaqueFd;
  };
  static_assert( sizeof( FenceGetWin32HandleInfoKHR ) == sizeof( VkFenceGetWin32HandleInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<FenceGetWin32HandleInfoKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eFenceGetWin32HandleInfoKHR>
  {
    using Type = FenceGetWin32HandleInfoKHR;
  };
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

  struct FilterCubicImageViewImageFormatPropertiesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eFilterCubicImageViewImageFormatPropertiesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR FilterCubicImageViewImageFormatPropertiesEXT(
      VULKAN_HPP_NAMESPACE::Bool32 filterCubic_       = {},
      VULKAN_HPP_NAMESPACE::Bool32 filterCubicMinmax_ = {} ) VULKAN_HPP_NOEXCEPT
      : filterCubic( filterCubic_ )
      , filterCubicMinmax( filterCubicMinmax_ )
    {}

    VULKAN_HPP_CONSTEXPR FilterCubicImageViewImageFormatPropertiesEXT(
      FilterCubicImageViewImageFormatPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    FilterCubicImageViewImageFormatPropertiesEXT( VkFilterCubicImageViewImageFormatPropertiesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : FilterCubicImageViewImageFormatPropertiesEXT(
          *reinterpret_cast<FilterCubicImageViewImageFormatPropertiesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 FilterCubicImageViewImageFormatPropertiesEXT &
                            operator=( FilterCubicImageViewImageFormatPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    FilterCubicImageViewImageFormatPropertiesEXT &
      operator=( VkFilterCubicImageViewImageFormatPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::FilterCubicImageViewImageFormatPropertiesEXT const *>( &rhs );
      return *this;
    }

    operator VkFilterCubicImageViewImageFormatPropertiesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkFilterCubicImageViewImageFormatPropertiesEXT *>( this );
    }

    operator VkFilterCubicImageViewImageFormatPropertiesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkFilterCubicImageViewImageFormatPropertiesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( FilterCubicImageViewImageFormatPropertiesEXT const & ) const = default;
#else
    bool operator==( FilterCubicImageViewImageFormatPropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( filterCubic == rhs.filterCubic ) &&
             ( filterCubicMinmax == rhs.filterCubicMinmax );
    }

    bool operator!=( FilterCubicImageViewImageFormatPropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType       = StructureType::eFilterCubicImageViewImageFormatPropertiesEXT;
    void *                              pNext       = {};
    VULKAN_HPP_NAMESPACE::Bool32        filterCubic = {};
    VULKAN_HPP_NAMESPACE::Bool32        filterCubicMinmax = {};
  };
  static_assert( sizeof( FilterCubicImageViewImageFormatPropertiesEXT ) ==
                   sizeof( VkFilterCubicImageViewImageFormatPropertiesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<FilterCubicImageViewImageFormatPropertiesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eFilterCubicImageViewImageFormatPropertiesEXT>
  {
    using Type = FilterCubicImageViewImageFormatPropertiesEXT;
  };

  struct FormatProperties
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      FormatProperties( VULKAN_HPP_NAMESPACE::FormatFeatureFlags linearTilingFeatures_  = {},
                        VULKAN_HPP_NAMESPACE::FormatFeatureFlags optimalTilingFeatures_ = {},
                        VULKAN_HPP_NAMESPACE::FormatFeatureFlags bufferFeatures_        = {} ) VULKAN_HPP_NOEXCEPT
      : linearTilingFeatures( linearTilingFeatures_ )
      , optimalTilingFeatures( optimalTilingFeatures_ )
      , bufferFeatures( bufferFeatures_ )
    {}

    VULKAN_HPP_CONSTEXPR FormatProperties( FormatProperties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    FormatProperties( VkFormatProperties const & rhs ) VULKAN_HPP_NOEXCEPT
      : FormatProperties( *reinterpret_cast<FormatProperties const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 FormatProperties & operator=( FormatProperties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    FormatProperties & operator=( VkFormatProperties const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::FormatProperties const *>( &rhs );
      return *this;
    }

    operator VkFormatProperties const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkFormatProperties *>( this );
    }

    operator VkFormatProperties &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkFormatProperties *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( FormatProperties const & ) const = default;
#else
    bool operator==( FormatProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( linearTilingFeatures == rhs.linearTilingFeatures ) &&
             ( optimalTilingFeatures == rhs.optimalTilingFeatures ) && ( bufferFeatures == rhs.bufferFeatures );
    }

    bool operator!=( FormatProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::FormatFeatureFlags linearTilingFeatures  = {};
    VULKAN_HPP_NAMESPACE::FormatFeatureFlags optimalTilingFeatures = {};
    VULKAN_HPP_NAMESPACE::FormatFeatureFlags bufferFeatures        = {};
  };
  static_assert( sizeof( FormatProperties ) == sizeof( VkFormatProperties ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<FormatProperties>::value, "struct wrapper is not a standard layout!" );

  struct FormatProperties2
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eFormatProperties2;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      FormatProperties2( VULKAN_HPP_NAMESPACE::FormatProperties formatProperties_ = {} ) VULKAN_HPP_NOEXCEPT
      : formatProperties( formatProperties_ )
    {}

    VULKAN_HPP_CONSTEXPR FormatProperties2( FormatProperties2 const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    FormatProperties2( VkFormatProperties2 const & rhs ) VULKAN_HPP_NOEXCEPT
      : FormatProperties2( *reinterpret_cast<FormatProperties2 const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 FormatProperties2 &
                            operator=( FormatProperties2 const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    FormatProperties2 & operator=( VkFormatProperties2 const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::FormatProperties2 const *>( &rhs );
      return *this;
    }

    operator VkFormatProperties2 const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkFormatProperties2 *>( this );
    }

    operator VkFormatProperties2 &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkFormatProperties2 *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( FormatProperties2 const & ) const = default;
#else
    bool operator==( FormatProperties2 const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( formatProperties == rhs.formatProperties );
    }

    bool operator!=( FormatProperties2 const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType    sType            = StructureType::eFormatProperties2;
    void *                                 pNext            = {};
    VULKAN_HPP_NAMESPACE::FormatProperties formatProperties = {};
  };
  static_assert( sizeof( FormatProperties2 ) == sizeof( VkFormatProperties2 ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<FormatProperties2>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eFormatProperties2>
  {
    using Type = FormatProperties2;
  };
  using FormatProperties2KHR = FormatProperties2;

  struct FragmentShadingRateAttachmentInfoKHR
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eFragmentShadingRateAttachmentInfoKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR FragmentShadingRateAttachmentInfoKHR(
      const VULKAN_HPP_NAMESPACE::AttachmentReference2 * pFragmentShadingRateAttachment_ = {},
      VULKAN_HPP_NAMESPACE::Extent2D                     shadingRateAttachmentTexelSize_ = {} ) VULKAN_HPP_NOEXCEPT
      : pFragmentShadingRateAttachment( pFragmentShadingRateAttachment_ )
      , shadingRateAttachmentTexelSize( shadingRateAttachmentTexelSize_ )
    {}

    VULKAN_HPP_CONSTEXPR FragmentShadingRateAttachmentInfoKHR( FragmentShadingRateAttachmentInfoKHR const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    FragmentShadingRateAttachmentInfoKHR( VkFragmentShadingRateAttachmentInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : FragmentShadingRateAttachmentInfoKHR( *reinterpret_cast<FragmentShadingRateAttachmentInfoKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 FragmentShadingRateAttachmentInfoKHR &
                            operator=( FragmentShadingRateAttachmentInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    FragmentShadingRateAttachmentInfoKHR &
      operator=( VkFragmentShadingRateAttachmentInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::FragmentShadingRateAttachmentInfoKHR const *>( &rhs );
      return *this;
    }

    FragmentShadingRateAttachmentInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    FragmentShadingRateAttachmentInfoKHR & setPFragmentShadingRateAttachment(
      const VULKAN_HPP_NAMESPACE::AttachmentReference2 * pFragmentShadingRateAttachment_ ) VULKAN_HPP_NOEXCEPT
    {
      pFragmentShadingRateAttachment = pFragmentShadingRateAttachment_;
      return *this;
    }

    FragmentShadingRateAttachmentInfoKHR & setShadingRateAttachmentTexelSize(
      VULKAN_HPP_NAMESPACE::Extent2D const & shadingRateAttachmentTexelSize_ ) VULKAN_HPP_NOEXCEPT
    {
      shadingRateAttachmentTexelSize = shadingRateAttachmentTexelSize_;
      return *this;
    }

    operator VkFragmentShadingRateAttachmentInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkFragmentShadingRateAttachmentInfoKHR *>( this );
    }

    operator VkFragmentShadingRateAttachmentInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkFragmentShadingRateAttachmentInfoKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( FragmentShadingRateAttachmentInfoKHR const & ) const = default;
#else
    bool operator==( FragmentShadingRateAttachmentInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( pFragmentShadingRateAttachment == rhs.pFragmentShadingRateAttachment ) &&
             ( shadingRateAttachmentTexelSize == rhs.shadingRateAttachmentTexelSize );
    }

    bool operator!=( FragmentShadingRateAttachmentInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                sType = StructureType::eFragmentShadingRateAttachmentInfoKHR;
    const void *                                       pNext = {};
    const VULKAN_HPP_NAMESPACE::AttachmentReference2 * pFragmentShadingRateAttachment = {};
    VULKAN_HPP_NAMESPACE::Extent2D                     shadingRateAttachmentTexelSize = {};
  };
  static_assert( sizeof( FragmentShadingRateAttachmentInfoKHR ) == sizeof( VkFragmentShadingRateAttachmentInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<FragmentShadingRateAttachmentInfoKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eFragmentShadingRateAttachmentInfoKHR>
  {
    using Type = FragmentShadingRateAttachmentInfoKHR;
  };

  struct FramebufferAttachmentImageInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eFramebufferAttachmentImageInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      FramebufferAttachmentImageInfo( VULKAN_HPP_NAMESPACE::ImageCreateFlags flags_           = {},
                                      VULKAN_HPP_NAMESPACE::ImageUsageFlags  usage_           = {},
                                      uint32_t                               width_           = {},
                                      uint32_t                               height_          = {},
                                      uint32_t                               layerCount_      = {},
                                      uint32_t                               viewFormatCount_ = {},
                                      const VULKAN_HPP_NAMESPACE::Format *   pViewFormats_    = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , usage( usage_ )
      , width( width_ )
      , height( height_ )
      , layerCount( layerCount_ )
      , viewFormatCount( viewFormatCount_ )
      , pViewFormats( pViewFormats_ )
    {}

    VULKAN_HPP_CONSTEXPR
      FramebufferAttachmentImageInfo( FramebufferAttachmentImageInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    FramebufferAttachmentImageInfo( VkFramebufferAttachmentImageInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : FramebufferAttachmentImageInfo( *reinterpret_cast<FramebufferAttachmentImageInfo const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    FramebufferAttachmentImageInfo(
      VULKAN_HPP_NAMESPACE::ImageCreateFlags                                                    flags_,
      VULKAN_HPP_NAMESPACE::ImageUsageFlags                                                     usage_,
      uint32_t                                                                                  width_,
      uint32_t                                                                                  height_,
      uint32_t                                                                                  layerCount_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::Format> const & viewFormats_ )
      : flags( flags_ )
      , usage( usage_ )
      , width( width_ )
      , height( height_ )
      , layerCount( layerCount_ )
      , viewFormatCount( static_cast<uint32_t>( viewFormats_.size() ) )
      , pViewFormats( viewFormats_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 FramebufferAttachmentImageInfo &
                            operator=( FramebufferAttachmentImageInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    FramebufferAttachmentImageInfo & operator=( VkFramebufferAttachmentImageInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::FramebufferAttachmentImageInfo const *>( &rhs );
      return *this;
    }

    FramebufferAttachmentImageInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    FramebufferAttachmentImageInfo & setFlags( VULKAN_HPP_NAMESPACE::ImageCreateFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    FramebufferAttachmentImageInfo & setUsage( VULKAN_HPP_NAMESPACE::ImageUsageFlags usage_ ) VULKAN_HPP_NOEXCEPT
    {
      usage = usage_;
      return *this;
    }

    FramebufferAttachmentImageInfo & setWidth( uint32_t width_ ) VULKAN_HPP_NOEXCEPT
    {
      width = width_;
      return *this;
    }

    FramebufferAttachmentImageInfo & setHeight( uint32_t height_ ) VULKAN_HPP_NOEXCEPT
    {
      height = height_;
      return *this;
    }

    FramebufferAttachmentImageInfo & setLayerCount( uint32_t layerCount_ ) VULKAN_HPP_NOEXCEPT
    {
      layerCount = layerCount_;
      return *this;
    }

    FramebufferAttachmentImageInfo & setViewFormatCount( uint32_t viewFormatCount_ ) VULKAN_HPP_NOEXCEPT
    {
      viewFormatCount = viewFormatCount_;
      return *this;
    }

    FramebufferAttachmentImageInfo &
      setPViewFormats( const VULKAN_HPP_NAMESPACE::Format * pViewFormats_ ) VULKAN_HPP_NOEXCEPT
    {
      pViewFormats = pViewFormats_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    FramebufferAttachmentImageInfo & setViewFormats(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::Format> const & viewFormats_ )
      VULKAN_HPP_NOEXCEPT
    {
      viewFormatCount = static_cast<uint32_t>( viewFormats_.size() );
      pViewFormats    = viewFormats_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkFramebufferAttachmentImageInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkFramebufferAttachmentImageInfo *>( this );
    }

    operator VkFramebufferAttachmentImageInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkFramebufferAttachmentImageInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( FramebufferAttachmentImageInfo const & ) const = default;
#else
    bool operator==( FramebufferAttachmentImageInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) && ( usage == rhs.usage ) &&
             ( width == rhs.width ) && ( height == rhs.height ) && ( layerCount == rhs.layerCount ) &&
             ( viewFormatCount == rhs.viewFormatCount ) && ( pViewFormats == rhs.pViewFormats );
    }

    bool operator!=( FramebufferAttachmentImageInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType    sType           = StructureType::eFramebufferAttachmentImageInfo;
    const void *                           pNext           = {};
    VULKAN_HPP_NAMESPACE::ImageCreateFlags flags           = {};
    VULKAN_HPP_NAMESPACE::ImageUsageFlags  usage           = {};
    uint32_t                               width           = {};
    uint32_t                               height          = {};
    uint32_t                               layerCount      = {};
    uint32_t                               viewFormatCount = {};
    const VULKAN_HPP_NAMESPACE::Format *   pViewFormats    = {};
  };
  static_assert( sizeof( FramebufferAttachmentImageInfo ) == sizeof( VkFramebufferAttachmentImageInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<FramebufferAttachmentImageInfo>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eFramebufferAttachmentImageInfo>
  {
    using Type = FramebufferAttachmentImageInfo;
  };
  using FramebufferAttachmentImageInfoKHR = FramebufferAttachmentImageInfo;

  struct FramebufferAttachmentsCreateInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eFramebufferAttachmentsCreateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR FramebufferAttachmentsCreateInfo(
      uint32_t                                                     attachmentImageInfoCount_ = {},
      const VULKAN_HPP_NAMESPACE::FramebufferAttachmentImageInfo * pAttachmentImageInfos_    = {} ) VULKAN_HPP_NOEXCEPT
      : attachmentImageInfoCount( attachmentImageInfoCount_ )
      , pAttachmentImageInfos( pAttachmentImageInfos_ )
    {}

    VULKAN_HPP_CONSTEXPR
      FramebufferAttachmentsCreateInfo( FramebufferAttachmentsCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    FramebufferAttachmentsCreateInfo( VkFramebufferAttachmentsCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : FramebufferAttachmentsCreateInfo( *reinterpret_cast<FramebufferAttachmentsCreateInfo const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    FramebufferAttachmentsCreateInfo(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::FramebufferAttachmentImageInfo> const &
        attachmentImageInfos_ )
      : attachmentImageInfoCount( static_cast<uint32_t>( attachmentImageInfos_.size() ) )
      , pAttachmentImageInfos( attachmentImageInfos_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 FramebufferAttachmentsCreateInfo &
                            operator=( FramebufferAttachmentsCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    FramebufferAttachmentsCreateInfo & operator=( VkFramebufferAttachmentsCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::FramebufferAttachmentsCreateInfo const *>( &rhs );
      return *this;
    }

    FramebufferAttachmentsCreateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    FramebufferAttachmentsCreateInfo &
      setAttachmentImageInfoCount( uint32_t attachmentImageInfoCount_ ) VULKAN_HPP_NOEXCEPT
    {
      attachmentImageInfoCount = attachmentImageInfoCount_;
      return *this;
    }

    FramebufferAttachmentsCreateInfo & setPAttachmentImageInfos(
      const VULKAN_HPP_NAMESPACE::FramebufferAttachmentImageInfo * pAttachmentImageInfos_ ) VULKAN_HPP_NOEXCEPT
    {
      pAttachmentImageInfos = pAttachmentImageInfos_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    FramebufferAttachmentsCreateInfo & setAttachmentImageInfos(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::FramebufferAttachmentImageInfo> const &
        attachmentImageInfos_ ) VULKAN_HPP_NOEXCEPT
    {
      attachmentImageInfoCount = static_cast<uint32_t>( attachmentImageInfos_.size() );
      pAttachmentImageInfos    = attachmentImageInfos_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkFramebufferAttachmentsCreateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkFramebufferAttachmentsCreateInfo *>( this );
    }

    operator VkFramebufferAttachmentsCreateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkFramebufferAttachmentsCreateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( FramebufferAttachmentsCreateInfo const & ) const = default;
#else
    bool operator==( FramebufferAttachmentsCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( attachmentImageInfoCount == rhs.attachmentImageInfoCount ) &&
             ( pAttachmentImageInfos == rhs.pAttachmentImageInfos );
    }

    bool operator!=( FramebufferAttachmentsCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType                    = StructureType::eFramebufferAttachmentsCreateInfo;
    const void *                        pNext                    = {};
    uint32_t                            attachmentImageInfoCount = {};
    const VULKAN_HPP_NAMESPACE::FramebufferAttachmentImageInfo * pAttachmentImageInfos = {};
  };
  static_assert( sizeof( FramebufferAttachmentsCreateInfo ) == sizeof( VkFramebufferAttachmentsCreateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<FramebufferAttachmentsCreateInfo>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eFramebufferAttachmentsCreateInfo>
  {
    using Type = FramebufferAttachmentsCreateInfo;
  };
  using FramebufferAttachmentsCreateInfoKHR = FramebufferAttachmentsCreateInfo;

  struct FramebufferCreateInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eFramebufferCreateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR FramebufferCreateInfo( VULKAN_HPP_NAMESPACE::FramebufferCreateFlags flags_           = {},
                                                VULKAN_HPP_NAMESPACE::RenderPass             renderPass_      = {},
                                                uint32_t                                     attachmentCount_ = {},
                                                const VULKAN_HPP_NAMESPACE::ImageView *      pAttachments_    = {},
                                                uint32_t                                     width_           = {},
                                                uint32_t                                     height_          = {},
                                                uint32_t layers_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , renderPass( renderPass_ )
      , attachmentCount( attachmentCount_ )
      , pAttachments( pAttachments_ )
      , width( width_ )
      , height( height_ )
      , layers( layers_ )
    {}

    VULKAN_HPP_CONSTEXPR FramebufferCreateInfo( FramebufferCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    FramebufferCreateInfo( VkFramebufferCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : FramebufferCreateInfo( *reinterpret_cast<FramebufferCreateInfo const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    FramebufferCreateInfo(
      VULKAN_HPP_NAMESPACE::FramebufferCreateFlags                                                 flags_,
      VULKAN_HPP_NAMESPACE::RenderPass                                                             renderPass_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::ImageView> const & attachments_,
      uint32_t                                                                                     width_  = {},
      uint32_t                                                                                     height_ = {},
      uint32_t                                                                                     layers_ = {} )
      : flags( flags_ )
      , renderPass( renderPass_ )
      , attachmentCount( static_cast<uint32_t>( attachments_.size() ) )
      , pAttachments( attachments_.data() )
      , width( width_ )
      , height( height_ )
      , layers( layers_ )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 FramebufferCreateInfo &
                            operator=( FramebufferCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    FramebufferCreateInfo & operator=( VkFramebufferCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::FramebufferCreateInfo const *>( &rhs );
      return *this;
    }

    FramebufferCreateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    FramebufferCreateInfo & setFlags( VULKAN_HPP_NAMESPACE::FramebufferCreateFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    FramebufferCreateInfo & setRenderPass( VULKAN_HPP_NAMESPACE::RenderPass renderPass_ ) VULKAN_HPP_NOEXCEPT
    {
      renderPass = renderPass_;
      return *this;
    }

    FramebufferCreateInfo & setAttachmentCount( uint32_t attachmentCount_ ) VULKAN_HPP_NOEXCEPT
    {
      attachmentCount = attachmentCount_;
      return *this;
    }

    FramebufferCreateInfo & setPAttachments( const VULKAN_HPP_NAMESPACE::ImageView * pAttachments_ ) VULKAN_HPP_NOEXCEPT
    {
      pAttachments = pAttachments_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    FramebufferCreateInfo & setAttachments(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::ImageView> const & attachments_ )
      VULKAN_HPP_NOEXCEPT
    {
      attachmentCount = static_cast<uint32_t>( attachments_.size() );
      pAttachments    = attachments_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    FramebufferCreateInfo & setWidth( uint32_t width_ ) VULKAN_HPP_NOEXCEPT
    {
      width = width_;
      return *this;
    }

    FramebufferCreateInfo & setHeight( uint32_t height_ ) VULKAN_HPP_NOEXCEPT
    {
      height = height_;
      return *this;
    }

    FramebufferCreateInfo & setLayers( uint32_t layers_ ) VULKAN_HPP_NOEXCEPT
    {
      layers = layers_;
      return *this;
    }

    operator VkFramebufferCreateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkFramebufferCreateInfo *>( this );
    }

    operator VkFramebufferCreateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkFramebufferCreateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( FramebufferCreateInfo const & ) const = default;
#else
    bool operator==( FramebufferCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( renderPass == rhs.renderPass ) && ( attachmentCount == rhs.attachmentCount ) &&
             ( pAttachments == rhs.pAttachments ) && ( width == rhs.width ) && ( height == rhs.height ) &&
             ( layers == rhs.layers );
    }

    bool operator!=( FramebufferCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType          sType           = StructureType::eFramebufferCreateInfo;
    const void *                                 pNext           = {};
    VULKAN_HPP_NAMESPACE::FramebufferCreateFlags flags           = {};
    VULKAN_HPP_NAMESPACE::RenderPass             renderPass      = {};
    uint32_t                                     attachmentCount = {};
    const VULKAN_HPP_NAMESPACE::ImageView *      pAttachments    = {};
    uint32_t                                     width           = {};
    uint32_t                                     height          = {};
    uint32_t                                     layers          = {};
  };
  static_assert( sizeof( FramebufferCreateInfo ) == sizeof( VkFramebufferCreateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<FramebufferCreateInfo>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eFramebufferCreateInfo>
  {
    using Type = FramebufferCreateInfo;
  };

  struct FramebufferMixedSamplesCombinationNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eFramebufferMixedSamplesCombinationNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR FramebufferMixedSamplesCombinationNV(
      VULKAN_HPP_NAMESPACE::CoverageReductionModeNV coverageReductionMode_ =
        VULKAN_HPP_NAMESPACE::CoverageReductionModeNV::eMerge,
      VULKAN_HPP_NAMESPACE::SampleCountFlagBits rasterizationSamples_ = VULKAN_HPP_NAMESPACE::SampleCountFlagBits::e1,
      VULKAN_HPP_NAMESPACE::SampleCountFlags    depthStencilSamples_  = {},
      VULKAN_HPP_NAMESPACE::SampleCountFlags    colorSamples_         = {} ) VULKAN_HPP_NOEXCEPT
      : coverageReductionMode( coverageReductionMode_ )
      , rasterizationSamples( rasterizationSamples_ )
      , depthStencilSamples( depthStencilSamples_ )
      , colorSamples( colorSamples_ )
    {}

    VULKAN_HPP_CONSTEXPR FramebufferMixedSamplesCombinationNV( FramebufferMixedSamplesCombinationNV const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    FramebufferMixedSamplesCombinationNV( VkFramebufferMixedSamplesCombinationNV const & rhs ) VULKAN_HPP_NOEXCEPT
      : FramebufferMixedSamplesCombinationNV( *reinterpret_cast<FramebufferMixedSamplesCombinationNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 FramebufferMixedSamplesCombinationNV &
                            operator=( FramebufferMixedSamplesCombinationNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    FramebufferMixedSamplesCombinationNV &
      operator=( VkFramebufferMixedSamplesCombinationNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::FramebufferMixedSamplesCombinationNV const *>( &rhs );
      return *this;
    }

    operator VkFramebufferMixedSamplesCombinationNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkFramebufferMixedSamplesCombinationNV *>( this );
    }

    operator VkFramebufferMixedSamplesCombinationNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkFramebufferMixedSamplesCombinationNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( FramebufferMixedSamplesCombinationNV const & ) const = default;
#else
    bool operator==( FramebufferMixedSamplesCombinationNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( coverageReductionMode == rhs.coverageReductionMode ) &&
             ( rasterizationSamples == rhs.rasterizationSamples ) &&
             ( depthStencilSamples == rhs.depthStencilSamples ) && ( colorSamples == rhs.colorSamples );
    }

    bool operator!=( FramebufferMixedSamplesCombinationNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType           sType = StructureType::eFramebufferMixedSamplesCombinationNV;
    void *                                        pNext = {};
    VULKAN_HPP_NAMESPACE::CoverageReductionModeNV coverageReductionMode =
      VULKAN_HPP_NAMESPACE::CoverageReductionModeNV::eMerge;
    VULKAN_HPP_NAMESPACE::SampleCountFlagBits rasterizationSamples = VULKAN_HPP_NAMESPACE::SampleCountFlagBits::e1;
    VULKAN_HPP_NAMESPACE::SampleCountFlags    depthStencilSamples  = {};
    VULKAN_HPP_NAMESPACE::SampleCountFlags    colorSamples         = {};
  };
  static_assert( sizeof( FramebufferMixedSamplesCombinationNV ) == sizeof( VkFramebufferMixedSamplesCombinationNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<FramebufferMixedSamplesCombinationNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eFramebufferMixedSamplesCombinationNV>
  {
    using Type = FramebufferMixedSamplesCombinationNV;
  };

  struct IndirectCommandsStreamNV
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR IndirectCommandsStreamNV( VULKAN_HPP_NAMESPACE::Buffer     buffer_ = {},
                                                   VULKAN_HPP_NAMESPACE::DeviceSize offset_ = {} ) VULKAN_HPP_NOEXCEPT
      : buffer( buffer_ )
      , offset( offset_ )
    {}

    VULKAN_HPP_CONSTEXPR IndirectCommandsStreamNV( IndirectCommandsStreamNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    IndirectCommandsStreamNV( VkIndirectCommandsStreamNV const & rhs ) VULKAN_HPP_NOEXCEPT
      : IndirectCommandsStreamNV( *reinterpret_cast<IndirectCommandsStreamNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 IndirectCommandsStreamNV &
                            operator=( IndirectCommandsStreamNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    IndirectCommandsStreamNV & operator=( VkIndirectCommandsStreamNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::IndirectCommandsStreamNV const *>( &rhs );
      return *this;
    }

    IndirectCommandsStreamNV & setBuffer( VULKAN_HPP_NAMESPACE::Buffer buffer_ ) VULKAN_HPP_NOEXCEPT
    {
      buffer = buffer_;
      return *this;
    }

    IndirectCommandsStreamNV & setOffset( VULKAN_HPP_NAMESPACE::DeviceSize offset_ ) VULKAN_HPP_NOEXCEPT
    {
      offset = offset_;
      return *this;
    }

    operator VkIndirectCommandsStreamNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkIndirectCommandsStreamNV *>( this );
    }

    operator VkIndirectCommandsStreamNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkIndirectCommandsStreamNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( IndirectCommandsStreamNV const & ) const = default;
#else
    bool operator==( IndirectCommandsStreamNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( buffer == rhs.buffer ) && ( offset == rhs.offset );
    }

    bool operator!=( IndirectCommandsStreamNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::Buffer     buffer = {};
    VULKAN_HPP_NAMESPACE::DeviceSize offset = {};
  };
  static_assert( sizeof( IndirectCommandsStreamNV ) == sizeof( VkIndirectCommandsStreamNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<IndirectCommandsStreamNV>::value, "struct wrapper is not a standard layout!" );

  struct GeneratedCommandsInfoNV
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eGeneratedCommandsInfoNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR GeneratedCommandsInfoNV(
      VULKAN_HPP_NAMESPACE::PipelineBindPoint pipelineBindPoint_ = VULKAN_HPP_NAMESPACE::PipelineBindPoint::eGraphics,
      VULKAN_HPP_NAMESPACE::Pipeline          pipeline_          = {},
      VULKAN_HPP_NAMESPACE::IndirectCommandsLayoutNV         indirectCommandsLayout_ = {},
      uint32_t                                               streamCount_            = {},
      const VULKAN_HPP_NAMESPACE::IndirectCommandsStreamNV * pStreams_               = {},
      uint32_t                                               sequencesCount_         = {},
      VULKAN_HPP_NAMESPACE::Buffer                           preprocessBuffer_       = {},
      VULKAN_HPP_NAMESPACE::DeviceSize                       preprocessOffset_       = {},
      VULKAN_HPP_NAMESPACE::DeviceSize                       preprocessSize_         = {},
      VULKAN_HPP_NAMESPACE::Buffer                           sequencesCountBuffer_   = {},
      VULKAN_HPP_NAMESPACE::DeviceSize                       sequencesCountOffset_   = {},
      VULKAN_HPP_NAMESPACE::Buffer                           sequencesIndexBuffer_   = {},
      VULKAN_HPP_NAMESPACE::DeviceSize                       sequencesIndexOffset_   = {} ) VULKAN_HPP_NOEXCEPT
      : pipelineBindPoint( pipelineBindPoint_ )
      , pipeline( pipeline_ )
      , indirectCommandsLayout( indirectCommandsLayout_ )
      , streamCount( streamCount_ )
      , pStreams( pStreams_ )
      , sequencesCount( sequencesCount_ )
      , preprocessBuffer( preprocessBuffer_ )
      , preprocessOffset( preprocessOffset_ )
      , preprocessSize( preprocessSize_ )
      , sequencesCountBuffer( sequencesCountBuffer_ )
      , sequencesCountOffset( sequencesCountOffset_ )
      , sequencesIndexBuffer( sequencesIndexBuffer_ )
      , sequencesIndexOffset( sequencesIndexOffset_ )
    {}

    VULKAN_HPP_CONSTEXPR GeneratedCommandsInfoNV( GeneratedCommandsInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    GeneratedCommandsInfoNV( VkGeneratedCommandsInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
      : GeneratedCommandsInfoNV( *reinterpret_cast<GeneratedCommandsInfoNV const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    GeneratedCommandsInfoNV(
      VULKAN_HPP_NAMESPACE::PipelineBindPoint        pipelineBindPoint_,
      VULKAN_HPP_NAMESPACE::Pipeline                 pipeline_,
      VULKAN_HPP_NAMESPACE::IndirectCommandsLayoutNV indirectCommandsLayout_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::IndirectCommandsStreamNV> const &
                                       streams_,
      uint32_t                         sequencesCount_       = {},
      VULKAN_HPP_NAMESPACE::Buffer     preprocessBuffer_     = {},
      VULKAN_HPP_NAMESPACE::DeviceSize preprocessOffset_     = {},
      VULKAN_HPP_NAMESPACE::DeviceSize preprocessSize_       = {},
      VULKAN_HPP_NAMESPACE::Buffer     sequencesCountBuffer_ = {},
      VULKAN_HPP_NAMESPACE::DeviceSize sequencesCountOffset_ = {},
      VULKAN_HPP_NAMESPACE::Buffer     sequencesIndexBuffer_ = {},
      VULKAN_HPP_NAMESPACE::DeviceSize sequencesIndexOffset_ = {} )
      : pipelineBindPoint( pipelineBindPoint_ )
      , pipeline( pipeline_ )
      , indirectCommandsLayout( indirectCommandsLayout_ )
      , streamCount( static_cast<uint32_t>( streams_.size() ) )
      , pStreams( streams_.data() )
      , sequencesCount( sequencesCount_ )
      , preprocessBuffer( preprocessBuffer_ )
      , preprocessOffset( preprocessOffset_ )
      , preprocessSize( preprocessSize_ )
      , sequencesCountBuffer( sequencesCountBuffer_ )
      , sequencesCountOffset( sequencesCountOffset_ )
      , sequencesIndexBuffer( sequencesIndexBuffer_ )
      , sequencesIndexOffset( sequencesIndexOffset_ )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 GeneratedCommandsInfoNV &
                            operator=( GeneratedCommandsInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    GeneratedCommandsInfoNV & operator=( VkGeneratedCommandsInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::GeneratedCommandsInfoNV const *>( &rhs );
      return *this;
    }

    GeneratedCommandsInfoNV & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    GeneratedCommandsInfoNV &
      setPipelineBindPoint( VULKAN_HPP_NAMESPACE::PipelineBindPoint pipelineBindPoint_ ) VULKAN_HPP_NOEXCEPT
    {
      pipelineBindPoint = pipelineBindPoint_;
      return *this;
    }

    GeneratedCommandsInfoNV & setPipeline( VULKAN_HPP_NAMESPACE::Pipeline pipeline_ ) VULKAN_HPP_NOEXCEPT
    {
      pipeline = pipeline_;
      return *this;
    }

    GeneratedCommandsInfoNV & setIndirectCommandsLayout(
      VULKAN_HPP_NAMESPACE::IndirectCommandsLayoutNV indirectCommandsLayout_ ) VULKAN_HPP_NOEXCEPT
    {
      indirectCommandsLayout = indirectCommandsLayout_;
      return *this;
    }

    GeneratedCommandsInfoNV & setStreamCount( uint32_t streamCount_ ) VULKAN_HPP_NOEXCEPT
    {
      streamCount = streamCount_;
      return *this;
    }

    GeneratedCommandsInfoNV &
      setPStreams( const VULKAN_HPP_NAMESPACE::IndirectCommandsStreamNV * pStreams_ ) VULKAN_HPP_NOEXCEPT
    {
      pStreams = pStreams_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    GeneratedCommandsInfoNV & setStreams(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::IndirectCommandsStreamNV> const &
        streams_ ) VULKAN_HPP_NOEXCEPT
    {
      streamCount = static_cast<uint32_t>( streams_.size() );
      pStreams    = streams_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    GeneratedCommandsInfoNV & setSequencesCount( uint32_t sequencesCount_ ) VULKAN_HPP_NOEXCEPT
    {
      sequencesCount = sequencesCount_;
      return *this;
    }

    GeneratedCommandsInfoNV & setPreprocessBuffer( VULKAN_HPP_NAMESPACE::Buffer preprocessBuffer_ ) VULKAN_HPP_NOEXCEPT
    {
      preprocessBuffer = preprocessBuffer_;
      return *this;
    }

    GeneratedCommandsInfoNV &
      setPreprocessOffset( VULKAN_HPP_NAMESPACE::DeviceSize preprocessOffset_ ) VULKAN_HPP_NOEXCEPT
    {
      preprocessOffset = preprocessOffset_;
      return *this;
    }

    GeneratedCommandsInfoNV & setPreprocessSize( VULKAN_HPP_NAMESPACE::DeviceSize preprocessSize_ ) VULKAN_HPP_NOEXCEPT
    {
      preprocessSize = preprocessSize_;
      return *this;
    }

    GeneratedCommandsInfoNV &
      setSequencesCountBuffer( VULKAN_HPP_NAMESPACE::Buffer sequencesCountBuffer_ ) VULKAN_HPP_NOEXCEPT
    {
      sequencesCountBuffer = sequencesCountBuffer_;
      return *this;
    }

    GeneratedCommandsInfoNV &
      setSequencesCountOffset( VULKAN_HPP_NAMESPACE::DeviceSize sequencesCountOffset_ ) VULKAN_HPP_NOEXCEPT
    {
      sequencesCountOffset = sequencesCountOffset_;
      return *this;
    }

    GeneratedCommandsInfoNV &
      setSequencesIndexBuffer( VULKAN_HPP_NAMESPACE::Buffer sequencesIndexBuffer_ ) VULKAN_HPP_NOEXCEPT
    {
      sequencesIndexBuffer = sequencesIndexBuffer_;
      return *this;
    }

    GeneratedCommandsInfoNV &
      setSequencesIndexOffset( VULKAN_HPP_NAMESPACE::DeviceSize sequencesIndexOffset_ ) VULKAN_HPP_NOEXCEPT
    {
      sequencesIndexOffset = sequencesIndexOffset_;
      return *this;
    }

    operator VkGeneratedCommandsInfoNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkGeneratedCommandsInfoNV *>( this );
    }

    operator VkGeneratedCommandsInfoNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkGeneratedCommandsInfoNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( GeneratedCommandsInfoNV const & ) const = default;
#else
    bool operator==( GeneratedCommandsInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( pipelineBindPoint == rhs.pipelineBindPoint ) &&
             ( pipeline == rhs.pipeline ) && ( indirectCommandsLayout == rhs.indirectCommandsLayout ) &&
             ( streamCount == rhs.streamCount ) && ( pStreams == rhs.pStreams ) &&
             ( sequencesCount == rhs.sequencesCount ) && ( preprocessBuffer == rhs.preprocessBuffer ) &&
             ( preprocessOffset == rhs.preprocessOffset ) && ( preprocessSize == rhs.preprocessSize ) &&
             ( sequencesCountBuffer == rhs.sequencesCountBuffer ) &&
             ( sequencesCountOffset == rhs.sequencesCountOffset ) &&
             ( sequencesIndexBuffer == rhs.sequencesIndexBuffer ) &&
             ( sequencesIndexOffset == rhs.sequencesIndexOffset );
    }

    bool operator!=( GeneratedCommandsInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType     sType             = StructureType::eGeneratedCommandsInfoNV;
    const void *                            pNext             = {};
    VULKAN_HPP_NAMESPACE::PipelineBindPoint pipelineBindPoint = VULKAN_HPP_NAMESPACE::PipelineBindPoint::eGraphics;
    VULKAN_HPP_NAMESPACE::Pipeline          pipeline          = {};
    VULKAN_HPP_NAMESPACE::IndirectCommandsLayoutNV         indirectCommandsLayout = {};
    uint32_t                                               streamCount            = {};
    const VULKAN_HPP_NAMESPACE::IndirectCommandsStreamNV * pStreams               = {};
    uint32_t                                               sequencesCount         = {};
    VULKAN_HPP_NAMESPACE::Buffer                           preprocessBuffer       = {};
    VULKAN_HPP_NAMESPACE::DeviceSize                       preprocessOffset       = {};
    VULKAN_HPP_NAMESPACE::DeviceSize                       preprocessSize         = {};
    VULKAN_HPP_NAMESPACE::Buffer                           sequencesCountBuffer   = {};
    VULKAN_HPP_NAMESPACE::DeviceSize                       sequencesCountOffset   = {};
    VULKAN_HPP_NAMESPACE::Buffer                           sequencesIndexBuffer   = {};
    VULKAN_HPP_NAMESPACE::DeviceSize                       sequencesIndexOffset   = {};
  };
  static_assert( sizeof( GeneratedCommandsInfoNV ) == sizeof( VkGeneratedCommandsInfoNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<GeneratedCommandsInfoNV>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eGeneratedCommandsInfoNV>
  {
    using Type = GeneratedCommandsInfoNV;
  };

  struct GeneratedCommandsMemoryRequirementsInfoNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eGeneratedCommandsMemoryRequirementsInfoNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR GeneratedCommandsMemoryRequirementsInfoNV(
      VULKAN_HPP_NAMESPACE::PipelineBindPoint pipelineBindPoint_ = VULKAN_HPP_NAMESPACE::PipelineBindPoint::eGraphics,
      VULKAN_HPP_NAMESPACE::Pipeline          pipeline_          = {},
      VULKAN_HPP_NAMESPACE::IndirectCommandsLayoutNV indirectCommandsLayout_ = {},
      uint32_t                                       maxSequencesCount_      = {} ) VULKAN_HPP_NOEXCEPT
      : pipelineBindPoint( pipelineBindPoint_ )
      , pipeline( pipeline_ )
      , indirectCommandsLayout( indirectCommandsLayout_ )
      , maxSequencesCount( maxSequencesCount_ )
    {}

    VULKAN_HPP_CONSTEXPR GeneratedCommandsMemoryRequirementsInfoNV(
      GeneratedCommandsMemoryRequirementsInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    GeneratedCommandsMemoryRequirementsInfoNV( VkGeneratedCommandsMemoryRequirementsInfoNV const & rhs )
      VULKAN_HPP_NOEXCEPT
      : GeneratedCommandsMemoryRequirementsInfoNV(
          *reinterpret_cast<GeneratedCommandsMemoryRequirementsInfoNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 GeneratedCommandsMemoryRequirementsInfoNV &
                            operator=( GeneratedCommandsMemoryRequirementsInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    GeneratedCommandsMemoryRequirementsInfoNV &
      operator=( VkGeneratedCommandsMemoryRequirementsInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::GeneratedCommandsMemoryRequirementsInfoNV const *>( &rhs );
      return *this;
    }

    GeneratedCommandsMemoryRequirementsInfoNV & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    GeneratedCommandsMemoryRequirementsInfoNV &
      setPipelineBindPoint( VULKAN_HPP_NAMESPACE::PipelineBindPoint pipelineBindPoint_ ) VULKAN_HPP_NOEXCEPT
    {
      pipelineBindPoint = pipelineBindPoint_;
      return *this;
    }

    GeneratedCommandsMemoryRequirementsInfoNV &
      setPipeline( VULKAN_HPP_NAMESPACE::Pipeline pipeline_ ) VULKAN_HPP_NOEXCEPT
    {
      pipeline = pipeline_;
      return *this;
    }

    GeneratedCommandsMemoryRequirementsInfoNV & setIndirectCommandsLayout(
      VULKAN_HPP_NAMESPACE::IndirectCommandsLayoutNV indirectCommandsLayout_ ) VULKAN_HPP_NOEXCEPT
    {
      indirectCommandsLayout = indirectCommandsLayout_;
      return *this;
    }

    GeneratedCommandsMemoryRequirementsInfoNV & setMaxSequencesCount( uint32_t maxSequencesCount_ ) VULKAN_HPP_NOEXCEPT
    {
      maxSequencesCount = maxSequencesCount_;
      return *this;
    }

    operator VkGeneratedCommandsMemoryRequirementsInfoNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkGeneratedCommandsMemoryRequirementsInfoNV *>( this );
    }

    operator VkGeneratedCommandsMemoryRequirementsInfoNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkGeneratedCommandsMemoryRequirementsInfoNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( GeneratedCommandsMemoryRequirementsInfoNV const & ) const = default;
#else
    bool operator==( GeneratedCommandsMemoryRequirementsInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( pipelineBindPoint == rhs.pipelineBindPoint ) &&
             ( pipeline == rhs.pipeline ) && ( indirectCommandsLayout == rhs.indirectCommandsLayout ) &&
             ( maxSequencesCount == rhs.maxSequencesCount );
    }

    bool operator!=( GeneratedCommandsMemoryRequirementsInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType     sType = StructureType::eGeneratedCommandsMemoryRequirementsInfoNV;
    const void *                            pNext = {};
    VULKAN_HPP_NAMESPACE::PipelineBindPoint pipelineBindPoint = VULKAN_HPP_NAMESPACE::PipelineBindPoint::eGraphics;
    VULKAN_HPP_NAMESPACE::Pipeline          pipeline          = {};
    VULKAN_HPP_NAMESPACE::IndirectCommandsLayoutNV indirectCommandsLayout = {};
    uint32_t                                       maxSequencesCount      = {};
  };
  static_assert( sizeof( GeneratedCommandsMemoryRequirementsInfoNV ) ==
                   sizeof( VkGeneratedCommandsMemoryRequirementsInfoNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<GeneratedCommandsMemoryRequirementsInfoNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eGeneratedCommandsMemoryRequirementsInfoNV>
  {
    using Type = GeneratedCommandsMemoryRequirementsInfoNV;
  };

  struct VertexInputBindingDescription
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      VertexInputBindingDescription( uint32_t                              binding_ = {},
                                     uint32_t                              stride_  = {},
                                     VULKAN_HPP_NAMESPACE::VertexInputRate inputRate_ =
                                       VULKAN_HPP_NAMESPACE::VertexInputRate::eVertex ) VULKAN_HPP_NOEXCEPT
      : binding( binding_ )
      , stride( stride_ )
      , inputRate( inputRate_ )
    {}

    VULKAN_HPP_CONSTEXPR
      VertexInputBindingDescription( VertexInputBindingDescription const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VertexInputBindingDescription( VkVertexInputBindingDescription const & rhs ) VULKAN_HPP_NOEXCEPT
      : VertexInputBindingDescription( *reinterpret_cast<VertexInputBindingDescription const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 VertexInputBindingDescription &
                            operator=( VertexInputBindingDescription const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VertexInputBindingDescription & operator=( VkVertexInputBindingDescription const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::VertexInputBindingDescription const *>( &rhs );
      return *this;
    }

    VertexInputBindingDescription & setBinding( uint32_t binding_ ) VULKAN_HPP_NOEXCEPT
    {
      binding = binding_;
      return *this;
    }

    VertexInputBindingDescription & setStride( uint32_t stride_ ) VULKAN_HPP_NOEXCEPT
    {
      stride = stride_;
      return *this;
    }

    VertexInputBindingDescription & setInputRate( VULKAN_HPP_NAMESPACE::VertexInputRate inputRate_ ) VULKAN_HPP_NOEXCEPT
    {
      inputRate = inputRate_;
      return *this;
    }

    operator VkVertexInputBindingDescription const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkVertexInputBindingDescription *>( this );
    }

    operator VkVertexInputBindingDescription &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkVertexInputBindingDescription *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( VertexInputBindingDescription const & ) const = default;
#else
    bool operator==( VertexInputBindingDescription const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( binding == rhs.binding ) && ( stride == rhs.stride ) && ( inputRate == rhs.inputRate );
    }

    bool operator!=( VertexInputBindingDescription const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    uint32_t                              binding   = {};
    uint32_t                              stride    = {};
    VULKAN_HPP_NAMESPACE::VertexInputRate inputRate = VULKAN_HPP_NAMESPACE::VertexInputRate::eVertex;
  };
  static_assert( sizeof( VertexInputBindingDescription ) == sizeof( VkVertexInputBindingDescription ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<VertexInputBindingDescription>::value,
                 "struct wrapper is not a standard layout!" );

  struct VertexInputAttributeDescription
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      VertexInputAttributeDescription( uint32_t                     location_ = {},
                                       uint32_t                     binding_  = {},
                                       VULKAN_HPP_NAMESPACE::Format format_ = VULKAN_HPP_NAMESPACE::Format::eUndefined,
                                       uint32_t                     offset_ = {} ) VULKAN_HPP_NOEXCEPT
      : location( location_ )
      , binding( binding_ )
      , format( format_ )
      , offset( offset_ )
    {}

    VULKAN_HPP_CONSTEXPR
      VertexInputAttributeDescription( VertexInputAttributeDescription const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VertexInputAttributeDescription( VkVertexInputAttributeDescription const & rhs ) VULKAN_HPP_NOEXCEPT
      : VertexInputAttributeDescription( *reinterpret_cast<VertexInputAttributeDescription const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 VertexInputAttributeDescription &
                            operator=( VertexInputAttributeDescription const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VertexInputAttributeDescription & operator=( VkVertexInputAttributeDescription const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::VertexInputAttributeDescription const *>( &rhs );
      return *this;
    }

    VertexInputAttributeDescription & setLocation( uint32_t location_ ) VULKAN_HPP_NOEXCEPT
    {
      location = location_;
      return *this;
    }

    VertexInputAttributeDescription & setBinding( uint32_t binding_ ) VULKAN_HPP_NOEXCEPT
    {
      binding = binding_;
      return *this;
    }

    VertexInputAttributeDescription & setFormat( VULKAN_HPP_NAMESPACE::Format format_ ) VULKAN_HPP_NOEXCEPT
    {
      format = format_;
      return *this;
    }

    VertexInputAttributeDescription & setOffset( uint32_t offset_ ) VULKAN_HPP_NOEXCEPT
    {
      offset = offset_;
      return *this;
    }

    operator VkVertexInputAttributeDescription const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkVertexInputAttributeDescription *>( this );
    }

    operator VkVertexInputAttributeDescription &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkVertexInputAttributeDescription *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( VertexInputAttributeDescription const & ) const = default;
#else
    bool operator==( VertexInputAttributeDescription const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( location == rhs.location ) && ( binding == rhs.binding ) && ( format == rhs.format ) &&
             ( offset == rhs.offset );
    }

    bool operator!=( VertexInputAttributeDescription const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    uint32_t                     location = {};
    uint32_t                     binding  = {};
    VULKAN_HPP_NAMESPACE::Format format   = VULKAN_HPP_NAMESPACE::Format::eUndefined;
    uint32_t                     offset   = {};
  };
  static_assert( sizeof( VertexInputAttributeDescription ) == sizeof( VkVertexInputAttributeDescription ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<VertexInputAttributeDescription>::value,
                 "struct wrapper is not a standard layout!" );

  struct PipelineVertexInputStateCreateInfo
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePipelineVertexInputStateCreateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PipelineVertexInputStateCreateInfo(
      VULKAN_HPP_NAMESPACE::PipelineVertexInputStateCreateFlags     flags_                           = {},
      uint32_t                                                      vertexBindingDescriptionCount_   = {},
      const VULKAN_HPP_NAMESPACE::VertexInputBindingDescription *   pVertexBindingDescriptions_      = {},
      uint32_t                                                      vertexAttributeDescriptionCount_ = {},
      const VULKAN_HPP_NAMESPACE::VertexInputAttributeDescription * pVertexAttributeDescriptions_    = {} )
      VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , vertexBindingDescriptionCount( vertexBindingDescriptionCount_ )
      , pVertexBindingDescriptions( pVertexBindingDescriptions_ )
      , vertexAttributeDescriptionCount( vertexAttributeDescriptionCount_ )
      , pVertexAttributeDescriptions( pVertexAttributeDescriptions_ )
    {}

    VULKAN_HPP_CONSTEXPR PipelineVertexInputStateCreateInfo( PipelineVertexInputStateCreateInfo const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    PipelineVertexInputStateCreateInfo( VkPipelineVertexInputStateCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : PipelineVertexInputStateCreateInfo( *reinterpret_cast<PipelineVertexInputStateCreateInfo const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    PipelineVertexInputStateCreateInfo(
      VULKAN_HPP_NAMESPACE::PipelineVertexInputStateCreateFlags flags_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::VertexInputBindingDescription> const &
        vertexBindingDescriptions_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::VertexInputAttributeDescription> const &
        vertexAttributeDescriptions_ = {} )
      : flags( flags_ )
      , vertexBindingDescriptionCount( static_cast<uint32_t>( vertexBindingDescriptions_.size() ) )
      , pVertexBindingDescriptions( vertexBindingDescriptions_.data() )
      , vertexAttributeDescriptionCount( static_cast<uint32_t>( vertexAttributeDescriptions_.size() ) )
      , pVertexAttributeDescriptions( vertexAttributeDescriptions_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PipelineVertexInputStateCreateInfo &
                            operator=( PipelineVertexInputStateCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineVertexInputStateCreateInfo &
      operator=( VkPipelineVertexInputStateCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PipelineVertexInputStateCreateInfo const *>( &rhs );
      return *this;
    }

    PipelineVertexInputStateCreateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PipelineVertexInputStateCreateInfo &
      setFlags( VULKAN_HPP_NAMESPACE::PipelineVertexInputStateCreateFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    PipelineVertexInputStateCreateInfo &
      setVertexBindingDescriptionCount( uint32_t vertexBindingDescriptionCount_ ) VULKAN_HPP_NOEXCEPT
    {
      vertexBindingDescriptionCount = vertexBindingDescriptionCount_;
      return *this;
    }

    PipelineVertexInputStateCreateInfo & setPVertexBindingDescriptions(
      const VULKAN_HPP_NAMESPACE::VertexInputBindingDescription * pVertexBindingDescriptions_ ) VULKAN_HPP_NOEXCEPT
    {
      pVertexBindingDescriptions = pVertexBindingDescriptions_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    PipelineVertexInputStateCreateInfo & setVertexBindingDescriptions(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::VertexInputBindingDescription> const &
        vertexBindingDescriptions_ ) VULKAN_HPP_NOEXCEPT
    {
      vertexBindingDescriptionCount = static_cast<uint32_t>( vertexBindingDescriptions_.size() );
      pVertexBindingDescriptions    = vertexBindingDescriptions_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    PipelineVertexInputStateCreateInfo &
      setVertexAttributeDescriptionCount( uint32_t vertexAttributeDescriptionCount_ ) VULKAN_HPP_NOEXCEPT
    {
      vertexAttributeDescriptionCount = vertexAttributeDescriptionCount_;
      return *this;
    }

    PipelineVertexInputStateCreateInfo & setPVertexAttributeDescriptions(
      const VULKAN_HPP_NAMESPACE::VertexInputAttributeDescription * pVertexAttributeDescriptions_ ) VULKAN_HPP_NOEXCEPT
    {
      pVertexAttributeDescriptions = pVertexAttributeDescriptions_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    PipelineVertexInputStateCreateInfo & setVertexAttributeDescriptions(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::VertexInputAttributeDescription> const &
        vertexAttributeDescriptions_ ) VULKAN_HPP_NOEXCEPT
    {
      vertexAttributeDescriptionCount = static_cast<uint32_t>( vertexAttributeDescriptions_.size() );
      pVertexAttributeDescriptions    = vertexAttributeDescriptions_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkPipelineVertexInputStateCreateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPipelineVertexInputStateCreateInfo *>( this );
    }

    operator VkPipelineVertexInputStateCreateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPipelineVertexInputStateCreateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PipelineVertexInputStateCreateInfo const & ) const = default;
#else
    bool operator==( PipelineVertexInputStateCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( vertexBindingDescriptionCount == rhs.vertexBindingDescriptionCount ) &&
             ( pVertexBindingDescriptions == rhs.pVertexBindingDescriptions ) &&
             ( vertexAttributeDescriptionCount == rhs.vertexAttributeDescriptionCount ) &&
             ( pVertexAttributeDescriptions == rhs.pVertexAttributeDescriptions );
    }

    bool operator!=( PipelineVertexInputStateCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePipelineVertexInputStateCreateInfo;
    const void *                        pNext = {};
    VULKAN_HPP_NAMESPACE::PipelineVertexInputStateCreateFlags     flags                           = {};
    uint32_t                                                      vertexBindingDescriptionCount   = {};
    const VULKAN_HPP_NAMESPACE::VertexInputBindingDescription *   pVertexBindingDescriptions      = {};
    uint32_t                                                      vertexAttributeDescriptionCount = {};
    const VULKAN_HPP_NAMESPACE::VertexInputAttributeDescription * pVertexAttributeDescriptions    = {};
  };
  static_assert( sizeof( PipelineVertexInputStateCreateInfo ) == sizeof( VkPipelineVertexInputStateCreateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PipelineVertexInputStateCreateInfo>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePipelineVertexInputStateCreateInfo>
  {
    using Type = PipelineVertexInputStateCreateInfo;
  };

  struct PipelineInputAssemblyStateCreateInfo
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePipelineInputAssemblyStateCreateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PipelineInputAssemblyStateCreateInfo(
      VULKAN_HPP_NAMESPACE::PipelineInputAssemblyStateCreateFlags flags_ = {},
      VULKAN_HPP_NAMESPACE::PrimitiveTopology topology_ = VULKAN_HPP_NAMESPACE::PrimitiveTopology::ePointList,
      VULKAN_HPP_NAMESPACE::Bool32            primitiveRestartEnable_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , topology( topology_ )
      , primitiveRestartEnable( primitiveRestartEnable_ )
    {}

    VULKAN_HPP_CONSTEXPR PipelineInputAssemblyStateCreateInfo( PipelineInputAssemblyStateCreateInfo const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    PipelineInputAssemblyStateCreateInfo( VkPipelineInputAssemblyStateCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : PipelineInputAssemblyStateCreateInfo( *reinterpret_cast<PipelineInputAssemblyStateCreateInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PipelineInputAssemblyStateCreateInfo &
                            operator=( PipelineInputAssemblyStateCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineInputAssemblyStateCreateInfo &
      operator=( VkPipelineInputAssemblyStateCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PipelineInputAssemblyStateCreateInfo const *>( &rhs );
      return *this;
    }

    PipelineInputAssemblyStateCreateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PipelineInputAssemblyStateCreateInfo &
      setFlags( VULKAN_HPP_NAMESPACE::PipelineInputAssemblyStateCreateFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    PipelineInputAssemblyStateCreateInfo &
      setTopology( VULKAN_HPP_NAMESPACE::PrimitiveTopology topology_ ) VULKAN_HPP_NOEXCEPT
    {
      topology = topology_;
      return *this;
    }

    PipelineInputAssemblyStateCreateInfo &
      setPrimitiveRestartEnable( VULKAN_HPP_NAMESPACE::Bool32 primitiveRestartEnable_ ) VULKAN_HPP_NOEXCEPT
    {
      primitiveRestartEnable = primitiveRestartEnable_;
      return *this;
    }

    operator VkPipelineInputAssemblyStateCreateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPipelineInputAssemblyStateCreateInfo *>( this );
    }

    operator VkPipelineInputAssemblyStateCreateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPipelineInputAssemblyStateCreateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PipelineInputAssemblyStateCreateInfo const & ) const = default;
#else
    bool operator==( PipelineInputAssemblyStateCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( topology == rhs.topology ) && ( primitiveRestartEnable == rhs.primitiveRestartEnable );
    }

    bool operator!=( PipelineInputAssemblyStateCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePipelineInputAssemblyStateCreateInfo;
    const void *                        pNext = {};
    VULKAN_HPP_NAMESPACE::PipelineInputAssemblyStateCreateFlags flags = {};
    VULKAN_HPP_NAMESPACE::PrimitiveTopology topology = VULKAN_HPP_NAMESPACE::PrimitiveTopology::ePointList;
    VULKAN_HPP_NAMESPACE::Bool32            primitiveRestartEnable = {};
  };
  static_assert( sizeof( PipelineInputAssemblyStateCreateInfo ) == sizeof( VkPipelineInputAssemblyStateCreateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PipelineInputAssemblyStateCreateInfo>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePipelineInputAssemblyStateCreateInfo>
  {
    using Type = PipelineInputAssemblyStateCreateInfo;
  };

  struct PipelineTessellationStateCreateInfo
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePipelineTessellationStateCreateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      PipelineTessellationStateCreateInfo( VULKAN_HPP_NAMESPACE::PipelineTessellationStateCreateFlags flags_ = {},
                                           uint32_t patchControlPoints_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , patchControlPoints( patchControlPoints_ )
    {}

    VULKAN_HPP_CONSTEXPR PipelineTessellationStateCreateInfo( PipelineTessellationStateCreateInfo const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    PipelineTessellationStateCreateInfo( VkPipelineTessellationStateCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : PipelineTessellationStateCreateInfo( *reinterpret_cast<PipelineTessellationStateCreateInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PipelineTessellationStateCreateInfo &
                            operator=( PipelineTessellationStateCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineTessellationStateCreateInfo &
      operator=( VkPipelineTessellationStateCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PipelineTessellationStateCreateInfo const *>( &rhs );
      return *this;
    }

    PipelineTessellationStateCreateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PipelineTessellationStateCreateInfo &
      setFlags( VULKAN_HPP_NAMESPACE::PipelineTessellationStateCreateFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    PipelineTessellationStateCreateInfo & setPatchControlPoints( uint32_t patchControlPoints_ ) VULKAN_HPP_NOEXCEPT
    {
      patchControlPoints = patchControlPoints_;
      return *this;
    }

    operator VkPipelineTessellationStateCreateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPipelineTessellationStateCreateInfo *>( this );
    }

    operator VkPipelineTessellationStateCreateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPipelineTessellationStateCreateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PipelineTessellationStateCreateInfo const & ) const = default;
#else
    bool operator==( PipelineTessellationStateCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( patchControlPoints == rhs.patchControlPoints );
    }

    bool operator!=( PipelineTessellationStateCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePipelineTessellationStateCreateInfo;
    const void *                        pNext = {};
    VULKAN_HPP_NAMESPACE::PipelineTessellationStateCreateFlags flags              = {};
    uint32_t                                                   patchControlPoints = {};
  };
  static_assert( sizeof( PipelineTessellationStateCreateInfo ) == sizeof( VkPipelineTessellationStateCreateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PipelineTessellationStateCreateInfo>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePipelineTessellationStateCreateInfo>
  {
    using Type = PipelineTessellationStateCreateInfo;
  };

  struct PipelineViewportStateCreateInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::ePipelineViewportStateCreateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      PipelineViewportStateCreateInfo( VULKAN_HPP_NAMESPACE::PipelineViewportStateCreateFlags flags_         = {},
                                       uint32_t                                               viewportCount_ = {},
                                       const VULKAN_HPP_NAMESPACE::Viewport *                 pViewports_    = {},
                                       uint32_t                                               scissorCount_  = {},
                                       const VULKAN_HPP_NAMESPACE::Rect2D * pScissors_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , viewportCount( viewportCount_ )
      , pViewports( pViewports_ )
      , scissorCount( scissorCount_ )
      , pScissors( pScissors_ )
    {}

    VULKAN_HPP_CONSTEXPR
      PipelineViewportStateCreateInfo( PipelineViewportStateCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineViewportStateCreateInfo( VkPipelineViewportStateCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : PipelineViewportStateCreateInfo( *reinterpret_cast<PipelineViewportStateCreateInfo const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    PipelineViewportStateCreateInfo(
      VULKAN_HPP_NAMESPACE::PipelineViewportStateCreateFlags                                      flags_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::Viewport> const & viewports_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::Rect2D> const &   scissors_ = {} )
      : flags( flags_ )
      , viewportCount( static_cast<uint32_t>( viewports_.size() ) )
      , pViewports( viewports_.data() )
      , scissorCount( static_cast<uint32_t>( scissors_.size() ) )
      , pScissors( scissors_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PipelineViewportStateCreateInfo &
                            operator=( PipelineViewportStateCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineViewportStateCreateInfo & operator=( VkPipelineViewportStateCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PipelineViewportStateCreateInfo const *>( &rhs );
      return *this;
    }

    PipelineViewportStateCreateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PipelineViewportStateCreateInfo &
      setFlags( VULKAN_HPP_NAMESPACE::PipelineViewportStateCreateFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    PipelineViewportStateCreateInfo & setViewportCount( uint32_t viewportCount_ ) VULKAN_HPP_NOEXCEPT
    {
      viewportCount = viewportCount_;
      return *this;
    }

    PipelineViewportStateCreateInfo &
      setPViewports( const VULKAN_HPP_NAMESPACE::Viewport * pViewports_ ) VULKAN_HPP_NOEXCEPT
    {
      pViewports = pViewports_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    PipelineViewportStateCreateInfo & setViewports(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::Viewport> const & viewports_ )
      VULKAN_HPP_NOEXCEPT
    {
      viewportCount = static_cast<uint32_t>( viewports_.size() );
      pViewports    = viewports_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    PipelineViewportStateCreateInfo & setScissorCount( uint32_t scissorCount_ ) VULKAN_HPP_NOEXCEPT
    {
      scissorCount = scissorCount_;
      return *this;
    }

    PipelineViewportStateCreateInfo &
      setPScissors( const VULKAN_HPP_NAMESPACE::Rect2D * pScissors_ ) VULKAN_HPP_NOEXCEPT
    {
      pScissors = pScissors_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    PipelineViewportStateCreateInfo &
      setScissors( VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::Rect2D> const & scissors_ )
        VULKAN_HPP_NOEXCEPT
    {
      scissorCount = static_cast<uint32_t>( scissors_.size() );
      pScissors    = scissors_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkPipelineViewportStateCreateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPipelineViewportStateCreateInfo *>( this );
    }

    operator VkPipelineViewportStateCreateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPipelineViewportStateCreateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PipelineViewportStateCreateInfo const & ) const = default;
#else
    bool operator==( PipelineViewportStateCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( viewportCount == rhs.viewportCount ) && ( pViewports == rhs.pViewports ) &&
             ( scissorCount == rhs.scissorCount ) && ( pScissors == rhs.pScissors );
    }

    bool operator!=( PipelineViewportStateCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                    sType = StructureType::ePipelineViewportStateCreateInfo;
    const void *                                           pNext = {};
    VULKAN_HPP_NAMESPACE::PipelineViewportStateCreateFlags flags = {};
    uint32_t                                               viewportCount = {};
    const VULKAN_HPP_NAMESPACE::Viewport *                 pViewports    = {};
    uint32_t                                               scissorCount  = {};
    const VULKAN_HPP_NAMESPACE::Rect2D *                   pScissors     = {};
  };
  static_assert( sizeof( PipelineViewportStateCreateInfo ) == sizeof( VkPipelineViewportStateCreateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PipelineViewportStateCreateInfo>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePipelineViewportStateCreateInfo>
  {
    using Type = PipelineViewportStateCreateInfo;
  };

  struct PipelineRasterizationStateCreateInfo
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePipelineRasterizationStateCreateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PipelineRasterizationStateCreateInfo(
      VULKAN_HPP_NAMESPACE::PipelineRasterizationStateCreateFlags flags_                   = {},
      VULKAN_HPP_NAMESPACE::Bool32                                depthClampEnable_        = {},
      VULKAN_HPP_NAMESPACE::Bool32                                rasterizerDiscardEnable_ = {},
      VULKAN_HPP_NAMESPACE::PolygonMode   polygonMode_             = VULKAN_HPP_NAMESPACE::PolygonMode::eFill,
      VULKAN_HPP_NAMESPACE::CullModeFlags cullMode_                = {},
      VULKAN_HPP_NAMESPACE::FrontFace     frontFace_               = VULKAN_HPP_NAMESPACE::FrontFace::eCounterClockwise,
      VULKAN_HPP_NAMESPACE::Bool32        depthBiasEnable_         = {},
      float                               depthBiasConstantFactor_ = {},
      float                               depthBiasClamp_          = {},
      float                               depthBiasSlopeFactor_    = {},
      float                               lineWidth_               = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , depthClampEnable( depthClampEnable_ )
      , rasterizerDiscardEnable( rasterizerDiscardEnable_ )
      , polygonMode( polygonMode_ )
      , cullMode( cullMode_ )
      , frontFace( frontFace_ )
      , depthBiasEnable( depthBiasEnable_ )
      , depthBiasConstantFactor( depthBiasConstantFactor_ )
      , depthBiasClamp( depthBiasClamp_ )
      , depthBiasSlopeFactor( depthBiasSlopeFactor_ )
      , lineWidth( lineWidth_ )
    {}

    VULKAN_HPP_CONSTEXPR PipelineRasterizationStateCreateInfo( PipelineRasterizationStateCreateInfo const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    PipelineRasterizationStateCreateInfo( VkPipelineRasterizationStateCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : PipelineRasterizationStateCreateInfo( *reinterpret_cast<PipelineRasterizationStateCreateInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PipelineRasterizationStateCreateInfo &
                            operator=( PipelineRasterizationStateCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineRasterizationStateCreateInfo &
      operator=( VkPipelineRasterizationStateCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PipelineRasterizationStateCreateInfo const *>( &rhs );
      return *this;
    }

    PipelineRasterizationStateCreateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PipelineRasterizationStateCreateInfo &
      setFlags( VULKAN_HPP_NAMESPACE::PipelineRasterizationStateCreateFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    PipelineRasterizationStateCreateInfo &
      setDepthClampEnable( VULKAN_HPP_NAMESPACE::Bool32 depthClampEnable_ ) VULKAN_HPP_NOEXCEPT
    {
      depthClampEnable = depthClampEnable_;
      return *this;
    }

    PipelineRasterizationStateCreateInfo &
      setRasterizerDiscardEnable( VULKAN_HPP_NAMESPACE::Bool32 rasterizerDiscardEnable_ ) VULKAN_HPP_NOEXCEPT
    {
      rasterizerDiscardEnable = rasterizerDiscardEnable_;
      return *this;
    }

    PipelineRasterizationStateCreateInfo &
      setPolygonMode( VULKAN_HPP_NAMESPACE::PolygonMode polygonMode_ ) VULKAN_HPP_NOEXCEPT
    {
      polygonMode = polygonMode_;
      return *this;
    }

    PipelineRasterizationStateCreateInfo &
      setCullMode( VULKAN_HPP_NAMESPACE::CullModeFlags cullMode_ ) VULKAN_HPP_NOEXCEPT
    {
      cullMode = cullMode_;
      return *this;
    }

    PipelineRasterizationStateCreateInfo &
      setFrontFace( VULKAN_HPP_NAMESPACE::FrontFace frontFace_ ) VULKAN_HPP_NOEXCEPT
    {
      frontFace = frontFace_;
      return *this;
    }

    PipelineRasterizationStateCreateInfo &
      setDepthBiasEnable( VULKAN_HPP_NAMESPACE::Bool32 depthBiasEnable_ ) VULKAN_HPP_NOEXCEPT
    {
      depthBiasEnable = depthBiasEnable_;
      return *this;
    }

    PipelineRasterizationStateCreateInfo &
      setDepthBiasConstantFactor( float depthBiasConstantFactor_ ) VULKAN_HPP_NOEXCEPT
    {
      depthBiasConstantFactor = depthBiasConstantFactor_;
      return *this;
    }

    PipelineRasterizationStateCreateInfo & setDepthBiasClamp( float depthBiasClamp_ ) VULKAN_HPP_NOEXCEPT
    {
      depthBiasClamp = depthBiasClamp_;
      return *this;
    }

    PipelineRasterizationStateCreateInfo & setDepthBiasSlopeFactor( float depthBiasSlopeFactor_ ) VULKAN_HPP_NOEXCEPT
    {
      depthBiasSlopeFactor = depthBiasSlopeFactor_;
      return *this;
    }

    PipelineRasterizationStateCreateInfo & setLineWidth( float lineWidth_ ) VULKAN_HPP_NOEXCEPT
    {
      lineWidth = lineWidth_;
      return *this;
    }

    operator VkPipelineRasterizationStateCreateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPipelineRasterizationStateCreateInfo *>( this );
    }

    operator VkPipelineRasterizationStateCreateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPipelineRasterizationStateCreateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PipelineRasterizationStateCreateInfo const & ) const = default;
#else
    bool operator==( PipelineRasterizationStateCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( depthClampEnable == rhs.depthClampEnable ) &&
             ( rasterizerDiscardEnable == rhs.rasterizerDiscardEnable ) && ( polygonMode == rhs.polygonMode ) &&
             ( cullMode == rhs.cullMode ) && ( frontFace == rhs.frontFace ) &&
             ( depthBiasEnable == rhs.depthBiasEnable ) && ( depthBiasConstantFactor == rhs.depthBiasConstantFactor ) &&
             ( depthBiasClamp == rhs.depthBiasClamp ) && ( depthBiasSlopeFactor == rhs.depthBiasSlopeFactor ) &&
             ( lineWidth == rhs.lineWidth );
    }

    bool operator!=( PipelineRasterizationStateCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePipelineRasterizationStateCreateInfo;
    const void *                        pNext = {};
    VULKAN_HPP_NAMESPACE::PipelineRasterizationStateCreateFlags flags                   = {};
    VULKAN_HPP_NAMESPACE::Bool32                                depthClampEnable        = {};
    VULKAN_HPP_NAMESPACE::Bool32                                rasterizerDiscardEnable = {};
    VULKAN_HPP_NAMESPACE::PolygonMode                           polygonMode = VULKAN_HPP_NAMESPACE::PolygonMode::eFill;
    VULKAN_HPP_NAMESPACE::CullModeFlags                         cullMode    = {};
    VULKAN_HPP_NAMESPACE::FrontFace frontFace               = VULKAN_HPP_NAMESPACE::FrontFace::eCounterClockwise;
    VULKAN_HPP_NAMESPACE::Bool32    depthBiasEnable         = {};
    float                           depthBiasConstantFactor = {};
    float                           depthBiasClamp          = {};
    float                           depthBiasSlopeFactor    = {};
    float                           lineWidth               = {};
  };
  static_assert( sizeof( PipelineRasterizationStateCreateInfo ) == sizeof( VkPipelineRasterizationStateCreateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PipelineRasterizationStateCreateInfo>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePipelineRasterizationStateCreateInfo>
  {
    using Type = PipelineRasterizationStateCreateInfo;
  };

  struct PipelineMultisampleStateCreateInfo
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePipelineMultisampleStateCreateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PipelineMultisampleStateCreateInfo(
      VULKAN_HPP_NAMESPACE::PipelineMultisampleStateCreateFlags flags_ = {},
      VULKAN_HPP_NAMESPACE::SampleCountFlagBits rasterizationSamples_  = VULKAN_HPP_NAMESPACE::SampleCountFlagBits::e1,
      VULKAN_HPP_NAMESPACE::Bool32              sampleShadingEnable_   = {},
      float                                     minSampleShading_      = {},
      const VULKAN_HPP_NAMESPACE::SampleMask *  pSampleMask_           = {},
      VULKAN_HPP_NAMESPACE::Bool32              alphaToCoverageEnable_ = {},
      VULKAN_HPP_NAMESPACE::Bool32              alphaToOneEnable_      = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , rasterizationSamples( rasterizationSamples_ )
      , sampleShadingEnable( sampleShadingEnable_ )
      , minSampleShading( minSampleShading_ )
      , pSampleMask( pSampleMask_ )
      , alphaToCoverageEnable( alphaToCoverageEnable_ )
      , alphaToOneEnable( alphaToOneEnable_ )
    {}

    VULKAN_HPP_CONSTEXPR PipelineMultisampleStateCreateInfo( PipelineMultisampleStateCreateInfo const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    PipelineMultisampleStateCreateInfo( VkPipelineMultisampleStateCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : PipelineMultisampleStateCreateInfo( *reinterpret_cast<PipelineMultisampleStateCreateInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PipelineMultisampleStateCreateInfo &
                            operator=( PipelineMultisampleStateCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineMultisampleStateCreateInfo &
      operator=( VkPipelineMultisampleStateCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PipelineMultisampleStateCreateInfo const *>( &rhs );
      return *this;
    }

    PipelineMultisampleStateCreateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PipelineMultisampleStateCreateInfo &
      setFlags( VULKAN_HPP_NAMESPACE::PipelineMultisampleStateCreateFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    PipelineMultisampleStateCreateInfo &
      setRasterizationSamples( VULKAN_HPP_NAMESPACE::SampleCountFlagBits rasterizationSamples_ ) VULKAN_HPP_NOEXCEPT
    {
      rasterizationSamples = rasterizationSamples_;
      return *this;
    }

    PipelineMultisampleStateCreateInfo &
      setSampleShadingEnable( VULKAN_HPP_NAMESPACE::Bool32 sampleShadingEnable_ ) VULKAN_HPP_NOEXCEPT
    {
      sampleShadingEnable = sampleShadingEnable_;
      return *this;
    }

    PipelineMultisampleStateCreateInfo & setMinSampleShading( float minSampleShading_ ) VULKAN_HPP_NOEXCEPT
    {
      minSampleShading = minSampleShading_;
      return *this;
    }

    PipelineMultisampleStateCreateInfo &
      setPSampleMask( const VULKAN_HPP_NAMESPACE::SampleMask * pSampleMask_ ) VULKAN_HPP_NOEXCEPT
    {
      pSampleMask = pSampleMask_;
      return *this;
    }

    PipelineMultisampleStateCreateInfo &
      setAlphaToCoverageEnable( VULKAN_HPP_NAMESPACE::Bool32 alphaToCoverageEnable_ ) VULKAN_HPP_NOEXCEPT
    {
      alphaToCoverageEnable = alphaToCoverageEnable_;
      return *this;
    }

    PipelineMultisampleStateCreateInfo &
      setAlphaToOneEnable( VULKAN_HPP_NAMESPACE::Bool32 alphaToOneEnable_ ) VULKAN_HPP_NOEXCEPT
    {
      alphaToOneEnable = alphaToOneEnable_;
      return *this;
    }

    operator VkPipelineMultisampleStateCreateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPipelineMultisampleStateCreateInfo *>( this );
    }

    operator VkPipelineMultisampleStateCreateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPipelineMultisampleStateCreateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PipelineMultisampleStateCreateInfo const & ) const = default;
#else
    bool operator==( PipelineMultisampleStateCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( rasterizationSamples == rhs.rasterizationSamples ) &&
             ( sampleShadingEnable == rhs.sampleShadingEnable ) && ( minSampleShading == rhs.minSampleShading ) &&
             ( pSampleMask == rhs.pSampleMask ) && ( alphaToCoverageEnable == rhs.alphaToCoverageEnable ) &&
             ( alphaToOneEnable == rhs.alphaToOneEnable );
    }

    bool operator!=( PipelineMultisampleStateCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePipelineMultisampleStateCreateInfo;
    const void *                        pNext = {};
    VULKAN_HPP_NAMESPACE::PipelineMultisampleStateCreateFlags flags = {};
    VULKAN_HPP_NAMESPACE::SampleCountFlagBits rasterizationSamples  = VULKAN_HPP_NAMESPACE::SampleCountFlagBits::e1;
    VULKAN_HPP_NAMESPACE::Bool32              sampleShadingEnable   = {};
    float                                     minSampleShading      = {};
    const VULKAN_HPP_NAMESPACE::SampleMask *  pSampleMask           = {};
    VULKAN_HPP_NAMESPACE::Bool32              alphaToCoverageEnable = {};
    VULKAN_HPP_NAMESPACE::Bool32              alphaToOneEnable      = {};
  };
  static_assert( sizeof( PipelineMultisampleStateCreateInfo ) == sizeof( VkPipelineMultisampleStateCreateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PipelineMultisampleStateCreateInfo>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePipelineMultisampleStateCreateInfo>
  {
    using Type = PipelineMultisampleStateCreateInfo;
  };

  struct StencilOpState
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      StencilOpState( VULKAN_HPP_NAMESPACE::StencilOp failOp_      = VULKAN_HPP_NAMESPACE::StencilOp::eKeep,
                      VULKAN_HPP_NAMESPACE::StencilOp passOp_      = VULKAN_HPP_NAMESPACE::StencilOp::eKeep,
                      VULKAN_HPP_NAMESPACE::StencilOp depthFailOp_ = VULKAN_HPP_NAMESPACE::StencilOp::eKeep,
                      VULKAN_HPP_NAMESPACE::CompareOp compareOp_   = VULKAN_HPP_NAMESPACE::CompareOp::eNever,
                      uint32_t                        compareMask_ = {},
                      uint32_t                        writeMask_   = {},
                      uint32_t                        reference_   = {} ) VULKAN_HPP_NOEXCEPT
      : failOp( failOp_ )
      , passOp( passOp_ )
      , depthFailOp( depthFailOp_ )
      , compareOp( compareOp_ )
      , compareMask( compareMask_ )
      , writeMask( writeMask_ )
      , reference( reference_ )
    {}

    VULKAN_HPP_CONSTEXPR StencilOpState( StencilOpState const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    StencilOpState( VkStencilOpState const & rhs ) VULKAN_HPP_NOEXCEPT
      : StencilOpState( *reinterpret_cast<StencilOpState const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 StencilOpState & operator=( StencilOpState const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    StencilOpState & operator=( VkStencilOpState const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::StencilOpState const *>( &rhs );
      return *this;
    }

    StencilOpState & setFailOp( VULKAN_HPP_NAMESPACE::StencilOp failOp_ ) VULKAN_HPP_NOEXCEPT
    {
      failOp = failOp_;
      return *this;
    }

    StencilOpState & setPassOp( VULKAN_HPP_NAMESPACE::StencilOp passOp_ ) VULKAN_HPP_NOEXCEPT
    {
      passOp = passOp_;
      return *this;
    }

    StencilOpState & setDepthFailOp( VULKAN_HPP_NAMESPACE::StencilOp depthFailOp_ ) VULKAN_HPP_NOEXCEPT
    {
      depthFailOp = depthFailOp_;
      return *this;
    }

    StencilOpState & setCompareOp( VULKAN_HPP_NAMESPACE::CompareOp compareOp_ ) VULKAN_HPP_NOEXCEPT
    {
      compareOp = compareOp_;
      return *this;
    }

    StencilOpState & setCompareMask( uint32_t compareMask_ ) VULKAN_HPP_NOEXCEPT
    {
      compareMask = compareMask_;
      return *this;
    }

    StencilOpState & setWriteMask( uint32_t writeMask_ ) VULKAN_HPP_NOEXCEPT
    {
      writeMask = writeMask_;
      return *this;
    }

    StencilOpState & setReference( uint32_t reference_ ) VULKAN_HPP_NOEXCEPT
    {
      reference = reference_;
      return *this;
    }

    operator VkStencilOpState const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkStencilOpState *>( this );
    }

    operator VkStencilOpState &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkStencilOpState *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( StencilOpState const & ) const = default;
#else
    bool operator==( StencilOpState const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( failOp == rhs.failOp ) && ( passOp == rhs.passOp ) && ( depthFailOp == rhs.depthFailOp ) &&
             ( compareOp == rhs.compareOp ) && ( compareMask == rhs.compareMask ) && ( writeMask == rhs.writeMask ) &&
             ( reference == rhs.reference );
    }

    bool operator!=( StencilOpState const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StencilOp failOp      = VULKAN_HPP_NAMESPACE::StencilOp::eKeep;
    VULKAN_HPP_NAMESPACE::StencilOp passOp      = VULKAN_HPP_NAMESPACE::StencilOp::eKeep;
    VULKAN_HPP_NAMESPACE::StencilOp depthFailOp = VULKAN_HPP_NAMESPACE::StencilOp::eKeep;
    VULKAN_HPP_NAMESPACE::CompareOp compareOp   = VULKAN_HPP_NAMESPACE::CompareOp::eNever;
    uint32_t                        compareMask = {};
    uint32_t                        writeMask   = {};
    uint32_t                        reference   = {};
  };
  static_assert( sizeof( StencilOpState ) == sizeof( VkStencilOpState ), "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<StencilOpState>::value, "struct wrapper is not a standard layout!" );

  struct PipelineDepthStencilStateCreateInfo
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePipelineDepthStencilStateCreateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PipelineDepthStencilStateCreateInfo(
      VULKAN_HPP_NAMESPACE::PipelineDepthStencilStateCreateFlags flags_            = {},
      VULKAN_HPP_NAMESPACE::Bool32                               depthTestEnable_  = {},
      VULKAN_HPP_NAMESPACE::Bool32                               depthWriteEnable_ = {},
      VULKAN_HPP_NAMESPACE::CompareOp      depthCompareOp_        = VULKAN_HPP_NAMESPACE::CompareOp::eNever,
      VULKAN_HPP_NAMESPACE::Bool32         depthBoundsTestEnable_ = {},
      VULKAN_HPP_NAMESPACE::Bool32         stencilTestEnable_     = {},
      VULKAN_HPP_NAMESPACE::StencilOpState front_                 = {},
      VULKAN_HPP_NAMESPACE::StencilOpState back_                  = {},
      float                                minDepthBounds_        = {},
      float                                maxDepthBounds_        = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , depthTestEnable( depthTestEnable_ )
      , depthWriteEnable( depthWriteEnable_ )
      , depthCompareOp( depthCompareOp_ )
      , depthBoundsTestEnable( depthBoundsTestEnable_ )
      , stencilTestEnable( stencilTestEnable_ )
      , front( front_ )
      , back( back_ )
      , minDepthBounds( minDepthBounds_ )
      , maxDepthBounds( maxDepthBounds_ )
    {}

    VULKAN_HPP_CONSTEXPR PipelineDepthStencilStateCreateInfo( PipelineDepthStencilStateCreateInfo const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    PipelineDepthStencilStateCreateInfo( VkPipelineDepthStencilStateCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : PipelineDepthStencilStateCreateInfo( *reinterpret_cast<PipelineDepthStencilStateCreateInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PipelineDepthStencilStateCreateInfo &
                            operator=( PipelineDepthStencilStateCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineDepthStencilStateCreateInfo &
      operator=( VkPipelineDepthStencilStateCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PipelineDepthStencilStateCreateInfo const *>( &rhs );
      return *this;
    }

    PipelineDepthStencilStateCreateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PipelineDepthStencilStateCreateInfo &
      setFlags( VULKAN_HPP_NAMESPACE::PipelineDepthStencilStateCreateFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    PipelineDepthStencilStateCreateInfo &
      setDepthTestEnable( VULKAN_HPP_NAMESPACE::Bool32 depthTestEnable_ ) VULKAN_HPP_NOEXCEPT
    {
      depthTestEnable = depthTestEnable_;
      return *this;
    }

    PipelineDepthStencilStateCreateInfo &
      setDepthWriteEnable( VULKAN_HPP_NAMESPACE::Bool32 depthWriteEnable_ ) VULKAN_HPP_NOEXCEPT
    {
      depthWriteEnable = depthWriteEnable_;
      return *this;
    }

    PipelineDepthStencilStateCreateInfo &
      setDepthCompareOp( VULKAN_HPP_NAMESPACE::CompareOp depthCompareOp_ ) VULKAN_HPP_NOEXCEPT
    {
      depthCompareOp = depthCompareOp_;
      return *this;
    }

    PipelineDepthStencilStateCreateInfo &
      setDepthBoundsTestEnable( VULKAN_HPP_NAMESPACE::Bool32 depthBoundsTestEnable_ ) VULKAN_HPP_NOEXCEPT
    {
      depthBoundsTestEnable = depthBoundsTestEnable_;
      return *this;
    }

    PipelineDepthStencilStateCreateInfo &
      setStencilTestEnable( VULKAN_HPP_NAMESPACE::Bool32 stencilTestEnable_ ) VULKAN_HPP_NOEXCEPT
    {
      stencilTestEnable = stencilTestEnable_;
      return *this;
    }

    PipelineDepthStencilStateCreateInfo &
      setFront( VULKAN_HPP_NAMESPACE::StencilOpState const & front_ ) VULKAN_HPP_NOEXCEPT
    {
      front = front_;
      return *this;
    }

    PipelineDepthStencilStateCreateInfo &
      setBack( VULKAN_HPP_NAMESPACE::StencilOpState const & back_ ) VULKAN_HPP_NOEXCEPT
    {
      back = back_;
      return *this;
    }

    PipelineDepthStencilStateCreateInfo & setMinDepthBounds( float minDepthBounds_ ) VULKAN_HPP_NOEXCEPT
    {
      minDepthBounds = minDepthBounds_;
      return *this;
    }

    PipelineDepthStencilStateCreateInfo & setMaxDepthBounds( float maxDepthBounds_ ) VULKAN_HPP_NOEXCEPT
    {
      maxDepthBounds = maxDepthBounds_;
      return *this;
    }

    operator VkPipelineDepthStencilStateCreateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPipelineDepthStencilStateCreateInfo *>( this );
    }

    operator VkPipelineDepthStencilStateCreateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPipelineDepthStencilStateCreateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PipelineDepthStencilStateCreateInfo const & ) const = default;
#else
    bool operator==( PipelineDepthStencilStateCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( depthTestEnable == rhs.depthTestEnable ) && ( depthWriteEnable == rhs.depthWriteEnable ) &&
             ( depthCompareOp == rhs.depthCompareOp ) && ( depthBoundsTestEnable == rhs.depthBoundsTestEnable ) &&
             ( stencilTestEnable == rhs.stencilTestEnable ) && ( front == rhs.front ) && ( back == rhs.back ) &&
             ( minDepthBounds == rhs.minDepthBounds ) && ( maxDepthBounds == rhs.maxDepthBounds );
    }

    bool operator!=( PipelineDepthStencilStateCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePipelineDepthStencilStateCreateInfo;
    const void *                        pNext = {};
    VULKAN_HPP_NAMESPACE::PipelineDepthStencilStateCreateFlags flags            = {};
    VULKAN_HPP_NAMESPACE::Bool32                               depthTestEnable  = {};
    VULKAN_HPP_NAMESPACE::Bool32                               depthWriteEnable = {};
    VULKAN_HPP_NAMESPACE::CompareOp                            depthCompareOp = VULKAN_HPP_NAMESPACE::CompareOp::eNever;
    VULKAN_HPP_NAMESPACE::Bool32                               depthBoundsTestEnable = {};
    VULKAN_HPP_NAMESPACE::Bool32                               stencilTestEnable     = {};
    VULKAN_HPP_NAMESPACE::StencilOpState                       front                 = {};
    VULKAN_HPP_NAMESPACE::StencilOpState                       back                  = {};
    float                                                      minDepthBounds        = {};
    float                                                      maxDepthBounds        = {};
  };
  static_assert( sizeof( PipelineDepthStencilStateCreateInfo ) == sizeof( VkPipelineDepthStencilStateCreateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PipelineDepthStencilStateCreateInfo>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePipelineDepthStencilStateCreateInfo>
  {
    using Type = PipelineDepthStencilStateCreateInfo;
  };

  struct PipelineColorBlendAttachmentState
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PipelineColorBlendAttachmentState(
      VULKAN_HPP_NAMESPACE::Bool32              blendEnable_         = {},
      VULKAN_HPP_NAMESPACE::BlendFactor         srcColorBlendFactor_ = VULKAN_HPP_NAMESPACE::BlendFactor::eZero,
      VULKAN_HPP_NAMESPACE::BlendFactor         dstColorBlendFactor_ = VULKAN_HPP_NAMESPACE::BlendFactor::eZero,
      VULKAN_HPP_NAMESPACE::BlendOp             colorBlendOp_        = VULKAN_HPP_NAMESPACE::BlendOp::eAdd,
      VULKAN_HPP_NAMESPACE::BlendFactor         srcAlphaBlendFactor_ = VULKAN_HPP_NAMESPACE::BlendFactor::eZero,
      VULKAN_HPP_NAMESPACE::BlendFactor         dstAlphaBlendFactor_ = VULKAN_HPP_NAMESPACE::BlendFactor::eZero,
      VULKAN_HPP_NAMESPACE::BlendOp             alphaBlendOp_        = VULKAN_HPP_NAMESPACE::BlendOp::eAdd,
      VULKAN_HPP_NAMESPACE::ColorComponentFlags colorWriteMask_      = {} ) VULKAN_HPP_NOEXCEPT
      : blendEnable( blendEnable_ )
      , srcColorBlendFactor( srcColorBlendFactor_ )
      , dstColorBlendFactor( dstColorBlendFactor_ )
      , colorBlendOp( colorBlendOp_ )
      , srcAlphaBlendFactor( srcAlphaBlendFactor_ )
      , dstAlphaBlendFactor( dstAlphaBlendFactor_ )
      , alphaBlendOp( alphaBlendOp_ )
      , colorWriteMask( colorWriteMask_ )
    {}

    VULKAN_HPP_CONSTEXPR
      PipelineColorBlendAttachmentState( PipelineColorBlendAttachmentState const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineColorBlendAttachmentState( VkPipelineColorBlendAttachmentState const & rhs ) VULKAN_HPP_NOEXCEPT
      : PipelineColorBlendAttachmentState( *reinterpret_cast<PipelineColorBlendAttachmentState const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PipelineColorBlendAttachmentState &
                            operator=( PipelineColorBlendAttachmentState const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineColorBlendAttachmentState & operator=( VkPipelineColorBlendAttachmentState const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PipelineColorBlendAttachmentState const *>( &rhs );
      return *this;
    }

    PipelineColorBlendAttachmentState & setBlendEnable( VULKAN_HPP_NAMESPACE::Bool32 blendEnable_ ) VULKAN_HPP_NOEXCEPT
    {
      blendEnable = blendEnable_;
      return *this;
    }

    PipelineColorBlendAttachmentState &
      setSrcColorBlendFactor( VULKAN_HPP_NAMESPACE::BlendFactor srcColorBlendFactor_ ) VULKAN_HPP_NOEXCEPT
    {
      srcColorBlendFactor = srcColorBlendFactor_;
      return *this;
    }

    PipelineColorBlendAttachmentState &
      setDstColorBlendFactor( VULKAN_HPP_NAMESPACE::BlendFactor dstColorBlendFactor_ ) VULKAN_HPP_NOEXCEPT
    {
      dstColorBlendFactor = dstColorBlendFactor_;
      return *this;
    }

    PipelineColorBlendAttachmentState &
      setColorBlendOp( VULKAN_HPP_NAMESPACE::BlendOp colorBlendOp_ ) VULKAN_HPP_NOEXCEPT
    {
      colorBlendOp = colorBlendOp_;
      return *this;
    }

    PipelineColorBlendAttachmentState &
      setSrcAlphaBlendFactor( VULKAN_HPP_NAMESPACE::BlendFactor srcAlphaBlendFactor_ ) VULKAN_HPP_NOEXCEPT
    {
      srcAlphaBlendFactor = srcAlphaBlendFactor_;
      return *this;
    }

    PipelineColorBlendAttachmentState &
      setDstAlphaBlendFactor( VULKAN_HPP_NAMESPACE::BlendFactor dstAlphaBlendFactor_ ) VULKAN_HPP_NOEXCEPT
    {
      dstAlphaBlendFactor = dstAlphaBlendFactor_;
      return *this;
    }

    PipelineColorBlendAttachmentState &
      setAlphaBlendOp( VULKAN_HPP_NAMESPACE::BlendOp alphaBlendOp_ ) VULKAN_HPP_NOEXCEPT
    {
      alphaBlendOp = alphaBlendOp_;
      return *this;
    }

    PipelineColorBlendAttachmentState &
      setColorWriteMask( VULKAN_HPP_NAMESPACE::ColorComponentFlags colorWriteMask_ ) VULKAN_HPP_NOEXCEPT
    {
      colorWriteMask = colorWriteMask_;
      return *this;
    }

    operator VkPipelineColorBlendAttachmentState const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPipelineColorBlendAttachmentState *>( this );
    }

    operator VkPipelineColorBlendAttachmentState &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPipelineColorBlendAttachmentState *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PipelineColorBlendAttachmentState const & ) const = default;
#else
    bool operator==( PipelineColorBlendAttachmentState const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( blendEnable == rhs.blendEnable ) && ( srcColorBlendFactor == rhs.srcColorBlendFactor ) &&
             ( dstColorBlendFactor == rhs.dstColorBlendFactor ) && ( colorBlendOp == rhs.colorBlendOp ) &&
             ( srcAlphaBlendFactor == rhs.srcAlphaBlendFactor ) && ( dstAlphaBlendFactor == rhs.dstAlphaBlendFactor ) &&
             ( alphaBlendOp == rhs.alphaBlendOp ) && ( colorWriteMask == rhs.colorWriteMask );
    }

    bool operator!=( PipelineColorBlendAttachmentState const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::Bool32              blendEnable         = {};
    VULKAN_HPP_NAMESPACE::BlendFactor         srcColorBlendFactor = VULKAN_HPP_NAMESPACE::BlendFactor::eZero;
    VULKAN_HPP_NAMESPACE::BlendFactor         dstColorBlendFactor = VULKAN_HPP_NAMESPACE::BlendFactor::eZero;
    VULKAN_HPP_NAMESPACE::BlendOp             colorBlendOp        = VULKAN_HPP_NAMESPACE::BlendOp::eAdd;
    VULKAN_HPP_NAMESPACE::BlendFactor         srcAlphaBlendFactor = VULKAN_HPP_NAMESPACE::BlendFactor::eZero;
    VULKAN_HPP_NAMESPACE::BlendFactor         dstAlphaBlendFactor = VULKAN_HPP_NAMESPACE::BlendFactor::eZero;
    VULKAN_HPP_NAMESPACE::BlendOp             alphaBlendOp        = VULKAN_HPP_NAMESPACE::BlendOp::eAdd;
    VULKAN_HPP_NAMESPACE::ColorComponentFlags colorWriteMask      = {};
  };
  static_assert( sizeof( PipelineColorBlendAttachmentState ) == sizeof( VkPipelineColorBlendAttachmentState ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PipelineColorBlendAttachmentState>::value,
                 "struct wrapper is not a standard layout!" );

  struct PipelineColorBlendStateCreateInfo
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePipelineColorBlendStateCreateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR_14 PipelineColorBlendStateCreateInfo(
      VULKAN_HPP_NAMESPACE::PipelineColorBlendStateCreateFlags        flags_         = {},
      VULKAN_HPP_NAMESPACE::Bool32                                    logicOpEnable_ = {},
      VULKAN_HPP_NAMESPACE::LogicOp                                   logicOp_ = VULKAN_HPP_NAMESPACE::LogicOp::eClear,
      uint32_t                                                        attachmentCount_ = {},
      const VULKAN_HPP_NAMESPACE::PipelineColorBlendAttachmentState * pAttachments_    = {},
      std::array<float, 4> const &                                    blendConstants_  = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , logicOpEnable( logicOpEnable_ )
      , logicOp( logicOp_ )
      , attachmentCount( attachmentCount_ )
      , pAttachments( pAttachments_ )
      , blendConstants( blendConstants_ )
    {}

    VULKAN_HPP_CONSTEXPR_14
      PipelineColorBlendStateCreateInfo( PipelineColorBlendStateCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineColorBlendStateCreateInfo( VkPipelineColorBlendStateCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : PipelineColorBlendStateCreateInfo( *reinterpret_cast<PipelineColorBlendStateCreateInfo const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    PipelineColorBlendStateCreateInfo(
      VULKAN_HPP_NAMESPACE::PipelineColorBlendStateCreateFlags flags_,
      VULKAN_HPP_NAMESPACE::Bool32                             logicOpEnable_,
      VULKAN_HPP_NAMESPACE::LogicOp                            logicOp_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<
        const VULKAN_HPP_NAMESPACE::PipelineColorBlendAttachmentState> const & attachments_,
      std::array<float, 4> const &                                             blendConstants_ = {} )
      : flags( flags_ )
      , logicOpEnable( logicOpEnable_ )
      , logicOp( logicOp_ )
      , attachmentCount( static_cast<uint32_t>( attachments_.size() ) )
      , pAttachments( attachments_.data() )
      , blendConstants( blendConstants_ )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PipelineColorBlendStateCreateInfo &
                            operator=( PipelineColorBlendStateCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineColorBlendStateCreateInfo & operator=( VkPipelineColorBlendStateCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PipelineColorBlendStateCreateInfo const *>( &rhs );
      return *this;
    }

    PipelineColorBlendStateCreateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PipelineColorBlendStateCreateInfo &
      setFlags( VULKAN_HPP_NAMESPACE::PipelineColorBlendStateCreateFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    PipelineColorBlendStateCreateInfo &
      setLogicOpEnable( VULKAN_HPP_NAMESPACE::Bool32 logicOpEnable_ ) VULKAN_HPP_NOEXCEPT
    {
      logicOpEnable = logicOpEnable_;
      return *this;
    }

    PipelineColorBlendStateCreateInfo & setLogicOp( VULKAN_HPP_NAMESPACE::LogicOp logicOp_ ) VULKAN_HPP_NOEXCEPT
    {
      logicOp = logicOp_;
      return *this;
    }

    PipelineColorBlendStateCreateInfo & setAttachmentCount( uint32_t attachmentCount_ ) VULKAN_HPP_NOEXCEPT
    {
      attachmentCount = attachmentCount_;
      return *this;
    }

    PipelineColorBlendStateCreateInfo & setPAttachments(
      const VULKAN_HPP_NAMESPACE::PipelineColorBlendAttachmentState * pAttachments_ ) VULKAN_HPP_NOEXCEPT
    {
      pAttachments = pAttachments_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    PipelineColorBlendStateCreateInfo & setAttachments(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<
        const VULKAN_HPP_NAMESPACE::PipelineColorBlendAttachmentState> const & attachments_ ) VULKAN_HPP_NOEXCEPT
    {
      attachmentCount = static_cast<uint32_t>( attachments_.size() );
      pAttachments    = attachments_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    PipelineColorBlendStateCreateInfo & setBlendConstants( std::array<float, 4> blendConstants_ ) VULKAN_HPP_NOEXCEPT
    {
      blendConstants = blendConstants_;
      return *this;
    }

    operator VkPipelineColorBlendStateCreateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPipelineColorBlendStateCreateInfo *>( this );
    }

    operator VkPipelineColorBlendStateCreateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPipelineColorBlendStateCreateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PipelineColorBlendStateCreateInfo const & ) const = default;
#else
    bool operator==( PipelineColorBlendStateCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( logicOpEnable == rhs.logicOpEnable ) && ( logicOp == rhs.logicOp ) &&
             ( attachmentCount == rhs.attachmentCount ) && ( pAttachments == rhs.pAttachments ) &&
             ( blendConstants == rhs.blendConstants );
    }

    bool operator!=( PipelineColorBlendStateCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                      sType = StructureType::ePipelineColorBlendStateCreateInfo;
    const void *                                             pNext = {};
    VULKAN_HPP_NAMESPACE::PipelineColorBlendStateCreateFlags flags = {};
    VULKAN_HPP_NAMESPACE::Bool32                             logicOpEnable   = {};
    VULKAN_HPP_NAMESPACE::LogicOp                            logicOp         = VULKAN_HPP_NAMESPACE::LogicOp::eClear;
    uint32_t                                                 attachmentCount = {};
    const VULKAN_HPP_NAMESPACE::PipelineColorBlendAttachmentState * pAttachments   = {};
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<float, 4>                  blendConstants = {};
  };
  static_assert( sizeof( PipelineColorBlendStateCreateInfo ) == sizeof( VkPipelineColorBlendStateCreateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PipelineColorBlendStateCreateInfo>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePipelineColorBlendStateCreateInfo>
  {
    using Type = PipelineColorBlendStateCreateInfo;
  };

  struct PipelineDynamicStateCreateInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::ePipelineDynamicStateCreateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PipelineDynamicStateCreateInfo(
      VULKAN_HPP_NAMESPACE::PipelineDynamicStateCreateFlags flags_             = {},
      uint32_t                                              dynamicStateCount_ = {},
      const VULKAN_HPP_NAMESPACE::DynamicState *            pDynamicStates_    = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , dynamicStateCount( dynamicStateCount_ )
      , pDynamicStates( pDynamicStates_ )
    {}

    VULKAN_HPP_CONSTEXPR
      PipelineDynamicStateCreateInfo( PipelineDynamicStateCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineDynamicStateCreateInfo( VkPipelineDynamicStateCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : PipelineDynamicStateCreateInfo( *reinterpret_cast<PipelineDynamicStateCreateInfo const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    PipelineDynamicStateCreateInfo(
      VULKAN_HPP_NAMESPACE::PipelineDynamicStateCreateFlags                                           flags_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::DynamicState> const & dynamicStates_ )
      : flags( flags_ )
      , dynamicStateCount( static_cast<uint32_t>( dynamicStates_.size() ) )
      , pDynamicStates( dynamicStates_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PipelineDynamicStateCreateInfo &
                            operator=( PipelineDynamicStateCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineDynamicStateCreateInfo & operator=( VkPipelineDynamicStateCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PipelineDynamicStateCreateInfo const *>( &rhs );
      return *this;
    }

    PipelineDynamicStateCreateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PipelineDynamicStateCreateInfo &
      setFlags( VULKAN_HPP_NAMESPACE::PipelineDynamicStateCreateFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    PipelineDynamicStateCreateInfo & setDynamicStateCount( uint32_t dynamicStateCount_ ) VULKAN_HPP_NOEXCEPT
    {
      dynamicStateCount = dynamicStateCount_;
      return *this;
    }

    PipelineDynamicStateCreateInfo &
      setPDynamicStates( const VULKAN_HPP_NAMESPACE::DynamicState * pDynamicStates_ ) VULKAN_HPP_NOEXCEPT
    {
      pDynamicStates = pDynamicStates_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    PipelineDynamicStateCreateInfo & setDynamicStates(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::DynamicState> const & dynamicStates_ )
      VULKAN_HPP_NOEXCEPT
    {
      dynamicStateCount = static_cast<uint32_t>( dynamicStates_.size() );
      pDynamicStates    = dynamicStates_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkPipelineDynamicStateCreateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPipelineDynamicStateCreateInfo *>( this );
    }

    operator VkPipelineDynamicStateCreateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPipelineDynamicStateCreateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PipelineDynamicStateCreateInfo const & ) const = default;
#else
    bool operator==( PipelineDynamicStateCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( dynamicStateCount == rhs.dynamicStateCount ) && ( pDynamicStates == rhs.pDynamicStates );
    }

    bool operator!=( PipelineDynamicStateCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                   sType = StructureType::ePipelineDynamicStateCreateInfo;
    const void *                                          pNext = {};
    VULKAN_HPP_NAMESPACE::PipelineDynamicStateCreateFlags flags = {};
    uint32_t                                              dynamicStateCount = {};
    const VULKAN_HPP_NAMESPACE::DynamicState *            pDynamicStates    = {};
  };
  static_assert( sizeof( PipelineDynamicStateCreateInfo ) == sizeof( VkPipelineDynamicStateCreateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PipelineDynamicStateCreateInfo>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePipelineDynamicStateCreateInfo>
  {
    using Type = PipelineDynamicStateCreateInfo;
  };

  struct GraphicsPipelineCreateInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eGraphicsPipelineCreateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR_14 GraphicsPipelineCreateInfo(
      VULKAN_HPP_NAMESPACE::PipelineCreateFlags                          flags_               = {},
      uint32_t                                                           stageCount_          = {},
      const VULKAN_HPP_NAMESPACE::PipelineShaderStageCreateInfo *        pStages_             = {},
      const VULKAN_HPP_NAMESPACE::PipelineVertexInputStateCreateInfo *   pVertexInputState_   = {},
      const VULKAN_HPP_NAMESPACE::PipelineInputAssemblyStateCreateInfo * pInputAssemblyState_ = {},
      const VULKAN_HPP_NAMESPACE::PipelineTessellationStateCreateInfo *  pTessellationState_  = {},
      const VULKAN_HPP_NAMESPACE::PipelineViewportStateCreateInfo *      pViewportState_      = {},
      const VULKAN_HPP_NAMESPACE::PipelineRasterizationStateCreateInfo * pRasterizationState_ = {},
      const VULKAN_HPP_NAMESPACE::PipelineMultisampleStateCreateInfo *   pMultisampleState_   = {},
      const VULKAN_HPP_NAMESPACE::PipelineDepthStencilStateCreateInfo *  pDepthStencilState_  = {},
      const VULKAN_HPP_NAMESPACE::PipelineColorBlendStateCreateInfo *    pColorBlendState_    = {},
      const VULKAN_HPP_NAMESPACE::PipelineDynamicStateCreateInfo *       pDynamicState_       = {},
      VULKAN_HPP_NAMESPACE::PipelineLayout                               layout_              = {},
      VULKAN_HPP_NAMESPACE::RenderPass                                   renderPass_          = {},
      uint32_t                                                           subpass_             = {},
      VULKAN_HPP_NAMESPACE::Pipeline                                     basePipelineHandle_  = {},
      int32_t                                                            basePipelineIndex_   = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , stageCount( stageCount_ )
      , pStages( pStages_ )
      , pVertexInputState( pVertexInputState_ )
      , pInputAssemblyState( pInputAssemblyState_ )
      , pTessellationState( pTessellationState_ )
      , pViewportState( pViewportState_ )
      , pRasterizationState( pRasterizationState_ )
      , pMultisampleState( pMultisampleState_ )
      , pDepthStencilState( pDepthStencilState_ )
      , pColorBlendState( pColorBlendState_ )
      , pDynamicState( pDynamicState_ )
      , layout( layout_ )
      , renderPass( renderPass_ )
      , subpass( subpass_ )
      , basePipelineHandle( basePipelineHandle_ )
      , basePipelineIndex( basePipelineIndex_ )
    {}

    VULKAN_HPP_CONSTEXPR_14
      GraphicsPipelineCreateInfo( GraphicsPipelineCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    GraphicsPipelineCreateInfo( VkGraphicsPipelineCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : GraphicsPipelineCreateInfo( *reinterpret_cast<GraphicsPipelineCreateInfo const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    GraphicsPipelineCreateInfo(
      VULKAN_HPP_NAMESPACE::PipelineCreateFlags flags_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::PipelineShaderStageCreateInfo> const &
                                                                         stages_,
      const VULKAN_HPP_NAMESPACE::PipelineVertexInputStateCreateInfo *   pVertexInputState_   = {},
      const VULKAN_HPP_NAMESPACE::PipelineInputAssemblyStateCreateInfo * pInputAssemblyState_ = {},
      const VULKAN_HPP_NAMESPACE::PipelineTessellationStateCreateInfo *  pTessellationState_  = {},
      const VULKAN_HPP_NAMESPACE::PipelineViewportStateCreateInfo *      pViewportState_      = {},
      const VULKAN_HPP_NAMESPACE::PipelineRasterizationStateCreateInfo * pRasterizationState_ = {},
      const VULKAN_HPP_NAMESPACE::PipelineMultisampleStateCreateInfo *   pMultisampleState_   = {},
      const VULKAN_HPP_NAMESPACE::PipelineDepthStencilStateCreateInfo *  pDepthStencilState_  = {},
      const VULKAN_HPP_NAMESPACE::PipelineColorBlendStateCreateInfo *    pColorBlendState_    = {},
      const VULKAN_HPP_NAMESPACE::PipelineDynamicStateCreateInfo *       pDynamicState_       = {},
      VULKAN_HPP_NAMESPACE::PipelineLayout                               layout_              = {},
      VULKAN_HPP_NAMESPACE::RenderPass                                   renderPass_          = {},
      uint32_t                                                           subpass_             = {},
      VULKAN_HPP_NAMESPACE::Pipeline                                     basePipelineHandle_  = {},
      int32_t                                                            basePipelineIndex_   = {} )
      : flags( flags_ )
      , stageCount( static_cast<uint32_t>( stages_.size() ) )
      , pStages( stages_.data() )
      , pVertexInputState( pVertexInputState_ )
      , pInputAssemblyState( pInputAssemblyState_ )
      , pTessellationState( pTessellationState_ )
      , pViewportState( pViewportState_ )
      , pRasterizationState( pRasterizationState_ )
      , pMultisampleState( pMultisampleState_ )
      , pDepthStencilState( pDepthStencilState_ )
      , pColorBlendState( pColorBlendState_ )
      , pDynamicState( pDynamicState_ )
      , layout( layout_ )
      , renderPass( renderPass_ )
      , subpass( subpass_ )
      , basePipelineHandle( basePipelineHandle_ )
      , basePipelineIndex( basePipelineIndex_ )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 GraphicsPipelineCreateInfo &
                            operator=( GraphicsPipelineCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    GraphicsPipelineCreateInfo & operator=( VkGraphicsPipelineCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::GraphicsPipelineCreateInfo const *>( &rhs );
      return *this;
    }

    GraphicsPipelineCreateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    GraphicsPipelineCreateInfo & setFlags( VULKAN_HPP_NAMESPACE::PipelineCreateFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    GraphicsPipelineCreateInfo & setStageCount( uint32_t stageCount_ ) VULKAN_HPP_NOEXCEPT
    {
      stageCount = stageCount_;
      return *this;
    }

    GraphicsPipelineCreateInfo &
      setPStages( const VULKAN_HPP_NAMESPACE::PipelineShaderStageCreateInfo * pStages_ ) VULKAN_HPP_NOEXCEPT
    {
      pStages = pStages_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    GraphicsPipelineCreateInfo & setStages(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::PipelineShaderStageCreateInfo> const &
        stages_ ) VULKAN_HPP_NOEXCEPT
    {
      stageCount = static_cast<uint32_t>( stages_.size() );
      pStages    = stages_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    GraphicsPipelineCreateInfo & setPVertexInputState(
      const VULKAN_HPP_NAMESPACE::PipelineVertexInputStateCreateInfo * pVertexInputState_ ) VULKAN_HPP_NOEXCEPT
    {
      pVertexInputState = pVertexInputState_;
      return *this;
    }

    GraphicsPipelineCreateInfo & setPInputAssemblyState(
      const VULKAN_HPP_NAMESPACE::PipelineInputAssemblyStateCreateInfo * pInputAssemblyState_ ) VULKAN_HPP_NOEXCEPT
    {
      pInputAssemblyState = pInputAssemblyState_;
      return *this;
    }

    GraphicsPipelineCreateInfo & setPTessellationState(
      const VULKAN_HPP_NAMESPACE::PipelineTessellationStateCreateInfo * pTessellationState_ ) VULKAN_HPP_NOEXCEPT
    {
      pTessellationState = pTessellationState_;
      return *this;
    }

    GraphicsPipelineCreateInfo & setPViewportState(
      const VULKAN_HPP_NAMESPACE::PipelineViewportStateCreateInfo * pViewportState_ ) VULKAN_HPP_NOEXCEPT
    {
      pViewportState = pViewportState_;
      return *this;
    }

    GraphicsPipelineCreateInfo & setPRasterizationState(
      const VULKAN_HPP_NAMESPACE::PipelineRasterizationStateCreateInfo * pRasterizationState_ ) VULKAN_HPP_NOEXCEPT
    {
      pRasterizationState = pRasterizationState_;
      return *this;
    }

    GraphicsPipelineCreateInfo & setPMultisampleState(
      const VULKAN_HPP_NAMESPACE::PipelineMultisampleStateCreateInfo * pMultisampleState_ ) VULKAN_HPP_NOEXCEPT
    {
      pMultisampleState = pMultisampleState_;
      return *this;
    }

    GraphicsPipelineCreateInfo & setPDepthStencilState(
      const VULKAN_HPP_NAMESPACE::PipelineDepthStencilStateCreateInfo * pDepthStencilState_ ) VULKAN_HPP_NOEXCEPT
    {
      pDepthStencilState = pDepthStencilState_;
      return *this;
    }

    GraphicsPipelineCreateInfo & setPColorBlendState(
      const VULKAN_HPP_NAMESPACE::PipelineColorBlendStateCreateInfo * pColorBlendState_ ) VULKAN_HPP_NOEXCEPT
    {
      pColorBlendState = pColorBlendState_;
      return *this;
    }

    GraphicsPipelineCreateInfo & setPDynamicState(
      const VULKAN_HPP_NAMESPACE::PipelineDynamicStateCreateInfo * pDynamicState_ ) VULKAN_HPP_NOEXCEPT
    {
      pDynamicState = pDynamicState_;
      return *this;
    }

    GraphicsPipelineCreateInfo & setLayout( VULKAN_HPP_NAMESPACE::PipelineLayout layout_ ) VULKAN_HPP_NOEXCEPT
    {
      layout = layout_;
      return *this;
    }

    GraphicsPipelineCreateInfo & setRenderPass( VULKAN_HPP_NAMESPACE::RenderPass renderPass_ ) VULKAN_HPP_NOEXCEPT
    {
      renderPass = renderPass_;
      return *this;
    }

    GraphicsPipelineCreateInfo & setSubpass( uint32_t subpass_ ) VULKAN_HPP_NOEXCEPT
    {
      subpass = subpass_;
      return *this;
    }

    GraphicsPipelineCreateInfo &
      setBasePipelineHandle( VULKAN_HPP_NAMESPACE::Pipeline basePipelineHandle_ ) VULKAN_HPP_NOEXCEPT
    {
      basePipelineHandle = basePipelineHandle_;
      return *this;
    }

    GraphicsPipelineCreateInfo & setBasePipelineIndex( int32_t basePipelineIndex_ ) VULKAN_HPP_NOEXCEPT
    {
      basePipelineIndex = basePipelineIndex_;
      return *this;
    }

    operator VkGraphicsPipelineCreateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkGraphicsPipelineCreateInfo *>( this );
    }

    operator VkGraphicsPipelineCreateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkGraphicsPipelineCreateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( GraphicsPipelineCreateInfo const & ) const = default;
#else
    bool operator==( GraphicsPipelineCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( stageCount == rhs.stageCount ) && ( pStages == rhs.pStages ) &&
             ( pVertexInputState == rhs.pVertexInputState ) && ( pInputAssemblyState == rhs.pInputAssemblyState ) &&
             ( pTessellationState == rhs.pTessellationState ) && ( pViewportState == rhs.pViewportState ) &&
             ( pRasterizationState == rhs.pRasterizationState ) && ( pMultisampleState == rhs.pMultisampleState ) &&
             ( pDepthStencilState == rhs.pDepthStencilState ) && ( pColorBlendState == rhs.pColorBlendState ) &&
             ( pDynamicState == rhs.pDynamicState ) && ( layout == rhs.layout ) && ( renderPass == rhs.renderPass ) &&
             ( subpass == rhs.subpass ) && ( basePipelineHandle == rhs.basePipelineHandle ) &&
             ( basePipelineIndex == rhs.basePipelineIndex );
    }

    bool operator!=( GraphicsPipelineCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                              sType = StructureType::eGraphicsPipelineCreateInfo;
    const void *                                                     pNext = {};
    VULKAN_HPP_NAMESPACE::PipelineCreateFlags                        flags = {};
    uint32_t                                                         stageCount            = {};
    const VULKAN_HPP_NAMESPACE::PipelineShaderStageCreateInfo *      pStages               = {};
    const VULKAN_HPP_NAMESPACE::PipelineVertexInputStateCreateInfo * pVertexInputState     = {};
    const VULKAN_HPP_NAMESPACE::PipelineInputAssemblyStateCreateInfo * pInputAssemblyState = {};
    const VULKAN_HPP_NAMESPACE::PipelineTessellationStateCreateInfo *  pTessellationState  = {};
    const VULKAN_HPP_NAMESPACE::PipelineViewportStateCreateInfo *      pViewportState      = {};
    const VULKAN_HPP_NAMESPACE::PipelineRasterizationStateCreateInfo * pRasterizationState = {};
    const VULKAN_HPP_NAMESPACE::PipelineMultisampleStateCreateInfo *   pMultisampleState   = {};
    const VULKAN_HPP_NAMESPACE::PipelineDepthStencilStateCreateInfo *  pDepthStencilState  = {};
    const VULKAN_HPP_NAMESPACE::PipelineColorBlendStateCreateInfo *    pColorBlendState    = {};
    const VULKAN_HPP_NAMESPACE::PipelineDynamicStateCreateInfo *       pDynamicState       = {};
    VULKAN_HPP_NAMESPACE::PipelineLayout                               layout              = {};
    VULKAN_HPP_NAMESPACE::RenderPass                                   renderPass          = {};
    uint32_t                                                           subpass             = {};
    VULKAN_HPP_NAMESPACE::Pipeline                                     basePipelineHandle  = {};
    int32_t                                                            basePipelineIndex   = {};
  };
  static_assert( sizeof( GraphicsPipelineCreateInfo ) == sizeof( VkGraphicsPipelineCreateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<GraphicsPipelineCreateInfo>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eGraphicsPipelineCreateInfo>
  {
    using Type = GraphicsPipelineCreateInfo;
  };

  struct GraphicsShaderGroupCreateInfoNV
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eGraphicsShaderGroupCreateInfoNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR GraphicsShaderGroupCreateInfoNV(
      uint32_t                                                          stageCount_         = {},
      const VULKAN_HPP_NAMESPACE::PipelineShaderStageCreateInfo *       pStages_            = {},
      const VULKAN_HPP_NAMESPACE::PipelineVertexInputStateCreateInfo *  pVertexInputState_  = {},
      const VULKAN_HPP_NAMESPACE::PipelineTessellationStateCreateInfo * pTessellationState_ = {} ) VULKAN_HPP_NOEXCEPT
      : stageCount( stageCount_ )
      , pStages( pStages_ )
      , pVertexInputState( pVertexInputState_ )
      , pTessellationState( pTessellationState_ )
    {}

    VULKAN_HPP_CONSTEXPR
      GraphicsShaderGroupCreateInfoNV( GraphicsShaderGroupCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    GraphicsShaderGroupCreateInfoNV( VkGraphicsShaderGroupCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
      : GraphicsShaderGroupCreateInfoNV( *reinterpret_cast<GraphicsShaderGroupCreateInfoNV const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    GraphicsShaderGroupCreateInfoNV(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::PipelineShaderStageCreateInfo> const &
                                                                        stages_,
      const VULKAN_HPP_NAMESPACE::PipelineVertexInputStateCreateInfo *  pVertexInputState_  = {},
      const VULKAN_HPP_NAMESPACE::PipelineTessellationStateCreateInfo * pTessellationState_ = {} )
      : stageCount( static_cast<uint32_t>( stages_.size() ) )
      , pStages( stages_.data() )
      , pVertexInputState( pVertexInputState_ )
      , pTessellationState( pTessellationState_ )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 GraphicsShaderGroupCreateInfoNV &
                            operator=( GraphicsShaderGroupCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    GraphicsShaderGroupCreateInfoNV & operator=( VkGraphicsShaderGroupCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::GraphicsShaderGroupCreateInfoNV const *>( &rhs );
      return *this;
    }

    GraphicsShaderGroupCreateInfoNV & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    GraphicsShaderGroupCreateInfoNV & setStageCount( uint32_t stageCount_ ) VULKAN_HPP_NOEXCEPT
    {
      stageCount = stageCount_;
      return *this;
    }

    GraphicsShaderGroupCreateInfoNV &
      setPStages( const VULKAN_HPP_NAMESPACE::PipelineShaderStageCreateInfo * pStages_ ) VULKAN_HPP_NOEXCEPT
    {
      pStages = pStages_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    GraphicsShaderGroupCreateInfoNV & setStages(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::PipelineShaderStageCreateInfo> const &
        stages_ ) VULKAN_HPP_NOEXCEPT
    {
      stageCount = static_cast<uint32_t>( stages_.size() );
      pStages    = stages_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    GraphicsShaderGroupCreateInfoNV & setPVertexInputState(
      const VULKAN_HPP_NAMESPACE::PipelineVertexInputStateCreateInfo * pVertexInputState_ ) VULKAN_HPP_NOEXCEPT
    {
      pVertexInputState = pVertexInputState_;
      return *this;
    }

    GraphicsShaderGroupCreateInfoNV & setPTessellationState(
      const VULKAN_HPP_NAMESPACE::PipelineTessellationStateCreateInfo * pTessellationState_ ) VULKAN_HPP_NOEXCEPT
    {
      pTessellationState = pTessellationState_;
      return *this;
    }

    operator VkGraphicsShaderGroupCreateInfoNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkGraphicsShaderGroupCreateInfoNV *>( this );
    }

    operator VkGraphicsShaderGroupCreateInfoNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkGraphicsShaderGroupCreateInfoNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( GraphicsShaderGroupCreateInfoNV const & ) const = default;
#else
    bool operator==( GraphicsShaderGroupCreateInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( stageCount == rhs.stageCount ) &&
             ( pStages == rhs.pStages ) && ( pVertexInputState == rhs.pVertexInputState ) &&
             ( pTessellationState == rhs.pTessellationState );
    }

    bool operator!=( GraphicsShaderGroupCreateInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                         sType = StructureType::eGraphicsShaderGroupCreateInfoNV;
    const void *                                                pNext = {};
    uint32_t                                                    stageCount               = {};
    const VULKAN_HPP_NAMESPACE::PipelineShaderStageCreateInfo * pStages                  = {};
    const VULKAN_HPP_NAMESPACE::PipelineVertexInputStateCreateInfo *  pVertexInputState  = {};
    const VULKAN_HPP_NAMESPACE::PipelineTessellationStateCreateInfo * pTessellationState = {};
  };
  static_assert( sizeof( GraphicsShaderGroupCreateInfoNV ) == sizeof( VkGraphicsShaderGroupCreateInfoNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<GraphicsShaderGroupCreateInfoNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eGraphicsShaderGroupCreateInfoNV>
  {
    using Type = GraphicsShaderGroupCreateInfoNV;
  };

  struct GraphicsPipelineShaderGroupsCreateInfoNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eGraphicsPipelineShaderGroupsCreateInfoNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR GraphicsPipelineShaderGroupsCreateInfoNV(
      uint32_t                                                      groupCount_    = {},
      const VULKAN_HPP_NAMESPACE::GraphicsShaderGroupCreateInfoNV * pGroups_       = {},
      uint32_t                                                      pipelineCount_ = {},
      const VULKAN_HPP_NAMESPACE::Pipeline *                        pPipelines_    = {} ) VULKAN_HPP_NOEXCEPT
      : groupCount( groupCount_ )
      , pGroups( pGroups_ )
      , pipelineCount( pipelineCount_ )
      , pPipelines( pPipelines_ )
    {}

    VULKAN_HPP_CONSTEXPR GraphicsPipelineShaderGroupsCreateInfoNV(
      GraphicsPipelineShaderGroupsCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    GraphicsPipelineShaderGroupsCreateInfoNV( VkGraphicsPipelineShaderGroupsCreateInfoNV const & rhs )
      VULKAN_HPP_NOEXCEPT
      : GraphicsPipelineShaderGroupsCreateInfoNV(
          *reinterpret_cast<GraphicsPipelineShaderGroupsCreateInfoNV const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    GraphicsPipelineShaderGroupsCreateInfoNV(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::GraphicsShaderGroupCreateInfoNV> const &
                                                                                                  groups_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::Pipeline> const & pipelines_ = {} )
      : groupCount( static_cast<uint32_t>( groups_.size() ) )
      , pGroups( groups_.data() )
      , pipelineCount( static_cast<uint32_t>( pipelines_.size() ) )
      , pPipelines( pipelines_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 GraphicsPipelineShaderGroupsCreateInfoNV &
                            operator=( GraphicsPipelineShaderGroupsCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    GraphicsPipelineShaderGroupsCreateInfoNV &
      operator=( VkGraphicsPipelineShaderGroupsCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::GraphicsPipelineShaderGroupsCreateInfoNV const *>( &rhs );
      return *this;
    }

    GraphicsPipelineShaderGroupsCreateInfoNV & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    GraphicsPipelineShaderGroupsCreateInfoNV & setGroupCount( uint32_t groupCount_ ) VULKAN_HPP_NOEXCEPT
    {
      groupCount = groupCount_;
      return *this;
    }

    GraphicsPipelineShaderGroupsCreateInfoNV &
      setPGroups( const VULKAN_HPP_NAMESPACE::GraphicsShaderGroupCreateInfoNV * pGroups_ ) VULKAN_HPP_NOEXCEPT
    {
      pGroups = pGroups_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    GraphicsPipelineShaderGroupsCreateInfoNV & setGroups(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::GraphicsShaderGroupCreateInfoNV> const &
        groups_ ) VULKAN_HPP_NOEXCEPT
    {
      groupCount = static_cast<uint32_t>( groups_.size() );
      pGroups    = groups_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    GraphicsPipelineShaderGroupsCreateInfoNV & setPipelineCount( uint32_t pipelineCount_ ) VULKAN_HPP_NOEXCEPT
    {
      pipelineCount = pipelineCount_;
      return *this;
    }

    GraphicsPipelineShaderGroupsCreateInfoNV &
      setPPipelines( const VULKAN_HPP_NAMESPACE::Pipeline * pPipelines_ ) VULKAN_HPP_NOEXCEPT
    {
      pPipelines = pPipelines_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    GraphicsPipelineShaderGroupsCreateInfoNV & setPipelines(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::Pipeline> const & pipelines_ )
      VULKAN_HPP_NOEXCEPT
    {
      pipelineCount = static_cast<uint32_t>( pipelines_.size() );
      pPipelines    = pipelines_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkGraphicsPipelineShaderGroupsCreateInfoNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkGraphicsPipelineShaderGroupsCreateInfoNV *>( this );
    }

    operator VkGraphicsPipelineShaderGroupsCreateInfoNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkGraphicsPipelineShaderGroupsCreateInfoNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( GraphicsPipelineShaderGroupsCreateInfoNV const & ) const = default;
#else
    bool operator==( GraphicsPipelineShaderGroupsCreateInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( groupCount == rhs.groupCount ) &&
             ( pGroups == rhs.pGroups ) && ( pipelineCount == rhs.pipelineCount ) && ( pPipelines == rhs.pPipelines );
    }

    bool operator!=( GraphicsPipelineShaderGroupsCreateInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType      = StructureType::eGraphicsPipelineShaderGroupsCreateInfoNV;
    const void *                        pNext      = {};
    uint32_t                            groupCount = {};
    const VULKAN_HPP_NAMESPACE::GraphicsShaderGroupCreateInfoNV * pGroups       = {};
    uint32_t                                                      pipelineCount = {};
    const VULKAN_HPP_NAMESPACE::Pipeline *                        pPipelines    = {};
  };
  static_assert( sizeof( GraphicsPipelineShaderGroupsCreateInfoNV ) ==
                   sizeof( VkGraphicsPipelineShaderGroupsCreateInfoNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<GraphicsPipelineShaderGroupsCreateInfoNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eGraphicsPipelineShaderGroupsCreateInfoNV>
  {
    using Type = GraphicsPipelineShaderGroupsCreateInfoNV;
  };

  struct XYColorEXT
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR XYColorEXT( float x_ = {}, float y_ = {} ) VULKAN_HPP_NOEXCEPT
      : x( x_ )
      , y( y_ )
    {}

    VULKAN_HPP_CONSTEXPR XYColorEXT( XYColorEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    XYColorEXT( VkXYColorEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : XYColorEXT( *reinterpret_cast<XYColorEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 XYColorEXT & operator=( XYColorEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    XYColorEXT & operator=( VkXYColorEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::XYColorEXT const *>( &rhs );
      return *this;
    }

    XYColorEXT & setX( float x_ ) VULKAN_HPP_NOEXCEPT
    {
      x = x_;
      return *this;
    }

    XYColorEXT & setY( float y_ ) VULKAN_HPP_NOEXCEPT
    {
      y = y_;
      return *this;
    }

    operator VkXYColorEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkXYColorEXT *>( this );
    }

    operator VkXYColorEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkXYColorEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( XYColorEXT const & ) const = default;
#else
    bool operator==( XYColorEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( x == rhs.x ) && ( y == rhs.y );
    }

    bool operator!=( XYColorEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    float x = {};
    float y = {};
  };
  static_assert( sizeof( XYColorEXT ) == sizeof( VkXYColorEXT ), "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<XYColorEXT>::value, "struct wrapper is not a standard layout!" );

  struct HdrMetadataEXT
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eHdrMetadataEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR HdrMetadataEXT( VULKAN_HPP_NAMESPACE::XYColorEXT displayPrimaryRed_    = {},
                                         VULKAN_HPP_NAMESPACE::XYColorEXT displayPrimaryGreen_  = {},
                                         VULKAN_HPP_NAMESPACE::XYColorEXT displayPrimaryBlue_   = {},
                                         VULKAN_HPP_NAMESPACE::XYColorEXT whitePoint_           = {},
                                         float                            maxLuminance_         = {},
                                         float                            minLuminance_         = {},
                                         float                            maxContentLightLevel_ = {},
                                         float maxFrameAverageLightLevel_ = {} ) VULKAN_HPP_NOEXCEPT
      : displayPrimaryRed( displayPrimaryRed_ )
      , displayPrimaryGreen( displayPrimaryGreen_ )
      , displayPrimaryBlue( displayPrimaryBlue_ )
      , whitePoint( whitePoint_ )
      , maxLuminance( maxLuminance_ )
      , minLuminance( minLuminance_ )
      , maxContentLightLevel( maxContentLightLevel_ )
      , maxFrameAverageLightLevel( maxFrameAverageLightLevel_ )
    {}

    VULKAN_HPP_CONSTEXPR HdrMetadataEXT( HdrMetadataEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    HdrMetadataEXT( VkHdrMetadataEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : HdrMetadataEXT( *reinterpret_cast<HdrMetadataEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 HdrMetadataEXT & operator=( HdrMetadataEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    HdrMetadataEXT & operator=( VkHdrMetadataEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::HdrMetadataEXT const *>( &rhs );
      return *this;
    }

    HdrMetadataEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    HdrMetadataEXT &
      setDisplayPrimaryRed( VULKAN_HPP_NAMESPACE::XYColorEXT const & displayPrimaryRed_ ) VULKAN_HPP_NOEXCEPT
    {
      displayPrimaryRed = displayPrimaryRed_;
      return *this;
    }

    HdrMetadataEXT &
      setDisplayPrimaryGreen( VULKAN_HPP_NAMESPACE::XYColorEXT const & displayPrimaryGreen_ ) VULKAN_HPP_NOEXCEPT
    {
      displayPrimaryGreen = displayPrimaryGreen_;
      return *this;
    }

    HdrMetadataEXT &
      setDisplayPrimaryBlue( VULKAN_HPP_NAMESPACE::XYColorEXT const & displayPrimaryBlue_ ) VULKAN_HPP_NOEXCEPT
    {
      displayPrimaryBlue = displayPrimaryBlue_;
      return *this;
    }

    HdrMetadataEXT & setWhitePoint( VULKAN_HPP_NAMESPACE::XYColorEXT const & whitePoint_ ) VULKAN_HPP_NOEXCEPT
    {
      whitePoint = whitePoint_;
      return *this;
    }

    HdrMetadataEXT & setMaxLuminance( float maxLuminance_ ) VULKAN_HPP_NOEXCEPT
    {
      maxLuminance = maxLuminance_;
      return *this;
    }

    HdrMetadataEXT & setMinLuminance( float minLuminance_ ) VULKAN_HPP_NOEXCEPT
    {
      minLuminance = minLuminance_;
      return *this;
    }

    HdrMetadataEXT & setMaxContentLightLevel( float maxContentLightLevel_ ) VULKAN_HPP_NOEXCEPT
    {
      maxContentLightLevel = maxContentLightLevel_;
      return *this;
    }

    HdrMetadataEXT & setMaxFrameAverageLightLevel( float maxFrameAverageLightLevel_ ) VULKAN_HPP_NOEXCEPT
    {
      maxFrameAverageLightLevel = maxFrameAverageLightLevel_;
      return *this;
    }

    operator VkHdrMetadataEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkHdrMetadataEXT *>( this );
    }

    operator VkHdrMetadataEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkHdrMetadataEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( HdrMetadataEXT const & ) const = default;
#else
    bool operator==( HdrMetadataEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( displayPrimaryRed == rhs.displayPrimaryRed ) &&
             ( displayPrimaryGreen == rhs.displayPrimaryGreen ) && ( displayPrimaryBlue == rhs.displayPrimaryBlue ) &&
             ( whitePoint == rhs.whitePoint ) && ( maxLuminance == rhs.maxLuminance ) &&
             ( minLuminance == rhs.minLuminance ) && ( maxContentLightLevel == rhs.maxContentLightLevel ) &&
             ( maxFrameAverageLightLevel == rhs.maxFrameAverageLightLevel );
    }

    bool operator!=( HdrMetadataEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType                     = StructureType::eHdrMetadataEXT;
    const void *                        pNext                     = {};
    VULKAN_HPP_NAMESPACE::XYColorEXT    displayPrimaryRed         = {};
    VULKAN_HPP_NAMESPACE::XYColorEXT    displayPrimaryGreen       = {};
    VULKAN_HPP_NAMESPACE::XYColorEXT    displayPrimaryBlue        = {};
    VULKAN_HPP_NAMESPACE::XYColorEXT    whitePoint                = {};
    float                               maxLuminance              = {};
    float                               minLuminance              = {};
    float                               maxContentLightLevel      = {};
    float                               maxFrameAverageLightLevel = {};
  };
  static_assert( sizeof( HdrMetadataEXT ) == sizeof( VkHdrMetadataEXT ), "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<HdrMetadataEXT>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eHdrMetadataEXT>
  {
    using Type = HdrMetadataEXT;
  };

  struct HeadlessSurfaceCreateInfoEXT
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eHeadlessSurfaceCreateInfoEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR HeadlessSurfaceCreateInfoEXT( VULKAN_HPP_NAMESPACE::HeadlessSurfaceCreateFlagsEXT flags_ = {} )
      VULKAN_HPP_NOEXCEPT : flags( flags_ )
    {}

    VULKAN_HPP_CONSTEXPR
      HeadlessSurfaceCreateInfoEXT( HeadlessSurfaceCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    HeadlessSurfaceCreateInfoEXT( VkHeadlessSurfaceCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : HeadlessSurfaceCreateInfoEXT( *reinterpret_cast<HeadlessSurfaceCreateInfoEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 HeadlessSurfaceCreateInfoEXT &
                            operator=( HeadlessSurfaceCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    HeadlessSurfaceCreateInfoEXT & operator=( VkHeadlessSurfaceCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::HeadlessSurfaceCreateInfoEXT const *>( &rhs );
      return *this;
    }

    HeadlessSurfaceCreateInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    HeadlessSurfaceCreateInfoEXT &
      setFlags( VULKAN_HPP_NAMESPACE::HeadlessSurfaceCreateFlagsEXT flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    operator VkHeadlessSurfaceCreateInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkHeadlessSurfaceCreateInfoEXT *>( this );
    }

    operator VkHeadlessSurfaceCreateInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkHeadlessSurfaceCreateInfoEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( HeadlessSurfaceCreateInfoEXT const & ) const = default;
#else
    bool operator==( HeadlessSurfaceCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags );
    }

    bool operator!=( HeadlessSurfaceCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                 sType = StructureType::eHeadlessSurfaceCreateInfoEXT;
    const void *                                        pNext = {};
    VULKAN_HPP_NAMESPACE::HeadlessSurfaceCreateFlagsEXT flags = {};
  };
  static_assert( sizeof( HeadlessSurfaceCreateInfoEXT ) == sizeof( VkHeadlessSurfaceCreateInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<HeadlessSurfaceCreateInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eHeadlessSurfaceCreateInfoEXT>
  {
    using Type = HeadlessSurfaceCreateInfoEXT;
  };

#if defined( VK_USE_PLATFORM_IOS_MVK )
  struct IOSSurfaceCreateInfoMVK
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eIosSurfaceCreateInfoMVK;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR IOSSurfaceCreateInfoMVK( VULKAN_HPP_NAMESPACE::IOSSurfaceCreateFlagsMVK flags_ = {},
                                                  const void * pView_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , pView( pView_ )
    {}

    VULKAN_HPP_CONSTEXPR IOSSurfaceCreateInfoMVK( IOSSurfaceCreateInfoMVK const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    IOSSurfaceCreateInfoMVK( VkIOSSurfaceCreateInfoMVK const & rhs ) VULKAN_HPP_NOEXCEPT
      : IOSSurfaceCreateInfoMVK( *reinterpret_cast<IOSSurfaceCreateInfoMVK const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 IOSSurfaceCreateInfoMVK &
                            operator=( IOSSurfaceCreateInfoMVK const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    IOSSurfaceCreateInfoMVK & operator=( VkIOSSurfaceCreateInfoMVK const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::IOSSurfaceCreateInfoMVK const *>( &rhs );
      return *this;
    }

    IOSSurfaceCreateInfoMVK & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    IOSSurfaceCreateInfoMVK & setFlags( VULKAN_HPP_NAMESPACE::IOSSurfaceCreateFlagsMVK flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    IOSSurfaceCreateInfoMVK & setPView( const void * pView_ ) VULKAN_HPP_NOEXCEPT
    {
      pView = pView_;
      return *this;
    }

    operator VkIOSSurfaceCreateInfoMVK const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkIOSSurfaceCreateInfoMVK *>( this );
    }

    operator VkIOSSurfaceCreateInfoMVK &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkIOSSurfaceCreateInfoMVK *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( IOSSurfaceCreateInfoMVK const & ) const = default;
#  else
    bool operator==( IOSSurfaceCreateInfoMVK const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) && ( pView == rhs.pView );
    }

    bool operator!=( IOSSurfaceCreateInfoMVK const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType            sType = StructureType::eIosSurfaceCreateInfoMVK;
    const void *                                   pNext = {};
    VULKAN_HPP_NAMESPACE::IOSSurfaceCreateFlagsMVK flags = {};
    const void *                                   pView = {};
  };
  static_assert( sizeof( IOSSurfaceCreateInfoMVK ) == sizeof( VkIOSSurfaceCreateInfoMVK ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<IOSSurfaceCreateInfoMVK>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eIosSurfaceCreateInfoMVK>
  {
    using Type = IOSSurfaceCreateInfoMVK;
  };
#endif /*VK_USE_PLATFORM_IOS_MVK*/

  struct ImageBlit
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR_14
      ImageBlit( VULKAN_HPP_NAMESPACE::ImageSubresourceLayers          srcSubresource_ = {},
                 std::array<VULKAN_HPP_NAMESPACE::Offset3D, 2> const & srcOffsets_     = {},
                 VULKAN_HPP_NAMESPACE::ImageSubresourceLayers          dstSubresource_ = {},
                 std::array<VULKAN_HPP_NAMESPACE::Offset3D, 2> const & dstOffsets_     = {} ) VULKAN_HPP_NOEXCEPT
      : srcSubresource( srcSubresource_ )
      , srcOffsets( srcOffsets_ )
      , dstSubresource( dstSubresource_ )
      , dstOffsets( dstOffsets_ )
    {}

    VULKAN_HPP_CONSTEXPR_14 ImageBlit( ImageBlit const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImageBlit( VkImageBlit const & rhs ) VULKAN_HPP_NOEXCEPT : ImageBlit( *reinterpret_cast<ImageBlit const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ImageBlit & operator=( ImageBlit const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImageBlit & operator=( VkImageBlit const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ImageBlit const *>( &rhs );
      return *this;
    }

    ImageBlit &
      setSrcSubresource( VULKAN_HPP_NAMESPACE::ImageSubresourceLayers const & srcSubresource_ ) VULKAN_HPP_NOEXCEPT
    {
      srcSubresource = srcSubresource_;
      return *this;
    }

    ImageBlit & setSrcOffsets( std::array<VULKAN_HPP_NAMESPACE::Offset3D, 2> const & srcOffsets_ ) VULKAN_HPP_NOEXCEPT
    {
      srcOffsets = srcOffsets_;
      return *this;
    }

    ImageBlit &
      setDstSubresource( VULKAN_HPP_NAMESPACE::ImageSubresourceLayers const & dstSubresource_ ) VULKAN_HPP_NOEXCEPT
    {
      dstSubresource = dstSubresource_;
      return *this;
    }

    ImageBlit & setDstOffsets( std::array<VULKAN_HPP_NAMESPACE::Offset3D, 2> const & dstOffsets_ ) VULKAN_HPP_NOEXCEPT
    {
      dstOffsets = dstOffsets_;
      return *this;
    }

    operator VkImageBlit const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkImageBlit *>( this );
    }

    operator VkImageBlit &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkImageBlit *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ImageBlit const & ) const = default;
#else
    bool operator==( ImageBlit const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( srcSubresource == rhs.srcSubresource ) && ( srcOffsets == rhs.srcOffsets ) &&
             ( dstSubresource == rhs.dstSubresource ) && ( dstOffsets == rhs.dstOffsets );
    }

    bool operator!=( ImageBlit const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::ImageSubresourceLayers                            srcSubresource = {};
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<VULKAN_HPP_NAMESPACE::Offset3D, 2> srcOffsets     = {};
    VULKAN_HPP_NAMESPACE::ImageSubresourceLayers                            dstSubresource = {};
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<VULKAN_HPP_NAMESPACE::Offset3D, 2> dstOffsets     = {};
  };
  static_assert( sizeof( ImageBlit ) == sizeof( VkImageBlit ), "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ImageBlit>::value, "struct wrapper is not a standard layout!" );

  struct ImageCopy
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ImageCopy( VULKAN_HPP_NAMESPACE::ImageSubresourceLayers srcSubresource_ = {},
                                    VULKAN_HPP_NAMESPACE::Offset3D               srcOffset_      = {},
                                    VULKAN_HPP_NAMESPACE::ImageSubresourceLayers dstSubresource_ = {},
                                    VULKAN_HPP_NAMESPACE::Offset3D               dstOffset_      = {},
                                    VULKAN_HPP_NAMESPACE::Extent3D               extent_ = {} ) VULKAN_HPP_NOEXCEPT
      : srcSubresource( srcSubresource_ )
      , srcOffset( srcOffset_ )
      , dstSubresource( dstSubresource_ )
      , dstOffset( dstOffset_ )
      , extent( extent_ )
    {}

    VULKAN_HPP_CONSTEXPR ImageCopy( ImageCopy const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImageCopy( VkImageCopy const & rhs ) VULKAN_HPP_NOEXCEPT : ImageCopy( *reinterpret_cast<ImageCopy const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ImageCopy & operator=( ImageCopy const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImageCopy & operator=( VkImageCopy const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ImageCopy const *>( &rhs );
      return *this;
    }

    ImageCopy &
      setSrcSubresource( VULKAN_HPP_NAMESPACE::ImageSubresourceLayers const & srcSubresource_ ) VULKAN_HPP_NOEXCEPT
    {
      srcSubresource = srcSubresource_;
      return *this;
    }

    ImageCopy & setSrcOffset( VULKAN_HPP_NAMESPACE::Offset3D const & srcOffset_ ) VULKAN_HPP_NOEXCEPT
    {
      srcOffset = srcOffset_;
      return *this;
    }

    ImageCopy &
      setDstSubresource( VULKAN_HPP_NAMESPACE::ImageSubresourceLayers const & dstSubresource_ ) VULKAN_HPP_NOEXCEPT
    {
      dstSubresource = dstSubresource_;
      return *this;
    }

    ImageCopy & setDstOffset( VULKAN_HPP_NAMESPACE::Offset3D const & dstOffset_ ) VULKAN_HPP_NOEXCEPT
    {
      dstOffset = dstOffset_;
      return *this;
    }

    ImageCopy & setExtent( VULKAN_HPP_NAMESPACE::Extent3D const & extent_ ) VULKAN_HPP_NOEXCEPT
    {
      extent = extent_;
      return *this;
    }

    operator VkImageCopy const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkImageCopy *>( this );
    }

    operator VkImageCopy &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkImageCopy *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ImageCopy const & ) const = default;
#else
    bool operator==( ImageCopy const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( srcSubresource == rhs.srcSubresource ) && ( srcOffset == rhs.srcOffset ) &&
             ( dstSubresource == rhs.dstSubresource ) && ( dstOffset == rhs.dstOffset ) && ( extent == rhs.extent );
    }

    bool operator!=( ImageCopy const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::ImageSubresourceLayers srcSubresource = {};
    VULKAN_HPP_NAMESPACE::Offset3D               srcOffset      = {};
    VULKAN_HPP_NAMESPACE::ImageSubresourceLayers dstSubresource = {};
    VULKAN_HPP_NAMESPACE::Offset3D               dstOffset      = {};
    VULKAN_HPP_NAMESPACE::Extent3D               extent         = {};
  };
  static_assert( sizeof( ImageCopy ) == sizeof( VkImageCopy ), "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ImageCopy>::value, "struct wrapper is not a standard layout!" );

  struct ImageCreateInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eImageCreateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ImageCreateInfo(
      VULKAN_HPP_NAMESPACE::ImageCreateFlags    flags_                 = {},
      VULKAN_HPP_NAMESPACE::ImageType           imageType_             = VULKAN_HPP_NAMESPACE::ImageType::e1D,
      VULKAN_HPP_NAMESPACE::Format              format_                = VULKAN_HPP_NAMESPACE::Format::eUndefined,
      VULKAN_HPP_NAMESPACE::Extent3D            extent_                = {},
      uint32_t                                  mipLevels_             = {},
      uint32_t                                  arrayLayers_           = {},
      VULKAN_HPP_NAMESPACE::SampleCountFlagBits samples_               = VULKAN_HPP_NAMESPACE::SampleCountFlagBits::e1,
      VULKAN_HPP_NAMESPACE::ImageTiling         tiling_                = VULKAN_HPP_NAMESPACE::ImageTiling::eOptimal,
      VULKAN_HPP_NAMESPACE::ImageUsageFlags     usage_                 = {},
      VULKAN_HPP_NAMESPACE::SharingMode         sharingMode_           = VULKAN_HPP_NAMESPACE::SharingMode::eExclusive,
      uint32_t                                  queueFamilyIndexCount_ = {},
      const uint32_t *                          pQueueFamilyIndices_   = {},
      VULKAN_HPP_NAMESPACE::ImageLayout         initialLayout_         = VULKAN_HPP_NAMESPACE::ImageLayout::eUndefined )
      VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , imageType( imageType_ )
      , format( format_ )
      , extent( extent_ )
      , mipLevels( mipLevels_ )
      , arrayLayers( arrayLayers_ )
      , samples( samples_ )
      , tiling( tiling_ )
      , usage( usage_ )
      , sharingMode( sharingMode_ )
      , queueFamilyIndexCount( queueFamilyIndexCount_ )
      , pQueueFamilyIndices( pQueueFamilyIndices_ )
      , initialLayout( initialLayout_ )
    {}

    VULKAN_HPP_CONSTEXPR ImageCreateInfo( ImageCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImageCreateInfo( VkImageCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : ImageCreateInfo( *reinterpret_cast<ImageCreateInfo const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    ImageCreateInfo( VULKAN_HPP_NAMESPACE::ImageCreateFlags                                flags_,
                     VULKAN_HPP_NAMESPACE::ImageType                                       imageType_,
                     VULKAN_HPP_NAMESPACE::Format                                          format_,
                     VULKAN_HPP_NAMESPACE::Extent3D                                        extent_,
                     uint32_t                                                              mipLevels_,
                     uint32_t                                                              arrayLayers_,
                     VULKAN_HPP_NAMESPACE::SampleCountFlagBits                             samples_,
                     VULKAN_HPP_NAMESPACE::ImageTiling                                     tiling_,
                     VULKAN_HPP_NAMESPACE::ImageUsageFlags                                 usage_,
                     VULKAN_HPP_NAMESPACE::SharingMode                                     sharingMode_,
                     VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const & queueFamilyIndices_,
                     VULKAN_HPP_NAMESPACE::ImageLayout initialLayout_ = VULKAN_HPP_NAMESPACE::ImageLayout::eUndefined )
      : flags( flags_ )
      , imageType( imageType_ )
      , format( format_ )
      , extent( extent_ )
      , mipLevels( mipLevels_ )
      , arrayLayers( arrayLayers_ )
      , samples( samples_ )
      , tiling( tiling_ )
      , usage( usage_ )
      , sharingMode( sharingMode_ )
      , queueFamilyIndexCount( static_cast<uint32_t>( queueFamilyIndices_.size() ) )
      , pQueueFamilyIndices( queueFamilyIndices_.data() )
      , initialLayout( initialLayout_ )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ImageCreateInfo & operator=( ImageCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImageCreateInfo & operator=( VkImageCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ImageCreateInfo const *>( &rhs );
      return *this;
    }

    ImageCreateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ImageCreateInfo & setFlags( VULKAN_HPP_NAMESPACE::ImageCreateFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    ImageCreateInfo & setImageType( VULKAN_HPP_NAMESPACE::ImageType imageType_ ) VULKAN_HPP_NOEXCEPT
    {
      imageType = imageType_;
      return *this;
    }

    ImageCreateInfo & setFormat( VULKAN_HPP_NAMESPACE::Format format_ ) VULKAN_HPP_NOEXCEPT
    {
      format = format_;
      return *this;
    }

    ImageCreateInfo & setExtent( VULKAN_HPP_NAMESPACE::Extent3D const & extent_ ) VULKAN_HPP_NOEXCEPT
    {
      extent = extent_;
      return *this;
    }

    ImageCreateInfo & setMipLevels( uint32_t mipLevels_ ) VULKAN_HPP_NOEXCEPT
    {
      mipLevels = mipLevels_;
      return *this;
    }

    ImageCreateInfo & setArrayLayers( uint32_t arrayLayers_ ) VULKAN_HPP_NOEXCEPT
    {
      arrayLayers = arrayLayers_;
      return *this;
    }

    ImageCreateInfo & setSamples( VULKAN_HPP_NAMESPACE::SampleCountFlagBits samples_ ) VULKAN_HPP_NOEXCEPT
    {
      samples = samples_;
      return *this;
    }

    ImageCreateInfo & setTiling( VULKAN_HPP_NAMESPACE::ImageTiling tiling_ ) VULKAN_HPP_NOEXCEPT
    {
      tiling = tiling_;
      return *this;
    }

    ImageCreateInfo & setUsage( VULKAN_HPP_NAMESPACE::ImageUsageFlags usage_ ) VULKAN_HPP_NOEXCEPT
    {
      usage = usage_;
      return *this;
    }

    ImageCreateInfo & setSharingMode( VULKAN_HPP_NAMESPACE::SharingMode sharingMode_ ) VULKAN_HPP_NOEXCEPT
    {
      sharingMode = sharingMode_;
      return *this;
    }

    ImageCreateInfo & setQueueFamilyIndexCount( uint32_t queueFamilyIndexCount_ ) VULKAN_HPP_NOEXCEPT
    {
      queueFamilyIndexCount = queueFamilyIndexCount_;
      return *this;
    }

    ImageCreateInfo & setPQueueFamilyIndices( const uint32_t * pQueueFamilyIndices_ ) VULKAN_HPP_NOEXCEPT
    {
      pQueueFamilyIndices = pQueueFamilyIndices_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    ImageCreateInfo & setQueueFamilyIndices(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const & queueFamilyIndices_ ) VULKAN_HPP_NOEXCEPT
    {
      queueFamilyIndexCount = static_cast<uint32_t>( queueFamilyIndices_.size() );
      pQueueFamilyIndices   = queueFamilyIndices_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    ImageCreateInfo & setInitialLayout( VULKAN_HPP_NAMESPACE::ImageLayout initialLayout_ ) VULKAN_HPP_NOEXCEPT
    {
      initialLayout = initialLayout_;
      return *this;
    }

    operator VkImageCreateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkImageCreateInfo *>( this );
    }

    operator VkImageCreateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkImageCreateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ImageCreateInfo const & ) const = default;
#else
    bool operator==( ImageCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( imageType == rhs.imageType ) && ( format == rhs.format ) && ( extent == rhs.extent ) &&
             ( mipLevels == rhs.mipLevels ) && ( arrayLayers == rhs.arrayLayers ) && ( samples == rhs.samples ) &&
             ( tiling == rhs.tiling ) && ( usage == rhs.usage ) && ( sharingMode == rhs.sharingMode ) &&
             ( queueFamilyIndexCount == rhs.queueFamilyIndexCount ) &&
             ( pQueueFamilyIndices == rhs.pQueueFamilyIndices ) && ( initialLayout == rhs.initialLayout );
    }

    bool operator!=( ImageCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType       sType                 = StructureType::eImageCreateInfo;
    const void *                              pNext                 = {};
    VULKAN_HPP_NAMESPACE::ImageCreateFlags    flags                 = {};
    VULKAN_HPP_NAMESPACE::ImageType           imageType             = VULKAN_HPP_NAMESPACE::ImageType::e1D;
    VULKAN_HPP_NAMESPACE::Format              format                = VULKAN_HPP_NAMESPACE::Format::eUndefined;
    VULKAN_HPP_NAMESPACE::Extent3D            extent                = {};
    uint32_t                                  mipLevels             = {};
    uint32_t                                  arrayLayers           = {};
    VULKAN_HPP_NAMESPACE::SampleCountFlagBits samples               = VULKAN_HPP_NAMESPACE::SampleCountFlagBits::e1;
    VULKAN_HPP_NAMESPACE::ImageTiling         tiling                = VULKAN_HPP_NAMESPACE::ImageTiling::eOptimal;
    VULKAN_HPP_NAMESPACE::ImageUsageFlags     usage                 = {};
    VULKAN_HPP_NAMESPACE::SharingMode         sharingMode           = VULKAN_HPP_NAMESPACE::SharingMode::eExclusive;
    uint32_t                                  queueFamilyIndexCount = {};
    const uint32_t *                          pQueueFamilyIndices   = {};
    VULKAN_HPP_NAMESPACE::ImageLayout         initialLayout         = VULKAN_HPP_NAMESPACE::ImageLayout::eUndefined;
  };
  static_assert( sizeof( ImageCreateInfo ) == sizeof( VkImageCreateInfo ), "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ImageCreateInfo>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eImageCreateInfo>
  {
    using Type = ImageCreateInfo;
  };

  struct SubresourceLayout
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR SubresourceLayout( VULKAN_HPP_NAMESPACE::DeviceSize offset_     = {},
                                            VULKAN_HPP_NAMESPACE::DeviceSize size_       = {},
                                            VULKAN_HPP_NAMESPACE::DeviceSize rowPitch_   = {},
                                            VULKAN_HPP_NAMESPACE::DeviceSize arrayPitch_ = {},
                                            VULKAN_HPP_NAMESPACE::DeviceSize depthPitch_ = {} ) VULKAN_HPP_NOEXCEPT
      : offset( offset_ )
      , size( size_ )
      , rowPitch( rowPitch_ )
      , arrayPitch( arrayPitch_ )
      , depthPitch( depthPitch_ )
    {}

    VULKAN_HPP_CONSTEXPR SubresourceLayout( SubresourceLayout const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SubresourceLayout( VkSubresourceLayout const & rhs ) VULKAN_HPP_NOEXCEPT
      : SubresourceLayout( *reinterpret_cast<SubresourceLayout const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SubresourceLayout &
                            operator=( SubresourceLayout const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SubresourceLayout & operator=( VkSubresourceLayout const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SubresourceLayout const *>( &rhs );
      return *this;
    }

    operator VkSubresourceLayout const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSubresourceLayout *>( this );
    }

    operator VkSubresourceLayout &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSubresourceLayout *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SubresourceLayout const & ) const = default;
#else
    bool operator==( SubresourceLayout const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( offset == rhs.offset ) && ( size == rhs.size ) && ( rowPitch == rhs.rowPitch ) &&
             ( arrayPitch == rhs.arrayPitch ) && ( depthPitch == rhs.depthPitch );
    }

    bool operator!=( SubresourceLayout const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::DeviceSize offset     = {};
    VULKAN_HPP_NAMESPACE::DeviceSize size       = {};
    VULKAN_HPP_NAMESPACE::DeviceSize rowPitch   = {};
    VULKAN_HPP_NAMESPACE::DeviceSize arrayPitch = {};
    VULKAN_HPP_NAMESPACE::DeviceSize depthPitch = {};
  };
  static_assert( sizeof( SubresourceLayout ) == sizeof( VkSubresourceLayout ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SubresourceLayout>::value, "struct wrapper is not a standard layout!" );

  struct ImageDrmFormatModifierExplicitCreateInfoEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eImageDrmFormatModifierExplicitCreateInfoEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ImageDrmFormatModifierExplicitCreateInfoEXT(
      uint64_t                                        drmFormatModifier_           = {},
      uint32_t                                        drmFormatModifierPlaneCount_ = {},
      const VULKAN_HPP_NAMESPACE::SubresourceLayout * pPlaneLayouts_               = {} ) VULKAN_HPP_NOEXCEPT
      : drmFormatModifier( drmFormatModifier_ )
      , drmFormatModifierPlaneCount( drmFormatModifierPlaneCount_ )
      , pPlaneLayouts( pPlaneLayouts_ )
    {}

    VULKAN_HPP_CONSTEXPR ImageDrmFormatModifierExplicitCreateInfoEXT(
      ImageDrmFormatModifierExplicitCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImageDrmFormatModifierExplicitCreateInfoEXT( VkImageDrmFormatModifierExplicitCreateInfoEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : ImageDrmFormatModifierExplicitCreateInfoEXT(
          *reinterpret_cast<ImageDrmFormatModifierExplicitCreateInfoEXT const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    ImageDrmFormatModifierExplicitCreateInfoEXT(
      uint64_t drmFormatModifier_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::SubresourceLayout> const &
        planeLayouts_ )
      : drmFormatModifier( drmFormatModifier_ )
      , drmFormatModifierPlaneCount( static_cast<uint32_t>( planeLayouts_.size() ) )
      , pPlaneLayouts( planeLayouts_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ImageDrmFormatModifierExplicitCreateInfoEXT &
                            operator=( ImageDrmFormatModifierExplicitCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImageDrmFormatModifierExplicitCreateInfoEXT &
      operator=( VkImageDrmFormatModifierExplicitCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ImageDrmFormatModifierExplicitCreateInfoEXT const *>( &rhs );
      return *this;
    }

    ImageDrmFormatModifierExplicitCreateInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ImageDrmFormatModifierExplicitCreateInfoEXT &
      setDrmFormatModifier( uint64_t drmFormatModifier_ ) VULKAN_HPP_NOEXCEPT
    {
      drmFormatModifier = drmFormatModifier_;
      return *this;
    }

    ImageDrmFormatModifierExplicitCreateInfoEXT &
      setDrmFormatModifierPlaneCount( uint32_t drmFormatModifierPlaneCount_ ) VULKAN_HPP_NOEXCEPT
    {
      drmFormatModifierPlaneCount = drmFormatModifierPlaneCount_;
      return *this;
    }

    ImageDrmFormatModifierExplicitCreateInfoEXT &
      setPPlaneLayouts( const VULKAN_HPP_NAMESPACE::SubresourceLayout * pPlaneLayouts_ ) VULKAN_HPP_NOEXCEPT
    {
      pPlaneLayouts = pPlaneLayouts_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    ImageDrmFormatModifierExplicitCreateInfoEXT & setPlaneLayouts(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::SubresourceLayout> const &
        planeLayouts_ ) VULKAN_HPP_NOEXCEPT
    {
      drmFormatModifierPlaneCount = static_cast<uint32_t>( planeLayouts_.size() );
      pPlaneLayouts               = planeLayouts_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkImageDrmFormatModifierExplicitCreateInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkImageDrmFormatModifierExplicitCreateInfoEXT *>( this );
    }

    operator VkImageDrmFormatModifierExplicitCreateInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkImageDrmFormatModifierExplicitCreateInfoEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ImageDrmFormatModifierExplicitCreateInfoEXT const & ) const = default;
#else
    bool operator==( ImageDrmFormatModifierExplicitCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( drmFormatModifier == rhs.drmFormatModifier ) &&
             ( drmFormatModifierPlaneCount == rhs.drmFormatModifierPlaneCount ) &&
             ( pPlaneLayouts == rhs.pPlaneLayouts );
    }

    bool operator!=( ImageDrmFormatModifierExplicitCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType             sType = StructureType::eImageDrmFormatModifierExplicitCreateInfoEXT;
    const void *                                    pNext = {};
    uint64_t                                        drmFormatModifier           = {};
    uint32_t                                        drmFormatModifierPlaneCount = {};
    const VULKAN_HPP_NAMESPACE::SubresourceLayout * pPlaneLayouts               = {};
  };
  static_assert( sizeof( ImageDrmFormatModifierExplicitCreateInfoEXT ) ==
                   sizeof( VkImageDrmFormatModifierExplicitCreateInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ImageDrmFormatModifierExplicitCreateInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eImageDrmFormatModifierExplicitCreateInfoEXT>
  {
    using Type = ImageDrmFormatModifierExplicitCreateInfoEXT;
  };

  struct ImageDrmFormatModifierListCreateInfoEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eImageDrmFormatModifierListCreateInfoEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      ImageDrmFormatModifierListCreateInfoEXT( uint32_t         drmFormatModifierCount_ = {},
                                               const uint64_t * pDrmFormatModifiers_    = {} ) VULKAN_HPP_NOEXCEPT
      : drmFormatModifierCount( drmFormatModifierCount_ )
      , pDrmFormatModifiers( pDrmFormatModifiers_ )
    {}

    VULKAN_HPP_CONSTEXPR ImageDrmFormatModifierListCreateInfoEXT( ImageDrmFormatModifierListCreateInfoEXT const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    ImageDrmFormatModifierListCreateInfoEXT( VkImageDrmFormatModifierListCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : ImageDrmFormatModifierListCreateInfoEXT(
          *reinterpret_cast<ImageDrmFormatModifierListCreateInfoEXT const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    ImageDrmFormatModifierListCreateInfoEXT(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint64_t> const & drmFormatModifiers_ )
      : drmFormatModifierCount( static_cast<uint32_t>( drmFormatModifiers_.size() ) )
      , pDrmFormatModifiers( drmFormatModifiers_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ImageDrmFormatModifierListCreateInfoEXT &
                            operator=( ImageDrmFormatModifierListCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImageDrmFormatModifierListCreateInfoEXT &
      operator=( VkImageDrmFormatModifierListCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ImageDrmFormatModifierListCreateInfoEXT const *>( &rhs );
      return *this;
    }

    ImageDrmFormatModifierListCreateInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ImageDrmFormatModifierListCreateInfoEXT &
      setDrmFormatModifierCount( uint32_t drmFormatModifierCount_ ) VULKAN_HPP_NOEXCEPT
    {
      drmFormatModifierCount = drmFormatModifierCount_;
      return *this;
    }

    ImageDrmFormatModifierListCreateInfoEXT &
      setPDrmFormatModifiers( const uint64_t * pDrmFormatModifiers_ ) VULKAN_HPP_NOEXCEPT
    {
      pDrmFormatModifiers = pDrmFormatModifiers_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    ImageDrmFormatModifierListCreateInfoEXT & setDrmFormatModifiers(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint64_t> const & drmFormatModifiers_ ) VULKAN_HPP_NOEXCEPT
    {
      drmFormatModifierCount = static_cast<uint32_t>( drmFormatModifiers_.size() );
      pDrmFormatModifiers    = drmFormatModifiers_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkImageDrmFormatModifierListCreateInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkImageDrmFormatModifierListCreateInfoEXT *>( this );
    }

    operator VkImageDrmFormatModifierListCreateInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkImageDrmFormatModifierListCreateInfoEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ImageDrmFormatModifierListCreateInfoEXT const & ) const = default;
#else
    bool operator==( ImageDrmFormatModifierListCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( drmFormatModifierCount == rhs.drmFormatModifierCount ) &&
             ( pDrmFormatModifiers == rhs.pDrmFormatModifiers );
    }

    bool operator!=( ImageDrmFormatModifierListCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::eImageDrmFormatModifierListCreateInfoEXT;
    const void *                        pNext = {};
    uint32_t                            drmFormatModifierCount = {};
    const uint64_t *                    pDrmFormatModifiers    = {};
  };
  static_assert( sizeof( ImageDrmFormatModifierListCreateInfoEXT ) ==
                   sizeof( VkImageDrmFormatModifierListCreateInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ImageDrmFormatModifierListCreateInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eImageDrmFormatModifierListCreateInfoEXT>
  {
    using Type = ImageDrmFormatModifierListCreateInfoEXT;
  };

  struct ImageDrmFormatModifierPropertiesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eImageDrmFormatModifierPropertiesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ImageDrmFormatModifierPropertiesEXT( uint64_t drmFormatModifier_ = {} ) VULKAN_HPP_NOEXCEPT
      : drmFormatModifier( drmFormatModifier_ )
    {}

    VULKAN_HPP_CONSTEXPR ImageDrmFormatModifierPropertiesEXT( ImageDrmFormatModifierPropertiesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    ImageDrmFormatModifierPropertiesEXT( VkImageDrmFormatModifierPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : ImageDrmFormatModifierPropertiesEXT( *reinterpret_cast<ImageDrmFormatModifierPropertiesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ImageDrmFormatModifierPropertiesEXT &
                            operator=( ImageDrmFormatModifierPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImageDrmFormatModifierPropertiesEXT &
      operator=( VkImageDrmFormatModifierPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ImageDrmFormatModifierPropertiesEXT const *>( &rhs );
      return *this;
    }

    operator VkImageDrmFormatModifierPropertiesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkImageDrmFormatModifierPropertiesEXT *>( this );
    }

    operator VkImageDrmFormatModifierPropertiesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkImageDrmFormatModifierPropertiesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ImageDrmFormatModifierPropertiesEXT const & ) const = default;
#else
    bool operator==( ImageDrmFormatModifierPropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( drmFormatModifier == rhs.drmFormatModifier );
    }

    bool operator!=( ImageDrmFormatModifierPropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType             = StructureType::eImageDrmFormatModifierPropertiesEXT;
    void *                              pNext             = {};
    uint64_t                            drmFormatModifier = {};
  };
  static_assert( sizeof( ImageDrmFormatModifierPropertiesEXT ) == sizeof( VkImageDrmFormatModifierPropertiesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ImageDrmFormatModifierPropertiesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eImageDrmFormatModifierPropertiesEXT>
  {
    using Type = ImageDrmFormatModifierPropertiesEXT;
  };

  struct ImageFormatListCreateInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eImageFormatListCreateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      ImageFormatListCreateInfo( uint32_t                             viewFormatCount_ = {},
                                 const VULKAN_HPP_NAMESPACE::Format * pViewFormats_    = {} ) VULKAN_HPP_NOEXCEPT
      : viewFormatCount( viewFormatCount_ )
      , pViewFormats( pViewFormats_ )
    {}

    VULKAN_HPP_CONSTEXPR
      ImageFormatListCreateInfo( ImageFormatListCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImageFormatListCreateInfo( VkImageFormatListCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : ImageFormatListCreateInfo( *reinterpret_cast<ImageFormatListCreateInfo const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    ImageFormatListCreateInfo(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::Format> const & viewFormats_ )
      : viewFormatCount( static_cast<uint32_t>( viewFormats_.size() ) ), pViewFormats( viewFormats_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ImageFormatListCreateInfo &
                            operator=( ImageFormatListCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImageFormatListCreateInfo & operator=( VkImageFormatListCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ImageFormatListCreateInfo const *>( &rhs );
      return *this;
    }

    ImageFormatListCreateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ImageFormatListCreateInfo & setViewFormatCount( uint32_t viewFormatCount_ ) VULKAN_HPP_NOEXCEPT
    {
      viewFormatCount = viewFormatCount_;
      return *this;
    }

    ImageFormatListCreateInfo &
      setPViewFormats( const VULKAN_HPP_NAMESPACE::Format * pViewFormats_ ) VULKAN_HPP_NOEXCEPT
    {
      pViewFormats = pViewFormats_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    ImageFormatListCreateInfo & setViewFormats(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::Format> const & viewFormats_ )
      VULKAN_HPP_NOEXCEPT
    {
      viewFormatCount = static_cast<uint32_t>( viewFormats_.size() );
      pViewFormats    = viewFormats_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkImageFormatListCreateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkImageFormatListCreateInfo *>( this );
    }

    operator VkImageFormatListCreateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkImageFormatListCreateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ImageFormatListCreateInfo const & ) const = default;
#else
    bool operator==( ImageFormatListCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( viewFormatCount == rhs.viewFormatCount ) &&
             ( pViewFormats == rhs.pViewFormats );
    }

    bool operator!=( ImageFormatListCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType  sType           = StructureType::eImageFormatListCreateInfo;
    const void *                         pNext           = {};
    uint32_t                             viewFormatCount = {};
    const VULKAN_HPP_NAMESPACE::Format * pViewFormats    = {};
  };
  static_assert( sizeof( ImageFormatListCreateInfo ) == sizeof( VkImageFormatListCreateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ImageFormatListCreateInfo>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eImageFormatListCreateInfo>
  {
    using Type = ImageFormatListCreateInfo;
  };
  using ImageFormatListCreateInfoKHR = ImageFormatListCreateInfo;

  struct ImageFormatProperties2
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eImageFormatProperties2;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ImageFormatProperties2(
      VULKAN_HPP_NAMESPACE::ImageFormatProperties imageFormatProperties_ = {} ) VULKAN_HPP_NOEXCEPT
      : imageFormatProperties( imageFormatProperties_ )
    {}

    VULKAN_HPP_CONSTEXPR ImageFormatProperties2( ImageFormatProperties2 const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImageFormatProperties2( VkImageFormatProperties2 const & rhs ) VULKAN_HPP_NOEXCEPT
      : ImageFormatProperties2( *reinterpret_cast<ImageFormatProperties2 const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ImageFormatProperties2 &
                            operator=( ImageFormatProperties2 const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImageFormatProperties2 & operator=( VkImageFormatProperties2 const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ImageFormatProperties2 const *>( &rhs );
      return *this;
    }

    operator VkImageFormatProperties2 const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkImageFormatProperties2 *>( this );
    }

    operator VkImageFormatProperties2 &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkImageFormatProperties2 *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ImageFormatProperties2 const & ) const = default;
#else
    bool operator==( ImageFormatProperties2 const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( imageFormatProperties == rhs.imageFormatProperties );
    }

    bool operator!=( ImageFormatProperties2 const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType         sType                 = StructureType::eImageFormatProperties2;
    void *                                      pNext                 = {};
    VULKAN_HPP_NAMESPACE::ImageFormatProperties imageFormatProperties = {};
  };
  static_assert( sizeof( ImageFormatProperties2 ) == sizeof( VkImageFormatProperties2 ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ImageFormatProperties2>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eImageFormatProperties2>
  {
    using Type = ImageFormatProperties2;
  };
  using ImageFormatProperties2KHR = ImageFormatProperties2;

  struct ImageMemoryBarrier
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eImageMemoryBarrier;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      ImageMemoryBarrier( VULKAN_HPP_NAMESPACE::AccessFlags srcAccessMask_ = {},
                          VULKAN_HPP_NAMESPACE::AccessFlags dstAccessMask_ = {},
                          VULKAN_HPP_NAMESPACE::ImageLayout oldLayout_ = VULKAN_HPP_NAMESPACE::ImageLayout::eUndefined,
                          VULKAN_HPP_NAMESPACE::ImageLayout newLayout_ = VULKAN_HPP_NAMESPACE::ImageLayout::eUndefined,
                          uint32_t                          srcQueueFamilyIndex_        = {},
                          uint32_t                          dstQueueFamilyIndex_        = {},
                          VULKAN_HPP_NAMESPACE::Image       image_                      = {},
                          VULKAN_HPP_NAMESPACE::ImageSubresourceRange subresourceRange_ = {} ) VULKAN_HPP_NOEXCEPT
      : srcAccessMask( srcAccessMask_ )
      , dstAccessMask( dstAccessMask_ )
      , oldLayout( oldLayout_ )
      , newLayout( newLayout_ )
      , srcQueueFamilyIndex( srcQueueFamilyIndex_ )
      , dstQueueFamilyIndex( dstQueueFamilyIndex_ )
      , image( image_ )
      , subresourceRange( subresourceRange_ )
    {}

    VULKAN_HPP_CONSTEXPR ImageMemoryBarrier( ImageMemoryBarrier const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImageMemoryBarrier( VkImageMemoryBarrier const & rhs ) VULKAN_HPP_NOEXCEPT
      : ImageMemoryBarrier( *reinterpret_cast<ImageMemoryBarrier const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ImageMemoryBarrier &
                            operator=( ImageMemoryBarrier const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImageMemoryBarrier & operator=( VkImageMemoryBarrier const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ImageMemoryBarrier const *>( &rhs );
      return *this;
    }

    ImageMemoryBarrier & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ImageMemoryBarrier & setSrcAccessMask( VULKAN_HPP_NAMESPACE::AccessFlags srcAccessMask_ ) VULKAN_HPP_NOEXCEPT
    {
      srcAccessMask = srcAccessMask_;
      return *this;
    }

    ImageMemoryBarrier & setDstAccessMask( VULKAN_HPP_NAMESPACE::AccessFlags dstAccessMask_ ) VULKAN_HPP_NOEXCEPT
    {
      dstAccessMask = dstAccessMask_;
      return *this;
    }

    ImageMemoryBarrier & setOldLayout( VULKAN_HPP_NAMESPACE::ImageLayout oldLayout_ ) VULKAN_HPP_NOEXCEPT
    {
      oldLayout = oldLayout_;
      return *this;
    }

    ImageMemoryBarrier & setNewLayout( VULKAN_HPP_NAMESPACE::ImageLayout newLayout_ ) VULKAN_HPP_NOEXCEPT
    {
      newLayout = newLayout_;
      return *this;
    }

    ImageMemoryBarrier & setSrcQueueFamilyIndex( uint32_t srcQueueFamilyIndex_ ) VULKAN_HPP_NOEXCEPT
    {
      srcQueueFamilyIndex = srcQueueFamilyIndex_;
      return *this;
    }

    ImageMemoryBarrier & setDstQueueFamilyIndex( uint32_t dstQueueFamilyIndex_ ) VULKAN_HPP_NOEXCEPT
    {
      dstQueueFamilyIndex = dstQueueFamilyIndex_;
      return *this;
    }

    ImageMemoryBarrier & setImage( VULKAN_HPP_NAMESPACE::Image image_ ) VULKAN_HPP_NOEXCEPT
    {
      image = image_;
      return *this;
    }

    ImageMemoryBarrier &
      setSubresourceRange( VULKAN_HPP_NAMESPACE::ImageSubresourceRange const & subresourceRange_ ) VULKAN_HPP_NOEXCEPT
    {
      subresourceRange = subresourceRange_;
      return *this;
    }

    operator VkImageMemoryBarrier const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkImageMemoryBarrier *>( this );
    }

    operator VkImageMemoryBarrier &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkImageMemoryBarrier *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ImageMemoryBarrier const & ) const = default;
#else
    bool operator==( ImageMemoryBarrier const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( srcAccessMask == rhs.srcAccessMask ) &&
             ( dstAccessMask == rhs.dstAccessMask ) && ( oldLayout == rhs.oldLayout ) &&
             ( newLayout == rhs.newLayout ) && ( srcQueueFamilyIndex == rhs.srcQueueFamilyIndex ) &&
             ( dstQueueFamilyIndex == rhs.dstQueueFamilyIndex ) && ( image == rhs.image ) &&
             ( subresourceRange == rhs.subresourceRange );
    }

    bool operator!=( ImageMemoryBarrier const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType         sType               = StructureType::eImageMemoryBarrier;
    const void *                                pNext               = {};
    VULKAN_HPP_NAMESPACE::AccessFlags           srcAccessMask       = {};
    VULKAN_HPP_NAMESPACE::AccessFlags           dstAccessMask       = {};
    VULKAN_HPP_NAMESPACE::ImageLayout           oldLayout           = VULKAN_HPP_NAMESPACE::ImageLayout::eUndefined;
    VULKAN_HPP_NAMESPACE::ImageLayout           newLayout           = VULKAN_HPP_NAMESPACE::ImageLayout::eUndefined;
    uint32_t                                    srcQueueFamilyIndex = {};
    uint32_t                                    dstQueueFamilyIndex = {};
    VULKAN_HPP_NAMESPACE::Image                 image               = {};
    VULKAN_HPP_NAMESPACE::ImageSubresourceRange subresourceRange    = {};
  };
  static_assert( sizeof( ImageMemoryBarrier ) == sizeof( VkImageMemoryBarrier ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ImageMemoryBarrier>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eImageMemoryBarrier>
  {
    using Type = ImageMemoryBarrier;
  };

  struct ImageMemoryRequirementsInfo2
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eImageMemoryRequirementsInfo2;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ImageMemoryRequirementsInfo2( VULKAN_HPP_NAMESPACE::Image image_ = {} ) VULKAN_HPP_NOEXCEPT
      : image( image_ )
    {}

    VULKAN_HPP_CONSTEXPR
      ImageMemoryRequirementsInfo2( ImageMemoryRequirementsInfo2 const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImageMemoryRequirementsInfo2( VkImageMemoryRequirementsInfo2 const & rhs ) VULKAN_HPP_NOEXCEPT
      : ImageMemoryRequirementsInfo2( *reinterpret_cast<ImageMemoryRequirementsInfo2 const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ImageMemoryRequirementsInfo2 &
                            operator=( ImageMemoryRequirementsInfo2 const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImageMemoryRequirementsInfo2 & operator=( VkImageMemoryRequirementsInfo2 const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ImageMemoryRequirementsInfo2 const *>( &rhs );
      return *this;
    }

    ImageMemoryRequirementsInfo2 & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ImageMemoryRequirementsInfo2 & setImage( VULKAN_HPP_NAMESPACE::Image image_ ) VULKAN_HPP_NOEXCEPT
    {
      image = image_;
      return *this;
    }

    operator VkImageMemoryRequirementsInfo2 const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkImageMemoryRequirementsInfo2 *>( this );
    }

    operator VkImageMemoryRequirementsInfo2 &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkImageMemoryRequirementsInfo2 *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ImageMemoryRequirementsInfo2 const & ) const = default;
#else
    bool operator==( ImageMemoryRequirementsInfo2 const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( image == rhs.image );
    }

    bool operator!=( ImageMemoryRequirementsInfo2 const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::eImageMemoryRequirementsInfo2;
    const void *                        pNext = {};
    VULKAN_HPP_NAMESPACE::Image         image = {};
  };
  static_assert( sizeof( ImageMemoryRequirementsInfo2 ) == sizeof( VkImageMemoryRequirementsInfo2 ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ImageMemoryRequirementsInfo2>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eImageMemoryRequirementsInfo2>
  {
    using Type = ImageMemoryRequirementsInfo2;
  };
  using ImageMemoryRequirementsInfo2KHR = ImageMemoryRequirementsInfo2;

#if defined( VK_USE_PLATFORM_FUCHSIA )
  struct ImagePipeSurfaceCreateInfoFUCHSIA
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eImagepipeSurfaceCreateInfoFUCHSIA;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      ImagePipeSurfaceCreateInfoFUCHSIA( VULKAN_HPP_NAMESPACE::ImagePipeSurfaceCreateFlagsFUCHSIA flags_ = {},
                                         zx_handle_t imagePipeHandle_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , imagePipeHandle( imagePipeHandle_ )
    {}

    VULKAN_HPP_CONSTEXPR
      ImagePipeSurfaceCreateInfoFUCHSIA( ImagePipeSurfaceCreateInfoFUCHSIA const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImagePipeSurfaceCreateInfoFUCHSIA( VkImagePipeSurfaceCreateInfoFUCHSIA const & rhs ) VULKAN_HPP_NOEXCEPT
      : ImagePipeSurfaceCreateInfoFUCHSIA( *reinterpret_cast<ImagePipeSurfaceCreateInfoFUCHSIA const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ImagePipeSurfaceCreateInfoFUCHSIA &
                            operator=( ImagePipeSurfaceCreateInfoFUCHSIA const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImagePipeSurfaceCreateInfoFUCHSIA & operator=( VkImagePipeSurfaceCreateInfoFUCHSIA const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ImagePipeSurfaceCreateInfoFUCHSIA const *>( &rhs );
      return *this;
    }

    ImagePipeSurfaceCreateInfoFUCHSIA & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ImagePipeSurfaceCreateInfoFUCHSIA &
      setFlags( VULKAN_HPP_NAMESPACE::ImagePipeSurfaceCreateFlagsFUCHSIA flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    ImagePipeSurfaceCreateInfoFUCHSIA & setImagePipeHandle( zx_handle_t imagePipeHandle_ ) VULKAN_HPP_NOEXCEPT
    {
      imagePipeHandle = imagePipeHandle_;
      return *this;
    }

    operator VkImagePipeSurfaceCreateInfoFUCHSIA const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkImagePipeSurfaceCreateInfoFUCHSIA *>( this );
    }

    operator VkImagePipeSurfaceCreateInfoFUCHSIA &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkImagePipeSurfaceCreateInfoFUCHSIA *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ImagePipeSurfaceCreateInfoFUCHSIA const & ) const = default;
#  else
    bool operator==( ImagePipeSurfaceCreateInfoFUCHSIA const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( memcmp( &imagePipeHandle, &rhs.imagePipeHandle, sizeof( zx_handle_t ) ) == 0 );
    }

    bool operator!=( ImagePipeSurfaceCreateInfoFUCHSIA const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                      sType = StructureType::eImagepipeSurfaceCreateInfoFUCHSIA;
    const void *                                             pNext = {};
    VULKAN_HPP_NAMESPACE::ImagePipeSurfaceCreateFlagsFUCHSIA flags = {};
    zx_handle_t                                              imagePipeHandle = {};
  };
  static_assert( sizeof( ImagePipeSurfaceCreateInfoFUCHSIA ) == sizeof( VkImagePipeSurfaceCreateInfoFUCHSIA ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ImagePipeSurfaceCreateInfoFUCHSIA>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eImagepipeSurfaceCreateInfoFUCHSIA>
  {
    using Type = ImagePipeSurfaceCreateInfoFUCHSIA;
  };
#endif /*VK_USE_PLATFORM_FUCHSIA*/

  struct ImagePlaneMemoryRequirementsInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eImagePlaneMemoryRequirementsInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      ImagePlaneMemoryRequirementsInfo( VULKAN_HPP_NAMESPACE::ImageAspectFlagBits planeAspect_ =
                                          VULKAN_HPP_NAMESPACE::ImageAspectFlagBits::eColor ) VULKAN_HPP_NOEXCEPT
      : planeAspect( planeAspect_ )
    {}

    VULKAN_HPP_CONSTEXPR
      ImagePlaneMemoryRequirementsInfo( ImagePlaneMemoryRequirementsInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImagePlaneMemoryRequirementsInfo( VkImagePlaneMemoryRequirementsInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : ImagePlaneMemoryRequirementsInfo( *reinterpret_cast<ImagePlaneMemoryRequirementsInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ImagePlaneMemoryRequirementsInfo &
                            operator=( ImagePlaneMemoryRequirementsInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImagePlaneMemoryRequirementsInfo & operator=( VkImagePlaneMemoryRequirementsInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ImagePlaneMemoryRequirementsInfo const *>( &rhs );
      return *this;
    }

    ImagePlaneMemoryRequirementsInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ImagePlaneMemoryRequirementsInfo &
      setPlaneAspect( VULKAN_HPP_NAMESPACE::ImageAspectFlagBits planeAspect_ ) VULKAN_HPP_NOEXCEPT
    {
      planeAspect = planeAspect_;
      return *this;
    }

    operator VkImagePlaneMemoryRequirementsInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkImagePlaneMemoryRequirementsInfo *>( this );
    }

    operator VkImagePlaneMemoryRequirementsInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkImagePlaneMemoryRequirementsInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ImagePlaneMemoryRequirementsInfo const & ) const = default;
#else
    bool operator==( ImagePlaneMemoryRequirementsInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( planeAspect == rhs.planeAspect );
    }

    bool operator!=( ImagePlaneMemoryRequirementsInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType       sType       = StructureType::eImagePlaneMemoryRequirementsInfo;
    const void *                              pNext       = {};
    VULKAN_HPP_NAMESPACE::ImageAspectFlagBits planeAspect = VULKAN_HPP_NAMESPACE::ImageAspectFlagBits::eColor;
  };
  static_assert( sizeof( ImagePlaneMemoryRequirementsInfo ) == sizeof( VkImagePlaneMemoryRequirementsInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ImagePlaneMemoryRequirementsInfo>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eImagePlaneMemoryRequirementsInfo>
  {
    using Type = ImagePlaneMemoryRequirementsInfo;
  };
  using ImagePlaneMemoryRequirementsInfoKHR = ImagePlaneMemoryRequirementsInfo;

  struct ImageResolve
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ImageResolve( VULKAN_HPP_NAMESPACE::ImageSubresourceLayers srcSubresource_ = {},
                                       VULKAN_HPP_NAMESPACE::Offset3D               srcOffset_      = {},
                                       VULKAN_HPP_NAMESPACE::ImageSubresourceLayers dstSubresource_ = {},
                                       VULKAN_HPP_NAMESPACE::Offset3D               dstOffset_      = {},
                                       VULKAN_HPP_NAMESPACE::Extent3D               extent_ = {} ) VULKAN_HPP_NOEXCEPT
      : srcSubresource( srcSubresource_ )
      , srcOffset( srcOffset_ )
      , dstSubresource( dstSubresource_ )
      , dstOffset( dstOffset_ )
      , extent( extent_ )
    {}

    VULKAN_HPP_CONSTEXPR ImageResolve( ImageResolve const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImageResolve( VkImageResolve const & rhs ) VULKAN_HPP_NOEXCEPT
      : ImageResolve( *reinterpret_cast<ImageResolve const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ImageResolve & operator=( ImageResolve const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImageResolve & operator=( VkImageResolve const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ImageResolve const *>( &rhs );
      return *this;
    }

    ImageResolve &
      setSrcSubresource( VULKAN_HPP_NAMESPACE::ImageSubresourceLayers const & srcSubresource_ ) VULKAN_HPP_NOEXCEPT
    {
      srcSubresource = srcSubresource_;
      return *this;
    }

    ImageResolve & setSrcOffset( VULKAN_HPP_NAMESPACE::Offset3D const & srcOffset_ ) VULKAN_HPP_NOEXCEPT
    {
      srcOffset = srcOffset_;
      return *this;
    }

    ImageResolve &
      setDstSubresource( VULKAN_HPP_NAMESPACE::ImageSubresourceLayers const & dstSubresource_ ) VULKAN_HPP_NOEXCEPT
    {
      dstSubresource = dstSubresource_;
      return *this;
    }

    ImageResolve & setDstOffset( VULKAN_HPP_NAMESPACE::Offset3D const & dstOffset_ ) VULKAN_HPP_NOEXCEPT
    {
      dstOffset = dstOffset_;
      return *this;
    }

    ImageResolve & setExtent( VULKAN_HPP_NAMESPACE::Extent3D const & extent_ ) VULKAN_HPP_NOEXCEPT
    {
      extent = extent_;
      return *this;
    }

    operator VkImageResolve const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkImageResolve *>( this );
    }

    operator VkImageResolve &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkImageResolve *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ImageResolve const & ) const = default;
#else
    bool operator==( ImageResolve const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( srcSubresource == rhs.srcSubresource ) && ( srcOffset == rhs.srcOffset ) &&
             ( dstSubresource == rhs.dstSubresource ) && ( dstOffset == rhs.dstOffset ) && ( extent == rhs.extent );
    }

    bool operator!=( ImageResolve const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::ImageSubresourceLayers srcSubresource = {};
    VULKAN_HPP_NAMESPACE::Offset3D               srcOffset      = {};
    VULKAN_HPP_NAMESPACE::ImageSubresourceLayers dstSubresource = {};
    VULKAN_HPP_NAMESPACE::Offset3D               dstOffset      = {};
    VULKAN_HPP_NAMESPACE::Extent3D               extent         = {};
  };
  static_assert( sizeof( ImageResolve ) == sizeof( VkImageResolve ), "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ImageResolve>::value, "struct wrapper is not a standard layout!" );

  struct ImageResolve2KHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eImageResolve2KHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ImageResolve2KHR( VULKAN_HPP_NAMESPACE::ImageSubresourceLayers srcSubresource_ = {},
                                           VULKAN_HPP_NAMESPACE::Offset3D               srcOffset_      = {},
                                           VULKAN_HPP_NAMESPACE::ImageSubresourceLayers dstSubresource_ = {},
                                           VULKAN_HPP_NAMESPACE::Offset3D               dstOffset_      = {},
                                           VULKAN_HPP_NAMESPACE::Extent3D extent_ = {} ) VULKAN_HPP_NOEXCEPT
      : srcSubresource( srcSubresource_ )
      , srcOffset( srcOffset_ )
      , dstSubresource( dstSubresource_ )
      , dstOffset( dstOffset_ )
      , extent( extent_ )
    {}

    VULKAN_HPP_CONSTEXPR ImageResolve2KHR( ImageResolve2KHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImageResolve2KHR( VkImageResolve2KHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : ImageResolve2KHR( *reinterpret_cast<ImageResolve2KHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ImageResolve2KHR & operator=( ImageResolve2KHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImageResolve2KHR & operator=( VkImageResolve2KHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ImageResolve2KHR const *>( &rhs );
      return *this;
    }

    ImageResolve2KHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ImageResolve2KHR &
      setSrcSubresource( VULKAN_HPP_NAMESPACE::ImageSubresourceLayers const & srcSubresource_ ) VULKAN_HPP_NOEXCEPT
    {
      srcSubresource = srcSubresource_;
      return *this;
    }

    ImageResolve2KHR & setSrcOffset( VULKAN_HPP_NAMESPACE::Offset3D const & srcOffset_ ) VULKAN_HPP_NOEXCEPT
    {
      srcOffset = srcOffset_;
      return *this;
    }

    ImageResolve2KHR &
      setDstSubresource( VULKAN_HPP_NAMESPACE::ImageSubresourceLayers const & dstSubresource_ ) VULKAN_HPP_NOEXCEPT
    {
      dstSubresource = dstSubresource_;
      return *this;
    }

    ImageResolve2KHR & setDstOffset( VULKAN_HPP_NAMESPACE::Offset3D const & dstOffset_ ) VULKAN_HPP_NOEXCEPT
    {
      dstOffset = dstOffset_;
      return *this;
    }

    ImageResolve2KHR & setExtent( VULKAN_HPP_NAMESPACE::Extent3D const & extent_ ) VULKAN_HPP_NOEXCEPT
    {
      extent = extent_;
      return *this;
    }

    operator VkImageResolve2KHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkImageResolve2KHR *>( this );
    }

    operator VkImageResolve2KHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkImageResolve2KHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ImageResolve2KHR const & ) const = default;
#else
    bool operator==( ImageResolve2KHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( srcSubresource == rhs.srcSubresource ) &&
             ( srcOffset == rhs.srcOffset ) && ( dstSubresource == rhs.dstSubresource ) &&
             ( dstOffset == rhs.dstOffset ) && ( extent == rhs.extent );
    }

    bool operator!=( ImageResolve2KHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType          sType          = StructureType::eImageResolve2KHR;
    const void *                                 pNext          = {};
    VULKAN_HPP_NAMESPACE::ImageSubresourceLayers srcSubresource = {};
    VULKAN_HPP_NAMESPACE::Offset3D               srcOffset      = {};
    VULKAN_HPP_NAMESPACE::ImageSubresourceLayers dstSubresource = {};
    VULKAN_HPP_NAMESPACE::Offset3D               dstOffset      = {};
    VULKAN_HPP_NAMESPACE::Extent3D               extent         = {};
  };
  static_assert( sizeof( ImageResolve2KHR ) == sizeof( VkImageResolve2KHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ImageResolve2KHR>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eImageResolve2KHR>
  {
    using Type = ImageResolve2KHR;
  };

  struct ImageSparseMemoryRequirementsInfo2
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eImageSparseMemoryRequirementsInfo2;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      ImageSparseMemoryRequirementsInfo2( VULKAN_HPP_NAMESPACE::Image image_ = {} ) VULKAN_HPP_NOEXCEPT
      : image( image_ )
    {}

    VULKAN_HPP_CONSTEXPR ImageSparseMemoryRequirementsInfo2( ImageSparseMemoryRequirementsInfo2 const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    ImageSparseMemoryRequirementsInfo2( VkImageSparseMemoryRequirementsInfo2 const & rhs ) VULKAN_HPP_NOEXCEPT
      : ImageSparseMemoryRequirementsInfo2( *reinterpret_cast<ImageSparseMemoryRequirementsInfo2 const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ImageSparseMemoryRequirementsInfo2 &
                            operator=( ImageSparseMemoryRequirementsInfo2 const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImageSparseMemoryRequirementsInfo2 &
      operator=( VkImageSparseMemoryRequirementsInfo2 const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ImageSparseMemoryRequirementsInfo2 const *>( &rhs );
      return *this;
    }

    ImageSparseMemoryRequirementsInfo2 & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ImageSparseMemoryRequirementsInfo2 & setImage( VULKAN_HPP_NAMESPACE::Image image_ ) VULKAN_HPP_NOEXCEPT
    {
      image = image_;
      return *this;
    }

    operator VkImageSparseMemoryRequirementsInfo2 const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkImageSparseMemoryRequirementsInfo2 *>( this );
    }

    operator VkImageSparseMemoryRequirementsInfo2 &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkImageSparseMemoryRequirementsInfo2 *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ImageSparseMemoryRequirementsInfo2 const & ) const = default;
#else
    bool operator==( ImageSparseMemoryRequirementsInfo2 const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( image == rhs.image );
    }

    bool operator!=( ImageSparseMemoryRequirementsInfo2 const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::eImageSparseMemoryRequirementsInfo2;
    const void *                        pNext = {};
    VULKAN_HPP_NAMESPACE::Image         image = {};
  };
  static_assert( sizeof( ImageSparseMemoryRequirementsInfo2 ) == sizeof( VkImageSparseMemoryRequirementsInfo2 ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ImageSparseMemoryRequirementsInfo2>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eImageSparseMemoryRequirementsInfo2>
  {
    using Type = ImageSparseMemoryRequirementsInfo2;
  };
  using ImageSparseMemoryRequirementsInfo2KHR = ImageSparseMemoryRequirementsInfo2;

  struct ImageStencilUsageCreateInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eImageStencilUsageCreateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      ImageStencilUsageCreateInfo( VULKAN_HPP_NAMESPACE::ImageUsageFlags stencilUsage_ = {} ) VULKAN_HPP_NOEXCEPT
      : stencilUsage( stencilUsage_ )
    {}

    VULKAN_HPP_CONSTEXPR
      ImageStencilUsageCreateInfo( ImageStencilUsageCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImageStencilUsageCreateInfo( VkImageStencilUsageCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : ImageStencilUsageCreateInfo( *reinterpret_cast<ImageStencilUsageCreateInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ImageStencilUsageCreateInfo &
                            operator=( ImageStencilUsageCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImageStencilUsageCreateInfo & operator=( VkImageStencilUsageCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ImageStencilUsageCreateInfo const *>( &rhs );
      return *this;
    }

    ImageStencilUsageCreateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ImageStencilUsageCreateInfo &
      setStencilUsage( VULKAN_HPP_NAMESPACE::ImageUsageFlags stencilUsage_ ) VULKAN_HPP_NOEXCEPT
    {
      stencilUsage = stencilUsage_;
      return *this;
    }

    operator VkImageStencilUsageCreateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkImageStencilUsageCreateInfo *>( this );
    }

    operator VkImageStencilUsageCreateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkImageStencilUsageCreateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ImageStencilUsageCreateInfo const & ) const = default;
#else
    bool operator==( ImageStencilUsageCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( stencilUsage == rhs.stencilUsage );
    }

    bool operator!=( ImageStencilUsageCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType   sType        = StructureType::eImageStencilUsageCreateInfo;
    const void *                          pNext        = {};
    VULKAN_HPP_NAMESPACE::ImageUsageFlags stencilUsage = {};
  };
  static_assert( sizeof( ImageStencilUsageCreateInfo ) == sizeof( VkImageStencilUsageCreateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ImageStencilUsageCreateInfo>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eImageStencilUsageCreateInfo>
  {
    using Type = ImageStencilUsageCreateInfo;
  };
  using ImageStencilUsageCreateInfoEXT = ImageStencilUsageCreateInfo;

  struct ImageSwapchainCreateInfoKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eImageSwapchainCreateInfoKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      ImageSwapchainCreateInfoKHR( VULKAN_HPP_NAMESPACE::SwapchainKHR swapchain_ = {} ) VULKAN_HPP_NOEXCEPT
      : swapchain( swapchain_ )
    {}

    VULKAN_HPP_CONSTEXPR
      ImageSwapchainCreateInfoKHR( ImageSwapchainCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImageSwapchainCreateInfoKHR( VkImageSwapchainCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : ImageSwapchainCreateInfoKHR( *reinterpret_cast<ImageSwapchainCreateInfoKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ImageSwapchainCreateInfoKHR &
                            operator=( ImageSwapchainCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImageSwapchainCreateInfoKHR & operator=( VkImageSwapchainCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ImageSwapchainCreateInfoKHR const *>( &rhs );
      return *this;
    }

    ImageSwapchainCreateInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ImageSwapchainCreateInfoKHR & setSwapchain( VULKAN_HPP_NAMESPACE::SwapchainKHR swapchain_ ) VULKAN_HPP_NOEXCEPT
    {
      swapchain = swapchain_;
      return *this;
    }

    operator VkImageSwapchainCreateInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkImageSwapchainCreateInfoKHR *>( this );
    }

    operator VkImageSwapchainCreateInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkImageSwapchainCreateInfoKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ImageSwapchainCreateInfoKHR const & ) const = default;
#else
    bool operator==( ImageSwapchainCreateInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( swapchain == rhs.swapchain );
    }

    bool operator!=( ImageSwapchainCreateInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType     = StructureType::eImageSwapchainCreateInfoKHR;
    const void *                        pNext     = {};
    VULKAN_HPP_NAMESPACE::SwapchainKHR  swapchain = {};
  };
  static_assert( sizeof( ImageSwapchainCreateInfoKHR ) == sizeof( VkImageSwapchainCreateInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ImageSwapchainCreateInfoKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eImageSwapchainCreateInfoKHR>
  {
    using Type = ImageSwapchainCreateInfoKHR;
  };

  struct ImageViewASTCDecodeModeEXT
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eImageViewAstcDecodeModeEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ImageViewASTCDecodeModeEXT(
      VULKAN_HPP_NAMESPACE::Format decodeMode_ = VULKAN_HPP_NAMESPACE::Format::eUndefined ) VULKAN_HPP_NOEXCEPT
      : decodeMode( decodeMode_ )
    {}

    VULKAN_HPP_CONSTEXPR
      ImageViewASTCDecodeModeEXT( ImageViewASTCDecodeModeEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImageViewASTCDecodeModeEXT( VkImageViewASTCDecodeModeEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : ImageViewASTCDecodeModeEXT( *reinterpret_cast<ImageViewASTCDecodeModeEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ImageViewASTCDecodeModeEXT &
                            operator=( ImageViewASTCDecodeModeEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImageViewASTCDecodeModeEXT & operator=( VkImageViewASTCDecodeModeEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ImageViewASTCDecodeModeEXT const *>( &rhs );
      return *this;
    }

    ImageViewASTCDecodeModeEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ImageViewASTCDecodeModeEXT & setDecodeMode( VULKAN_HPP_NAMESPACE::Format decodeMode_ ) VULKAN_HPP_NOEXCEPT
    {
      decodeMode = decodeMode_;
      return *this;
    }

    operator VkImageViewASTCDecodeModeEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkImageViewASTCDecodeModeEXT *>( this );
    }

    operator VkImageViewASTCDecodeModeEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkImageViewASTCDecodeModeEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ImageViewASTCDecodeModeEXT const & ) const = default;
#else
    bool operator==( ImageViewASTCDecodeModeEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( decodeMode == rhs.decodeMode );
    }

    bool operator!=( ImageViewASTCDecodeModeEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType      = StructureType::eImageViewAstcDecodeModeEXT;
    const void *                        pNext      = {};
    VULKAN_HPP_NAMESPACE::Format        decodeMode = VULKAN_HPP_NAMESPACE::Format::eUndefined;
  };
  static_assert( sizeof( ImageViewASTCDecodeModeEXT ) == sizeof( VkImageViewASTCDecodeModeEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ImageViewASTCDecodeModeEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eImageViewAstcDecodeModeEXT>
  {
    using Type = ImageViewASTCDecodeModeEXT;
  };

  struct ImageViewAddressPropertiesNVX
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eImageViewAddressPropertiesNVX;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      ImageViewAddressPropertiesNVX( VULKAN_HPP_NAMESPACE::DeviceAddress deviceAddress_ = {},
                                     VULKAN_HPP_NAMESPACE::DeviceSize    size_          = {} ) VULKAN_HPP_NOEXCEPT
      : deviceAddress( deviceAddress_ )
      , size( size_ )
    {}

    VULKAN_HPP_CONSTEXPR
      ImageViewAddressPropertiesNVX( ImageViewAddressPropertiesNVX const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImageViewAddressPropertiesNVX( VkImageViewAddressPropertiesNVX const & rhs ) VULKAN_HPP_NOEXCEPT
      : ImageViewAddressPropertiesNVX( *reinterpret_cast<ImageViewAddressPropertiesNVX const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ImageViewAddressPropertiesNVX &
                            operator=( ImageViewAddressPropertiesNVX const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImageViewAddressPropertiesNVX & operator=( VkImageViewAddressPropertiesNVX const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ImageViewAddressPropertiesNVX const *>( &rhs );
      return *this;
    }

    operator VkImageViewAddressPropertiesNVX const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkImageViewAddressPropertiesNVX *>( this );
    }

    operator VkImageViewAddressPropertiesNVX &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkImageViewAddressPropertiesNVX *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ImageViewAddressPropertiesNVX const & ) const = default;
#else
    bool operator==( ImageViewAddressPropertiesNVX const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( deviceAddress == rhs.deviceAddress ) &&
             ( size == rhs.size );
    }

    bool operator!=( ImageViewAddressPropertiesNVX const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType         = StructureType::eImageViewAddressPropertiesNVX;
    void *                              pNext         = {};
    VULKAN_HPP_NAMESPACE::DeviceAddress deviceAddress = {};
    VULKAN_HPP_NAMESPACE::DeviceSize    size          = {};
  };
  static_assert( sizeof( ImageViewAddressPropertiesNVX ) == sizeof( VkImageViewAddressPropertiesNVX ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ImageViewAddressPropertiesNVX>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eImageViewAddressPropertiesNVX>
  {
    using Type = ImageViewAddressPropertiesNVX;
  };

  struct ImageViewCreateInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eImageViewCreateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      ImageViewCreateInfo( VULKAN_HPP_NAMESPACE::ImageViewCreateFlags flags_ = {},
                           VULKAN_HPP_NAMESPACE::Image                image_ = {},
                           VULKAN_HPP_NAMESPACE::ImageViewType    viewType_  = VULKAN_HPP_NAMESPACE::ImageViewType::e1D,
                           VULKAN_HPP_NAMESPACE::Format           format_    = VULKAN_HPP_NAMESPACE::Format::eUndefined,
                           VULKAN_HPP_NAMESPACE::ComponentMapping components_            = {},
                           VULKAN_HPP_NAMESPACE::ImageSubresourceRange subresourceRange_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , image( image_ )
      , viewType( viewType_ )
      , format( format_ )
      , components( components_ )
      , subresourceRange( subresourceRange_ )
    {}

    VULKAN_HPP_CONSTEXPR ImageViewCreateInfo( ImageViewCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImageViewCreateInfo( VkImageViewCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : ImageViewCreateInfo( *reinterpret_cast<ImageViewCreateInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ImageViewCreateInfo &
                            operator=( ImageViewCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImageViewCreateInfo & operator=( VkImageViewCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ImageViewCreateInfo const *>( &rhs );
      return *this;
    }

    ImageViewCreateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ImageViewCreateInfo & setFlags( VULKAN_HPP_NAMESPACE::ImageViewCreateFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    ImageViewCreateInfo & setImage( VULKAN_HPP_NAMESPACE::Image image_ ) VULKAN_HPP_NOEXCEPT
    {
      image = image_;
      return *this;
    }

    ImageViewCreateInfo & setViewType( VULKAN_HPP_NAMESPACE::ImageViewType viewType_ ) VULKAN_HPP_NOEXCEPT
    {
      viewType = viewType_;
      return *this;
    }

    ImageViewCreateInfo & setFormat( VULKAN_HPP_NAMESPACE::Format format_ ) VULKAN_HPP_NOEXCEPT
    {
      format = format_;
      return *this;
    }

    ImageViewCreateInfo &
      setComponents( VULKAN_HPP_NAMESPACE::ComponentMapping const & components_ ) VULKAN_HPP_NOEXCEPT
    {
      components = components_;
      return *this;
    }

    ImageViewCreateInfo &
      setSubresourceRange( VULKAN_HPP_NAMESPACE::ImageSubresourceRange const & subresourceRange_ ) VULKAN_HPP_NOEXCEPT
    {
      subresourceRange = subresourceRange_;
      return *this;
    }

    operator VkImageViewCreateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkImageViewCreateInfo *>( this );
    }

    operator VkImageViewCreateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkImageViewCreateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ImageViewCreateInfo const & ) const = default;
#else
    bool operator==( ImageViewCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) && ( image == rhs.image ) &&
             ( viewType == rhs.viewType ) && ( format == rhs.format ) && ( components == rhs.components ) &&
             ( subresourceRange == rhs.subresourceRange );
    }

    bool operator!=( ImageViewCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType         sType            = StructureType::eImageViewCreateInfo;
    const void *                                pNext            = {};
    VULKAN_HPP_NAMESPACE::ImageViewCreateFlags  flags            = {};
    VULKAN_HPP_NAMESPACE::Image                 image            = {};
    VULKAN_HPP_NAMESPACE::ImageViewType         viewType         = VULKAN_HPP_NAMESPACE::ImageViewType::e1D;
    VULKAN_HPP_NAMESPACE::Format                format           = VULKAN_HPP_NAMESPACE::Format::eUndefined;
    VULKAN_HPP_NAMESPACE::ComponentMapping      components       = {};
    VULKAN_HPP_NAMESPACE::ImageSubresourceRange subresourceRange = {};
  };
  static_assert( sizeof( ImageViewCreateInfo ) == sizeof( VkImageViewCreateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ImageViewCreateInfo>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eImageViewCreateInfo>
  {
    using Type = ImageViewCreateInfo;
  };

  struct ImageViewHandleInfoNVX
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eImageViewHandleInfoNVX;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ImageViewHandleInfoNVX(
      VULKAN_HPP_NAMESPACE::ImageView      imageView_      = {},
      VULKAN_HPP_NAMESPACE::DescriptorType descriptorType_ = VULKAN_HPP_NAMESPACE::DescriptorType::eSampler,
      VULKAN_HPP_NAMESPACE::Sampler        sampler_        = {} ) VULKAN_HPP_NOEXCEPT
      : imageView( imageView_ )
      , descriptorType( descriptorType_ )
      , sampler( sampler_ )
    {}

    VULKAN_HPP_CONSTEXPR ImageViewHandleInfoNVX( ImageViewHandleInfoNVX const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImageViewHandleInfoNVX( VkImageViewHandleInfoNVX const & rhs ) VULKAN_HPP_NOEXCEPT
      : ImageViewHandleInfoNVX( *reinterpret_cast<ImageViewHandleInfoNVX const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ImageViewHandleInfoNVX &
                            operator=( ImageViewHandleInfoNVX const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImageViewHandleInfoNVX & operator=( VkImageViewHandleInfoNVX const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ImageViewHandleInfoNVX const *>( &rhs );
      return *this;
    }

    ImageViewHandleInfoNVX & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ImageViewHandleInfoNVX & setImageView( VULKAN_HPP_NAMESPACE::ImageView imageView_ ) VULKAN_HPP_NOEXCEPT
    {
      imageView = imageView_;
      return *this;
    }

    ImageViewHandleInfoNVX &
      setDescriptorType( VULKAN_HPP_NAMESPACE::DescriptorType descriptorType_ ) VULKAN_HPP_NOEXCEPT
    {
      descriptorType = descriptorType_;
      return *this;
    }

    ImageViewHandleInfoNVX & setSampler( VULKAN_HPP_NAMESPACE::Sampler sampler_ ) VULKAN_HPP_NOEXCEPT
    {
      sampler = sampler_;
      return *this;
    }

    operator VkImageViewHandleInfoNVX const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkImageViewHandleInfoNVX *>( this );
    }

    operator VkImageViewHandleInfoNVX &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkImageViewHandleInfoNVX *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ImageViewHandleInfoNVX const & ) const = default;
#else
    bool operator==( ImageViewHandleInfoNVX const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( imageView == rhs.imageView ) &&
             ( descriptorType == rhs.descriptorType ) && ( sampler == rhs.sampler );
    }

    bool operator!=( ImageViewHandleInfoNVX const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType  sType          = StructureType::eImageViewHandleInfoNVX;
    const void *                         pNext          = {};
    VULKAN_HPP_NAMESPACE::ImageView      imageView      = {};
    VULKAN_HPP_NAMESPACE::DescriptorType descriptorType = VULKAN_HPP_NAMESPACE::DescriptorType::eSampler;
    VULKAN_HPP_NAMESPACE::Sampler        sampler        = {};
  };
  static_assert( sizeof( ImageViewHandleInfoNVX ) == sizeof( VkImageViewHandleInfoNVX ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ImageViewHandleInfoNVX>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eImageViewHandleInfoNVX>
  {
    using Type = ImageViewHandleInfoNVX;
  };

  struct ImageViewUsageCreateInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eImageViewUsageCreateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      ImageViewUsageCreateInfo( VULKAN_HPP_NAMESPACE::ImageUsageFlags usage_ = {} ) VULKAN_HPP_NOEXCEPT
      : usage( usage_ )
    {}

    VULKAN_HPP_CONSTEXPR ImageViewUsageCreateInfo( ImageViewUsageCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImageViewUsageCreateInfo( VkImageViewUsageCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : ImageViewUsageCreateInfo( *reinterpret_cast<ImageViewUsageCreateInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ImageViewUsageCreateInfo &
                            operator=( ImageViewUsageCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImageViewUsageCreateInfo & operator=( VkImageViewUsageCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ImageViewUsageCreateInfo const *>( &rhs );
      return *this;
    }

    ImageViewUsageCreateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ImageViewUsageCreateInfo & setUsage( VULKAN_HPP_NAMESPACE::ImageUsageFlags usage_ ) VULKAN_HPP_NOEXCEPT
    {
      usage = usage_;
      return *this;
    }

    operator VkImageViewUsageCreateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkImageViewUsageCreateInfo *>( this );
    }

    operator VkImageViewUsageCreateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkImageViewUsageCreateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ImageViewUsageCreateInfo const & ) const = default;
#else
    bool operator==( ImageViewUsageCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( usage == rhs.usage );
    }

    bool operator!=( ImageViewUsageCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType   sType = StructureType::eImageViewUsageCreateInfo;
    const void *                          pNext = {};
    VULKAN_HPP_NAMESPACE::ImageUsageFlags usage = {};
  };
  static_assert( sizeof( ImageViewUsageCreateInfo ) == sizeof( VkImageViewUsageCreateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ImageViewUsageCreateInfo>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eImageViewUsageCreateInfo>
  {
    using Type = ImageViewUsageCreateInfo;
  };
  using ImageViewUsageCreateInfoKHR = ImageViewUsageCreateInfo;

#if defined( VK_USE_PLATFORM_ANDROID_KHR )
  struct ImportAndroidHardwareBufferInfoANDROID
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eImportAndroidHardwareBufferInfoANDROID;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      ImportAndroidHardwareBufferInfoANDROID( struct AHardwareBuffer * buffer_ = {} ) VULKAN_HPP_NOEXCEPT
      : buffer( buffer_ )
    {}

    VULKAN_HPP_CONSTEXPR ImportAndroidHardwareBufferInfoANDROID( ImportAndroidHardwareBufferInfoANDROID const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    ImportAndroidHardwareBufferInfoANDROID( VkImportAndroidHardwareBufferInfoANDROID const & rhs ) VULKAN_HPP_NOEXCEPT
      : ImportAndroidHardwareBufferInfoANDROID(
          *reinterpret_cast<ImportAndroidHardwareBufferInfoANDROID const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ImportAndroidHardwareBufferInfoANDROID &
                            operator=( ImportAndroidHardwareBufferInfoANDROID const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImportAndroidHardwareBufferInfoANDROID &
      operator=( VkImportAndroidHardwareBufferInfoANDROID const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ImportAndroidHardwareBufferInfoANDROID const *>( &rhs );
      return *this;
    }

    ImportAndroidHardwareBufferInfoANDROID & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ImportAndroidHardwareBufferInfoANDROID & setBuffer( struct AHardwareBuffer * buffer_ ) VULKAN_HPP_NOEXCEPT
    {
      buffer = buffer_;
      return *this;
    }

    operator VkImportAndroidHardwareBufferInfoANDROID const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkImportAndroidHardwareBufferInfoANDROID *>( this );
    }

    operator VkImportAndroidHardwareBufferInfoANDROID &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkImportAndroidHardwareBufferInfoANDROID *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ImportAndroidHardwareBufferInfoANDROID const & ) const = default;
#  else
    bool operator==( ImportAndroidHardwareBufferInfoANDROID const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( buffer == rhs.buffer );
    }

    bool operator!=( ImportAndroidHardwareBufferInfoANDROID const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType  = StructureType::eImportAndroidHardwareBufferInfoANDROID;
    const void *                        pNext  = {};
    struct AHardwareBuffer *            buffer = {};
  };
  static_assert( sizeof( ImportAndroidHardwareBufferInfoANDROID ) == sizeof( VkImportAndroidHardwareBufferInfoANDROID ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ImportAndroidHardwareBufferInfoANDROID>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eImportAndroidHardwareBufferInfoANDROID>
  {
    using Type = ImportAndroidHardwareBufferInfoANDROID;
  };
#endif /*VK_USE_PLATFORM_ANDROID_KHR*/

  struct ImportFenceFdInfoKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eImportFenceFdInfoKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ImportFenceFdInfoKHR( VULKAN_HPP_NAMESPACE::Fence                           fence_ = {},
                                               VULKAN_HPP_NAMESPACE::FenceImportFlags                flags_ = {},
                                               VULKAN_HPP_NAMESPACE::ExternalFenceHandleTypeFlagBits handleType_ =
                                                 VULKAN_HPP_NAMESPACE::ExternalFenceHandleTypeFlagBits::eOpaqueFd,
                                               int fd_ = {} ) VULKAN_HPP_NOEXCEPT
      : fence( fence_ )
      , flags( flags_ )
      , handleType( handleType_ )
      , fd( fd_ )
    {}

    VULKAN_HPP_CONSTEXPR ImportFenceFdInfoKHR( ImportFenceFdInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImportFenceFdInfoKHR( VkImportFenceFdInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : ImportFenceFdInfoKHR( *reinterpret_cast<ImportFenceFdInfoKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ImportFenceFdInfoKHR &
                            operator=( ImportFenceFdInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImportFenceFdInfoKHR & operator=( VkImportFenceFdInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ImportFenceFdInfoKHR const *>( &rhs );
      return *this;
    }

    ImportFenceFdInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ImportFenceFdInfoKHR & setFence( VULKAN_HPP_NAMESPACE::Fence fence_ ) VULKAN_HPP_NOEXCEPT
    {
      fence = fence_;
      return *this;
    }

    ImportFenceFdInfoKHR & setFlags( VULKAN_HPP_NAMESPACE::FenceImportFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    ImportFenceFdInfoKHR &
      setHandleType( VULKAN_HPP_NAMESPACE::ExternalFenceHandleTypeFlagBits handleType_ ) VULKAN_HPP_NOEXCEPT
    {
      handleType = handleType_;
      return *this;
    }

    ImportFenceFdInfoKHR & setFd( int fd_ ) VULKAN_HPP_NOEXCEPT
    {
      fd = fd_;
      return *this;
    }

    operator VkImportFenceFdInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkImportFenceFdInfoKHR *>( this );
    }

    operator VkImportFenceFdInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkImportFenceFdInfoKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ImportFenceFdInfoKHR const & ) const = default;
#else
    bool operator==( ImportFenceFdInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( fence == rhs.fence ) && ( flags == rhs.flags ) &&
             ( handleType == rhs.handleType ) && ( fd == rhs.fd );
    }

    bool operator!=( ImportFenceFdInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                   sType = StructureType::eImportFenceFdInfoKHR;
    const void *                                          pNext = {};
    VULKAN_HPP_NAMESPACE::Fence                           fence = {};
    VULKAN_HPP_NAMESPACE::FenceImportFlags                flags = {};
    VULKAN_HPP_NAMESPACE::ExternalFenceHandleTypeFlagBits handleType =
      VULKAN_HPP_NAMESPACE::ExternalFenceHandleTypeFlagBits::eOpaqueFd;
    int fd = {};
  };
  static_assert( sizeof( ImportFenceFdInfoKHR ) == sizeof( VkImportFenceFdInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ImportFenceFdInfoKHR>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eImportFenceFdInfoKHR>
  {
    using Type = ImportFenceFdInfoKHR;
  };

#if defined( VK_USE_PLATFORM_WIN32_KHR )
  struct ImportFenceWin32HandleInfoKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eImportFenceWin32HandleInfoKHR;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      ImportFenceWin32HandleInfoKHR( VULKAN_HPP_NAMESPACE::Fence                           fence_ = {},
                                     VULKAN_HPP_NAMESPACE::FenceImportFlags                flags_ = {},
                                     VULKAN_HPP_NAMESPACE::ExternalFenceHandleTypeFlagBits handleType_ =
                                       VULKAN_HPP_NAMESPACE::ExternalFenceHandleTypeFlagBits::eOpaqueFd,
                                     HANDLE  handle_ = {},
                                     LPCWSTR name_   = {} ) VULKAN_HPP_NOEXCEPT
      : fence( fence_ )
      , flags( flags_ )
      , handleType( handleType_ )
      , handle( handle_ )
      , name( name_ )
    {}

    VULKAN_HPP_CONSTEXPR
      ImportFenceWin32HandleInfoKHR( ImportFenceWin32HandleInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImportFenceWin32HandleInfoKHR( VkImportFenceWin32HandleInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : ImportFenceWin32HandleInfoKHR( *reinterpret_cast<ImportFenceWin32HandleInfoKHR const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ImportFenceWin32HandleInfoKHR &
                            operator=( ImportFenceWin32HandleInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImportFenceWin32HandleInfoKHR & operator=( VkImportFenceWin32HandleInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ImportFenceWin32HandleInfoKHR const *>( &rhs );
      return *this;
    }

    ImportFenceWin32HandleInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ImportFenceWin32HandleInfoKHR & setFence( VULKAN_HPP_NAMESPACE::Fence fence_ ) VULKAN_HPP_NOEXCEPT
    {
      fence = fence_;
      return *this;
    }

    ImportFenceWin32HandleInfoKHR & setFlags( VULKAN_HPP_NAMESPACE::FenceImportFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    ImportFenceWin32HandleInfoKHR &
      setHandleType( VULKAN_HPP_NAMESPACE::ExternalFenceHandleTypeFlagBits handleType_ ) VULKAN_HPP_NOEXCEPT
    {
      handleType = handleType_;
      return *this;
    }

    ImportFenceWin32HandleInfoKHR & setHandle( HANDLE handle_ ) VULKAN_HPP_NOEXCEPT
    {
      handle = handle_;
      return *this;
    }

    ImportFenceWin32HandleInfoKHR & setName( LPCWSTR name_ ) VULKAN_HPP_NOEXCEPT
    {
      name = name_;
      return *this;
    }

    operator VkImportFenceWin32HandleInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkImportFenceWin32HandleInfoKHR *>( this );
    }

    operator VkImportFenceWin32HandleInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkImportFenceWin32HandleInfoKHR *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ImportFenceWin32HandleInfoKHR const & ) const = default;
#  else
    bool operator==( ImportFenceWin32HandleInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( fence == rhs.fence ) && ( flags == rhs.flags ) &&
             ( handleType == rhs.handleType ) && ( handle == rhs.handle ) && ( name == rhs.name );
    }

    bool operator!=( ImportFenceWin32HandleInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                   sType = StructureType::eImportFenceWin32HandleInfoKHR;
    const void *                                          pNext = {};
    VULKAN_HPP_NAMESPACE::Fence                           fence = {};
    VULKAN_HPP_NAMESPACE::FenceImportFlags                flags = {};
    VULKAN_HPP_NAMESPACE::ExternalFenceHandleTypeFlagBits handleType =
      VULKAN_HPP_NAMESPACE::ExternalFenceHandleTypeFlagBits::eOpaqueFd;
    HANDLE  handle = {};
    LPCWSTR name   = {};
  };
  static_assert( sizeof( ImportFenceWin32HandleInfoKHR ) == sizeof( VkImportFenceWin32HandleInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ImportFenceWin32HandleInfoKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eImportFenceWin32HandleInfoKHR>
  {
    using Type = ImportFenceWin32HandleInfoKHR;
  };
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

  struct ImportMemoryFdInfoKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eImportMemoryFdInfoKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ImportMemoryFdInfoKHR( VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagBits handleType_ =
                                                  VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagBits::eOpaqueFd,
                                                int fd_ = {} ) VULKAN_HPP_NOEXCEPT
      : handleType( handleType_ )
      , fd( fd_ )
    {}

    VULKAN_HPP_CONSTEXPR ImportMemoryFdInfoKHR( ImportMemoryFdInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImportMemoryFdInfoKHR( VkImportMemoryFdInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : ImportMemoryFdInfoKHR( *reinterpret_cast<ImportMemoryFdInfoKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ImportMemoryFdInfoKHR &
                            operator=( ImportMemoryFdInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImportMemoryFdInfoKHR & operator=( VkImportMemoryFdInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ImportMemoryFdInfoKHR const *>( &rhs );
      return *this;
    }

    ImportMemoryFdInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ImportMemoryFdInfoKHR &
      setHandleType( VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagBits handleType_ ) VULKAN_HPP_NOEXCEPT
    {
      handleType = handleType_;
      return *this;
    }

    ImportMemoryFdInfoKHR & setFd( int fd_ ) VULKAN_HPP_NOEXCEPT
    {
      fd = fd_;
      return *this;
    }

    operator VkImportMemoryFdInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkImportMemoryFdInfoKHR *>( this );
    }

    operator VkImportMemoryFdInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkImportMemoryFdInfoKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ImportMemoryFdInfoKHR const & ) const = default;
#else
    bool operator==( ImportMemoryFdInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( handleType == rhs.handleType ) && ( fd == rhs.fd );
    }

    bool operator!=( ImportMemoryFdInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                    sType = StructureType::eImportMemoryFdInfoKHR;
    const void *                                           pNext = {};
    VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagBits handleType =
      VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagBits::eOpaqueFd;
    int fd = {};
  };
  static_assert( sizeof( ImportMemoryFdInfoKHR ) == sizeof( VkImportMemoryFdInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ImportMemoryFdInfoKHR>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eImportMemoryFdInfoKHR>
  {
    using Type = ImportMemoryFdInfoKHR;
  };

  struct ImportMemoryHostPointerInfoEXT
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eImportMemoryHostPointerInfoEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      ImportMemoryHostPointerInfoEXT( VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagBits handleType_ =
                                        VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagBits::eOpaqueFd,
                                      void * pHostPointer_ = {} ) VULKAN_HPP_NOEXCEPT
      : handleType( handleType_ )
      , pHostPointer( pHostPointer_ )
    {}

    VULKAN_HPP_CONSTEXPR
      ImportMemoryHostPointerInfoEXT( ImportMemoryHostPointerInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImportMemoryHostPointerInfoEXT( VkImportMemoryHostPointerInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : ImportMemoryHostPointerInfoEXT( *reinterpret_cast<ImportMemoryHostPointerInfoEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ImportMemoryHostPointerInfoEXT &
                            operator=( ImportMemoryHostPointerInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImportMemoryHostPointerInfoEXT & operator=( VkImportMemoryHostPointerInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ImportMemoryHostPointerInfoEXT const *>( &rhs );
      return *this;
    }

    ImportMemoryHostPointerInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ImportMemoryHostPointerInfoEXT &
      setHandleType( VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagBits handleType_ ) VULKAN_HPP_NOEXCEPT
    {
      handleType = handleType_;
      return *this;
    }

    ImportMemoryHostPointerInfoEXT & setPHostPointer( void * pHostPointer_ ) VULKAN_HPP_NOEXCEPT
    {
      pHostPointer = pHostPointer_;
      return *this;
    }

    operator VkImportMemoryHostPointerInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkImportMemoryHostPointerInfoEXT *>( this );
    }

    operator VkImportMemoryHostPointerInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkImportMemoryHostPointerInfoEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ImportMemoryHostPointerInfoEXT const & ) const = default;
#else
    bool operator==( ImportMemoryHostPointerInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( handleType == rhs.handleType ) &&
             ( pHostPointer == rhs.pHostPointer );
    }

    bool operator!=( ImportMemoryHostPointerInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                    sType = StructureType::eImportMemoryHostPointerInfoEXT;
    const void *                                           pNext = {};
    VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagBits handleType =
      VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagBits::eOpaqueFd;
    void * pHostPointer = {};
  };
  static_assert( sizeof( ImportMemoryHostPointerInfoEXT ) == sizeof( VkImportMemoryHostPointerInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ImportMemoryHostPointerInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eImportMemoryHostPointerInfoEXT>
  {
    using Type = ImportMemoryHostPointerInfoEXT;
  };

#if defined( VK_USE_PLATFORM_WIN32_KHR )
  struct ImportMemoryWin32HandleInfoKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eImportMemoryWin32HandleInfoKHR;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      ImportMemoryWin32HandleInfoKHR( VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagBits handleType_ =
                                        VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagBits::eOpaqueFd,
                                      HANDLE  handle_ = {},
                                      LPCWSTR name_   = {} ) VULKAN_HPP_NOEXCEPT
      : handleType( handleType_ )
      , handle( handle_ )
      , name( name_ )
    {}

    VULKAN_HPP_CONSTEXPR
      ImportMemoryWin32HandleInfoKHR( ImportMemoryWin32HandleInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImportMemoryWin32HandleInfoKHR( VkImportMemoryWin32HandleInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : ImportMemoryWin32HandleInfoKHR( *reinterpret_cast<ImportMemoryWin32HandleInfoKHR const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ImportMemoryWin32HandleInfoKHR &
                            operator=( ImportMemoryWin32HandleInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImportMemoryWin32HandleInfoKHR & operator=( VkImportMemoryWin32HandleInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ImportMemoryWin32HandleInfoKHR const *>( &rhs );
      return *this;
    }

    ImportMemoryWin32HandleInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ImportMemoryWin32HandleInfoKHR &
      setHandleType( VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagBits handleType_ ) VULKAN_HPP_NOEXCEPT
    {
      handleType = handleType_;
      return *this;
    }

    ImportMemoryWin32HandleInfoKHR & setHandle( HANDLE handle_ ) VULKAN_HPP_NOEXCEPT
    {
      handle = handle_;
      return *this;
    }

    ImportMemoryWin32HandleInfoKHR & setName( LPCWSTR name_ ) VULKAN_HPP_NOEXCEPT
    {
      name = name_;
      return *this;
    }

    operator VkImportMemoryWin32HandleInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkImportMemoryWin32HandleInfoKHR *>( this );
    }

    operator VkImportMemoryWin32HandleInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkImportMemoryWin32HandleInfoKHR *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ImportMemoryWin32HandleInfoKHR const & ) const = default;
#  else
    bool operator==( ImportMemoryWin32HandleInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( handleType == rhs.handleType ) &&
             ( handle == rhs.handle ) && ( name == rhs.name );
    }

    bool operator!=( ImportMemoryWin32HandleInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                    sType = StructureType::eImportMemoryWin32HandleInfoKHR;
    const void *                                           pNext = {};
    VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagBits handleType =
      VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagBits::eOpaqueFd;
    HANDLE  handle = {};
    LPCWSTR name   = {};
  };
  static_assert( sizeof( ImportMemoryWin32HandleInfoKHR ) == sizeof( VkImportMemoryWin32HandleInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ImportMemoryWin32HandleInfoKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eImportMemoryWin32HandleInfoKHR>
  {
    using Type = ImportMemoryWin32HandleInfoKHR;
  };
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

#if defined( VK_USE_PLATFORM_WIN32_KHR )
  struct ImportMemoryWin32HandleInfoNV
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eImportMemoryWin32HandleInfoNV;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      ImportMemoryWin32HandleInfoNV( VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagsNV handleType_ = {},
                                     HANDLE handle_ = {} ) VULKAN_HPP_NOEXCEPT
      : handleType( handleType_ )
      , handle( handle_ )
    {}

    VULKAN_HPP_CONSTEXPR
      ImportMemoryWin32HandleInfoNV( ImportMemoryWin32HandleInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImportMemoryWin32HandleInfoNV( VkImportMemoryWin32HandleInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
      : ImportMemoryWin32HandleInfoNV( *reinterpret_cast<ImportMemoryWin32HandleInfoNV const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ImportMemoryWin32HandleInfoNV &
                            operator=( ImportMemoryWin32HandleInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImportMemoryWin32HandleInfoNV & operator=( VkImportMemoryWin32HandleInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ImportMemoryWin32HandleInfoNV const *>( &rhs );
      return *this;
    }

    ImportMemoryWin32HandleInfoNV & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ImportMemoryWin32HandleInfoNV &
      setHandleType( VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagsNV handleType_ ) VULKAN_HPP_NOEXCEPT
    {
      handleType = handleType_;
      return *this;
    }

    ImportMemoryWin32HandleInfoNV & setHandle( HANDLE handle_ ) VULKAN_HPP_NOEXCEPT
    {
      handle = handle_;
      return *this;
    }

    operator VkImportMemoryWin32HandleInfoNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkImportMemoryWin32HandleInfoNV *>( this );
    }

    operator VkImportMemoryWin32HandleInfoNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkImportMemoryWin32HandleInfoNV *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ImportMemoryWin32HandleInfoNV const & ) const = default;
#  else
    bool operator==( ImportMemoryWin32HandleInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( handleType == rhs.handleType ) &&
             ( handle == rhs.handle );
    }

    bool operator!=( ImportMemoryWin32HandleInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                   sType      = StructureType::eImportMemoryWin32HandleInfoNV;
    const void *                                          pNext      = {};
    VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagsNV handleType = {};
    HANDLE                                                handle     = {};
  };
  static_assert( sizeof( ImportMemoryWin32HandleInfoNV ) == sizeof( VkImportMemoryWin32HandleInfoNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ImportMemoryWin32HandleInfoNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eImportMemoryWin32HandleInfoNV>
  {
    using Type = ImportMemoryWin32HandleInfoNV;
  };
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

#if defined( VK_USE_PLATFORM_FUCHSIA )
  struct ImportMemoryZirconHandleInfoFUCHSIA
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eImportMemoryZirconHandleInfoFUCHSIA;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      ImportMemoryZirconHandleInfoFUCHSIA( VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagBits handleType_ =
                                             VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagBits::eOpaqueFd,
                                           zx_handle_t handle_ = {} ) VULKAN_HPP_NOEXCEPT
      : handleType( handleType_ )
      , handle( handle_ )
    {}

    VULKAN_HPP_CONSTEXPR ImportMemoryZirconHandleInfoFUCHSIA( ImportMemoryZirconHandleInfoFUCHSIA const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    ImportMemoryZirconHandleInfoFUCHSIA( VkImportMemoryZirconHandleInfoFUCHSIA const & rhs ) VULKAN_HPP_NOEXCEPT
      : ImportMemoryZirconHandleInfoFUCHSIA( *reinterpret_cast<ImportMemoryZirconHandleInfoFUCHSIA const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ImportMemoryZirconHandleInfoFUCHSIA &
                            operator=( ImportMemoryZirconHandleInfoFUCHSIA const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImportMemoryZirconHandleInfoFUCHSIA &
      operator=( VkImportMemoryZirconHandleInfoFUCHSIA const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ImportMemoryZirconHandleInfoFUCHSIA const *>( &rhs );
      return *this;
    }

    ImportMemoryZirconHandleInfoFUCHSIA & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ImportMemoryZirconHandleInfoFUCHSIA &
      setHandleType( VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagBits handleType_ ) VULKAN_HPP_NOEXCEPT
    {
      handleType = handleType_;
      return *this;
    }

    ImportMemoryZirconHandleInfoFUCHSIA & setHandle( zx_handle_t handle_ ) VULKAN_HPP_NOEXCEPT
    {
      handle = handle_;
      return *this;
    }

    operator VkImportMemoryZirconHandleInfoFUCHSIA const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkImportMemoryZirconHandleInfoFUCHSIA *>( this );
    }

    operator VkImportMemoryZirconHandleInfoFUCHSIA &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkImportMemoryZirconHandleInfoFUCHSIA *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ImportMemoryZirconHandleInfoFUCHSIA const & ) const = default;
#  else
    bool operator==( ImportMemoryZirconHandleInfoFUCHSIA const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( handleType == rhs.handleType ) &&
             ( memcmp( &handle, &rhs.handle, sizeof( zx_handle_t ) ) == 0 );
    }

    bool operator!=( ImportMemoryZirconHandleInfoFUCHSIA const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                    sType = StructureType::eImportMemoryZirconHandleInfoFUCHSIA;
    const void *                                           pNext = {};
    VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagBits handleType =
      VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagBits::eOpaqueFd;
    zx_handle_t handle = {};
  };
  static_assert( sizeof( ImportMemoryZirconHandleInfoFUCHSIA ) == sizeof( VkImportMemoryZirconHandleInfoFUCHSIA ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ImportMemoryZirconHandleInfoFUCHSIA>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eImportMemoryZirconHandleInfoFUCHSIA>
  {
    using Type = ImportMemoryZirconHandleInfoFUCHSIA;
  };
#endif /*VK_USE_PLATFORM_FUCHSIA*/

  struct ImportSemaphoreFdInfoKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eImportSemaphoreFdInfoKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      ImportSemaphoreFdInfoKHR( VULKAN_HPP_NAMESPACE::Semaphore                           semaphore_ = {},
                                VULKAN_HPP_NAMESPACE::SemaphoreImportFlags                flags_     = {},
                                VULKAN_HPP_NAMESPACE::ExternalSemaphoreHandleTypeFlagBits handleType_ =
                                  VULKAN_HPP_NAMESPACE::ExternalSemaphoreHandleTypeFlagBits::eOpaqueFd,
                                int fd_ = {} ) VULKAN_HPP_NOEXCEPT
      : semaphore( semaphore_ )
      , flags( flags_ )
      , handleType( handleType_ )
      , fd( fd_ )
    {}

    VULKAN_HPP_CONSTEXPR ImportSemaphoreFdInfoKHR( ImportSemaphoreFdInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImportSemaphoreFdInfoKHR( VkImportSemaphoreFdInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : ImportSemaphoreFdInfoKHR( *reinterpret_cast<ImportSemaphoreFdInfoKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ImportSemaphoreFdInfoKHR &
                            operator=( ImportSemaphoreFdInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImportSemaphoreFdInfoKHR & operator=( VkImportSemaphoreFdInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ImportSemaphoreFdInfoKHR const *>( &rhs );
      return *this;
    }

    ImportSemaphoreFdInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ImportSemaphoreFdInfoKHR & setSemaphore( VULKAN_HPP_NAMESPACE::Semaphore semaphore_ ) VULKAN_HPP_NOEXCEPT
    {
      semaphore = semaphore_;
      return *this;
    }

    ImportSemaphoreFdInfoKHR & setFlags( VULKAN_HPP_NAMESPACE::SemaphoreImportFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    ImportSemaphoreFdInfoKHR &
      setHandleType( VULKAN_HPP_NAMESPACE::ExternalSemaphoreHandleTypeFlagBits handleType_ ) VULKAN_HPP_NOEXCEPT
    {
      handleType = handleType_;
      return *this;
    }

    ImportSemaphoreFdInfoKHR & setFd( int fd_ ) VULKAN_HPP_NOEXCEPT
    {
      fd = fd_;
      return *this;
    }

    operator VkImportSemaphoreFdInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkImportSemaphoreFdInfoKHR *>( this );
    }

    operator VkImportSemaphoreFdInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkImportSemaphoreFdInfoKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ImportSemaphoreFdInfoKHR const & ) const = default;
#else
    bool operator==( ImportSemaphoreFdInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( semaphore == rhs.semaphore ) &&
             ( flags == rhs.flags ) && ( handleType == rhs.handleType ) && ( fd == rhs.fd );
    }

    bool operator!=( ImportSemaphoreFdInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                       sType     = StructureType::eImportSemaphoreFdInfoKHR;
    const void *                                              pNext     = {};
    VULKAN_HPP_NAMESPACE::Semaphore                           semaphore = {};
    VULKAN_HPP_NAMESPACE::SemaphoreImportFlags                flags     = {};
    VULKAN_HPP_NAMESPACE::ExternalSemaphoreHandleTypeFlagBits handleType =
      VULKAN_HPP_NAMESPACE::ExternalSemaphoreHandleTypeFlagBits::eOpaqueFd;
    int fd = {};
  };
  static_assert( sizeof( ImportSemaphoreFdInfoKHR ) == sizeof( VkImportSemaphoreFdInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ImportSemaphoreFdInfoKHR>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eImportSemaphoreFdInfoKHR>
  {
    using Type = ImportSemaphoreFdInfoKHR;
  };

#if defined( VK_USE_PLATFORM_WIN32_KHR )
  struct ImportSemaphoreWin32HandleInfoKHR
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eImportSemaphoreWin32HandleInfoKHR;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      ImportSemaphoreWin32HandleInfoKHR( VULKAN_HPP_NAMESPACE::Semaphore                           semaphore_ = {},
                                         VULKAN_HPP_NAMESPACE::SemaphoreImportFlags                flags_     = {},
                                         VULKAN_HPP_NAMESPACE::ExternalSemaphoreHandleTypeFlagBits handleType_ =
                                           VULKAN_HPP_NAMESPACE::ExternalSemaphoreHandleTypeFlagBits::eOpaqueFd,
                                         HANDLE  handle_ = {},
                                         LPCWSTR name_   = {} ) VULKAN_HPP_NOEXCEPT
      : semaphore( semaphore_ )
      , flags( flags_ )
      , handleType( handleType_ )
      , handle( handle_ )
      , name( name_ )
    {}

    VULKAN_HPP_CONSTEXPR
      ImportSemaphoreWin32HandleInfoKHR( ImportSemaphoreWin32HandleInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImportSemaphoreWin32HandleInfoKHR( VkImportSemaphoreWin32HandleInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : ImportSemaphoreWin32HandleInfoKHR( *reinterpret_cast<ImportSemaphoreWin32HandleInfoKHR const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ImportSemaphoreWin32HandleInfoKHR &
                            operator=( ImportSemaphoreWin32HandleInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImportSemaphoreWin32HandleInfoKHR & operator=( VkImportSemaphoreWin32HandleInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ImportSemaphoreWin32HandleInfoKHR const *>( &rhs );
      return *this;
    }

    ImportSemaphoreWin32HandleInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ImportSemaphoreWin32HandleInfoKHR & setSemaphore( VULKAN_HPP_NAMESPACE::Semaphore semaphore_ ) VULKAN_HPP_NOEXCEPT
    {
      semaphore = semaphore_;
      return *this;
    }

    ImportSemaphoreWin32HandleInfoKHR &
      setFlags( VULKAN_HPP_NAMESPACE::SemaphoreImportFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    ImportSemaphoreWin32HandleInfoKHR &
      setHandleType( VULKAN_HPP_NAMESPACE::ExternalSemaphoreHandleTypeFlagBits handleType_ ) VULKAN_HPP_NOEXCEPT
    {
      handleType = handleType_;
      return *this;
    }

    ImportSemaphoreWin32HandleInfoKHR & setHandle( HANDLE handle_ ) VULKAN_HPP_NOEXCEPT
    {
      handle = handle_;
      return *this;
    }

    ImportSemaphoreWin32HandleInfoKHR & setName( LPCWSTR name_ ) VULKAN_HPP_NOEXCEPT
    {
      name = name_;
      return *this;
    }

    operator VkImportSemaphoreWin32HandleInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkImportSemaphoreWin32HandleInfoKHR *>( this );
    }

    operator VkImportSemaphoreWin32HandleInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkImportSemaphoreWin32HandleInfoKHR *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ImportSemaphoreWin32HandleInfoKHR const & ) const = default;
#  else
    bool operator==( ImportSemaphoreWin32HandleInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( semaphore == rhs.semaphore ) &&
             ( flags == rhs.flags ) && ( handleType == rhs.handleType ) && ( handle == rhs.handle ) &&
             ( name == rhs.name );
    }

    bool operator!=( ImportSemaphoreWin32HandleInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                       sType = StructureType::eImportSemaphoreWin32HandleInfoKHR;
    const void *                                              pNext = {};
    VULKAN_HPP_NAMESPACE::Semaphore                           semaphore = {};
    VULKAN_HPP_NAMESPACE::SemaphoreImportFlags                flags     = {};
    VULKAN_HPP_NAMESPACE::ExternalSemaphoreHandleTypeFlagBits handleType =
      VULKAN_HPP_NAMESPACE::ExternalSemaphoreHandleTypeFlagBits::eOpaqueFd;
    HANDLE  handle = {};
    LPCWSTR name   = {};
  };
  static_assert( sizeof( ImportSemaphoreWin32HandleInfoKHR ) == sizeof( VkImportSemaphoreWin32HandleInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ImportSemaphoreWin32HandleInfoKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eImportSemaphoreWin32HandleInfoKHR>
  {
    using Type = ImportSemaphoreWin32HandleInfoKHR;
  };
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

#if defined( VK_USE_PLATFORM_FUCHSIA )
  struct ImportSemaphoreZirconHandleInfoFUCHSIA
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eImportSemaphoreZirconHandleInfoFUCHSIA;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      ImportSemaphoreZirconHandleInfoFUCHSIA( VULKAN_HPP_NAMESPACE::Semaphore                           semaphore_ = {},
                                              VULKAN_HPP_NAMESPACE::SemaphoreImportFlags                flags_     = {},
                                              VULKAN_HPP_NAMESPACE::ExternalSemaphoreHandleTypeFlagBits handleType_ =
                                                VULKAN_HPP_NAMESPACE::ExternalSemaphoreHandleTypeFlagBits::eOpaqueFd,
                                              zx_handle_t zirconHandle_ = {} ) VULKAN_HPP_NOEXCEPT
      : semaphore( semaphore_ )
      , flags( flags_ )
      , handleType( handleType_ )
      , zirconHandle( zirconHandle_ )
    {}

    VULKAN_HPP_CONSTEXPR ImportSemaphoreZirconHandleInfoFUCHSIA( ImportSemaphoreZirconHandleInfoFUCHSIA const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    ImportSemaphoreZirconHandleInfoFUCHSIA( VkImportSemaphoreZirconHandleInfoFUCHSIA const & rhs ) VULKAN_HPP_NOEXCEPT
      : ImportSemaphoreZirconHandleInfoFUCHSIA(
          *reinterpret_cast<ImportSemaphoreZirconHandleInfoFUCHSIA const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ImportSemaphoreZirconHandleInfoFUCHSIA &
                            operator=( ImportSemaphoreZirconHandleInfoFUCHSIA const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ImportSemaphoreZirconHandleInfoFUCHSIA &
      operator=( VkImportSemaphoreZirconHandleInfoFUCHSIA const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ImportSemaphoreZirconHandleInfoFUCHSIA const *>( &rhs );
      return *this;
    }

    ImportSemaphoreZirconHandleInfoFUCHSIA & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ImportSemaphoreZirconHandleInfoFUCHSIA &
      setSemaphore( VULKAN_HPP_NAMESPACE::Semaphore semaphore_ ) VULKAN_HPP_NOEXCEPT
    {
      semaphore = semaphore_;
      return *this;
    }

    ImportSemaphoreZirconHandleInfoFUCHSIA &
      setFlags( VULKAN_HPP_NAMESPACE::SemaphoreImportFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    ImportSemaphoreZirconHandleInfoFUCHSIA &
      setHandleType( VULKAN_HPP_NAMESPACE::ExternalSemaphoreHandleTypeFlagBits handleType_ ) VULKAN_HPP_NOEXCEPT
    {
      handleType = handleType_;
      return *this;
    }

    ImportSemaphoreZirconHandleInfoFUCHSIA & setZirconHandle( zx_handle_t zirconHandle_ ) VULKAN_HPP_NOEXCEPT
    {
      zirconHandle = zirconHandle_;
      return *this;
    }

    operator VkImportSemaphoreZirconHandleInfoFUCHSIA const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkImportSemaphoreZirconHandleInfoFUCHSIA *>( this );
    }

    operator VkImportSemaphoreZirconHandleInfoFUCHSIA &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkImportSemaphoreZirconHandleInfoFUCHSIA *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ImportSemaphoreZirconHandleInfoFUCHSIA const & ) const = default;
#  else
    bool operator==( ImportSemaphoreZirconHandleInfoFUCHSIA const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( semaphore == rhs.semaphore ) &&
             ( flags == rhs.flags ) && ( handleType == rhs.handleType ) &&
             ( memcmp( &zirconHandle, &rhs.zirconHandle, sizeof( zx_handle_t ) ) == 0 );
    }

    bool operator!=( ImportSemaphoreZirconHandleInfoFUCHSIA const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType        sType     = StructureType::eImportSemaphoreZirconHandleInfoFUCHSIA;
    const void *                               pNext     = {};
    VULKAN_HPP_NAMESPACE::Semaphore            semaphore = {};
    VULKAN_HPP_NAMESPACE::SemaphoreImportFlags flags     = {};
    VULKAN_HPP_NAMESPACE::ExternalSemaphoreHandleTypeFlagBits handleType =
      VULKAN_HPP_NAMESPACE::ExternalSemaphoreHandleTypeFlagBits::eOpaqueFd;
    zx_handle_t zirconHandle = {};
  };
  static_assert( sizeof( ImportSemaphoreZirconHandleInfoFUCHSIA ) == sizeof( VkImportSemaphoreZirconHandleInfoFUCHSIA ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ImportSemaphoreZirconHandleInfoFUCHSIA>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eImportSemaphoreZirconHandleInfoFUCHSIA>
  {
    using Type = ImportSemaphoreZirconHandleInfoFUCHSIA;
  };
#endif /*VK_USE_PLATFORM_FUCHSIA*/

  struct IndirectCommandsLayoutTokenNV
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eIndirectCommandsLayoutTokenNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      IndirectCommandsLayoutTokenNV( VULKAN_HPP_NAMESPACE::IndirectCommandsTokenTypeNV tokenType_ =
                                       VULKAN_HPP_NAMESPACE::IndirectCommandsTokenTypeNV::eShaderGroup,
                                     uint32_t                                   stream_                       = {},
                                     uint32_t                                   offset_                       = {},
                                     uint32_t                                   vertexBindingUnit_            = {},
                                     VULKAN_HPP_NAMESPACE::Bool32               vertexDynamicStride_          = {},
                                     VULKAN_HPP_NAMESPACE::PipelineLayout       pushconstantPipelineLayout_   = {},
                                     VULKAN_HPP_NAMESPACE::ShaderStageFlags     pushconstantShaderStageFlags_ = {},
                                     uint32_t                                   pushconstantOffset_           = {},
                                     uint32_t                                   pushconstantSize_             = {},
                                     VULKAN_HPP_NAMESPACE::IndirectStateFlagsNV indirectStateFlags_           = {},
                                     uint32_t                                   indexTypeCount_               = {},
                                     const VULKAN_HPP_NAMESPACE::IndexType *    pIndexTypes_                  = {},
                                     const uint32_t * pIndexTypeValues_ = {} ) VULKAN_HPP_NOEXCEPT
      : tokenType( tokenType_ )
      , stream( stream_ )
      , offset( offset_ )
      , vertexBindingUnit( vertexBindingUnit_ )
      , vertexDynamicStride( vertexDynamicStride_ )
      , pushconstantPipelineLayout( pushconstantPipelineLayout_ )
      , pushconstantShaderStageFlags( pushconstantShaderStageFlags_ )
      , pushconstantOffset( pushconstantOffset_ )
      , pushconstantSize( pushconstantSize_ )
      , indirectStateFlags( indirectStateFlags_ )
      , indexTypeCount( indexTypeCount_ )
      , pIndexTypes( pIndexTypes_ )
      , pIndexTypeValues( pIndexTypeValues_ )
    {}

    VULKAN_HPP_CONSTEXPR
      IndirectCommandsLayoutTokenNV( IndirectCommandsLayoutTokenNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    IndirectCommandsLayoutTokenNV( VkIndirectCommandsLayoutTokenNV const & rhs ) VULKAN_HPP_NOEXCEPT
      : IndirectCommandsLayoutTokenNV( *reinterpret_cast<IndirectCommandsLayoutTokenNV const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    IndirectCommandsLayoutTokenNV(
      VULKAN_HPP_NAMESPACE::IndirectCommandsTokenTypeNV tokenType_,
      uint32_t                                          stream_,
      uint32_t                                          offset_,
      uint32_t                                          vertexBindingUnit_,
      VULKAN_HPP_NAMESPACE::Bool32                      vertexDynamicStride_,
      VULKAN_HPP_NAMESPACE::PipelineLayout              pushconstantPipelineLayout_,
      VULKAN_HPP_NAMESPACE::ShaderStageFlags            pushconstantShaderStageFlags_,
      uint32_t                                          pushconstantOffset_,
      uint32_t                                          pushconstantSize_,
      VULKAN_HPP_NAMESPACE::IndirectStateFlagsNV        indirectStateFlags_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::IndexType> const & indexTypes_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const & indexTypeValues_ = {} )
      : tokenType( tokenType_ )
      , stream( stream_ )
      , offset( offset_ )
      , vertexBindingUnit( vertexBindingUnit_ )
      , vertexDynamicStride( vertexDynamicStride_ )
      , pushconstantPipelineLayout( pushconstantPipelineLayout_ )
      , pushconstantShaderStageFlags( pushconstantShaderStageFlags_ )
      , pushconstantOffset( pushconstantOffset_ )
      , pushconstantSize( pushconstantSize_ )
      , indirectStateFlags( indirectStateFlags_ )
      , indexTypeCount( static_cast<uint32_t>( indexTypes_.size() ) )
      , pIndexTypes( indexTypes_.data() )
      , pIndexTypeValues( indexTypeValues_.data() )
    {
#    ifdef VULKAN_HPP_NO_EXCEPTIONS
      VULKAN_HPP_ASSERT( indexTypes_.size() == indexTypeValues_.size() );
#    else
      if ( indexTypes_.size() != indexTypeValues_.size() )
      {
        throw LogicError(
          VULKAN_HPP_NAMESPACE_STRING
          "::IndirectCommandsLayoutTokenNV::IndirectCommandsLayoutTokenNV: indexTypes_.size() != indexTypeValues_.size()" );
      }
#    endif /*VULKAN_HPP_NO_EXCEPTIONS*/
    }
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 IndirectCommandsLayoutTokenNV &
                            operator=( IndirectCommandsLayoutTokenNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    IndirectCommandsLayoutTokenNV & operator=( VkIndirectCommandsLayoutTokenNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::IndirectCommandsLayoutTokenNV const *>( &rhs );
      return *this;
    }

    IndirectCommandsLayoutTokenNV & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    IndirectCommandsLayoutTokenNV &
      setTokenType( VULKAN_HPP_NAMESPACE::IndirectCommandsTokenTypeNV tokenType_ ) VULKAN_HPP_NOEXCEPT
    {
      tokenType = tokenType_;
      return *this;
    }

    IndirectCommandsLayoutTokenNV & setStream( uint32_t stream_ ) VULKAN_HPP_NOEXCEPT
    {
      stream = stream_;
      return *this;
    }

    IndirectCommandsLayoutTokenNV & setOffset( uint32_t offset_ ) VULKAN_HPP_NOEXCEPT
    {
      offset = offset_;
      return *this;
    }

    IndirectCommandsLayoutTokenNV & setVertexBindingUnit( uint32_t vertexBindingUnit_ ) VULKAN_HPP_NOEXCEPT
    {
      vertexBindingUnit = vertexBindingUnit_;
      return *this;
    }

    IndirectCommandsLayoutTokenNV &
      setVertexDynamicStride( VULKAN_HPP_NAMESPACE::Bool32 vertexDynamicStride_ ) VULKAN_HPP_NOEXCEPT
    {
      vertexDynamicStride = vertexDynamicStride_;
      return *this;
    }

    IndirectCommandsLayoutTokenNV & setPushconstantPipelineLayout(
      VULKAN_HPP_NAMESPACE::PipelineLayout pushconstantPipelineLayout_ ) VULKAN_HPP_NOEXCEPT
    {
      pushconstantPipelineLayout = pushconstantPipelineLayout_;
      return *this;
    }

    IndirectCommandsLayoutTokenNV & setPushconstantShaderStageFlags(
      VULKAN_HPP_NAMESPACE::ShaderStageFlags pushconstantShaderStageFlags_ ) VULKAN_HPP_NOEXCEPT
    {
      pushconstantShaderStageFlags = pushconstantShaderStageFlags_;
      return *this;
    }

    IndirectCommandsLayoutTokenNV & setPushconstantOffset( uint32_t pushconstantOffset_ ) VULKAN_HPP_NOEXCEPT
    {
      pushconstantOffset = pushconstantOffset_;
      return *this;
    }

    IndirectCommandsLayoutTokenNV & setPushconstantSize( uint32_t pushconstantSize_ ) VULKAN_HPP_NOEXCEPT
    {
      pushconstantSize = pushconstantSize_;
      return *this;
    }

    IndirectCommandsLayoutTokenNV &
      setIndirectStateFlags( VULKAN_HPP_NAMESPACE::IndirectStateFlagsNV indirectStateFlags_ ) VULKAN_HPP_NOEXCEPT
    {
      indirectStateFlags = indirectStateFlags_;
      return *this;
    }

    IndirectCommandsLayoutTokenNV & setIndexTypeCount( uint32_t indexTypeCount_ ) VULKAN_HPP_NOEXCEPT
    {
      indexTypeCount = indexTypeCount_;
      return *this;
    }

    IndirectCommandsLayoutTokenNV &
      setPIndexTypes( const VULKAN_HPP_NAMESPACE::IndexType * pIndexTypes_ ) VULKAN_HPP_NOEXCEPT
    {
      pIndexTypes = pIndexTypes_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    IndirectCommandsLayoutTokenNV & setIndexTypes(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::IndexType> const & indexTypes_ )
      VULKAN_HPP_NOEXCEPT
    {
      indexTypeCount = static_cast<uint32_t>( indexTypes_.size() );
      pIndexTypes    = indexTypes_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    IndirectCommandsLayoutTokenNV & setPIndexTypeValues( const uint32_t * pIndexTypeValues_ ) VULKAN_HPP_NOEXCEPT
    {
      pIndexTypeValues = pIndexTypeValues_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    IndirectCommandsLayoutTokenNV & setIndexTypeValues(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const & indexTypeValues_ ) VULKAN_HPP_NOEXCEPT
    {
      indexTypeCount   = static_cast<uint32_t>( indexTypeValues_.size() );
      pIndexTypeValues = indexTypeValues_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkIndirectCommandsLayoutTokenNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkIndirectCommandsLayoutTokenNV *>( this );
    }

    operator VkIndirectCommandsLayoutTokenNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkIndirectCommandsLayoutTokenNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( IndirectCommandsLayoutTokenNV const & ) const = default;
#else
    bool operator==( IndirectCommandsLayoutTokenNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( tokenType == rhs.tokenType ) &&
             ( stream == rhs.stream ) && ( offset == rhs.offset ) && ( vertexBindingUnit == rhs.vertexBindingUnit ) &&
             ( vertexDynamicStride == rhs.vertexDynamicStride ) &&
             ( pushconstantPipelineLayout == rhs.pushconstantPipelineLayout ) &&
             ( pushconstantShaderStageFlags == rhs.pushconstantShaderStageFlags ) &&
             ( pushconstantOffset == rhs.pushconstantOffset ) && ( pushconstantSize == rhs.pushconstantSize ) &&
             ( indirectStateFlags == rhs.indirectStateFlags ) && ( indexTypeCount == rhs.indexTypeCount ) &&
             ( pIndexTypes == rhs.pIndexTypes ) && ( pIndexTypeValues == rhs.pIndexTypeValues );
    }

    bool operator!=( IndirectCommandsLayoutTokenNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType               sType = StructureType::eIndirectCommandsLayoutTokenNV;
    const void *                                      pNext = {};
    VULKAN_HPP_NAMESPACE::IndirectCommandsTokenTypeNV tokenType =
      VULKAN_HPP_NAMESPACE::IndirectCommandsTokenTypeNV::eShaderGroup;
    uint32_t                                   stream                       = {};
    uint32_t                                   offset                       = {};
    uint32_t                                   vertexBindingUnit            = {};
    VULKAN_HPP_NAMESPACE::Bool32               vertexDynamicStride          = {};
    VULKAN_HPP_NAMESPACE::PipelineLayout       pushconstantPipelineLayout   = {};
    VULKAN_HPP_NAMESPACE::ShaderStageFlags     pushconstantShaderStageFlags = {};
    uint32_t                                   pushconstantOffset           = {};
    uint32_t                                   pushconstantSize             = {};
    VULKAN_HPP_NAMESPACE::IndirectStateFlagsNV indirectStateFlags           = {};
    uint32_t                                   indexTypeCount               = {};
    const VULKAN_HPP_NAMESPACE::IndexType *    pIndexTypes                  = {};
    const uint32_t *                           pIndexTypeValues             = {};
  };
  static_assert( sizeof( IndirectCommandsLayoutTokenNV ) == sizeof( VkIndirectCommandsLayoutTokenNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<IndirectCommandsLayoutTokenNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eIndirectCommandsLayoutTokenNV>
  {
    using Type = IndirectCommandsLayoutTokenNV;
  };

  struct IndirectCommandsLayoutCreateInfoNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eIndirectCommandsLayoutCreateInfoNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR IndirectCommandsLayoutCreateInfoNV(
      VULKAN_HPP_NAMESPACE::IndirectCommandsLayoutUsageFlagsNV flags_ = {},
      VULKAN_HPP_NAMESPACE::PipelineBindPoint pipelineBindPoint_ = VULKAN_HPP_NAMESPACE::PipelineBindPoint::eGraphics,
      uint32_t                                tokenCount_        = {},
      const VULKAN_HPP_NAMESPACE::IndirectCommandsLayoutTokenNV * pTokens_        = {},
      uint32_t                                                    streamCount_    = {},
      const uint32_t *                                            pStreamStrides_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , pipelineBindPoint( pipelineBindPoint_ )
      , tokenCount( tokenCount_ )
      , pTokens( pTokens_ )
      , streamCount( streamCount_ )
      , pStreamStrides( pStreamStrides_ )
    {}

    VULKAN_HPP_CONSTEXPR IndirectCommandsLayoutCreateInfoNV( IndirectCommandsLayoutCreateInfoNV const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    IndirectCommandsLayoutCreateInfoNV( VkIndirectCommandsLayoutCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
      : IndirectCommandsLayoutCreateInfoNV( *reinterpret_cast<IndirectCommandsLayoutCreateInfoNV const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    IndirectCommandsLayoutCreateInfoNV(
      VULKAN_HPP_NAMESPACE::IndirectCommandsLayoutUsageFlagsNV flags_,
      VULKAN_HPP_NAMESPACE::PipelineBindPoint                  pipelineBindPoint_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::IndirectCommandsLayoutTokenNV> const &
                                                                            tokens_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const & streamStrides_ = {} )
      : flags( flags_ )
      , pipelineBindPoint( pipelineBindPoint_ )
      , tokenCount( static_cast<uint32_t>( tokens_.size() ) )
      , pTokens( tokens_.data() )
      , streamCount( static_cast<uint32_t>( streamStrides_.size() ) )
      , pStreamStrides( streamStrides_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 IndirectCommandsLayoutCreateInfoNV &
                            operator=( IndirectCommandsLayoutCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    IndirectCommandsLayoutCreateInfoNV &
      operator=( VkIndirectCommandsLayoutCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::IndirectCommandsLayoutCreateInfoNV const *>( &rhs );
      return *this;
    }

    IndirectCommandsLayoutCreateInfoNV & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    IndirectCommandsLayoutCreateInfoNV &
      setFlags( VULKAN_HPP_NAMESPACE::IndirectCommandsLayoutUsageFlagsNV flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    IndirectCommandsLayoutCreateInfoNV &
      setPipelineBindPoint( VULKAN_HPP_NAMESPACE::PipelineBindPoint pipelineBindPoint_ ) VULKAN_HPP_NOEXCEPT
    {
      pipelineBindPoint = pipelineBindPoint_;
      return *this;
    }

    IndirectCommandsLayoutCreateInfoNV & setTokenCount( uint32_t tokenCount_ ) VULKAN_HPP_NOEXCEPT
    {
      tokenCount = tokenCount_;
      return *this;
    }

    IndirectCommandsLayoutCreateInfoNV &
      setPTokens( const VULKAN_HPP_NAMESPACE::IndirectCommandsLayoutTokenNV * pTokens_ ) VULKAN_HPP_NOEXCEPT
    {
      pTokens = pTokens_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    IndirectCommandsLayoutCreateInfoNV & setTokens(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::IndirectCommandsLayoutTokenNV> const &
        tokens_ ) VULKAN_HPP_NOEXCEPT
    {
      tokenCount = static_cast<uint32_t>( tokens_.size() );
      pTokens    = tokens_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    IndirectCommandsLayoutCreateInfoNV & setStreamCount( uint32_t streamCount_ ) VULKAN_HPP_NOEXCEPT
    {
      streamCount = streamCount_;
      return *this;
    }

    IndirectCommandsLayoutCreateInfoNV & setPStreamStrides( const uint32_t * pStreamStrides_ ) VULKAN_HPP_NOEXCEPT
    {
      pStreamStrides = pStreamStrides_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    IndirectCommandsLayoutCreateInfoNV & setStreamStrides(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const & streamStrides_ ) VULKAN_HPP_NOEXCEPT
    {
      streamCount    = static_cast<uint32_t>( streamStrides_.size() );
      pStreamStrides = streamStrides_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkIndirectCommandsLayoutCreateInfoNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkIndirectCommandsLayoutCreateInfoNV *>( this );
    }

    operator VkIndirectCommandsLayoutCreateInfoNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkIndirectCommandsLayoutCreateInfoNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( IndirectCommandsLayoutCreateInfoNV const & ) const = default;
#else
    bool operator==( IndirectCommandsLayoutCreateInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( pipelineBindPoint == rhs.pipelineBindPoint ) && ( tokenCount == rhs.tokenCount ) &&
             ( pTokens == rhs.pTokens ) && ( streamCount == rhs.streamCount ) &&
             ( pStreamStrides == rhs.pStreamStrides );
    }

    bool operator!=( IndirectCommandsLayoutCreateInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                      sType = StructureType::eIndirectCommandsLayoutCreateInfoNV;
    const void *                                             pNext = {};
    VULKAN_HPP_NAMESPACE::IndirectCommandsLayoutUsageFlagsNV flags = {};
    VULKAN_HPP_NAMESPACE::PipelineBindPoint pipelineBindPoint      = VULKAN_HPP_NAMESPACE::PipelineBindPoint::eGraphics;
    uint32_t                                tokenCount             = {};
    const VULKAN_HPP_NAMESPACE::IndirectCommandsLayoutTokenNV * pTokens        = {};
    uint32_t                                                    streamCount    = {};
    const uint32_t *                                            pStreamStrides = {};
  };
  static_assert( sizeof( IndirectCommandsLayoutCreateInfoNV ) == sizeof( VkIndirectCommandsLayoutCreateInfoNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<IndirectCommandsLayoutCreateInfoNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eIndirectCommandsLayoutCreateInfoNV>
  {
    using Type = IndirectCommandsLayoutCreateInfoNV;
  };

  struct InitializePerformanceApiInfoINTEL
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eInitializePerformanceApiInfoINTEL;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR InitializePerformanceApiInfoINTEL( void * pUserData_ = {} ) VULKAN_HPP_NOEXCEPT
      : pUserData( pUserData_ )
    {}

    VULKAN_HPP_CONSTEXPR
      InitializePerformanceApiInfoINTEL( InitializePerformanceApiInfoINTEL const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    InitializePerformanceApiInfoINTEL( VkInitializePerformanceApiInfoINTEL const & rhs ) VULKAN_HPP_NOEXCEPT
      : InitializePerformanceApiInfoINTEL( *reinterpret_cast<InitializePerformanceApiInfoINTEL const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 InitializePerformanceApiInfoINTEL &
                            operator=( InitializePerformanceApiInfoINTEL const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    InitializePerformanceApiInfoINTEL & operator=( VkInitializePerformanceApiInfoINTEL const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::InitializePerformanceApiInfoINTEL const *>( &rhs );
      return *this;
    }

    InitializePerformanceApiInfoINTEL & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    InitializePerformanceApiInfoINTEL & setPUserData( void * pUserData_ ) VULKAN_HPP_NOEXCEPT
    {
      pUserData = pUserData_;
      return *this;
    }

    operator VkInitializePerformanceApiInfoINTEL const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkInitializePerformanceApiInfoINTEL *>( this );
    }

    operator VkInitializePerformanceApiInfoINTEL &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkInitializePerformanceApiInfoINTEL *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( InitializePerformanceApiInfoINTEL const & ) const = default;
#else
    bool operator==( InitializePerformanceApiInfoINTEL const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( pUserData == rhs.pUserData );
    }

    bool operator!=( InitializePerformanceApiInfoINTEL const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType     = StructureType::eInitializePerformanceApiInfoINTEL;
    const void *                        pNext     = {};
    void *                              pUserData = {};
  };
  static_assert( sizeof( InitializePerformanceApiInfoINTEL ) == sizeof( VkInitializePerformanceApiInfoINTEL ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<InitializePerformanceApiInfoINTEL>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eInitializePerformanceApiInfoINTEL>
  {
    using Type = InitializePerformanceApiInfoINTEL;
  };

  struct InputAttachmentAspectReference
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      InputAttachmentAspectReference( uint32_t                               subpass_              = {},
                                      uint32_t                               inputAttachmentIndex_ = {},
                                      VULKAN_HPP_NAMESPACE::ImageAspectFlags aspectMask_ = {} ) VULKAN_HPP_NOEXCEPT
      : subpass( subpass_ )
      , inputAttachmentIndex( inputAttachmentIndex_ )
      , aspectMask( aspectMask_ )
    {}

    VULKAN_HPP_CONSTEXPR
      InputAttachmentAspectReference( InputAttachmentAspectReference const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    InputAttachmentAspectReference( VkInputAttachmentAspectReference const & rhs ) VULKAN_HPP_NOEXCEPT
      : InputAttachmentAspectReference( *reinterpret_cast<InputAttachmentAspectReference const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 InputAttachmentAspectReference &
                            operator=( InputAttachmentAspectReference const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    InputAttachmentAspectReference & operator=( VkInputAttachmentAspectReference const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::InputAttachmentAspectReference const *>( &rhs );
      return *this;
    }

    InputAttachmentAspectReference & setSubpass( uint32_t subpass_ ) VULKAN_HPP_NOEXCEPT
    {
      subpass = subpass_;
      return *this;
    }

    InputAttachmentAspectReference & setInputAttachmentIndex( uint32_t inputAttachmentIndex_ ) VULKAN_HPP_NOEXCEPT
    {
      inputAttachmentIndex = inputAttachmentIndex_;
      return *this;
    }

    InputAttachmentAspectReference &
      setAspectMask( VULKAN_HPP_NAMESPACE::ImageAspectFlags aspectMask_ ) VULKAN_HPP_NOEXCEPT
    {
      aspectMask = aspectMask_;
      return *this;
    }

    operator VkInputAttachmentAspectReference const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkInputAttachmentAspectReference *>( this );
    }

    operator VkInputAttachmentAspectReference &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkInputAttachmentAspectReference *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( InputAttachmentAspectReference const & ) const = default;
#else
    bool operator==( InputAttachmentAspectReference const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( subpass == rhs.subpass ) && ( inputAttachmentIndex == rhs.inputAttachmentIndex ) &&
             ( aspectMask == rhs.aspectMask );
    }

    bool operator!=( InputAttachmentAspectReference const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    uint32_t                               subpass              = {};
    uint32_t                               inputAttachmentIndex = {};
    VULKAN_HPP_NAMESPACE::ImageAspectFlags aspectMask           = {};
  };
  static_assert( sizeof( InputAttachmentAspectReference ) == sizeof( VkInputAttachmentAspectReference ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<InputAttachmentAspectReference>::value,
                 "struct wrapper is not a standard layout!" );
  using InputAttachmentAspectReferenceKHR = InputAttachmentAspectReference;

  struct InstanceCreateInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eInstanceCreateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR InstanceCreateInfo( VULKAN_HPP_NAMESPACE::InstanceCreateFlags     flags_                 = {},
                                             const VULKAN_HPP_NAMESPACE::ApplicationInfo * pApplicationInfo_      = {},
                                             uint32_t                                      enabledLayerCount_     = {},
                                             const char * const *                          ppEnabledLayerNames_   = {},
                                             uint32_t                                      enabledExtensionCount_ = {},
                                             const char * const * ppEnabledExtensionNames_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , pApplicationInfo( pApplicationInfo_ )
      , enabledLayerCount( enabledLayerCount_ )
      , ppEnabledLayerNames( ppEnabledLayerNames_ )
      , enabledExtensionCount( enabledExtensionCount_ )
      , ppEnabledExtensionNames( ppEnabledExtensionNames_ )
    {}

    VULKAN_HPP_CONSTEXPR InstanceCreateInfo( InstanceCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    InstanceCreateInfo( VkInstanceCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : InstanceCreateInfo( *reinterpret_cast<InstanceCreateInfo const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    InstanceCreateInfo(
      VULKAN_HPP_NAMESPACE::InstanceCreateFlags                                 flags_,
      const VULKAN_HPP_NAMESPACE::ApplicationInfo *                             pApplicationInfo_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const char * const> const & pEnabledLayerNames_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const char * const> const & pEnabledExtensionNames_ = {} )
      : flags( flags_ )
      , pApplicationInfo( pApplicationInfo_ )
      , enabledLayerCount( static_cast<uint32_t>( pEnabledLayerNames_.size() ) )
      , ppEnabledLayerNames( pEnabledLayerNames_.data() )
      , enabledExtensionCount( static_cast<uint32_t>( pEnabledExtensionNames_.size() ) )
      , ppEnabledExtensionNames( pEnabledExtensionNames_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 InstanceCreateInfo &
                            operator=( InstanceCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    InstanceCreateInfo & operator=( VkInstanceCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::InstanceCreateInfo const *>( &rhs );
      return *this;
    }

    InstanceCreateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    InstanceCreateInfo & setFlags( VULKAN_HPP_NAMESPACE::InstanceCreateFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    InstanceCreateInfo &
      setPApplicationInfo( const VULKAN_HPP_NAMESPACE::ApplicationInfo * pApplicationInfo_ ) VULKAN_HPP_NOEXCEPT
    {
      pApplicationInfo = pApplicationInfo_;
      return *this;
    }

    InstanceCreateInfo & setEnabledLayerCount( uint32_t enabledLayerCount_ ) VULKAN_HPP_NOEXCEPT
    {
      enabledLayerCount = enabledLayerCount_;
      return *this;
    }

    InstanceCreateInfo & setPpEnabledLayerNames( const char * const * ppEnabledLayerNames_ ) VULKAN_HPP_NOEXCEPT
    {
      ppEnabledLayerNames = ppEnabledLayerNames_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    InstanceCreateInfo & setPEnabledLayerNames(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const char * const> const & pEnabledLayerNames_ )
      VULKAN_HPP_NOEXCEPT
    {
      enabledLayerCount   = static_cast<uint32_t>( pEnabledLayerNames_.size() );
      ppEnabledLayerNames = pEnabledLayerNames_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    InstanceCreateInfo & setEnabledExtensionCount( uint32_t enabledExtensionCount_ ) VULKAN_HPP_NOEXCEPT
    {
      enabledExtensionCount = enabledExtensionCount_;
      return *this;
    }

    InstanceCreateInfo & setPpEnabledExtensionNames( const char * const * ppEnabledExtensionNames_ ) VULKAN_HPP_NOEXCEPT
    {
      ppEnabledExtensionNames = ppEnabledExtensionNames_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    InstanceCreateInfo & setPEnabledExtensionNames(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const char * const> const & pEnabledExtensionNames_ )
      VULKAN_HPP_NOEXCEPT
    {
      enabledExtensionCount   = static_cast<uint32_t>( pEnabledExtensionNames_.size() );
      ppEnabledExtensionNames = pEnabledExtensionNames_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkInstanceCreateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkInstanceCreateInfo *>( this );
    }

    operator VkInstanceCreateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkInstanceCreateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( InstanceCreateInfo const & ) const = default;
#else
    bool operator==( InstanceCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( pApplicationInfo == rhs.pApplicationInfo ) && ( enabledLayerCount == rhs.enabledLayerCount ) &&
             ( ppEnabledLayerNames == rhs.ppEnabledLayerNames ) &&
             ( enabledExtensionCount == rhs.enabledExtensionCount ) &&
             ( ppEnabledExtensionNames == rhs.ppEnabledExtensionNames );
    }

    bool operator!=( InstanceCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType           sType                   = StructureType::eInstanceCreateInfo;
    const void *                                  pNext                   = {};
    VULKAN_HPP_NAMESPACE::InstanceCreateFlags     flags                   = {};
    const VULKAN_HPP_NAMESPACE::ApplicationInfo * pApplicationInfo        = {};
    uint32_t                                      enabledLayerCount       = {};
    const char * const *                          ppEnabledLayerNames     = {};
    uint32_t                                      enabledExtensionCount   = {};
    const char * const *                          ppEnabledExtensionNames = {};
  };
  static_assert( sizeof( InstanceCreateInfo ) == sizeof( VkInstanceCreateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<InstanceCreateInfo>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eInstanceCreateInfo>
  {
    using Type = InstanceCreateInfo;
  };

  struct LayerProperties
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR_14
      LayerProperties( std::array<char, VK_MAX_EXTENSION_NAME_SIZE> const & layerName_             = {},
                       uint32_t                                             specVersion_           = {},
                       uint32_t                                             implementationVersion_ = {},
                       std::array<char, VK_MAX_DESCRIPTION_SIZE> const &    description_ = {} ) VULKAN_HPP_NOEXCEPT
      : layerName( layerName_ )
      , specVersion( specVersion_ )
      , implementationVersion( implementationVersion_ )
      , description( description_ )
    {}

    VULKAN_HPP_CONSTEXPR_14 LayerProperties( LayerProperties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    LayerProperties( VkLayerProperties const & rhs ) VULKAN_HPP_NOEXCEPT
      : LayerProperties( *reinterpret_cast<LayerProperties const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 LayerProperties & operator=( LayerProperties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    LayerProperties & operator=( VkLayerProperties const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::LayerProperties const *>( &rhs );
      return *this;
    }

    operator VkLayerProperties const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkLayerProperties *>( this );
    }

    operator VkLayerProperties &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkLayerProperties *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( LayerProperties const & ) const = default;
#else
    bool operator==( LayerProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( layerName == rhs.layerName ) && ( specVersion == rhs.specVersion ) &&
             ( implementationVersion == rhs.implementationVersion ) && ( description == rhs.description );
    }

    bool operator!=( LayerProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<char, VK_MAX_EXTENSION_NAME_SIZE> layerName             = {};
    uint32_t                                                               specVersion           = {};
    uint32_t                                                               implementationVersion = {};
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<char, VK_MAX_DESCRIPTION_SIZE>    description           = {};
  };
  static_assert( sizeof( LayerProperties ) == sizeof( VkLayerProperties ), "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<LayerProperties>::value, "struct wrapper is not a standard layout!" );

#if defined( VK_USE_PLATFORM_MACOS_MVK )
  struct MacOSSurfaceCreateInfoMVK
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eMacosSurfaceCreateInfoMVK;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR MacOSSurfaceCreateInfoMVK( VULKAN_HPP_NAMESPACE::MacOSSurfaceCreateFlagsMVK flags_ = {},
                                                    const void * pView_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , pView( pView_ )
    {}

    VULKAN_HPP_CONSTEXPR
      MacOSSurfaceCreateInfoMVK( MacOSSurfaceCreateInfoMVK const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MacOSSurfaceCreateInfoMVK( VkMacOSSurfaceCreateInfoMVK const & rhs ) VULKAN_HPP_NOEXCEPT
      : MacOSSurfaceCreateInfoMVK( *reinterpret_cast<MacOSSurfaceCreateInfoMVK const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 MacOSSurfaceCreateInfoMVK &
                            operator=( MacOSSurfaceCreateInfoMVK const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MacOSSurfaceCreateInfoMVK & operator=( VkMacOSSurfaceCreateInfoMVK const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::MacOSSurfaceCreateInfoMVK const *>( &rhs );
      return *this;
    }

    MacOSSurfaceCreateInfoMVK & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    MacOSSurfaceCreateInfoMVK & setFlags( VULKAN_HPP_NAMESPACE::MacOSSurfaceCreateFlagsMVK flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    MacOSSurfaceCreateInfoMVK & setPView( const void * pView_ ) VULKAN_HPP_NOEXCEPT
    {
      pView = pView_;
      return *this;
    }

    operator VkMacOSSurfaceCreateInfoMVK const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkMacOSSurfaceCreateInfoMVK *>( this );
    }

    operator VkMacOSSurfaceCreateInfoMVK &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkMacOSSurfaceCreateInfoMVK *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( MacOSSurfaceCreateInfoMVK const & ) const = default;
#  else
    bool operator==( MacOSSurfaceCreateInfoMVK const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) && ( pView == rhs.pView );
    }

    bool operator!=( MacOSSurfaceCreateInfoMVK const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType              sType = StructureType::eMacosSurfaceCreateInfoMVK;
    const void *                                     pNext = {};
    VULKAN_HPP_NAMESPACE::MacOSSurfaceCreateFlagsMVK flags = {};
    const void *                                     pView = {};
  };
  static_assert( sizeof( MacOSSurfaceCreateInfoMVK ) == sizeof( VkMacOSSurfaceCreateInfoMVK ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<MacOSSurfaceCreateInfoMVK>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eMacosSurfaceCreateInfoMVK>
  {
    using Type = MacOSSurfaceCreateInfoMVK;
  };
#endif /*VK_USE_PLATFORM_MACOS_MVK*/

  struct MappedMemoryRange
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eMappedMemoryRange;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR MappedMemoryRange( VULKAN_HPP_NAMESPACE::DeviceMemory memory_ = {},
                                            VULKAN_HPP_NAMESPACE::DeviceSize   offset_ = {},
                                            VULKAN_HPP_NAMESPACE::DeviceSize   size_   = {} ) VULKAN_HPP_NOEXCEPT
      : memory( memory_ )
      , offset( offset_ )
      , size( size_ )
    {}

    VULKAN_HPP_CONSTEXPR MappedMemoryRange( MappedMemoryRange const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MappedMemoryRange( VkMappedMemoryRange const & rhs ) VULKAN_HPP_NOEXCEPT
      : MappedMemoryRange( *reinterpret_cast<MappedMemoryRange const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 MappedMemoryRange &
                            operator=( MappedMemoryRange const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MappedMemoryRange & operator=( VkMappedMemoryRange const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::MappedMemoryRange const *>( &rhs );
      return *this;
    }

    MappedMemoryRange & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    MappedMemoryRange & setMemory( VULKAN_HPP_NAMESPACE::DeviceMemory memory_ ) VULKAN_HPP_NOEXCEPT
    {
      memory = memory_;
      return *this;
    }

    MappedMemoryRange & setOffset( VULKAN_HPP_NAMESPACE::DeviceSize offset_ ) VULKAN_HPP_NOEXCEPT
    {
      offset = offset_;
      return *this;
    }

    MappedMemoryRange & setSize( VULKAN_HPP_NAMESPACE::DeviceSize size_ ) VULKAN_HPP_NOEXCEPT
    {
      size = size_;
      return *this;
    }

    operator VkMappedMemoryRange const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkMappedMemoryRange *>( this );
    }

    operator VkMappedMemoryRange &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkMappedMemoryRange *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( MappedMemoryRange const & ) const = default;
#else
    bool operator==( MappedMemoryRange const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( memory == rhs.memory ) && ( offset == rhs.offset ) &&
             ( size == rhs.size );
    }

    bool operator!=( MappedMemoryRange const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType  = StructureType::eMappedMemoryRange;
    const void *                        pNext  = {};
    VULKAN_HPP_NAMESPACE::DeviceMemory  memory = {};
    VULKAN_HPP_NAMESPACE::DeviceSize    offset = {};
    VULKAN_HPP_NAMESPACE::DeviceSize    size   = {};
  };
  static_assert( sizeof( MappedMemoryRange ) == sizeof( VkMappedMemoryRange ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<MappedMemoryRange>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eMappedMemoryRange>
  {
    using Type = MappedMemoryRange;
  };

  struct MemoryAllocateFlagsInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eMemoryAllocateFlagsInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR MemoryAllocateFlagsInfo( VULKAN_HPP_NAMESPACE::MemoryAllocateFlags flags_ = {},
                                                  uint32_t deviceMask_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , deviceMask( deviceMask_ )
    {}

    VULKAN_HPP_CONSTEXPR MemoryAllocateFlagsInfo( MemoryAllocateFlagsInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MemoryAllocateFlagsInfo( VkMemoryAllocateFlagsInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : MemoryAllocateFlagsInfo( *reinterpret_cast<MemoryAllocateFlagsInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 MemoryAllocateFlagsInfo &
                            operator=( MemoryAllocateFlagsInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MemoryAllocateFlagsInfo & operator=( VkMemoryAllocateFlagsInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::MemoryAllocateFlagsInfo const *>( &rhs );
      return *this;
    }

    MemoryAllocateFlagsInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    MemoryAllocateFlagsInfo & setFlags( VULKAN_HPP_NAMESPACE::MemoryAllocateFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    MemoryAllocateFlagsInfo & setDeviceMask( uint32_t deviceMask_ ) VULKAN_HPP_NOEXCEPT
    {
      deviceMask = deviceMask_;
      return *this;
    }

    operator VkMemoryAllocateFlagsInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkMemoryAllocateFlagsInfo *>( this );
    }

    operator VkMemoryAllocateFlagsInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkMemoryAllocateFlagsInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( MemoryAllocateFlagsInfo const & ) const = default;
#else
    bool operator==( MemoryAllocateFlagsInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( deviceMask == rhs.deviceMask );
    }

    bool operator!=( MemoryAllocateFlagsInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType       sType      = StructureType::eMemoryAllocateFlagsInfo;
    const void *                              pNext      = {};
    VULKAN_HPP_NAMESPACE::MemoryAllocateFlags flags      = {};
    uint32_t                                  deviceMask = {};
  };
  static_assert( sizeof( MemoryAllocateFlagsInfo ) == sizeof( VkMemoryAllocateFlagsInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<MemoryAllocateFlagsInfo>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eMemoryAllocateFlagsInfo>
  {
    using Type = MemoryAllocateFlagsInfo;
  };
  using MemoryAllocateFlagsInfoKHR = MemoryAllocateFlagsInfo;

  struct MemoryAllocateInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eMemoryAllocateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR MemoryAllocateInfo( VULKAN_HPP_NAMESPACE::DeviceSize allocationSize_ = {},
                                             uint32_t memoryTypeIndex_                        = {} ) VULKAN_HPP_NOEXCEPT
      : allocationSize( allocationSize_ )
      , memoryTypeIndex( memoryTypeIndex_ )
    {}

    VULKAN_HPP_CONSTEXPR MemoryAllocateInfo( MemoryAllocateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MemoryAllocateInfo( VkMemoryAllocateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : MemoryAllocateInfo( *reinterpret_cast<MemoryAllocateInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 MemoryAllocateInfo &
                            operator=( MemoryAllocateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MemoryAllocateInfo & operator=( VkMemoryAllocateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::MemoryAllocateInfo const *>( &rhs );
      return *this;
    }

    MemoryAllocateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    MemoryAllocateInfo & setAllocationSize( VULKAN_HPP_NAMESPACE::DeviceSize allocationSize_ ) VULKAN_HPP_NOEXCEPT
    {
      allocationSize = allocationSize_;
      return *this;
    }

    MemoryAllocateInfo & setMemoryTypeIndex( uint32_t memoryTypeIndex_ ) VULKAN_HPP_NOEXCEPT
    {
      memoryTypeIndex = memoryTypeIndex_;
      return *this;
    }

    operator VkMemoryAllocateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkMemoryAllocateInfo *>( this );
    }

    operator VkMemoryAllocateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkMemoryAllocateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( MemoryAllocateInfo const & ) const = default;
#else
    bool operator==( MemoryAllocateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( allocationSize == rhs.allocationSize ) &&
             ( memoryTypeIndex == rhs.memoryTypeIndex );
    }

    bool operator!=( MemoryAllocateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType           = StructureType::eMemoryAllocateInfo;
    const void *                        pNext           = {};
    VULKAN_HPP_NAMESPACE::DeviceSize    allocationSize  = {};
    uint32_t                            memoryTypeIndex = {};
  };
  static_assert( sizeof( MemoryAllocateInfo ) == sizeof( VkMemoryAllocateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<MemoryAllocateInfo>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eMemoryAllocateInfo>
  {
    using Type = MemoryAllocateInfo;
  };

  struct MemoryBarrier
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eMemoryBarrier;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR MemoryBarrier( VULKAN_HPP_NAMESPACE::AccessFlags srcAccessMask_ = {},
                                        VULKAN_HPP_NAMESPACE::AccessFlags dstAccessMask_ = {} ) VULKAN_HPP_NOEXCEPT
      : srcAccessMask( srcAccessMask_ )
      , dstAccessMask( dstAccessMask_ )
    {}

    VULKAN_HPP_CONSTEXPR MemoryBarrier( MemoryBarrier const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MemoryBarrier( VkMemoryBarrier const & rhs ) VULKAN_HPP_NOEXCEPT
      : MemoryBarrier( *reinterpret_cast<MemoryBarrier const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 MemoryBarrier & operator=( MemoryBarrier const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MemoryBarrier & operator=( VkMemoryBarrier const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::MemoryBarrier const *>( &rhs );
      return *this;
    }

    MemoryBarrier & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    MemoryBarrier & setSrcAccessMask( VULKAN_HPP_NAMESPACE::AccessFlags srcAccessMask_ ) VULKAN_HPP_NOEXCEPT
    {
      srcAccessMask = srcAccessMask_;
      return *this;
    }

    MemoryBarrier & setDstAccessMask( VULKAN_HPP_NAMESPACE::AccessFlags dstAccessMask_ ) VULKAN_HPP_NOEXCEPT
    {
      dstAccessMask = dstAccessMask_;
      return *this;
    }

    operator VkMemoryBarrier const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkMemoryBarrier *>( this );
    }

    operator VkMemoryBarrier &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkMemoryBarrier *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( MemoryBarrier const & ) const = default;
#else
    bool operator==( MemoryBarrier const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( srcAccessMask == rhs.srcAccessMask ) &&
             ( dstAccessMask == rhs.dstAccessMask );
    }

    bool operator!=( MemoryBarrier const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType         = StructureType::eMemoryBarrier;
    const void *                        pNext         = {};
    VULKAN_HPP_NAMESPACE::AccessFlags   srcAccessMask = {};
    VULKAN_HPP_NAMESPACE::AccessFlags   dstAccessMask = {};
  };
  static_assert( sizeof( MemoryBarrier ) == sizeof( VkMemoryBarrier ), "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<MemoryBarrier>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eMemoryBarrier>
  {
    using Type = MemoryBarrier;
  };

  struct MemoryDedicatedAllocateInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eMemoryDedicatedAllocateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR MemoryDedicatedAllocateInfo( VULKAN_HPP_NAMESPACE::Image  image_  = {},
                                                      VULKAN_HPP_NAMESPACE::Buffer buffer_ = {} ) VULKAN_HPP_NOEXCEPT
      : image( image_ )
      , buffer( buffer_ )
    {}

    VULKAN_HPP_CONSTEXPR
      MemoryDedicatedAllocateInfo( MemoryDedicatedAllocateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MemoryDedicatedAllocateInfo( VkMemoryDedicatedAllocateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : MemoryDedicatedAllocateInfo( *reinterpret_cast<MemoryDedicatedAllocateInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 MemoryDedicatedAllocateInfo &
                            operator=( MemoryDedicatedAllocateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MemoryDedicatedAllocateInfo & operator=( VkMemoryDedicatedAllocateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::MemoryDedicatedAllocateInfo const *>( &rhs );
      return *this;
    }

    MemoryDedicatedAllocateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    MemoryDedicatedAllocateInfo & setImage( VULKAN_HPP_NAMESPACE::Image image_ ) VULKAN_HPP_NOEXCEPT
    {
      image = image_;
      return *this;
    }

    MemoryDedicatedAllocateInfo & setBuffer( VULKAN_HPP_NAMESPACE::Buffer buffer_ ) VULKAN_HPP_NOEXCEPT
    {
      buffer = buffer_;
      return *this;
    }

    operator VkMemoryDedicatedAllocateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkMemoryDedicatedAllocateInfo *>( this );
    }

    operator VkMemoryDedicatedAllocateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkMemoryDedicatedAllocateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( MemoryDedicatedAllocateInfo const & ) const = default;
#else
    bool operator==( MemoryDedicatedAllocateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( image == rhs.image ) && ( buffer == rhs.buffer );
    }

    bool operator!=( MemoryDedicatedAllocateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType  = StructureType::eMemoryDedicatedAllocateInfo;
    const void *                        pNext  = {};
    VULKAN_HPP_NAMESPACE::Image         image  = {};
    VULKAN_HPP_NAMESPACE::Buffer        buffer = {};
  };
  static_assert( sizeof( MemoryDedicatedAllocateInfo ) == sizeof( VkMemoryDedicatedAllocateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<MemoryDedicatedAllocateInfo>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eMemoryDedicatedAllocateInfo>
  {
    using Type = MemoryDedicatedAllocateInfo;
  };
  using MemoryDedicatedAllocateInfoKHR = MemoryDedicatedAllocateInfo;

  struct MemoryDedicatedRequirements
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eMemoryDedicatedRequirements;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      MemoryDedicatedRequirements( VULKAN_HPP_NAMESPACE::Bool32 prefersDedicatedAllocation_  = {},
                                   VULKAN_HPP_NAMESPACE::Bool32 requiresDedicatedAllocation_ = {} ) VULKAN_HPP_NOEXCEPT
      : prefersDedicatedAllocation( prefersDedicatedAllocation_ )
      , requiresDedicatedAllocation( requiresDedicatedAllocation_ )
    {}

    VULKAN_HPP_CONSTEXPR
      MemoryDedicatedRequirements( MemoryDedicatedRequirements const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MemoryDedicatedRequirements( VkMemoryDedicatedRequirements const & rhs ) VULKAN_HPP_NOEXCEPT
      : MemoryDedicatedRequirements( *reinterpret_cast<MemoryDedicatedRequirements const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 MemoryDedicatedRequirements &
                            operator=( MemoryDedicatedRequirements const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MemoryDedicatedRequirements & operator=( VkMemoryDedicatedRequirements const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::MemoryDedicatedRequirements const *>( &rhs );
      return *this;
    }

    operator VkMemoryDedicatedRequirements const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkMemoryDedicatedRequirements *>( this );
    }

    operator VkMemoryDedicatedRequirements &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkMemoryDedicatedRequirements *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( MemoryDedicatedRequirements const & ) const = default;
#else
    bool operator==( MemoryDedicatedRequirements const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( prefersDedicatedAllocation == rhs.prefersDedicatedAllocation ) &&
             ( requiresDedicatedAllocation == rhs.requiresDedicatedAllocation );
    }

    bool operator!=( MemoryDedicatedRequirements const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType                       = StructureType::eMemoryDedicatedRequirements;
    void *                              pNext                       = {};
    VULKAN_HPP_NAMESPACE::Bool32        prefersDedicatedAllocation  = {};
    VULKAN_HPP_NAMESPACE::Bool32        requiresDedicatedAllocation = {};
  };
  static_assert( sizeof( MemoryDedicatedRequirements ) == sizeof( VkMemoryDedicatedRequirements ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<MemoryDedicatedRequirements>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eMemoryDedicatedRequirements>
  {
    using Type = MemoryDedicatedRequirements;
  };
  using MemoryDedicatedRequirementsKHR = MemoryDedicatedRequirements;

  struct MemoryFdPropertiesKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eMemoryFdPropertiesKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR MemoryFdPropertiesKHR( uint32_t memoryTypeBits_ = {} ) VULKAN_HPP_NOEXCEPT
      : memoryTypeBits( memoryTypeBits_ )
    {}

    VULKAN_HPP_CONSTEXPR MemoryFdPropertiesKHR( MemoryFdPropertiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MemoryFdPropertiesKHR( VkMemoryFdPropertiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : MemoryFdPropertiesKHR( *reinterpret_cast<MemoryFdPropertiesKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 MemoryFdPropertiesKHR &
                            operator=( MemoryFdPropertiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MemoryFdPropertiesKHR & operator=( VkMemoryFdPropertiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::MemoryFdPropertiesKHR const *>( &rhs );
      return *this;
    }

    operator VkMemoryFdPropertiesKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkMemoryFdPropertiesKHR *>( this );
    }

    operator VkMemoryFdPropertiesKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkMemoryFdPropertiesKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( MemoryFdPropertiesKHR const & ) const = default;
#else
    bool operator==( MemoryFdPropertiesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( memoryTypeBits == rhs.memoryTypeBits );
    }

    bool operator!=( MemoryFdPropertiesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType          = StructureType::eMemoryFdPropertiesKHR;
    void *                              pNext          = {};
    uint32_t                            memoryTypeBits = {};
  };
  static_assert( sizeof( MemoryFdPropertiesKHR ) == sizeof( VkMemoryFdPropertiesKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<MemoryFdPropertiesKHR>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eMemoryFdPropertiesKHR>
  {
    using Type = MemoryFdPropertiesKHR;
  };

#if defined( VK_USE_PLATFORM_ANDROID_KHR )
  struct MemoryGetAndroidHardwareBufferInfoANDROID
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eMemoryGetAndroidHardwareBufferInfoANDROID;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      MemoryGetAndroidHardwareBufferInfoANDROID( VULKAN_HPP_NAMESPACE::DeviceMemory memory_ = {} ) VULKAN_HPP_NOEXCEPT
      : memory( memory_ )
    {}

    VULKAN_HPP_CONSTEXPR MemoryGetAndroidHardwareBufferInfoANDROID(
      MemoryGetAndroidHardwareBufferInfoANDROID const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MemoryGetAndroidHardwareBufferInfoANDROID( VkMemoryGetAndroidHardwareBufferInfoANDROID const & rhs )
      VULKAN_HPP_NOEXCEPT
      : MemoryGetAndroidHardwareBufferInfoANDROID(
          *reinterpret_cast<MemoryGetAndroidHardwareBufferInfoANDROID const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 MemoryGetAndroidHardwareBufferInfoANDROID &
                            operator=( MemoryGetAndroidHardwareBufferInfoANDROID const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MemoryGetAndroidHardwareBufferInfoANDROID &
      operator=( VkMemoryGetAndroidHardwareBufferInfoANDROID const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::MemoryGetAndroidHardwareBufferInfoANDROID const *>( &rhs );
      return *this;
    }

    MemoryGetAndroidHardwareBufferInfoANDROID & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    MemoryGetAndroidHardwareBufferInfoANDROID &
      setMemory( VULKAN_HPP_NAMESPACE::DeviceMemory memory_ ) VULKAN_HPP_NOEXCEPT
    {
      memory = memory_;
      return *this;
    }

    operator VkMemoryGetAndroidHardwareBufferInfoANDROID const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkMemoryGetAndroidHardwareBufferInfoANDROID *>( this );
    }

    operator VkMemoryGetAndroidHardwareBufferInfoANDROID &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkMemoryGetAndroidHardwareBufferInfoANDROID *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( MemoryGetAndroidHardwareBufferInfoANDROID const & ) const = default;
#  else
    bool operator==( MemoryGetAndroidHardwareBufferInfoANDROID const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( memory == rhs.memory );
    }

    bool operator!=( MemoryGetAndroidHardwareBufferInfoANDROID const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType  = StructureType::eMemoryGetAndroidHardwareBufferInfoANDROID;
    const void *                        pNext  = {};
    VULKAN_HPP_NAMESPACE::DeviceMemory  memory = {};
  };
  static_assert( sizeof( MemoryGetAndroidHardwareBufferInfoANDROID ) ==
                   sizeof( VkMemoryGetAndroidHardwareBufferInfoANDROID ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<MemoryGetAndroidHardwareBufferInfoANDROID>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eMemoryGetAndroidHardwareBufferInfoANDROID>
  {
    using Type = MemoryGetAndroidHardwareBufferInfoANDROID;
  };
#endif /*VK_USE_PLATFORM_ANDROID_KHR*/

  struct MemoryGetFdInfoKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eMemoryGetFdInfoKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      MemoryGetFdInfoKHR( VULKAN_HPP_NAMESPACE::DeviceMemory                     memory_ = {},
                          VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagBits handleType_ =
                            VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagBits::eOpaqueFd ) VULKAN_HPP_NOEXCEPT
      : memory( memory_ )
      , handleType( handleType_ )
    {}

    VULKAN_HPP_CONSTEXPR MemoryGetFdInfoKHR( MemoryGetFdInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MemoryGetFdInfoKHR( VkMemoryGetFdInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : MemoryGetFdInfoKHR( *reinterpret_cast<MemoryGetFdInfoKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 MemoryGetFdInfoKHR &
                            operator=( MemoryGetFdInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MemoryGetFdInfoKHR & operator=( VkMemoryGetFdInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::MemoryGetFdInfoKHR const *>( &rhs );
      return *this;
    }

    MemoryGetFdInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    MemoryGetFdInfoKHR & setMemory( VULKAN_HPP_NAMESPACE::DeviceMemory memory_ ) VULKAN_HPP_NOEXCEPT
    {
      memory = memory_;
      return *this;
    }

    MemoryGetFdInfoKHR &
      setHandleType( VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagBits handleType_ ) VULKAN_HPP_NOEXCEPT
    {
      handleType = handleType_;
      return *this;
    }

    operator VkMemoryGetFdInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkMemoryGetFdInfoKHR *>( this );
    }

    operator VkMemoryGetFdInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkMemoryGetFdInfoKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( MemoryGetFdInfoKHR const & ) const = default;
#else
    bool operator==( MemoryGetFdInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( memory == rhs.memory ) &&
             ( handleType == rhs.handleType );
    }

    bool operator!=( MemoryGetFdInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                    sType  = StructureType::eMemoryGetFdInfoKHR;
    const void *                                           pNext  = {};
    VULKAN_HPP_NAMESPACE::DeviceMemory                     memory = {};
    VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagBits handleType =
      VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagBits::eOpaqueFd;
  };
  static_assert( sizeof( MemoryGetFdInfoKHR ) == sizeof( VkMemoryGetFdInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<MemoryGetFdInfoKHR>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eMemoryGetFdInfoKHR>
  {
    using Type = MemoryGetFdInfoKHR;
  };

#if defined( VK_USE_PLATFORM_WIN32_KHR )
  struct MemoryGetWin32HandleInfoKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eMemoryGetWin32HandleInfoKHR;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR MemoryGetWin32HandleInfoKHR(
      VULKAN_HPP_NAMESPACE::DeviceMemory                     memory_ = {},
      VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagBits handleType_ =
        VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagBits::eOpaqueFd ) VULKAN_HPP_NOEXCEPT
      : memory( memory_ )
      , handleType( handleType_ )
    {}

    VULKAN_HPP_CONSTEXPR
      MemoryGetWin32HandleInfoKHR( MemoryGetWin32HandleInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MemoryGetWin32HandleInfoKHR( VkMemoryGetWin32HandleInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : MemoryGetWin32HandleInfoKHR( *reinterpret_cast<MemoryGetWin32HandleInfoKHR const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 MemoryGetWin32HandleInfoKHR &
                            operator=( MemoryGetWin32HandleInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MemoryGetWin32HandleInfoKHR & operator=( VkMemoryGetWin32HandleInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::MemoryGetWin32HandleInfoKHR const *>( &rhs );
      return *this;
    }

    MemoryGetWin32HandleInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    MemoryGetWin32HandleInfoKHR & setMemory( VULKAN_HPP_NAMESPACE::DeviceMemory memory_ ) VULKAN_HPP_NOEXCEPT
    {
      memory = memory_;
      return *this;
    }

    MemoryGetWin32HandleInfoKHR &
      setHandleType( VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagBits handleType_ ) VULKAN_HPP_NOEXCEPT
    {
      handleType = handleType_;
      return *this;
    }

    operator VkMemoryGetWin32HandleInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkMemoryGetWin32HandleInfoKHR *>( this );
    }

    operator VkMemoryGetWin32HandleInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkMemoryGetWin32HandleInfoKHR *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( MemoryGetWin32HandleInfoKHR const & ) const = default;
#  else
    bool operator==( MemoryGetWin32HandleInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( memory == rhs.memory ) &&
             ( handleType == rhs.handleType );
    }

    bool operator!=( MemoryGetWin32HandleInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                    sType  = StructureType::eMemoryGetWin32HandleInfoKHR;
    const void *                                           pNext  = {};
    VULKAN_HPP_NAMESPACE::DeviceMemory                     memory = {};
    VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagBits handleType =
      VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagBits::eOpaqueFd;
  };
  static_assert( sizeof( MemoryGetWin32HandleInfoKHR ) == sizeof( VkMemoryGetWin32HandleInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<MemoryGetWin32HandleInfoKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eMemoryGetWin32HandleInfoKHR>
  {
    using Type = MemoryGetWin32HandleInfoKHR;
  };
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

#if defined( VK_USE_PLATFORM_FUCHSIA )
  struct MemoryGetZirconHandleInfoFUCHSIA
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eMemoryGetZirconHandleInfoFUCHSIA;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR MemoryGetZirconHandleInfoFUCHSIA(
      VULKAN_HPP_NAMESPACE::DeviceMemory                     memory_ = {},
      VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagBits handleType_ =
        VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagBits::eOpaqueFd ) VULKAN_HPP_NOEXCEPT
      : memory( memory_ )
      , handleType( handleType_ )
    {}

    VULKAN_HPP_CONSTEXPR
      MemoryGetZirconHandleInfoFUCHSIA( MemoryGetZirconHandleInfoFUCHSIA const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MemoryGetZirconHandleInfoFUCHSIA( VkMemoryGetZirconHandleInfoFUCHSIA const & rhs ) VULKAN_HPP_NOEXCEPT
      : MemoryGetZirconHandleInfoFUCHSIA( *reinterpret_cast<MemoryGetZirconHandleInfoFUCHSIA const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 MemoryGetZirconHandleInfoFUCHSIA &
                            operator=( MemoryGetZirconHandleInfoFUCHSIA const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MemoryGetZirconHandleInfoFUCHSIA & operator=( VkMemoryGetZirconHandleInfoFUCHSIA const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::MemoryGetZirconHandleInfoFUCHSIA const *>( &rhs );
      return *this;
    }

    MemoryGetZirconHandleInfoFUCHSIA & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    MemoryGetZirconHandleInfoFUCHSIA & setMemory( VULKAN_HPP_NAMESPACE::DeviceMemory memory_ ) VULKAN_HPP_NOEXCEPT
    {
      memory = memory_;
      return *this;
    }

    MemoryGetZirconHandleInfoFUCHSIA &
      setHandleType( VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagBits handleType_ ) VULKAN_HPP_NOEXCEPT
    {
      handleType = handleType_;
      return *this;
    }

    operator VkMemoryGetZirconHandleInfoFUCHSIA const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkMemoryGetZirconHandleInfoFUCHSIA *>( this );
    }

    operator VkMemoryGetZirconHandleInfoFUCHSIA &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkMemoryGetZirconHandleInfoFUCHSIA *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( MemoryGetZirconHandleInfoFUCHSIA const & ) const = default;
#  else
    bool operator==( MemoryGetZirconHandleInfoFUCHSIA const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( memory == rhs.memory ) &&
             ( handleType == rhs.handleType );
    }

    bool operator!=( MemoryGetZirconHandleInfoFUCHSIA const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                    sType  = StructureType::eMemoryGetZirconHandleInfoFUCHSIA;
    const void *                                           pNext  = {};
    VULKAN_HPP_NAMESPACE::DeviceMemory                     memory = {};
    VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagBits handleType =
      VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagBits::eOpaqueFd;
  };
  static_assert( sizeof( MemoryGetZirconHandleInfoFUCHSIA ) == sizeof( VkMemoryGetZirconHandleInfoFUCHSIA ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<MemoryGetZirconHandleInfoFUCHSIA>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eMemoryGetZirconHandleInfoFUCHSIA>
  {
    using Type = MemoryGetZirconHandleInfoFUCHSIA;
  };
#endif /*VK_USE_PLATFORM_FUCHSIA*/

  struct MemoryHeap
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR MemoryHeap( VULKAN_HPP_NAMESPACE::DeviceSize      size_  = {},
                                     VULKAN_HPP_NAMESPACE::MemoryHeapFlags flags_ = {} ) VULKAN_HPP_NOEXCEPT
      : size( size_ )
      , flags( flags_ )
    {}

    VULKAN_HPP_CONSTEXPR MemoryHeap( MemoryHeap const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MemoryHeap( VkMemoryHeap const & rhs ) VULKAN_HPP_NOEXCEPT
      : MemoryHeap( *reinterpret_cast<MemoryHeap const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 MemoryHeap & operator=( MemoryHeap const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MemoryHeap & operator=( VkMemoryHeap const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::MemoryHeap const *>( &rhs );
      return *this;
    }

    operator VkMemoryHeap const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkMemoryHeap *>( this );
    }

    operator VkMemoryHeap &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkMemoryHeap *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( MemoryHeap const & ) const = default;
#else
    bool operator==( MemoryHeap const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( size == rhs.size ) && ( flags == rhs.flags );
    }

    bool operator!=( MemoryHeap const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::DeviceSize      size  = {};
    VULKAN_HPP_NAMESPACE::MemoryHeapFlags flags = {};
  };
  static_assert( sizeof( MemoryHeap ) == sizeof( VkMemoryHeap ), "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<MemoryHeap>::value, "struct wrapper is not a standard layout!" );

  struct MemoryHostPointerPropertiesEXT
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eMemoryHostPointerPropertiesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR MemoryHostPointerPropertiesEXT( uint32_t memoryTypeBits_ = {} ) VULKAN_HPP_NOEXCEPT
      : memoryTypeBits( memoryTypeBits_ )
    {}

    VULKAN_HPP_CONSTEXPR
      MemoryHostPointerPropertiesEXT( MemoryHostPointerPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MemoryHostPointerPropertiesEXT( VkMemoryHostPointerPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : MemoryHostPointerPropertiesEXT( *reinterpret_cast<MemoryHostPointerPropertiesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 MemoryHostPointerPropertiesEXT &
                            operator=( MemoryHostPointerPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MemoryHostPointerPropertiesEXT & operator=( VkMemoryHostPointerPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::MemoryHostPointerPropertiesEXT const *>( &rhs );
      return *this;
    }

    operator VkMemoryHostPointerPropertiesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkMemoryHostPointerPropertiesEXT *>( this );
    }

    operator VkMemoryHostPointerPropertiesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkMemoryHostPointerPropertiesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( MemoryHostPointerPropertiesEXT const & ) const = default;
#else
    bool operator==( MemoryHostPointerPropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( memoryTypeBits == rhs.memoryTypeBits );
    }

    bool operator!=( MemoryHostPointerPropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType          = StructureType::eMemoryHostPointerPropertiesEXT;
    void *                              pNext          = {};
    uint32_t                            memoryTypeBits = {};
  };
  static_assert( sizeof( MemoryHostPointerPropertiesEXT ) == sizeof( VkMemoryHostPointerPropertiesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<MemoryHostPointerPropertiesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eMemoryHostPointerPropertiesEXT>
  {
    using Type = MemoryHostPointerPropertiesEXT;
  };

  struct MemoryOpaqueCaptureAddressAllocateInfo
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eMemoryOpaqueCaptureAddressAllocateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      MemoryOpaqueCaptureAddressAllocateInfo( uint64_t opaqueCaptureAddress_ = {} ) VULKAN_HPP_NOEXCEPT
      : opaqueCaptureAddress( opaqueCaptureAddress_ )
    {}

    VULKAN_HPP_CONSTEXPR MemoryOpaqueCaptureAddressAllocateInfo( MemoryOpaqueCaptureAddressAllocateInfo const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    MemoryOpaqueCaptureAddressAllocateInfo( VkMemoryOpaqueCaptureAddressAllocateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : MemoryOpaqueCaptureAddressAllocateInfo(
          *reinterpret_cast<MemoryOpaqueCaptureAddressAllocateInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 MemoryOpaqueCaptureAddressAllocateInfo &
                            operator=( MemoryOpaqueCaptureAddressAllocateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MemoryOpaqueCaptureAddressAllocateInfo &
      operator=( VkMemoryOpaqueCaptureAddressAllocateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::MemoryOpaqueCaptureAddressAllocateInfo const *>( &rhs );
      return *this;
    }

    MemoryOpaqueCaptureAddressAllocateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    MemoryOpaqueCaptureAddressAllocateInfo &
      setOpaqueCaptureAddress( uint64_t opaqueCaptureAddress_ ) VULKAN_HPP_NOEXCEPT
    {
      opaqueCaptureAddress = opaqueCaptureAddress_;
      return *this;
    }

    operator VkMemoryOpaqueCaptureAddressAllocateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkMemoryOpaqueCaptureAddressAllocateInfo *>( this );
    }

    operator VkMemoryOpaqueCaptureAddressAllocateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkMemoryOpaqueCaptureAddressAllocateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( MemoryOpaqueCaptureAddressAllocateInfo const & ) const = default;
#else
    bool operator==( MemoryOpaqueCaptureAddressAllocateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( opaqueCaptureAddress == rhs.opaqueCaptureAddress );
    }

    bool operator!=( MemoryOpaqueCaptureAddressAllocateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType                = StructureType::eMemoryOpaqueCaptureAddressAllocateInfo;
    const void *                        pNext                = {};
    uint64_t                            opaqueCaptureAddress = {};
  };
  static_assert( sizeof( MemoryOpaqueCaptureAddressAllocateInfo ) == sizeof( VkMemoryOpaqueCaptureAddressAllocateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<MemoryOpaqueCaptureAddressAllocateInfo>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eMemoryOpaqueCaptureAddressAllocateInfo>
  {
    using Type = MemoryOpaqueCaptureAddressAllocateInfo;
  };
  using MemoryOpaqueCaptureAddressAllocateInfoKHR = MemoryOpaqueCaptureAddressAllocateInfo;

  struct MemoryPriorityAllocateInfoEXT
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eMemoryPriorityAllocateInfoEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR MemoryPriorityAllocateInfoEXT( float priority_ = {} ) VULKAN_HPP_NOEXCEPT
      : priority( priority_ )
    {}

    VULKAN_HPP_CONSTEXPR
      MemoryPriorityAllocateInfoEXT( MemoryPriorityAllocateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MemoryPriorityAllocateInfoEXT( VkMemoryPriorityAllocateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : MemoryPriorityAllocateInfoEXT( *reinterpret_cast<MemoryPriorityAllocateInfoEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 MemoryPriorityAllocateInfoEXT &
                            operator=( MemoryPriorityAllocateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MemoryPriorityAllocateInfoEXT & operator=( VkMemoryPriorityAllocateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::MemoryPriorityAllocateInfoEXT const *>( &rhs );
      return *this;
    }

    MemoryPriorityAllocateInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    MemoryPriorityAllocateInfoEXT & setPriority( float priority_ ) VULKAN_HPP_NOEXCEPT
    {
      priority = priority_;
      return *this;
    }

    operator VkMemoryPriorityAllocateInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkMemoryPriorityAllocateInfoEXT *>( this );
    }

    operator VkMemoryPriorityAllocateInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkMemoryPriorityAllocateInfoEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( MemoryPriorityAllocateInfoEXT const & ) const = default;
#else
    bool operator==( MemoryPriorityAllocateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( priority == rhs.priority );
    }

    bool operator!=( MemoryPriorityAllocateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType    = StructureType::eMemoryPriorityAllocateInfoEXT;
    const void *                        pNext    = {};
    float                               priority = {};
  };
  static_assert( sizeof( MemoryPriorityAllocateInfoEXT ) == sizeof( VkMemoryPriorityAllocateInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<MemoryPriorityAllocateInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eMemoryPriorityAllocateInfoEXT>
  {
    using Type = MemoryPriorityAllocateInfoEXT;
  };

  struct MemoryRequirements
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR MemoryRequirements( VULKAN_HPP_NAMESPACE::DeviceSize size_           = {},
                                             VULKAN_HPP_NAMESPACE::DeviceSize alignment_      = {},
                                             uint32_t                         memoryTypeBits_ = {} ) VULKAN_HPP_NOEXCEPT
      : size( size_ )
      , alignment( alignment_ )
      , memoryTypeBits( memoryTypeBits_ )
    {}

    VULKAN_HPP_CONSTEXPR MemoryRequirements( MemoryRequirements const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MemoryRequirements( VkMemoryRequirements const & rhs ) VULKAN_HPP_NOEXCEPT
      : MemoryRequirements( *reinterpret_cast<MemoryRequirements const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 MemoryRequirements &
                            operator=( MemoryRequirements const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MemoryRequirements & operator=( VkMemoryRequirements const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::MemoryRequirements const *>( &rhs );
      return *this;
    }

    operator VkMemoryRequirements const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkMemoryRequirements *>( this );
    }

    operator VkMemoryRequirements &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkMemoryRequirements *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( MemoryRequirements const & ) const = default;
#else
    bool operator==( MemoryRequirements const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( size == rhs.size ) && ( alignment == rhs.alignment ) && ( memoryTypeBits == rhs.memoryTypeBits );
    }

    bool operator!=( MemoryRequirements const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::DeviceSize size           = {};
    VULKAN_HPP_NAMESPACE::DeviceSize alignment      = {};
    uint32_t                         memoryTypeBits = {};
  };
  static_assert( sizeof( MemoryRequirements ) == sizeof( VkMemoryRequirements ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<MemoryRequirements>::value, "struct wrapper is not a standard layout!" );

  struct MemoryRequirements2
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eMemoryRequirements2;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      MemoryRequirements2( VULKAN_HPP_NAMESPACE::MemoryRequirements memoryRequirements_ = {} ) VULKAN_HPP_NOEXCEPT
      : memoryRequirements( memoryRequirements_ )
    {}

    VULKAN_HPP_CONSTEXPR MemoryRequirements2( MemoryRequirements2 const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MemoryRequirements2( VkMemoryRequirements2 const & rhs ) VULKAN_HPP_NOEXCEPT
      : MemoryRequirements2( *reinterpret_cast<MemoryRequirements2 const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 MemoryRequirements2 &
                            operator=( MemoryRequirements2 const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MemoryRequirements2 & operator=( VkMemoryRequirements2 const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::MemoryRequirements2 const *>( &rhs );
      return *this;
    }

    operator VkMemoryRequirements2 const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkMemoryRequirements2 *>( this );
    }

    operator VkMemoryRequirements2 &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkMemoryRequirements2 *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( MemoryRequirements2 const & ) const = default;
#else
    bool operator==( MemoryRequirements2 const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( memoryRequirements == rhs.memoryRequirements );
    }

    bool operator!=( MemoryRequirements2 const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType      sType              = StructureType::eMemoryRequirements2;
    void *                                   pNext              = {};
    VULKAN_HPP_NAMESPACE::MemoryRequirements memoryRequirements = {};
  };
  static_assert( sizeof( MemoryRequirements2 ) == sizeof( VkMemoryRequirements2 ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<MemoryRequirements2>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eMemoryRequirements2>
  {
    using Type = MemoryRequirements2;
  };
  using MemoryRequirements2KHR = MemoryRequirements2;

  struct MemoryType
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR MemoryType( VULKAN_HPP_NAMESPACE::MemoryPropertyFlags propertyFlags_ = {},
                                     uint32_t                                  heapIndex_     = {} ) VULKAN_HPP_NOEXCEPT
      : propertyFlags( propertyFlags_ )
      , heapIndex( heapIndex_ )
    {}

    VULKAN_HPP_CONSTEXPR MemoryType( MemoryType const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MemoryType( VkMemoryType const & rhs ) VULKAN_HPP_NOEXCEPT
      : MemoryType( *reinterpret_cast<MemoryType const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 MemoryType & operator=( MemoryType const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MemoryType & operator=( VkMemoryType const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::MemoryType const *>( &rhs );
      return *this;
    }

    operator VkMemoryType const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkMemoryType *>( this );
    }

    operator VkMemoryType &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkMemoryType *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( MemoryType const & ) const = default;
#else
    bool operator==( MemoryType const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( propertyFlags == rhs.propertyFlags ) && ( heapIndex == rhs.heapIndex );
    }

    bool operator!=( MemoryType const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::MemoryPropertyFlags propertyFlags = {};
    uint32_t                                  heapIndex     = {};
  };
  static_assert( sizeof( MemoryType ) == sizeof( VkMemoryType ), "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<MemoryType>::value, "struct wrapper is not a standard layout!" );

#if defined( VK_USE_PLATFORM_WIN32_KHR )
  struct MemoryWin32HandlePropertiesKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eMemoryWin32HandlePropertiesKHR;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR MemoryWin32HandlePropertiesKHR( uint32_t memoryTypeBits_ = {} ) VULKAN_HPP_NOEXCEPT
      : memoryTypeBits( memoryTypeBits_ )
    {}

    VULKAN_HPP_CONSTEXPR
      MemoryWin32HandlePropertiesKHR( MemoryWin32HandlePropertiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MemoryWin32HandlePropertiesKHR( VkMemoryWin32HandlePropertiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : MemoryWin32HandlePropertiesKHR( *reinterpret_cast<MemoryWin32HandlePropertiesKHR const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 MemoryWin32HandlePropertiesKHR &
                            operator=( MemoryWin32HandlePropertiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MemoryWin32HandlePropertiesKHR & operator=( VkMemoryWin32HandlePropertiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::MemoryWin32HandlePropertiesKHR const *>( &rhs );
      return *this;
    }

    operator VkMemoryWin32HandlePropertiesKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkMemoryWin32HandlePropertiesKHR *>( this );
    }

    operator VkMemoryWin32HandlePropertiesKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkMemoryWin32HandlePropertiesKHR *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( MemoryWin32HandlePropertiesKHR const & ) const = default;
#  else
    bool operator==( MemoryWin32HandlePropertiesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( memoryTypeBits == rhs.memoryTypeBits );
    }

    bool operator!=( MemoryWin32HandlePropertiesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType          = StructureType::eMemoryWin32HandlePropertiesKHR;
    void *                              pNext          = {};
    uint32_t                            memoryTypeBits = {};
  };
  static_assert( sizeof( MemoryWin32HandlePropertiesKHR ) == sizeof( VkMemoryWin32HandlePropertiesKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<MemoryWin32HandlePropertiesKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eMemoryWin32HandlePropertiesKHR>
  {
    using Type = MemoryWin32HandlePropertiesKHR;
  };
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

#if defined( VK_USE_PLATFORM_FUCHSIA )
  struct MemoryZirconHandlePropertiesFUCHSIA
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eMemoryZirconHandlePropertiesFUCHSIA;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR MemoryZirconHandlePropertiesFUCHSIA( uint32_t memoryTypeBits_ = {} ) VULKAN_HPP_NOEXCEPT
      : memoryTypeBits( memoryTypeBits_ )
    {}

    VULKAN_HPP_CONSTEXPR MemoryZirconHandlePropertiesFUCHSIA( MemoryZirconHandlePropertiesFUCHSIA const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    MemoryZirconHandlePropertiesFUCHSIA( VkMemoryZirconHandlePropertiesFUCHSIA const & rhs ) VULKAN_HPP_NOEXCEPT
      : MemoryZirconHandlePropertiesFUCHSIA( *reinterpret_cast<MemoryZirconHandlePropertiesFUCHSIA const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 MemoryZirconHandlePropertiesFUCHSIA &
                            operator=( MemoryZirconHandlePropertiesFUCHSIA const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MemoryZirconHandlePropertiesFUCHSIA &
      operator=( VkMemoryZirconHandlePropertiesFUCHSIA const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::MemoryZirconHandlePropertiesFUCHSIA const *>( &rhs );
      return *this;
    }

    operator VkMemoryZirconHandlePropertiesFUCHSIA const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkMemoryZirconHandlePropertiesFUCHSIA *>( this );
    }

    operator VkMemoryZirconHandlePropertiesFUCHSIA &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkMemoryZirconHandlePropertiesFUCHSIA *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( MemoryZirconHandlePropertiesFUCHSIA const & ) const = default;
#  else
    bool operator==( MemoryZirconHandlePropertiesFUCHSIA const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( memoryTypeBits == rhs.memoryTypeBits );
    }

    bool operator!=( MemoryZirconHandlePropertiesFUCHSIA const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType          = StructureType::eMemoryZirconHandlePropertiesFUCHSIA;
    void *                              pNext          = {};
    uint32_t                            memoryTypeBits = {};
  };
  static_assert( sizeof( MemoryZirconHandlePropertiesFUCHSIA ) == sizeof( VkMemoryZirconHandlePropertiesFUCHSIA ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<MemoryZirconHandlePropertiesFUCHSIA>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eMemoryZirconHandlePropertiesFUCHSIA>
  {
    using Type = MemoryZirconHandlePropertiesFUCHSIA;
  };
#endif /*VK_USE_PLATFORM_FUCHSIA*/

#if defined( VK_USE_PLATFORM_METAL_EXT )
  struct MetalSurfaceCreateInfoEXT
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eMetalSurfaceCreateInfoEXT;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR MetalSurfaceCreateInfoEXT( VULKAN_HPP_NAMESPACE::MetalSurfaceCreateFlagsEXT flags_ = {},
                                                    const CAMetalLayer * pLayer_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , pLayer( pLayer_ )
    {}

    VULKAN_HPP_CONSTEXPR
      MetalSurfaceCreateInfoEXT( MetalSurfaceCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MetalSurfaceCreateInfoEXT( VkMetalSurfaceCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : MetalSurfaceCreateInfoEXT( *reinterpret_cast<MetalSurfaceCreateInfoEXT const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 MetalSurfaceCreateInfoEXT &
                            operator=( MetalSurfaceCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MetalSurfaceCreateInfoEXT & operator=( VkMetalSurfaceCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::MetalSurfaceCreateInfoEXT const *>( &rhs );
      return *this;
    }

    MetalSurfaceCreateInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    MetalSurfaceCreateInfoEXT & setFlags( VULKAN_HPP_NAMESPACE::MetalSurfaceCreateFlagsEXT flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    MetalSurfaceCreateInfoEXT & setPLayer( const CAMetalLayer * pLayer_ ) VULKAN_HPP_NOEXCEPT
    {
      pLayer = pLayer_;
      return *this;
    }

    operator VkMetalSurfaceCreateInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkMetalSurfaceCreateInfoEXT *>( this );
    }

    operator VkMetalSurfaceCreateInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkMetalSurfaceCreateInfoEXT *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( MetalSurfaceCreateInfoEXT const & ) const = default;
#  else
    bool operator==( MetalSurfaceCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) && ( pLayer == rhs.pLayer );
    }

    bool operator!=( MetalSurfaceCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType              sType  = StructureType::eMetalSurfaceCreateInfoEXT;
    const void *                                     pNext  = {};
    VULKAN_HPP_NAMESPACE::MetalSurfaceCreateFlagsEXT flags  = {};
    const CAMetalLayer *                             pLayer = {};
  };
  static_assert( sizeof( MetalSurfaceCreateInfoEXT ) == sizeof( VkMetalSurfaceCreateInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<MetalSurfaceCreateInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eMetalSurfaceCreateInfoEXT>
  {
    using Type = MetalSurfaceCreateInfoEXT;
  };
#endif /*VK_USE_PLATFORM_METAL_EXT*/

  struct MultiDrawIndexedInfoEXT
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR MultiDrawIndexedInfoEXT( uint32_t firstIndex_   = {},
                                                  uint32_t indexCount_   = {},
                                                  int32_t  vertexOffset_ = {} ) VULKAN_HPP_NOEXCEPT
      : firstIndex( firstIndex_ )
      , indexCount( indexCount_ )
      , vertexOffset( vertexOffset_ )
    {}

    VULKAN_HPP_CONSTEXPR MultiDrawIndexedInfoEXT( MultiDrawIndexedInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MultiDrawIndexedInfoEXT( VkMultiDrawIndexedInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : MultiDrawIndexedInfoEXT( *reinterpret_cast<MultiDrawIndexedInfoEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 MultiDrawIndexedInfoEXT &
                            operator=( MultiDrawIndexedInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MultiDrawIndexedInfoEXT & operator=( VkMultiDrawIndexedInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::MultiDrawIndexedInfoEXT const *>( &rhs );
      return *this;
    }

    MultiDrawIndexedInfoEXT & setFirstIndex( uint32_t firstIndex_ ) VULKAN_HPP_NOEXCEPT
    {
      firstIndex = firstIndex_;
      return *this;
    }

    MultiDrawIndexedInfoEXT & setIndexCount( uint32_t indexCount_ ) VULKAN_HPP_NOEXCEPT
    {
      indexCount = indexCount_;
      return *this;
    }

    MultiDrawIndexedInfoEXT & setVertexOffset( int32_t vertexOffset_ ) VULKAN_HPP_NOEXCEPT
    {
      vertexOffset = vertexOffset_;
      return *this;
    }

    operator VkMultiDrawIndexedInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkMultiDrawIndexedInfoEXT *>( this );
    }

    operator VkMultiDrawIndexedInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkMultiDrawIndexedInfoEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( MultiDrawIndexedInfoEXT const & ) const = default;
#else
    bool operator==( MultiDrawIndexedInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( firstIndex == rhs.firstIndex ) && ( indexCount == rhs.indexCount ) &&
             ( vertexOffset == rhs.vertexOffset );
    }

    bool operator!=( MultiDrawIndexedInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    uint32_t firstIndex   = {};
    uint32_t indexCount   = {};
    int32_t  vertexOffset = {};
  };
  static_assert( sizeof( MultiDrawIndexedInfoEXT ) == sizeof( VkMultiDrawIndexedInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<MultiDrawIndexedInfoEXT>::value, "struct wrapper is not a standard layout!" );

  struct MultiDrawInfoEXT
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR MultiDrawInfoEXT( uint32_t firstVertex_ = {}, uint32_t vertexCount_ = {} ) VULKAN_HPP_NOEXCEPT
      : firstVertex( firstVertex_ )
      , vertexCount( vertexCount_ )
    {}

    VULKAN_HPP_CONSTEXPR MultiDrawInfoEXT( MultiDrawInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MultiDrawInfoEXT( VkMultiDrawInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : MultiDrawInfoEXT( *reinterpret_cast<MultiDrawInfoEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 MultiDrawInfoEXT & operator=( MultiDrawInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MultiDrawInfoEXT & operator=( VkMultiDrawInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::MultiDrawInfoEXT const *>( &rhs );
      return *this;
    }

    MultiDrawInfoEXT & setFirstVertex( uint32_t firstVertex_ ) VULKAN_HPP_NOEXCEPT
    {
      firstVertex = firstVertex_;
      return *this;
    }

    MultiDrawInfoEXT & setVertexCount( uint32_t vertexCount_ ) VULKAN_HPP_NOEXCEPT
    {
      vertexCount = vertexCount_;
      return *this;
    }

    operator VkMultiDrawInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkMultiDrawInfoEXT *>( this );
    }

    operator VkMultiDrawInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkMultiDrawInfoEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( MultiDrawInfoEXT const & ) const = default;
#else
    bool operator==( MultiDrawInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( firstVertex == rhs.firstVertex ) && ( vertexCount == rhs.vertexCount );
    }

    bool operator!=( MultiDrawInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    uint32_t firstVertex = {};
    uint32_t vertexCount = {};
  };
  static_assert( sizeof( MultiDrawInfoEXT ) == sizeof( VkMultiDrawInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<MultiDrawInfoEXT>::value, "struct wrapper is not a standard layout!" );

  struct MultisamplePropertiesEXT
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eMultisamplePropertiesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      MultisamplePropertiesEXT( VULKAN_HPP_NAMESPACE::Extent2D maxSampleLocationGridSize_ = {} ) VULKAN_HPP_NOEXCEPT
      : maxSampleLocationGridSize( maxSampleLocationGridSize_ )
    {}

    VULKAN_HPP_CONSTEXPR MultisamplePropertiesEXT( MultisamplePropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MultisamplePropertiesEXT( VkMultisamplePropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : MultisamplePropertiesEXT( *reinterpret_cast<MultisamplePropertiesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 MultisamplePropertiesEXT &
                            operator=( MultisamplePropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MultisamplePropertiesEXT & operator=( VkMultisamplePropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::MultisamplePropertiesEXT const *>( &rhs );
      return *this;
    }

    operator VkMultisamplePropertiesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkMultisamplePropertiesEXT *>( this );
    }

    operator VkMultisamplePropertiesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkMultisamplePropertiesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( MultisamplePropertiesEXT const & ) const = default;
#else
    bool operator==( MultisamplePropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( maxSampleLocationGridSize == rhs.maxSampleLocationGridSize );
    }

    bool operator!=( MultisamplePropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType                     = StructureType::eMultisamplePropertiesEXT;
    void *                              pNext                     = {};
    VULKAN_HPP_NAMESPACE::Extent2D      maxSampleLocationGridSize = {};
  };
  static_assert( sizeof( MultisamplePropertiesEXT ) == sizeof( VkMultisamplePropertiesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<MultisamplePropertiesEXT>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eMultisamplePropertiesEXT>
  {
    using Type = MultisamplePropertiesEXT;
  };

  struct MutableDescriptorTypeListVALVE
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR MutableDescriptorTypeListVALVE(
      uint32_t                                     descriptorTypeCount_ = {},
      const VULKAN_HPP_NAMESPACE::DescriptorType * pDescriptorTypes_    = {} ) VULKAN_HPP_NOEXCEPT
      : descriptorTypeCount( descriptorTypeCount_ )
      , pDescriptorTypes( pDescriptorTypes_ )
    {}

    VULKAN_HPP_CONSTEXPR
      MutableDescriptorTypeListVALVE( MutableDescriptorTypeListVALVE const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MutableDescriptorTypeListVALVE( VkMutableDescriptorTypeListVALVE const & rhs ) VULKAN_HPP_NOEXCEPT
      : MutableDescriptorTypeListVALVE( *reinterpret_cast<MutableDescriptorTypeListVALVE const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    MutableDescriptorTypeListVALVE(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::DescriptorType> const &
        descriptorTypes_ )
      : descriptorTypeCount( static_cast<uint32_t>( descriptorTypes_.size() ) )
      , pDescriptorTypes( descriptorTypes_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 MutableDescriptorTypeListVALVE &
                            operator=( MutableDescriptorTypeListVALVE const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MutableDescriptorTypeListVALVE & operator=( VkMutableDescriptorTypeListVALVE const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::MutableDescriptorTypeListVALVE const *>( &rhs );
      return *this;
    }

    MutableDescriptorTypeListVALVE & setDescriptorTypeCount( uint32_t descriptorTypeCount_ ) VULKAN_HPP_NOEXCEPT
    {
      descriptorTypeCount = descriptorTypeCount_;
      return *this;
    }

    MutableDescriptorTypeListVALVE &
      setPDescriptorTypes( const VULKAN_HPP_NAMESPACE::DescriptorType * pDescriptorTypes_ ) VULKAN_HPP_NOEXCEPT
    {
      pDescriptorTypes = pDescriptorTypes_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    MutableDescriptorTypeListVALVE & setDescriptorTypes(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::DescriptorType> const &
        descriptorTypes_ ) VULKAN_HPP_NOEXCEPT
    {
      descriptorTypeCount = static_cast<uint32_t>( descriptorTypes_.size() );
      pDescriptorTypes    = descriptorTypes_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkMutableDescriptorTypeListVALVE const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkMutableDescriptorTypeListVALVE *>( this );
    }

    operator VkMutableDescriptorTypeListVALVE &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkMutableDescriptorTypeListVALVE *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( MutableDescriptorTypeListVALVE const & ) const = default;
#else
    bool operator==( MutableDescriptorTypeListVALVE const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( descriptorTypeCount == rhs.descriptorTypeCount ) && ( pDescriptorTypes == rhs.pDescriptorTypes );
    }

    bool operator!=( MutableDescriptorTypeListVALVE const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    uint32_t                                     descriptorTypeCount = {};
    const VULKAN_HPP_NAMESPACE::DescriptorType * pDescriptorTypes    = {};
  };
  static_assert( sizeof( MutableDescriptorTypeListVALVE ) == sizeof( VkMutableDescriptorTypeListVALVE ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<MutableDescriptorTypeListVALVE>::value,
                 "struct wrapper is not a standard layout!" );

  struct MutableDescriptorTypeCreateInfoVALVE
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eMutableDescriptorTypeCreateInfoVALVE;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR MutableDescriptorTypeCreateInfoVALVE(
      uint32_t                                                     mutableDescriptorTypeListCount_ = {},
      const VULKAN_HPP_NAMESPACE::MutableDescriptorTypeListVALVE * pMutableDescriptorTypeLists_    = {} )
      VULKAN_HPP_NOEXCEPT
      : mutableDescriptorTypeListCount( mutableDescriptorTypeListCount_ )
      , pMutableDescriptorTypeLists( pMutableDescriptorTypeLists_ )
    {}

    VULKAN_HPP_CONSTEXPR MutableDescriptorTypeCreateInfoVALVE( MutableDescriptorTypeCreateInfoVALVE const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    MutableDescriptorTypeCreateInfoVALVE( VkMutableDescriptorTypeCreateInfoVALVE const & rhs ) VULKAN_HPP_NOEXCEPT
      : MutableDescriptorTypeCreateInfoVALVE( *reinterpret_cast<MutableDescriptorTypeCreateInfoVALVE const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    MutableDescriptorTypeCreateInfoVALVE(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::MutableDescriptorTypeListVALVE> const &
        mutableDescriptorTypeLists_ )
      : mutableDescriptorTypeListCount( static_cast<uint32_t>( mutableDescriptorTypeLists_.size() ) )
      , pMutableDescriptorTypeLists( mutableDescriptorTypeLists_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 MutableDescriptorTypeCreateInfoVALVE &
                            operator=( MutableDescriptorTypeCreateInfoVALVE const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    MutableDescriptorTypeCreateInfoVALVE &
      operator=( VkMutableDescriptorTypeCreateInfoVALVE const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::MutableDescriptorTypeCreateInfoVALVE const *>( &rhs );
      return *this;
    }

    MutableDescriptorTypeCreateInfoVALVE & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    MutableDescriptorTypeCreateInfoVALVE &
      setMutableDescriptorTypeListCount( uint32_t mutableDescriptorTypeListCount_ ) VULKAN_HPP_NOEXCEPT
    {
      mutableDescriptorTypeListCount = mutableDescriptorTypeListCount_;
      return *this;
    }

    MutableDescriptorTypeCreateInfoVALVE & setPMutableDescriptorTypeLists(
      const VULKAN_HPP_NAMESPACE::MutableDescriptorTypeListVALVE * pMutableDescriptorTypeLists_ ) VULKAN_HPP_NOEXCEPT
    {
      pMutableDescriptorTypeLists = pMutableDescriptorTypeLists_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    MutableDescriptorTypeCreateInfoVALVE & setMutableDescriptorTypeLists(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::MutableDescriptorTypeListVALVE> const &
        mutableDescriptorTypeLists_ ) VULKAN_HPP_NOEXCEPT
    {
      mutableDescriptorTypeListCount = static_cast<uint32_t>( mutableDescriptorTypeLists_.size() );
      pMutableDescriptorTypeLists    = mutableDescriptorTypeLists_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkMutableDescriptorTypeCreateInfoVALVE const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkMutableDescriptorTypeCreateInfoVALVE *>( this );
    }

    operator VkMutableDescriptorTypeCreateInfoVALVE &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkMutableDescriptorTypeCreateInfoVALVE *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( MutableDescriptorTypeCreateInfoVALVE const & ) const = default;
#else
    bool operator==( MutableDescriptorTypeCreateInfoVALVE const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( mutableDescriptorTypeListCount == rhs.mutableDescriptorTypeListCount ) &&
             ( pMutableDescriptorTypeLists == rhs.pMutableDescriptorTypeLists );
    }

    bool operator!=( MutableDescriptorTypeCreateInfoVALVE const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::eMutableDescriptorTypeCreateInfoVALVE;
    const void *                        pNext = {};
    uint32_t                            mutableDescriptorTypeListCount                       = {};
    const VULKAN_HPP_NAMESPACE::MutableDescriptorTypeListVALVE * pMutableDescriptorTypeLists = {};
  };
  static_assert( sizeof( MutableDescriptorTypeCreateInfoVALVE ) == sizeof( VkMutableDescriptorTypeCreateInfoVALVE ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<MutableDescriptorTypeCreateInfoVALVE>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eMutableDescriptorTypeCreateInfoVALVE>
  {
    using Type = MutableDescriptorTypeCreateInfoVALVE;
  };

  struct PastPresentationTimingGOOGLE
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PastPresentationTimingGOOGLE( uint32_t presentID_           = {},
                                                       uint64_t desiredPresentTime_  = {},
                                                       uint64_t actualPresentTime_   = {},
                                                       uint64_t earliestPresentTime_ = {},
                                                       uint64_t presentMargin_       = {} ) VULKAN_HPP_NOEXCEPT
      : presentID( presentID_ )
      , desiredPresentTime( desiredPresentTime_ )
      , actualPresentTime( actualPresentTime_ )
      , earliestPresentTime( earliestPresentTime_ )
      , presentMargin( presentMargin_ )
    {}

    VULKAN_HPP_CONSTEXPR
      PastPresentationTimingGOOGLE( PastPresentationTimingGOOGLE const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PastPresentationTimingGOOGLE( VkPastPresentationTimingGOOGLE const & rhs ) VULKAN_HPP_NOEXCEPT
      : PastPresentationTimingGOOGLE( *reinterpret_cast<PastPresentationTimingGOOGLE const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PastPresentationTimingGOOGLE &
                            operator=( PastPresentationTimingGOOGLE const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PastPresentationTimingGOOGLE & operator=( VkPastPresentationTimingGOOGLE const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PastPresentationTimingGOOGLE const *>( &rhs );
      return *this;
    }

    operator VkPastPresentationTimingGOOGLE const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPastPresentationTimingGOOGLE *>( this );
    }

    operator VkPastPresentationTimingGOOGLE &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPastPresentationTimingGOOGLE *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PastPresentationTimingGOOGLE const & ) const = default;
#else
    bool operator==( PastPresentationTimingGOOGLE const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( presentID == rhs.presentID ) && ( desiredPresentTime == rhs.desiredPresentTime ) &&
             ( actualPresentTime == rhs.actualPresentTime ) && ( earliestPresentTime == rhs.earliestPresentTime ) &&
             ( presentMargin == rhs.presentMargin );
    }

    bool operator!=( PastPresentationTimingGOOGLE const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    uint32_t presentID           = {};
    uint64_t desiredPresentTime  = {};
    uint64_t actualPresentTime   = {};
    uint64_t earliestPresentTime = {};
    uint64_t presentMargin       = {};
  };
  static_assert( sizeof( PastPresentationTimingGOOGLE ) == sizeof( VkPastPresentationTimingGOOGLE ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PastPresentationTimingGOOGLE>::value,
                 "struct wrapper is not a standard layout!" );

  struct PerformanceConfigurationAcquireInfoINTEL
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePerformanceConfigurationAcquireInfoINTEL;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PerformanceConfigurationAcquireInfoINTEL(
      VULKAN_HPP_NAMESPACE::PerformanceConfigurationTypeINTEL type_ =
        VULKAN_HPP_NAMESPACE::PerformanceConfigurationTypeINTEL::eCommandQueueMetricsDiscoveryActivated )
      VULKAN_HPP_NOEXCEPT : type( type_ )
    {}

    VULKAN_HPP_CONSTEXPR PerformanceConfigurationAcquireInfoINTEL(
      PerformanceConfigurationAcquireInfoINTEL const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PerformanceConfigurationAcquireInfoINTEL( VkPerformanceConfigurationAcquireInfoINTEL const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PerformanceConfigurationAcquireInfoINTEL(
          *reinterpret_cast<PerformanceConfigurationAcquireInfoINTEL const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PerformanceConfigurationAcquireInfoINTEL &
                            operator=( PerformanceConfigurationAcquireInfoINTEL const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PerformanceConfigurationAcquireInfoINTEL &
      operator=( VkPerformanceConfigurationAcquireInfoINTEL const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PerformanceConfigurationAcquireInfoINTEL const *>( &rhs );
      return *this;
    }

    PerformanceConfigurationAcquireInfoINTEL & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PerformanceConfigurationAcquireInfoINTEL &
      setType( VULKAN_HPP_NAMESPACE::PerformanceConfigurationTypeINTEL type_ ) VULKAN_HPP_NOEXCEPT
    {
      type = type_;
      return *this;
    }

    operator VkPerformanceConfigurationAcquireInfoINTEL const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPerformanceConfigurationAcquireInfoINTEL *>( this );
    }

    operator VkPerformanceConfigurationAcquireInfoINTEL &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPerformanceConfigurationAcquireInfoINTEL *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PerformanceConfigurationAcquireInfoINTEL const & ) const = default;
#else
    bool operator==( PerformanceConfigurationAcquireInfoINTEL const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( type == rhs.type );
    }

    bool operator!=( PerformanceConfigurationAcquireInfoINTEL const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePerformanceConfigurationAcquireInfoINTEL;
    const void *                        pNext = {};
    VULKAN_HPP_NAMESPACE::PerformanceConfigurationTypeINTEL type =
      VULKAN_HPP_NAMESPACE::PerformanceConfigurationTypeINTEL::eCommandQueueMetricsDiscoveryActivated;
  };
  static_assert( sizeof( PerformanceConfigurationAcquireInfoINTEL ) ==
                   sizeof( VkPerformanceConfigurationAcquireInfoINTEL ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PerformanceConfigurationAcquireInfoINTEL>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePerformanceConfigurationAcquireInfoINTEL>
  {
    using Type = PerformanceConfigurationAcquireInfoINTEL;
  };

  struct PerformanceCounterDescriptionKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::ePerformanceCounterDescriptionKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR_14 PerformanceCounterDescriptionKHR(
      VULKAN_HPP_NAMESPACE::PerformanceCounterDescriptionFlagsKHR flags_       = {},
      std::array<char, VK_MAX_DESCRIPTION_SIZE> const &           name_        = {},
      std::array<char, VK_MAX_DESCRIPTION_SIZE> const &           category_    = {},
      std::array<char, VK_MAX_DESCRIPTION_SIZE> const &           description_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , name( name_ )
      , category( category_ )
      , description( description_ )
    {}

    VULKAN_HPP_CONSTEXPR_14
      PerformanceCounterDescriptionKHR( PerformanceCounterDescriptionKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PerformanceCounterDescriptionKHR( VkPerformanceCounterDescriptionKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : PerformanceCounterDescriptionKHR( *reinterpret_cast<PerformanceCounterDescriptionKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PerformanceCounterDescriptionKHR &
                            operator=( PerformanceCounterDescriptionKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PerformanceCounterDescriptionKHR & operator=( VkPerformanceCounterDescriptionKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PerformanceCounterDescriptionKHR const *>( &rhs );
      return *this;
    }

    operator VkPerformanceCounterDescriptionKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPerformanceCounterDescriptionKHR *>( this );
    }

    operator VkPerformanceCounterDescriptionKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPerformanceCounterDescriptionKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PerformanceCounterDescriptionKHR const & ) const = default;
#else
    bool operator==( PerformanceCounterDescriptionKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) && ( name == rhs.name ) &&
             ( category == rhs.category ) && ( description == rhs.description );
    }

    bool operator!=( PerformanceCounterDescriptionKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePerformanceCounterDescriptionKHR;
    const void *                        pNext = {};
    VULKAN_HPP_NAMESPACE::PerformanceCounterDescriptionFlagsKHR         flags       = {};
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<char, VK_MAX_DESCRIPTION_SIZE> name        = {};
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<char, VK_MAX_DESCRIPTION_SIZE> category    = {};
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<char, VK_MAX_DESCRIPTION_SIZE> description = {};
  };
  static_assert( sizeof( PerformanceCounterDescriptionKHR ) == sizeof( VkPerformanceCounterDescriptionKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PerformanceCounterDescriptionKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePerformanceCounterDescriptionKHR>
  {
    using Type = PerformanceCounterDescriptionKHR;
  };

  struct PerformanceCounterKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::ePerformanceCounterKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR_14 PerformanceCounterKHR(
      VULKAN_HPP_NAMESPACE::PerformanceCounterUnitKHR unit_ = VULKAN_HPP_NAMESPACE::PerformanceCounterUnitKHR::eGeneric,
      VULKAN_HPP_NAMESPACE::PerformanceCounterScopeKHR scope_ =
        VULKAN_HPP_NAMESPACE::PerformanceCounterScopeKHR::eCommandBuffer,
      VULKAN_HPP_NAMESPACE::PerformanceCounterStorageKHR storage_ =
        VULKAN_HPP_NAMESPACE::PerformanceCounterStorageKHR::eInt32,
      std::array<uint8_t, VK_UUID_SIZE> const & uuid_ = {} ) VULKAN_HPP_NOEXCEPT
      : unit( unit_ )
      , scope( scope_ )
      , storage( storage_ )
      , uuid( uuid_ )
    {}

    VULKAN_HPP_CONSTEXPR_14 PerformanceCounterKHR( PerformanceCounterKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PerformanceCounterKHR( VkPerformanceCounterKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : PerformanceCounterKHR( *reinterpret_cast<PerformanceCounterKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PerformanceCounterKHR &
                            operator=( PerformanceCounterKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PerformanceCounterKHR & operator=( VkPerformanceCounterKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PerformanceCounterKHR const *>( &rhs );
      return *this;
    }

    operator VkPerformanceCounterKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPerformanceCounterKHR *>( this );
    }

    operator VkPerformanceCounterKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPerformanceCounterKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PerformanceCounterKHR const & ) const = default;
#else
    bool operator==( PerformanceCounterKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( unit == rhs.unit ) && ( scope == rhs.scope ) &&
             ( storage == rhs.storage ) && ( uuid == rhs.uuid );
    }

    bool operator!=( PerformanceCounterKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType              sType = StructureType::ePerformanceCounterKHR;
    const void *                                     pNext = {};
    VULKAN_HPP_NAMESPACE::PerformanceCounterUnitKHR  unit  = VULKAN_HPP_NAMESPACE::PerformanceCounterUnitKHR::eGeneric;
    VULKAN_HPP_NAMESPACE::PerformanceCounterScopeKHR scope =
      VULKAN_HPP_NAMESPACE::PerformanceCounterScopeKHR::eCommandBuffer;
    VULKAN_HPP_NAMESPACE::PerformanceCounterStorageKHR storage =
      VULKAN_HPP_NAMESPACE::PerformanceCounterStorageKHR::eInt32;
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<uint8_t, VK_UUID_SIZE> uuid = {};
  };
  static_assert( sizeof( PerformanceCounterKHR ) == sizeof( VkPerformanceCounterKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PerformanceCounterKHR>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePerformanceCounterKHR>
  {
    using Type = PerformanceCounterKHR;
  };

  union PerformanceCounterResultKHR
  {
    PerformanceCounterResultKHR( VULKAN_HPP_NAMESPACE::PerformanceCounterResultKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      memcpy( static_cast<void *>( this ), &rhs, sizeof( VULKAN_HPP_NAMESPACE::PerformanceCounterResultKHR ) );
    }

    PerformanceCounterResultKHR( int32_t int32_ = {} ) : int32( int32_ ) {}

    PerformanceCounterResultKHR( int64_t int64_ ) : int64( int64_ ) {}

    PerformanceCounterResultKHR( uint32_t uint32_ ) : uint32( uint32_ ) {}

    PerformanceCounterResultKHR( uint64_t uint64_ ) : uint64( uint64_ ) {}

    PerformanceCounterResultKHR( float float32_ ) : float32( float32_ ) {}

    PerformanceCounterResultKHR( double float64_ ) : float64( float64_ ) {}

    PerformanceCounterResultKHR & setInt32( int32_t int32_ ) VULKAN_HPP_NOEXCEPT
    {
      int32 = int32_;
      return *this;
    }

    PerformanceCounterResultKHR & setInt64( int64_t int64_ ) VULKAN_HPP_NOEXCEPT
    {
      int64 = int64_;
      return *this;
    }

    PerformanceCounterResultKHR & setUint32( uint32_t uint32_ ) VULKAN_HPP_NOEXCEPT
    {
      uint32 = uint32_;
      return *this;
    }

    PerformanceCounterResultKHR & setUint64( uint64_t uint64_ ) VULKAN_HPP_NOEXCEPT
    {
      uint64 = uint64_;
      return *this;
    }

    PerformanceCounterResultKHR & setFloat32( float float32_ ) VULKAN_HPP_NOEXCEPT
    {
      float32 = float32_;
      return *this;
    }

    PerformanceCounterResultKHR & setFloat64( double float64_ ) VULKAN_HPP_NOEXCEPT
    {
      float64 = float64_;
      return *this;
    }

    VULKAN_HPP_NAMESPACE::PerformanceCounterResultKHR &
      operator=( VULKAN_HPP_NAMESPACE::PerformanceCounterResultKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      memcpy( static_cast<void *>( this ), &rhs, sizeof( VULKAN_HPP_NAMESPACE::PerformanceCounterResultKHR ) );
      return *this;
    }

    operator VkPerformanceCounterResultKHR const &() const
    {
      return *reinterpret_cast<const VkPerformanceCounterResultKHR *>( this );
    }

    operator VkPerformanceCounterResultKHR &()
    {
      return *reinterpret_cast<VkPerformanceCounterResultKHR *>( this );
    }

    int32_t  int32;
    int64_t  int64;
    uint32_t uint32;
    uint64_t uint64;
    float    float32;
    double   float64;
  };

  struct PerformanceMarkerInfoINTEL
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::ePerformanceMarkerInfoINTEL;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PerformanceMarkerInfoINTEL( uint64_t marker_ = {} ) VULKAN_HPP_NOEXCEPT : marker( marker_ ) {}

    VULKAN_HPP_CONSTEXPR
      PerformanceMarkerInfoINTEL( PerformanceMarkerInfoINTEL const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PerformanceMarkerInfoINTEL( VkPerformanceMarkerInfoINTEL const & rhs ) VULKAN_HPP_NOEXCEPT
      : PerformanceMarkerInfoINTEL( *reinterpret_cast<PerformanceMarkerInfoINTEL const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PerformanceMarkerInfoINTEL &
                            operator=( PerformanceMarkerInfoINTEL const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PerformanceMarkerInfoINTEL & operator=( VkPerformanceMarkerInfoINTEL const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PerformanceMarkerInfoINTEL const *>( &rhs );
      return *this;
    }

    PerformanceMarkerInfoINTEL & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PerformanceMarkerInfoINTEL & setMarker( uint64_t marker_ ) VULKAN_HPP_NOEXCEPT
    {
      marker = marker_;
      return *this;
    }

    operator VkPerformanceMarkerInfoINTEL const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPerformanceMarkerInfoINTEL *>( this );
    }

    operator VkPerformanceMarkerInfoINTEL &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPerformanceMarkerInfoINTEL *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PerformanceMarkerInfoINTEL const & ) const = default;
#else
    bool operator==( PerformanceMarkerInfoINTEL const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( marker == rhs.marker );
    }

    bool operator!=( PerformanceMarkerInfoINTEL const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType  = StructureType::ePerformanceMarkerInfoINTEL;
    const void *                        pNext  = {};
    uint64_t                            marker = {};
  };
  static_assert( sizeof( PerformanceMarkerInfoINTEL ) == sizeof( VkPerformanceMarkerInfoINTEL ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PerformanceMarkerInfoINTEL>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePerformanceMarkerInfoINTEL>
  {
    using Type = PerformanceMarkerInfoINTEL;
  };

  struct PerformanceOverrideInfoINTEL
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::ePerformanceOverrideInfoINTEL;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      PerformanceOverrideInfoINTEL( VULKAN_HPP_NAMESPACE::PerformanceOverrideTypeINTEL type_ =
                                      VULKAN_HPP_NAMESPACE::PerformanceOverrideTypeINTEL::eNullHardware,
                                    VULKAN_HPP_NAMESPACE::Bool32 enable_    = {},
                                    uint64_t                     parameter_ = {} ) VULKAN_HPP_NOEXCEPT
      : type( type_ )
      , enable( enable_ )
      , parameter( parameter_ )
    {}

    VULKAN_HPP_CONSTEXPR
      PerformanceOverrideInfoINTEL( PerformanceOverrideInfoINTEL const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PerformanceOverrideInfoINTEL( VkPerformanceOverrideInfoINTEL const & rhs ) VULKAN_HPP_NOEXCEPT
      : PerformanceOverrideInfoINTEL( *reinterpret_cast<PerformanceOverrideInfoINTEL const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PerformanceOverrideInfoINTEL &
                            operator=( PerformanceOverrideInfoINTEL const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PerformanceOverrideInfoINTEL & operator=( VkPerformanceOverrideInfoINTEL const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PerformanceOverrideInfoINTEL const *>( &rhs );
      return *this;
    }

    PerformanceOverrideInfoINTEL & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PerformanceOverrideInfoINTEL &
      setType( VULKAN_HPP_NAMESPACE::PerformanceOverrideTypeINTEL type_ ) VULKAN_HPP_NOEXCEPT
    {
      type = type_;
      return *this;
    }

    PerformanceOverrideInfoINTEL & setEnable( VULKAN_HPP_NAMESPACE::Bool32 enable_ ) VULKAN_HPP_NOEXCEPT
    {
      enable = enable_;
      return *this;
    }

    PerformanceOverrideInfoINTEL & setParameter( uint64_t parameter_ ) VULKAN_HPP_NOEXCEPT
    {
      parameter = parameter_;
      return *this;
    }

    operator VkPerformanceOverrideInfoINTEL const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPerformanceOverrideInfoINTEL *>( this );
    }

    operator VkPerformanceOverrideInfoINTEL &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPerformanceOverrideInfoINTEL *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PerformanceOverrideInfoINTEL const & ) const = default;
#else
    bool operator==( PerformanceOverrideInfoINTEL const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( type == rhs.type ) && ( enable == rhs.enable ) &&
             ( parameter == rhs.parameter );
    }

    bool operator!=( PerformanceOverrideInfoINTEL const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                sType = StructureType::ePerformanceOverrideInfoINTEL;
    const void *                                       pNext = {};
    VULKAN_HPP_NAMESPACE::PerformanceOverrideTypeINTEL type =
      VULKAN_HPP_NAMESPACE::PerformanceOverrideTypeINTEL::eNullHardware;
    VULKAN_HPP_NAMESPACE::Bool32 enable    = {};
    uint64_t                     parameter = {};
  };
  static_assert( sizeof( PerformanceOverrideInfoINTEL ) == sizeof( VkPerformanceOverrideInfoINTEL ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PerformanceOverrideInfoINTEL>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePerformanceOverrideInfoINTEL>
  {
    using Type = PerformanceOverrideInfoINTEL;
  };

  struct PerformanceQuerySubmitInfoKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::ePerformanceQuerySubmitInfoKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PerformanceQuerySubmitInfoKHR( uint32_t counterPassIndex_ = {} ) VULKAN_HPP_NOEXCEPT
      : counterPassIndex( counterPassIndex_ )
    {}

    VULKAN_HPP_CONSTEXPR
      PerformanceQuerySubmitInfoKHR( PerformanceQuerySubmitInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PerformanceQuerySubmitInfoKHR( VkPerformanceQuerySubmitInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : PerformanceQuerySubmitInfoKHR( *reinterpret_cast<PerformanceQuerySubmitInfoKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PerformanceQuerySubmitInfoKHR &
                            operator=( PerformanceQuerySubmitInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PerformanceQuerySubmitInfoKHR & operator=( VkPerformanceQuerySubmitInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PerformanceQuerySubmitInfoKHR const *>( &rhs );
      return *this;
    }

    PerformanceQuerySubmitInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PerformanceQuerySubmitInfoKHR & setCounterPassIndex( uint32_t counterPassIndex_ ) VULKAN_HPP_NOEXCEPT
    {
      counterPassIndex = counterPassIndex_;
      return *this;
    }

    operator VkPerformanceQuerySubmitInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPerformanceQuerySubmitInfoKHR *>( this );
    }

    operator VkPerformanceQuerySubmitInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPerformanceQuerySubmitInfoKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PerformanceQuerySubmitInfoKHR const & ) const = default;
#else
    bool operator==( PerformanceQuerySubmitInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( counterPassIndex == rhs.counterPassIndex );
    }

    bool operator!=( PerformanceQuerySubmitInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType            = StructureType::ePerformanceQuerySubmitInfoKHR;
    const void *                        pNext            = {};
    uint32_t                            counterPassIndex = {};
  };
  static_assert( sizeof( PerformanceQuerySubmitInfoKHR ) == sizeof( VkPerformanceQuerySubmitInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PerformanceQuerySubmitInfoKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePerformanceQuerySubmitInfoKHR>
  {
    using Type = PerformanceQuerySubmitInfoKHR;
  };

  struct PerformanceStreamMarkerInfoINTEL
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::ePerformanceStreamMarkerInfoINTEL;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PerformanceStreamMarkerInfoINTEL( uint32_t marker_ = {} ) VULKAN_HPP_NOEXCEPT
      : marker( marker_ )
    {}

    VULKAN_HPP_CONSTEXPR
      PerformanceStreamMarkerInfoINTEL( PerformanceStreamMarkerInfoINTEL const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PerformanceStreamMarkerInfoINTEL( VkPerformanceStreamMarkerInfoINTEL const & rhs ) VULKAN_HPP_NOEXCEPT
      : PerformanceStreamMarkerInfoINTEL( *reinterpret_cast<PerformanceStreamMarkerInfoINTEL const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PerformanceStreamMarkerInfoINTEL &
                            operator=( PerformanceStreamMarkerInfoINTEL const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PerformanceStreamMarkerInfoINTEL & operator=( VkPerformanceStreamMarkerInfoINTEL const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PerformanceStreamMarkerInfoINTEL const *>( &rhs );
      return *this;
    }

    PerformanceStreamMarkerInfoINTEL & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PerformanceStreamMarkerInfoINTEL & setMarker( uint32_t marker_ ) VULKAN_HPP_NOEXCEPT
    {
      marker = marker_;
      return *this;
    }

    operator VkPerformanceStreamMarkerInfoINTEL const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPerformanceStreamMarkerInfoINTEL *>( this );
    }

    operator VkPerformanceStreamMarkerInfoINTEL &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPerformanceStreamMarkerInfoINTEL *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PerformanceStreamMarkerInfoINTEL const & ) const = default;
#else
    bool operator==( PerformanceStreamMarkerInfoINTEL const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( marker == rhs.marker );
    }

    bool operator!=( PerformanceStreamMarkerInfoINTEL const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType  = StructureType::ePerformanceStreamMarkerInfoINTEL;
    const void *                        pNext  = {};
    uint32_t                            marker = {};
  };
  static_assert( sizeof( PerformanceStreamMarkerInfoINTEL ) == sizeof( VkPerformanceStreamMarkerInfoINTEL ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PerformanceStreamMarkerInfoINTEL>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePerformanceStreamMarkerInfoINTEL>
  {
    using Type = PerformanceStreamMarkerInfoINTEL;
  };

  union PerformanceValueDataINTEL
  {
    PerformanceValueDataINTEL( VULKAN_HPP_NAMESPACE::PerformanceValueDataINTEL const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      memcpy( static_cast<void *>( this ), &rhs, sizeof( VULKAN_HPP_NAMESPACE::PerformanceValueDataINTEL ) );
    }

    PerformanceValueDataINTEL( uint32_t value32_ = {} ) : value32( value32_ ) {}

    PerformanceValueDataINTEL( uint64_t value64_ ) : value64( value64_ ) {}

    PerformanceValueDataINTEL( float valueFloat_ ) : valueFloat( valueFloat_ ) {}

    PerformanceValueDataINTEL( const char * valueString_ ) : valueString( valueString_ ) {}

    PerformanceValueDataINTEL & setValue32( uint32_t value32_ ) VULKAN_HPP_NOEXCEPT
    {
      value32 = value32_;
      return *this;
    }

    PerformanceValueDataINTEL & setValue64( uint64_t value64_ ) VULKAN_HPP_NOEXCEPT
    {
      value64 = value64_;
      return *this;
    }

    PerformanceValueDataINTEL & setValueFloat( float valueFloat_ ) VULKAN_HPP_NOEXCEPT
    {
      valueFloat = valueFloat_;
      return *this;
    }

    PerformanceValueDataINTEL & setValueBool( VULKAN_HPP_NAMESPACE::Bool32 valueBool_ ) VULKAN_HPP_NOEXCEPT
    {
      valueBool = valueBool_;
      return *this;
    }

    PerformanceValueDataINTEL & setValueString( const char * valueString_ ) VULKAN_HPP_NOEXCEPT
    {
      valueString = valueString_;
      return *this;
    }

    VULKAN_HPP_NAMESPACE::PerformanceValueDataINTEL &
      operator=( VULKAN_HPP_NAMESPACE::PerformanceValueDataINTEL const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      memcpy( static_cast<void *>( this ), &rhs, sizeof( VULKAN_HPP_NAMESPACE::PerformanceValueDataINTEL ) );
      return *this;
    }

    operator VkPerformanceValueDataINTEL const &() const
    {
      return *reinterpret_cast<const VkPerformanceValueDataINTEL *>( this );
    }

    operator VkPerformanceValueDataINTEL &()
    {
      return *reinterpret_cast<VkPerformanceValueDataINTEL *>( this );
    }

#ifdef VULKAN_HPP_HAS_UNRESTRICTED_UNIONS
    uint32_t                     value32;
    uint64_t                     value64;
    float                        valueFloat;
    VULKAN_HPP_NAMESPACE::Bool32 valueBool;
    const char *                 valueString;
#else
    uint32_t     value32;
    uint64_t     value64;
    float        valueFloat;
    VkBool32     valueBool;
    const char * valueString;
#endif /*VULKAN_HPP_HAS_UNRESTRICTED_UNIONS*/
  };

  struct PerformanceValueINTEL
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    PerformanceValueINTEL(
      VULKAN_HPP_NAMESPACE::PerformanceValueTypeINTEL type_ = VULKAN_HPP_NAMESPACE::PerformanceValueTypeINTEL::eUint32,
      VULKAN_HPP_NAMESPACE::PerformanceValueDataINTEL data_ = {} ) VULKAN_HPP_NOEXCEPT
      : type( type_ )
      , data( data_ )
    {}

    PerformanceValueINTEL( PerformanceValueINTEL const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PerformanceValueINTEL( VkPerformanceValueINTEL const & rhs ) VULKAN_HPP_NOEXCEPT
      : PerformanceValueINTEL( *reinterpret_cast<PerformanceValueINTEL const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    PerformanceValueINTEL & operator=( PerformanceValueINTEL const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PerformanceValueINTEL & operator=( VkPerformanceValueINTEL const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PerformanceValueINTEL const *>( &rhs );
      return *this;
    }

    PerformanceValueINTEL & setType( VULKAN_HPP_NAMESPACE::PerformanceValueTypeINTEL type_ ) VULKAN_HPP_NOEXCEPT
    {
      type = type_;
      return *this;
    }

    PerformanceValueINTEL & setData( VULKAN_HPP_NAMESPACE::PerformanceValueDataINTEL const & data_ ) VULKAN_HPP_NOEXCEPT
    {
      data = data_;
      return *this;
    }

    operator VkPerformanceValueINTEL const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPerformanceValueINTEL *>( this );
    }

    operator VkPerformanceValueINTEL &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPerformanceValueINTEL *>( this );
    }

  public:
    VULKAN_HPP_NAMESPACE::PerformanceValueTypeINTEL type = VULKAN_HPP_NAMESPACE::PerformanceValueTypeINTEL::eUint32;
    VULKAN_HPP_NAMESPACE::PerformanceValueDataINTEL data = {};
  };
  static_assert( sizeof( PerformanceValueINTEL ) == sizeof( VkPerformanceValueINTEL ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PerformanceValueINTEL>::value, "struct wrapper is not a standard layout!" );

  struct PhysicalDevice16BitStorageFeatures
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDevice16BitStorageFeatures;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      PhysicalDevice16BitStorageFeatures( VULKAN_HPP_NAMESPACE::Bool32 storageBuffer16BitAccess_           = {},
                                          VULKAN_HPP_NAMESPACE::Bool32 uniformAndStorageBuffer16BitAccess_ = {},
                                          VULKAN_HPP_NAMESPACE::Bool32 storagePushConstant16_              = {},
                                          VULKAN_HPP_NAMESPACE::Bool32 storageInputOutput16_ = {} ) VULKAN_HPP_NOEXCEPT
      : storageBuffer16BitAccess( storageBuffer16BitAccess_ )
      , uniformAndStorageBuffer16BitAccess( uniformAndStorageBuffer16BitAccess_ )
      , storagePushConstant16( storagePushConstant16_ )
      , storageInputOutput16( storageInputOutput16_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDevice16BitStorageFeatures( PhysicalDevice16BitStorageFeatures const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    PhysicalDevice16BitStorageFeatures( VkPhysicalDevice16BitStorageFeatures const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDevice16BitStorageFeatures( *reinterpret_cast<PhysicalDevice16BitStorageFeatures const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDevice16BitStorageFeatures &
                            operator=( PhysicalDevice16BitStorageFeatures const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDevice16BitStorageFeatures &
      operator=( VkPhysicalDevice16BitStorageFeatures const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDevice16BitStorageFeatures const *>( &rhs );
      return *this;
    }

    PhysicalDevice16BitStorageFeatures & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDevice16BitStorageFeatures &
      setStorageBuffer16BitAccess( VULKAN_HPP_NAMESPACE::Bool32 storageBuffer16BitAccess_ ) VULKAN_HPP_NOEXCEPT
    {
      storageBuffer16BitAccess = storageBuffer16BitAccess_;
      return *this;
    }

    PhysicalDevice16BitStorageFeatures & setUniformAndStorageBuffer16BitAccess(
      VULKAN_HPP_NAMESPACE::Bool32 uniformAndStorageBuffer16BitAccess_ ) VULKAN_HPP_NOEXCEPT
    {
      uniformAndStorageBuffer16BitAccess = uniformAndStorageBuffer16BitAccess_;
      return *this;
    }

    PhysicalDevice16BitStorageFeatures &
      setStoragePushConstant16( VULKAN_HPP_NAMESPACE::Bool32 storagePushConstant16_ ) VULKAN_HPP_NOEXCEPT
    {
      storagePushConstant16 = storagePushConstant16_;
      return *this;
    }

    PhysicalDevice16BitStorageFeatures &
      setStorageInputOutput16( VULKAN_HPP_NAMESPACE::Bool32 storageInputOutput16_ ) VULKAN_HPP_NOEXCEPT
    {
      storageInputOutput16 = storageInputOutput16_;
      return *this;
    }

    operator VkPhysicalDevice16BitStorageFeatures const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDevice16BitStorageFeatures *>( this );
    }

    operator VkPhysicalDevice16BitStorageFeatures &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDevice16BitStorageFeatures *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDevice16BitStorageFeatures const & ) const = default;
#else
    bool         operator==( PhysicalDevice16BitStorageFeatures const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( storageBuffer16BitAccess == rhs.storageBuffer16BitAccess ) &&
             ( uniformAndStorageBuffer16BitAccess == rhs.uniformAndStorageBuffer16BitAccess ) &&
             ( storagePushConstant16 == rhs.storagePushConstant16 ) &&
             ( storageInputOutput16 == rhs.storageInputOutput16 );
    }

    bool operator!=( PhysicalDevice16BitStorageFeatures const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType                    = StructureType::ePhysicalDevice16BitStorageFeatures;
    void *                              pNext                    = {};
    VULKAN_HPP_NAMESPACE::Bool32        storageBuffer16BitAccess = {};
    VULKAN_HPP_NAMESPACE::Bool32        uniformAndStorageBuffer16BitAccess = {};
    VULKAN_HPP_NAMESPACE::Bool32        storagePushConstant16              = {};
    VULKAN_HPP_NAMESPACE::Bool32        storageInputOutput16               = {};
  };
  static_assert( sizeof( PhysicalDevice16BitStorageFeatures ) == sizeof( VkPhysicalDevice16BitStorageFeatures ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDevice16BitStorageFeatures>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDevice16BitStorageFeatures>
  {
    using Type = PhysicalDevice16BitStorageFeatures;
  };
  using PhysicalDevice16BitStorageFeaturesKHR = PhysicalDevice16BitStorageFeatures;

  struct PhysicalDevice4444FormatsFeaturesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDevice4444FormatsFeaturesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      PhysicalDevice4444FormatsFeaturesEXT( VULKAN_HPP_NAMESPACE::Bool32 formatA4R4G4B4_ = {},
                                            VULKAN_HPP_NAMESPACE::Bool32 formatA4B4G4R4_ = {} ) VULKAN_HPP_NOEXCEPT
      : formatA4R4G4B4( formatA4R4G4B4_ )
      , formatA4B4G4R4( formatA4B4G4R4_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDevice4444FormatsFeaturesEXT( PhysicalDevice4444FormatsFeaturesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    PhysicalDevice4444FormatsFeaturesEXT( VkPhysicalDevice4444FormatsFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDevice4444FormatsFeaturesEXT( *reinterpret_cast<PhysicalDevice4444FormatsFeaturesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDevice4444FormatsFeaturesEXT &
                            operator=( PhysicalDevice4444FormatsFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDevice4444FormatsFeaturesEXT &
      operator=( VkPhysicalDevice4444FormatsFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDevice4444FormatsFeaturesEXT const *>( &rhs );
      return *this;
    }

    PhysicalDevice4444FormatsFeaturesEXT & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDevice4444FormatsFeaturesEXT &
      setFormatA4R4G4B4( VULKAN_HPP_NAMESPACE::Bool32 formatA4R4G4B4_ ) VULKAN_HPP_NOEXCEPT
    {
      formatA4R4G4B4 = formatA4R4G4B4_;
      return *this;
    }

    PhysicalDevice4444FormatsFeaturesEXT &
      setFormatA4B4G4R4( VULKAN_HPP_NAMESPACE::Bool32 formatA4B4G4R4_ ) VULKAN_HPP_NOEXCEPT
    {
      formatA4B4G4R4 = formatA4B4G4R4_;
      return *this;
    }

    operator VkPhysicalDevice4444FormatsFeaturesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDevice4444FormatsFeaturesEXT *>( this );
    }

    operator VkPhysicalDevice4444FormatsFeaturesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDevice4444FormatsFeaturesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDevice4444FormatsFeaturesEXT const & ) const = default;
#else
    bool operator==( PhysicalDevice4444FormatsFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( formatA4R4G4B4 == rhs.formatA4R4G4B4 ) &&
             ( formatA4B4G4R4 == rhs.formatA4B4G4R4 );
    }

    bool operator!=( PhysicalDevice4444FormatsFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType          = StructureType::ePhysicalDevice4444FormatsFeaturesEXT;
    void *                              pNext          = {};
    VULKAN_HPP_NAMESPACE::Bool32        formatA4R4G4B4 = {};
    VULKAN_HPP_NAMESPACE::Bool32        formatA4B4G4R4 = {};
  };
  static_assert( sizeof( PhysicalDevice4444FormatsFeaturesEXT ) == sizeof( VkPhysicalDevice4444FormatsFeaturesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDevice4444FormatsFeaturesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDevice4444FormatsFeaturesEXT>
  {
    using Type = PhysicalDevice4444FormatsFeaturesEXT;
  };

  struct PhysicalDevice8BitStorageFeatures
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDevice8BitStorageFeatures;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      PhysicalDevice8BitStorageFeatures( VULKAN_HPP_NAMESPACE::Bool32 storageBuffer8BitAccess_           = {},
                                         VULKAN_HPP_NAMESPACE::Bool32 uniformAndStorageBuffer8BitAccess_ = {},
                                         VULKAN_HPP_NAMESPACE::Bool32 storagePushConstant8_ = {} ) VULKAN_HPP_NOEXCEPT
      : storageBuffer8BitAccess( storageBuffer8BitAccess_ )
      , uniformAndStorageBuffer8BitAccess( uniformAndStorageBuffer8BitAccess_ )
      , storagePushConstant8( storagePushConstant8_ )
    {}

    VULKAN_HPP_CONSTEXPR
      PhysicalDevice8BitStorageFeatures( PhysicalDevice8BitStorageFeatures const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDevice8BitStorageFeatures( VkPhysicalDevice8BitStorageFeatures const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDevice8BitStorageFeatures( *reinterpret_cast<PhysicalDevice8BitStorageFeatures const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDevice8BitStorageFeatures &
                            operator=( PhysicalDevice8BitStorageFeatures const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDevice8BitStorageFeatures & operator=( VkPhysicalDevice8BitStorageFeatures const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDevice8BitStorageFeatures const *>( &rhs );
      return *this;
    }

    PhysicalDevice8BitStorageFeatures & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDevice8BitStorageFeatures &
      setStorageBuffer8BitAccess( VULKAN_HPP_NAMESPACE::Bool32 storageBuffer8BitAccess_ ) VULKAN_HPP_NOEXCEPT
    {
      storageBuffer8BitAccess = storageBuffer8BitAccess_;
      return *this;
    }

    PhysicalDevice8BitStorageFeatures & setUniformAndStorageBuffer8BitAccess(
      VULKAN_HPP_NAMESPACE::Bool32 uniformAndStorageBuffer8BitAccess_ ) VULKAN_HPP_NOEXCEPT
    {
      uniformAndStorageBuffer8BitAccess = uniformAndStorageBuffer8BitAccess_;
      return *this;
    }

    PhysicalDevice8BitStorageFeatures &
      setStoragePushConstant8( VULKAN_HPP_NAMESPACE::Bool32 storagePushConstant8_ ) VULKAN_HPP_NOEXCEPT
    {
      storagePushConstant8 = storagePushConstant8_;
      return *this;
    }

    operator VkPhysicalDevice8BitStorageFeatures const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDevice8BitStorageFeatures *>( this );
    }

    operator VkPhysicalDevice8BitStorageFeatures &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDevice8BitStorageFeatures *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDevice8BitStorageFeatures const & ) const = default;
#else
    bool operator==( PhysicalDevice8BitStorageFeatures const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( storageBuffer8BitAccess == rhs.storageBuffer8BitAccess ) &&
             ( uniformAndStorageBuffer8BitAccess == rhs.uniformAndStorageBuffer8BitAccess ) &&
             ( storagePushConstant8 == rhs.storagePushConstant8 );
    }

    bool operator!=( PhysicalDevice8BitStorageFeatures const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType                   = StructureType::ePhysicalDevice8BitStorageFeatures;
    void *                              pNext                   = {};
    VULKAN_HPP_NAMESPACE::Bool32        storageBuffer8BitAccess = {};
    VULKAN_HPP_NAMESPACE::Bool32        uniformAndStorageBuffer8BitAccess = {};
    VULKAN_HPP_NAMESPACE::Bool32        storagePushConstant8              = {};
  };
  static_assert( sizeof( PhysicalDevice8BitStorageFeatures ) == sizeof( VkPhysicalDevice8BitStorageFeatures ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDevice8BitStorageFeatures>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDevice8BitStorageFeatures>
  {
    using Type = PhysicalDevice8BitStorageFeatures;
  };
  using PhysicalDevice8BitStorageFeaturesKHR = PhysicalDevice8BitStorageFeatures;

  struct PhysicalDeviceASTCDecodeFeaturesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceAstcDecodeFeaturesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceASTCDecodeFeaturesEXT(
      VULKAN_HPP_NAMESPACE::Bool32 decodeModeSharedExponent_ = {} ) VULKAN_HPP_NOEXCEPT
      : decodeModeSharedExponent( decodeModeSharedExponent_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceASTCDecodeFeaturesEXT( PhysicalDeviceASTCDecodeFeaturesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceASTCDecodeFeaturesEXT( VkPhysicalDeviceASTCDecodeFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceASTCDecodeFeaturesEXT( *reinterpret_cast<PhysicalDeviceASTCDecodeFeaturesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceASTCDecodeFeaturesEXT &
                            operator=( PhysicalDeviceASTCDecodeFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceASTCDecodeFeaturesEXT &
      operator=( VkPhysicalDeviceASTCDecodeFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceASTCDecodeFeaturesEXT const *>( &rhs );
      return *this;
    }

    PhysicalDeviceASTCDecodeFeaturesEXT & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceASTCDecodeFeaturesEXT &
      setDecodeModeSharedExponent( VULKAN_HPP_NAMESPACE::Bool32 decodeModeSharedExponent_ ) VULKAN_HPP_NOEXCEPT
    {
      decodeModeSharedExponent = decodeModeSharedExponent_;
      return *this;
    }

    operator VkPhysicalDeviceASTCDecodeFeaturesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceASTCDecodeFeaturesEXT *>( this );
    }

    operator VkPhysicalDeviceASTCDecodeFeaturesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceASTCDecodeFeaturesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceASTCDecodeFeaturesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceASTCDecodeFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( decodeModeSharedExponent == rhs.decodeModeSharedExponent );
    }

    bool operator!=( PhysicalDeviceASTCDecodeFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType                    = StructureType::ePhysicalDeviceAstcDecodeFeaturesEXT;
    void *                              pNext                    = {};
    VULKAN_HPP_NAMESPACE::Bool32        decodeModeSharedExponent = {};
  };
  static_assert( sizeof( PhysicalDeviceASTCDecodeFeaturesEXT ) == sizeof( VkPhysicalDeviceASTCDecodeFeaturesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceASTCDecodeFeaturesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceAstcDecodeFeaturesEXT>
  {
    using Type = PhysicalDeviceASTCDecodeFeaturesEXT;
  };

  struct PhysicalDeviceAccelerationStructureFeaturesKHR
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceAccelerationStructureFeaturesKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceAccelerationStructureFeaturesKHR(
      VULKAN_HPP_NAMESPACE::Bool32 accelerationStructure_                                 = {},
      VULKAN_HPP_NAMESPACE::Bool32 accelerationStructureCaptureReplay_                    = {},
      VULKAN_HPP_NAMESPACE::Bool32 accelerationStructureIndirectBuild_                    = {},
      VULKAN_HPP_NAMESPACE::Bool32 accelerationStructureHostCommands_                     = {},
      VULKAN_HPP_NAMESPACE::Bool32 descriptorBindingAccelerationStructureUpdateAfterBind_ = {} ) VULKAN_HPP_NOEXCEPT
      : accelerationStructure( accelerationStructure_ )
      , accelerationStructureCaptureReplay( accelerationStructureCaptureReplay_ )
      , accelerationStructureIndirectBuild( accelerationStructureIndirectBuild_ )
      , accelerationStructureHostCommands( accelerationStructureHostCommands_ )
      , descriptorBindingAccelerationStructureUpdateAfterBind( descriptorBindingAccelerationStructureUpdateAfterBind_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceAccelerationStructureFeaturesKHR(
      PhysicalDeviceAccelerationStructureFeaturesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceAccelerationStructureFeaturesKHR( VkPhysicalDeviceAccelerationStructureFeaturesKHR const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceAccelerationStructureFeaturesKHR(
          *reinterpret_cast<PhysicalDeviceAccelerationStructureFeaturesKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceAccelerationStructureFeaturesKHR &
                            operator=( PhysicalDeviceAccelerationStructureFeaturesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceAccelerationStructureFeaturesKHR &
      operator=( VkPhysicalDeviceAccelerationStructureFeaturesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceAccelerationStructureFeaturesKHR const *>( &rhs );
      return *this;
    }

    PhysicalDeviceAccelerationStructureFeaturesKHR & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceAccelerationStructureFeaturesKHR &
      setAccelerationStructure( VULKAN_HPP_NAMESPACE::Bool32 accelerationStructure_ ) VULKAN_HPP_NOEXCEPT
    {
      accelerationStructure = accelerationStructure_;
      return *this;
    }

    PhysicalDeviceAccelerationStructureFeaturesKHR & setAccelerationStructureCaptureReplay(
      VULKAN_HPP_NAMESPACE::Bool32 accelerationStructureCaptureReplay_ ) VULKAN_HPP_NOEXCEPT
    {
      accelerationStructureCaptureReplay = accelerationStructureCaptureReplay_;
      return *this;
    }

    PhysicalDeviceAccelerationStructureFeaturesKHR & setAccelerationStructureIndirectBuild(
      VULKAN_HPP_NAMESPACE::Bool32 accelerationStructureIndirectBuild_ ) VULKAN_HPP_NOEXCEPT
    {
      accelerationStructureIndirectBuild = accelerationStructureIndirectBuild_;
      return *this;
    }

    PhysicalDeviceAccelerationStructureFeaturesKHR & setAccelerationStructureHostCommands(
      VULKAN_HPP_NAMESPACE::Bool32 accelerationStructureHostCommands_ ) VULKAN_HPP_NOEXCEPT
    {
      accelerationStructureHostCommands = accelerationStructureHostCommands_;
      return *this;
    }

    PhysicalDeviceAccelerationStructureFeaturesKHR & setDescriptorBindingAccelerationStructureUpdateAfterBind(
      VULKAN_HPP_NAMESPACE::Bool32 descriptorBindingAccelerationStructureUpdateAfterBind_ ) VULKAN_HPP_NOEXCEPT
    {
      descriptorBindingAccelerationStructureUpdateAfterBind = descriptorBindingAccelerationStructureUpdateAfterBind_;
      return *this;
    }

    operator VkPhysicalDeviceAccelerationStructureFeaturesKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceAccelerationStructureFeaturesKHR *>( this );
    }

    operator VkPhysicalDeviceAccelerationStructureFeaturesKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceAccelerationStructureFeaturesKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceAccelerationStructureFeaturesKHR const & ) const = default;
#else
    bool operator==( PhysicalDeviceAccelerationStructureFeaturesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( accelerationStructure == rhs.accelerationStructure ) &&
             ( accelerationStructureCaptureReplay == rhs.accelerationStructureCaptureReplay ) &&
             ( accelerationStructureIndirectBuild == rhs.accelerationStructureIndirectBuild ) &&
             ( accelerationStructureHostCommands == rhs.accelerationStructureHostCommands ) &&
             ( descriptorBindingAccelerationStructureUpdateAfterBind ==
               rhs.descriptorBindingAccelerationStructureUpdateAfterBind );
    }

    bool operator!=( PhysicalDeviceAccelerationStructureFeaturesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceAccelerationStructureFeaturesKHR;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        accelerationStructure                                 = {};
    VULKAN_HPP_NAMESPACE::Bool32        accelerationStructureCaptureReplay                    = {};
    VULKAN_HPP_NAMESPACE::Bool32        accelerationStructureIndirectBuild                    = {};
    VULKAN_HPP_NAMESPACE::Bool32        accelerationStructureHostCommands                     = {};
    VULKAN_HPP_NAMESPACE::Bool32        descriptorBindingAccelerationStructureUpdateAfterBind = {};
  };
  static_assert( sizeof( PhysicalDeviceAccelerationStructureFeaturesKHR ) ==
                   sizeof( VkPhysicalDeviceAccelerationStructureFeaturesKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceAccelerationStructureFeaturesKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceAccelerationStructureFeaturesKHR>
  {
    using Type = PhysicalDeviceAccelerationStructureFeaturesKHR;
  };

  struct PhysicalDeviceAccelerationStructurePropertiesKHR
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceAccelerationStructurePropertiesKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceAccelerationStructurePropertiesKHR(
      uint64_t maxGeometryCount_                                           = {},
      uint64_t maxInstanceCount_                                           = {},
      uint64_t maxPrimitiveCount_                                          = {},
      uint32_t maxPerStageDescriptorAccelerationStructures_                = {},
      uint32_t maxPerStageDescriptorUpdateAfterBindAccelerationStructures_ = {},
      uint32_t maxDescriptorSetAccelerationStructures_                     = {},
      uint32_t maxDescriptorSetUpdateAfterBindAccelerationStructures_      = {},
      uint32_t minAccelerationStructureScratchOffsetAlignment_             = {} ) VULKAN_HPP_NOEXCEPT
      : maxGeometryCount( maxGeometryCount_ )
      , maxInstanceCount( maxInstanceCount_ )
      , maxPrimitiveCount( maxPrimitiveCount_ )
      , maxPerStageDescriptorAccelerationStructures( maxPerStageDescriptorAccelerationStructures_ )
      , maxPerStageDescriptorUpdateAfterBindAccelerationStructures(
          maxPerStageDescriptorUpdateAfterBindAccelerationStructures_ )
      , maxDescriptorSetAccelerationStructures( maxDescriptorSetAccelerationStructures_ )
      , maxDescriptorSetUpdateAfterBindAccelerationStructures( maxDescriptorSetUpdateAfterBindAccelerationStructures_ )
      , minAccelerationStructureScratchOffsetAlignment( minAccelerationStructureScratchOffsetAlignment_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceAccelerationStructurePropertiesKHR(
      PhysicalDeviceAccelerationStructurePropertiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceAccelerationStructurePropertiesKHR( VkPhysicalDeviceAccelerationStructurePropertiesKHR const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceAccelerationStructurePropertiesKHR(
          *reinterpret_cast<PhysicalDeviceAccelerationStructurePropertiesKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceAccelerationStructurePropertiesKHR &
                            operator=( PhysicalDeviceAccelerationStructurePropertiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceAccelerationStructurePropertiesKHR &
      operator=( VkPhysicalDeviceAccelerationStructurePropertiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceAccelerationStructurePropertiesKHR const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceAccelerationStructurePropertiesKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceAccelerationStructurePropertiesKHR *>( this );
    }

    operator VkPhysicalDeviceAccelerationStructurePropertiesKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceAccelerationStructurePropertiesKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceAccelerationStructurePropertiesKHR const & ) const = default;
#else
    bool operator==( PhysicalDeviceAccelerationStructurePropertiesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( maxGeometryCount == rhs.maxGeometryCount ) &&
             ( maxInstanceCount == rhs.maxInstanceCount ) && ( maxPrimitiveCount == rhs.maxPrimitiveCount ) &&
             ( maxPerStageDescriptorAccelerationStructures == rhs.maxPerStageDescriptorAccelerationStructures ) &&
             ( maxPerStageDescriptorUpdateAfterBindAccelerationStructures ==
               rhs.maxPerStageDescriptorUpdateAfterBindAccelerationStructures ) &&
             ( maxDescriptorSetAccelerationStructures == rhs.maxDescriptorSetAccelerationStructures ) &&
             ( maxDescriptorSetUpdateAfterBindAccelerationStructures ==
               rhs.maxDescriptorSetUpdateAfterBindAccelerationStructures ) &&
             ( minAccelerationStructureScratchOffsetAlignment == rhs.minAccelerationStructureScratchOffsetAlignment );
    }

    bool operator!=( PhysicalDeviceAccelerationStructurePropertiesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceAccelerationStructurePropertiesKHR;
    void *                              pNext = {};
    uint64_t                            maxGeometryCount                                           = {};
    uint64_t                            maxInstanceCount                                           = {};
    uint64_t                            maxPrimitiveCount                                          = {};
    uint32_t                            maxPerStageDescriptorAccelerationStructures                = {};
    uint32_t                            maxPerStageDescriptorUpdateAfterBindAccelerationStructures = {};
    uint32_t                            maxDescriptorSetAccelerationStructures                     = {};
    uint32_t                            maxDescriptorSetUpdateAfterBindAccelerationStructures      = {};
    uint32_t                            minAccelerationStructureScratchOffsetAlignment             = {};
  };
  static_assert( sizeof( PhysicalDeviceAccelerationStructurePropertiesKHR ) ==
                   sizeof( VkPhysicalDeviceAccelerationStructurePropertiesKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceAccelerationStructurePropertiesKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceAccelerationStructurePropertiesKHR>
  {
    using Type = PhysicalDeviceAccelerationStructurePropertiesKHR;
  };

  struct PhysicalDeviceBlendOperationAdvancedFeaturesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceBlendOperationAdvancedFeaturesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceBlendOperationAdvancedFeaturesEXT(
      VULKAN_HPP_NAMESPACE::Bool32 advancedBlendCoherentOperations_ = {} ) VULKAN_HPP_NOEXCEPT
      : advancedBlendCoherentOperations( advancedBlendCoherentOperations_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceBlendOperationAdvancedFeaturesEXT(
      PhysicalDeviceBlendOperationAdvancedFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceBlendOperationAdvancedFeaturesEXT( VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceBlendOperationAdvancedFeaturesEXT(
          *reinterpret_cast<PhysicalDeviceBlendOperationAdvancedFeaturesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceBlendOperationAdvancedFeaturesEXT &
                            operator=( PhysicalDeviceBlendOperationAdvancedFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceBlendOperationAdvancedFeaturesEXT &
      operator=( VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceBlendOperationAdvancedFeaturesEXT const *>( &rhs );
      return *this;
    }

    PhysicalDeviceBlendOperationAdvancedFeaturesEXT & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceBlendOperationAdvancedFeaturesEXT & setAdvancedBlendCoherentOperations(
      VULKAN_HPP_NAMESPACE::Bool32 advancedBlendCoherentOperations_ ) VULKAN_HPP_NOEXCEPT
    {
      advancedBlendCoherentOperations = advancedBlendCoherentOperations_;
      return *this;
    }

    operator VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT *>( this );
    }

    operator VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceBlendOperationAdvancedFeaturesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceBlendOperationAdvancedFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( advancedBlendCoherentOperations == rhs.advancedBlendCoherentOperations );
    }

    bool operator!=( PhysicalDeviceBlendOperationAdvancedFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceBlendOperationAdvancedFeaturesEXT;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        advancedBlendCoherentOperations = {};
  };
  static_assert( sizeof( PhysicalDeviceBlendOperationAdvancedFeaturesEXT ) ==
                   sizeof( VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceBlendOperationAdvancedFeaturesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceBlendOperationAdvancedFeaturesEXT>
  {
    using Type = PhysicalDeviceBlendOperationAdvancedFeaturesEXT;
  };

  struct PhysicalDeviceBlendOperationAdvancedPropertiesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceBlendOperationAdvancedPropertiesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceBlendOperationAdvancedPropertiesEXT(
      uint32_t                     advancedBlendMaxColorAttachments_      = {},
      VULKAN_HPP_NAMESPACE::Bool32 advancedBlendIndependentBlend_         = {},
      VULKAN_HPP_NAMESPACE::Bool32 advancedBlendNonPremultipliedSrcColor_ = {},
      VULKAN_HPP_NAMESPACE::Bool32 advancedBlendNonPremultipliedDstColor_ = {},
      VULKAN_HPP_NAMESPACE::Bool32 advancedBlendCorrelatedOverlap_        = {},
      VULKAN_HPP_NAMESPACE::Bool32 advancedBlendAllOperations_            = {} ) VULKAN_HPP_NOEXCEPT
      : advancedBlendMaxColorAttachments( advancedBlendMaxColorAttachments_ )
      , advancedBlendIndependentBlend( advancedBlendIndependentBlend_ )
      , advancedBlendNonPremultipliedSrcColor( advancedBlendNonPremultipliedSrcColor_ )
      , advancedBlendNonPremultipliedDstColor( advancedBlendNonPremultipliedDstColor_ )
      , advancedBlendCorrelatedOverlap( advancedBlendCorrelatedOverlap_ )
      , advancedBlendAllOperations( advancedBlendAllOperations_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceBlendOperationAdvancedPropertiesEXT(
      PhysicalDeviceBlendOperationAdvancedPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceBlendOperationAdvancedPropertiesEXT( VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceBlendOperationAdvancedPropertiesEXT(
          *reinterpret_cast<PhysicalDeviceBlendOperationAdvancedPropertiesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceBlendOperationAdvancedPropertiesEXT &
                            operator=( PhysicalDeviceBlendOperationAdvancedPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceBlendOperationAdvancedPropertiesEXT &
      operator=( VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this =
        *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceBlendOperationAdvancedPropertiesEXT const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT *>( this );
    }

    operator VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceBlendOperationAdvancedPropertiesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceBlendOperationAdvancedPropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( advancedBlendMaxColorAttachments == rhs.advancedBlendMaxColorAttachments ) &&
             ( advancedBlendIndependentBlend == rhs.advancedBlendIndependentBlend ) &&
             ( advancedBlendNonPremultipliedSrcColor == rhs.advancedBlendNonPremultipliedSrcColor ) &&
             ( advancedBlendNonPremultipliedDstColor == rhs.advancedBlendNonPremultipliedDstColor ) &&
             ( advancedBlendCorrelatedOverlap == rhs.advancedBlendCorrelatedOverlap ) &&
             ( advancedBlendAllOperations == rhs.advancedBlendAllOperations );
    }

    bool operator!=( PhysicalDeviceBlendOperationAdvancedPropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceBlendOperationAdvancedPropertiesEXT;
    void *                              pNext = {};
    uint32_t                            advancedBlendMaxColorAttachments      = {};
    VULKAN_HPP_NAMESPACE::Bool32        advancedBlendIndependentBlend         = {};
    VULKAN_HPP_NAMESPACE::Bool32        advancedBlendNonPremultipliedSrcColor = {};
    VULKAN_HPP_NAMESPACE::Bool32        advancedBlendNonPremultipliedDstColor = {};
    VULKAN_HPP_NAMESPACE::Bool32        advancedBlendCorrelatedOverlap        = {};
    VULKAN_HPP_NAMESPACE::Bool32        advancedBlendAllOperations            = {};
  };
  static_assert( sizeof( PhysicalDeviceBlendOperationAdvancedPropertiesEXT ) ==
                   sizeof( VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceBlendOperationAdvancedPropertiesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceBlendOperationAdvancedPropertiesEXT>
  {
    using Type = PhysicalDeviceBlendOperationAdvancedPropertiesEXT;
  };

  struct PhysicalDeviceBufferDeviceAddressFeatures
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceBufferDeviceAddressFeatures;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceBufferDeviceAddressFeatures(
      VULKAN_HPP_NAMESPACE::Bool32 bufferDeviceAddress_              = {},
      VULKAN_HPP_NAMESPACE::Bool32 bufferDeviceAddressCaptureReplay_ = {},
      VULKAN_HPP_NAMESPACE::Bool32 bufferDeviceAddressMultiDevice_   = {} ) VULKAN_HPP_NOEXCEPT
      : bufferDeviceAddress( bufferDeviceAddress_ )
      , bufferDeviceAddressCaptureReplay( bufferDeviceAddressCaptureReplay_ )
      , bufferDeviceAddressMultiDevice( bufferDeviceAddressMultiDevice_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceBufferDeviceAddressFeatures(
      PhysicalDeviceBufferDeviceAddressFeatures const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceBufferDeviceAddressFeatures( VkPhysicalDeviceBufferDeviceAddressFeatures const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceBufferDeviceAddressFeatures(
          *reinterpret_cast<PhysicalDeviceBufferDeviceAddressFeatures const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceBufferDeviceAddressFeatures &
                            operator=( PhysicalDeviceBufferDeviceAddressFeatures const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceBufferDeviceAddressFeatures &
      operator=( VkPhysicalDeviceBufferDeviceAddressFeatures const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceBufferDeviceAddressFeatures const *>( &rhs );
      return *this;
    }

    PhysicalDeviceBufferDeviceAddressFeatures & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceBufferDeviceAddressFeatures &
      setBufferDeviceAddress( VULKAN_HPP_NAMESPACE::Bool32 bufferDeviceAddress_ ) VULKAN_HPP_NOEXCEPT
    {
      bufferDeviceAddress = bufferDeviceAddress_;
      return *this;
    }

    PhysicalDeviceBufferDeviceAddressFeatures & setBufferDeviceAddressCaptureReplay(
      VULKAN_HPP_NAMESPACE::Bool32 bufferDeviceAddressCaptureReplay_ ) VULKAN_HPP_NOEXCEPT
    {
      bufferDeviceAddressCaptureReplay = bufferDeviceAddressCaptureReplay_;
      return *this;
    }

    PhysicalDeviceBufferDeviceAddressFeatures & setBufferDeviceAddressMultiDevice(
      VULKAN_HPP_NAMESPACE::Bool32 bufferDeviceAddressMultiDevice_ ) VULKAN_HPP_NOEXCEPT
    {
      bufferDeviceAddressMultiDevice = bufferDeviceAddressMultiDevice_;
      return *this;
    }

    operator VkPhysicalDeviceBufferDeviceAddressFeatures const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceBufferDeviceAddressFeatures *>( this );
    }

    operator VkPhysicalDeviceBufferDeviceAddressFeatures &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceBufferDeviceAddressFeatures *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceBufferDeviceAddressFeatures const & ) const = default;
#else
    bool operator==( PhysicalDeviceBufferDeviceAddressFeatures const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( bufferDeviceAddress == rhs.bufferDeviceAddress ) &&
             ( bufferDeviceAddressCaptureReplay == rhs.bufferDeviceAddressCaptureReplay ) &&
             ( bufferDeviceAddressMultiDevice == rhs.bufferDeviceAddressMultiDevice );
    }

    bool operator!=( PhysicalDeviceBufferDeviceAddressFeatures const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType               = StructureType::ePhysicalDeviceBufferDeviceAddressFeatures;
    void *                              pNext               = {};
    VULKAN_HPP_NAMESPACE::Bool32        bufferDeviceAddress = {};
    VULKAN_HPP_NAMESPACE::Bool32        bufferDeviceAddressCaptureReplay = {};
    VULKAN_HPP_NAMESPACE::Bool32        bufferDeviceAddressMultiDevice   = {};
  };
  static_assert( sizeof( PhysicalDeviceBufferDeviceAddressFeatures ) ==
                   sizeof( VkPhysicalDeviceBufferDeviceAddressFeatures ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceBufferDeviceAddressFeatures>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceBufferDeviceAddressFeatures>
  {
    using Type = PhysicalDeviceBufferDeviceAddressFeatures;
  };
  using PhysicalDeviceBufferDeviceAddressFeaturesKHR = PhysicalDeviceBufferDeviceAddressFeatures;

  struct PhysicalDeviceBufferDeviceAddressFeaturesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceBufferDeviceAddressFeaturesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceBufferDeviceAddressFeaturesEXT(
      VULKAN_HPP_NAMESPACE::Bool32 bufferDeviceAddress_              = {},
      VULKAN_HPP_NAMESPACE::Bool32 bufferDeviceAddressCaptureReplay_ = {},
      VULKAN_HPP_NAMESPACE::Bool32 bufferDeviceAddressMultiDevice_   = {} ) VULKAN_HPP_NOEXCEPT
      : bufferDeviceAddress( bufferDeviceAddress_ )
      , bufferDeviceAddressCaptureReplay( bufferDeviceAddressCaptureReplay_ )
      , bufferDeviceAddressMultiDevice( bufferDeviceAddressMultiDevice_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceBufferDeviceAddressFeaturesEXT(
      PhysicalDeviceBufferDeviceAddressFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceBufferDeviceAddressFeaturesEXT( VkPhysicalDeviceBufferDeviceAddressFeaturesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceBufferDeviceAddressFeaturesEXT(
          *reinterpret_cast<PhysicalDeviceBufferDeviceAddressFeaturesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceBufferDeviceAddressFeaturesEXT &
                            operator=( PhysicalDeviceBufferDeviceAddressFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceBufferDeviceAddressFeaturesEXT &
      operator=( VkPhysicalDeviceBufferDeviceAddressFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceBufferDeviceAddressFeaturesEXT const *>( &rhs );
      return *this;
    }

    PhysicalDeviceBufferDeviceAddressFeaturesEXT & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceBufferDeviceAddressFeaturesEXT &
      setBufferDeviceAddress( VULKAN_HPP_NAMESPACE::Bool32 bufferDeviceAddress_ ) VULKAN_HPP_NOEXCEPT
    {
      bufferDeviceAddress = bufferDeviceAddress_;
      return *this;
    }

    PhysicalDeviceBufferDeviceAddressFeaturesEXT & setBufferDeviceAddressCaptureReplay(
      VULKAN_HPP_NAMESPACE::Bool32 bufferDeviceAddressCaptureReplay_ ) VULKAN_HPP_NOEXCEPT
    {
      bufferDeviceAddressCaptureReplay = bufferDeviceAddressCaptureReplay_;
      return *this;
    }

    PhysicalDeviceBufferDeviceAddressFeaturesEXT & setBufferDeviceAddressMultiDevice(
      VULKAN_HPP_NAMESPACE::Bool32 bufferDeviceAddressMultiDevice_ ) VULKAN_HPP_NOEXCEPT
    {
      bufferDeviceAddressMultiDevice = bufferDeviceAddressMultiDevice_;
      return *this;
    }

    operator VkPhysicalDeviceBufferDeviceAddressFeaturesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT *>( this );
    }

    operator VkPhysicalDeviceBufferDeviceAddressFeaturesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceBufferDeviceAddressFeaturesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceBufferDeviceAddressFeaturesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceBufferDeviceAddressFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( bufferDeviceAddress == rhs.bufferDeviceAddress ) &&
             ( bufferDeviceAddressCaptureReplay == rhs.bufferDeviceAddressCaptureReplay ) &&
             ( bufferDeviceAddressMultiDevice == rhs.bufferDeviceAddressMultiDevice );
    }

    bool operator!=( PhysicalDeviceBufferDeviceAddressFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceBufferDeviceAddressFeaturesEXT;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        bufferDeviceAddress              = {};
    VULKAN_HPP_NAMESPACE::Bool32        bufferDeviceAddressCaptureReplay = {};
    VULKAN_HPP_NAMESPACE::Bool32        bufferDeviceAddressMultiDevice   = {};
  };
  static_assert( sizeof( PhysicalDeviceBufferDeviceAddressFeaturesEXT ) ==
                   sizeof( VkPhysicalDeviceBufferDeviceAddressFeaturesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceBufferDeviceAddressFeaturesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceBufferDeviceAddressFeaturesEXT>
  {
    using Type = PhysicalDeviceBufferDeviceAddressFeaturesEXT;
  };
  using PhysicalDeviceBufferAddressFeaturesEXT = PhysicalDeviceBufferDeviceAddressFeaturesEXT;

  struct PhysicalDeviceCoherentMemoryFeaturesAMD
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceCoherentMemoryFeaturesAMD;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceCoherentMemoryFeaturesAMD(
      VULKAN_HPP_NAMESPACE::Bool32 deviceCoherentMemory_ = {} ) VULKAN_HPP_NOEXCEPT
      : deviceCoherentMemory( deviceCoherentMemory_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceCoherentMemoryFeaturesAMD( PhysicalDeviceCoherentMemoryFeaturesAMD const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceCoherentMemoryFeaturesAMD( VkPhysicalDeviceCoherentMemoryFeaturesAMD const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceCoherentMemoryFeaturesAMD(
          *reinterpret_cast<PhysicalDeviceCoherentMemoryFeaturesAMD const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceCoherentMemoryFeaturesAMD &
                            operator=( PhysicalDeviceCoherentMemoryFeaturesAMD const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceCoherentMemoryFeaturesAMD &
      operator=( VkPhysicalDeviceCoherentMemoryFeaturesAMD const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceCoherentMemoryFeaturesAMD const *>( &rhs );
      return *this;
    }

    PhysicalDeviceCoherentMemoryFeaturesAMD & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceCoherentMemoryFeaturesAMD &
      setDeviceCoherentMemory( VULKAN_HPP_NAMESPACE::Bool32 deviceCoherentMemory_ ) VULKAN_HPP_NOEXCEPT
    {
      deviceCoherentMemory = deviceCoherentMemory_;
      return *this;
    }

    operator VkPhysicalDeviceCoherentMemoryFeaturesAMD const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceCoherentMemoryFeaturesAMD *>( this );
    }

    operator VkPhysicalDeviceCoherentMemoryFeaturesAMD &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceCoherentMemoryFeaturesAMD *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceCoherentMemoryFeaturesAMD const & ) const = default;
#else
    bool operator==( PhysicalDeviceCoherentMemoryFeaturesAMD const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( deviceCoherentMemory == rhs.deviceCoherentMemory );
    }

    bool operator!=( PhysicalDeviceCoherentMemoryFeaturesAMD const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType                = StructureType::ePhysicalDeviceCoherentMemoryFeaturesAMD;
    void *                              pNext                = {};
    VULKAN_HPP_NAMESPACE::Bool32        deviceCoherentMemory = {};
  };
  static_assert( sizeof( PhysicalDeviceCoherentMemoryFeaturesAMD ) ==
                   sizeof( VkPhysicalDeviceCoherentMemoryFeaturesAMD ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceCoherentMemoryFeaturesAMD>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceCoherentMemoryFeaturesAMD>
  {
    using Type = PhysicalDeviceCoherentMemoryFeaturesAMD;
  };

  struct PhysicalDeviceColorWriteEnableFeaturesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceColorWriteEnableFeaturesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceColorWriteEnableFeaturesEXT(
      VULKAN_HPP_NAMESPACE::Bool32 colorWriteEnable_ = {} ) VULKAN_HPP_NOEXCEPT : colorWriteEnable( colorWriteEnable_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceColorWriteEnableFeaturesEXT(
      PhysicalDeviceColorWriteEnableFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceColorWriteEnableFeaturesEXT( VkPhysicalDeviceColorWriteEnableFeaturesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceColorWriteEnableFeaturesEXT(
          *reinterpret_cast<PhysicalDeviceColorWriteEnableFeaturesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceColorWriteEnableFeaturesEXT &
                            operator=( PhysicalDeviceColorWriteEnableFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceColorWriteEnableFeaturesEXT &
      operator=( VkPhysicalDeviceColorWriteEnableFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceColorWriteEnableFeaturesEXT const *>( &rhs );
      return *this;
    }

    PhysicalDeviceColorWriteEnableFeaturesEXT & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceColorWriteEnableFeaturesEXT &
      setColorWriteEnable( VULKAN_HPP_NAMESPACE::Bool32 colorWriteEnable_ ) VULKAN_HPP_NOEXCEPT
    {
      colorWriteEnable = colorWriteEnable_;
      return *this;
    }

    operator VkPhysicalDeviceColorWriteEnableFeaturesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceColorWriteEnableFeaturesEXT *>( this );
    }

    operator VkPhysicalDeviceColorWriteEnableFeaturesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceColorWriteEnableFeaturesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceColorWriteEnableFeaturesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceColorWriteEnableFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( colorWriteEnable == rhs.colorWriteEnable );
    }

    bool operator!=( PhysicalDeviceColorWriteEnableFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType            = StructureType::ePhysicalDeviceColorWriteEnableFeaturesEXT;
    void *                              pNext            = {};
    VULKAN_HPP_NAMESPACE::Bool32        colorWriteEnable = {};
  };
  static_assert( sizeof( PhysicalDeviceColorWriteEnableFeaturesEXT ) ==
                   sizeof( VkPhysicalDeviceColorWriteEnableFeaturesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceColorWriteEnableFeaturesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceColorWriteEnableFeaturesEXT>
  {
    using Type = PhysicalDeviceColorWriteEnableFeaturesEXT;
  };

  struct PhysicalDeviceComputeShaderDerivativesFeaturesNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceComputeShaderDerivativesFeaturesNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceComputeShaderDerivativesFeaturesNV(
      VULKAN_HPP_NAMESPACE::Bool32 computeDerivativeGroupQuads_  = {},
      VULKAN_HPP_NAMESPACE::Bool32 computeDerivativeGroupLinear_ = {} ) VULKAN_HPP_NOEXCEPT
      : computeDerivativeGroupQuads( computeDerivativeGroupQuads_ )
      , computeDerivativeGroupLinear( computeDerivativeGroupLinear_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceComputeShaderDerivativesFeaturesNV(
      PhysicalDeviceComputeShaderDerivativesFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceComputeShaderDerivativesFeaturesNV( VkPhysicalDeviceComputeShaderDerivativesFeaturesNV const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceComputeShaderDerivativesFeaturesNV(
          *reinterpret_cast<PhysicalDeviceComputeShaderDerivativesFeaturesNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceComputeShaderDerivativesFeaturesNV &
                            operator=( PhysicalDeviceComputeShaderDerivativesFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceComputeShaderDerivativesFeaturesNV &
      operator=( VkPhysicalDeviceComputeShaderDerivativesFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceComputeShaderDerivativesFeaturesNV const *>( &rhs );
      return *this;
    }

    PhysicalDeviceComputeShaderDerivativesFeaturesNV & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceComputeShaderDerivativesFeaturesNV &
      setComputeDerivativeGroupQuads( VULKAN_HPP_NAMESPACE::Bool32 computeDerivativeGroupQuads_ ) VULKAN_HPP_NOEXCEPT
    {
      computeDerivativeGroupQuads = computeDerivativeGroupQuads_;
      return *this;
    }

    PhysicalDeviceComputeShaderDerivativesFeaturesNV &
      setComputeDerivativeGroupLinear( VULKAN_HPP_NAMESPACE::Bool32 computeDerivativeGroupLinear_ ) VULKAN_HPP_NOEXCEPT
    {
      computeDerivativeGroupLinear = computeDerivativeGroupLinear_;
      return *this;
    }

    operator VkPhysicalDeviceComputeShaderDerivativesFeaturesNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceComputeShaderDerivativesFeaturesNV *>( this );
    }

    operator VkPhysicalDeviceComputeShaderDerivativesFeaturesNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceComputeShaderDerivativesFeaturesNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceComputeShaderDerivativesFeaturesNV const & ) const = default;
#else
    bool operator==( PhysicalDeviceComputeShaderDerivativesFeaturesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( computeDerivativeGroupQuads == rhs.computeDerivativeGroupQuads ) &&
             ( computeDerivativeGroupLinear == rhs.computeDerivativeGroupLinear );
    }

    bool operator!=( PhysicalDeviceComputeShaderDerivativesFeaturesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceComputeShaderDerivativesFeaturesNV;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        computeDerivativeGroupQuads  = {};
    VULKAN_HPP_NAMESPACE::Bool32        computeDerivativeGroupLinear = {};
  };
  static_assert( sizeof( PhysicalDeviceComputeShaderDerivativesFeaturesNV ) ==
                   sizeof( VkPhysicalDeviceComputeShaderDerivativesFeaturesNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceComputeShaderDerivativesFeaturesNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceComputeShaderDerivativesFeaturesNV>
  {
    using Type = PhysicalDeviceComputeShaderDerivativesFeaturesNV;
  };

  struct PhysicalDeviceConditionalRenderingFeaturesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceConditionalRenderingFeaturesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceConditionalRenderingFeaturesEXT(
      VULKAN_HPP_NAMESPACE::Bool32 conditionalRendering_          = {},
      VULKAN_HPP_NAMESPACE::Bool32 inheritedConditionalRendering_ = {} ) VULKAN_HPP_NOEXCEPT
      : conditionalRendering( conditionalRendering_ )
      , inheritedConditionalRendering( inheritedConditionalRendering_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceConditionalRenderingFeaturesEXT(
      PhysicalDeviceConditionalRenderingFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceConditionalRenderingFeaturesEXT( VkPhysicalDeviceConditionalRenderingFeaturesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceConditionalRenderingFeaturesEXT(
          *reinterpret_cast<PhysicalDeviceConditionalRenderingFeaturesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceConditionalRenderingFeaturesEXT &
                            operator=( PhysicalDeviceConditionalRenderingFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceConditionalRenderingFeaturesEXT &
      operator=( VkPhysicalDeviceConditionalRenderingFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceConditionalRenderingFeaturesEXT const *>( &rhs );
      return *this;
    }

    PhysicalDeviceConditionalRenderingFeaturesEXT & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceConditionalRenderingFeaturesEXT &
      setConditionalRendering( VULKAN_HPP_NAMESPACE::Bool32 conditionalRendering_ ) VULKAN_HPP_NOEXCEPT
    {
      conditionalRendering = conditionalRendering_;
      return *this;
    }

    PhysicalDeviceConditionalRenderingFeaturesEXT & setInheritedConditionalRendering(
      VULKAN_HPP_NAMESPACE::Bool32 inheritedConditionalRendering_ ) VULKAN_HPP_NOEXCEPT
    {
      inheritedConditionalRendering = inheritedConditionalRendering_;
      return *this;
    }

    operator VkPhysicalDeviceConditionalRenderingFeaturesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceConditionalRenderingFeaturesEXT *>( this );
    }

    operator VkPhysicalDeviceConditionalRenderingFeaturesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceConditionalRenderingFeaturesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceConditionalRenderingFeaturesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceConditionalRenderingFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( conditionalRendering == rhs.conditionalRendering ) &&
             ( inheritedConditionalRendering == rhs.inheritedConditionalRendering );
    }

    bool operator!=( PhysicalDeviceConditionalRenderingFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceConditionalRenderingFeaturesEXT;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        conditionalRendering          = {};
    VULKAN_HPP_NAMESPACE::Bool32        inheritedConditionalRendering = {};
  };
  static_assert( sizeof( PhysicalDeviceConditionalRenderingFeaturesEXT ) ==
                   sizeof( VkPhysicalDeviceConditionalRenderingFeaturesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceConditionalRenderingFeaturesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceConditionalRenderingFeaturesEXT>
  {
    using Type = PhysicalDeviceConditionalRenderingFeaturesEXT;
  };

  struct PhysicalDeviceConservativeRasterizationPropertiesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceConservativeRasterizationPropertiesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceConservativeRasterizationPropertiesEXT(
      float                        primitiveOverestimationSize_                 = {},
      float                        maxExtraPrimitiveOverestimationSize_         = {},
      float                        extraPrimitiveOverestimationSizeGranularity_ = {},
      VULKAN_HPP_NAMESPACE::Bool32 primitiveUnderestimation_                    = {},
      VULKAN_HPP_NAMESPACE::Bool32 conservativePointAndLineRasterization_       = {},
      VULKAN_HPP_NAMESPACE::Bool32 degenerateTrianglesRasterized_               = {},
      VULKAN_HPP_NAMESPACE::Bool32 degenerateLinesRasterized_                   = {},
      VULKAN_HPP_NAMESPACE::Bool32 fullyCoveredFragmentShaderInputVariable_     = {},
      VULKAN_HPP_NAMESPACE::Bool32 conservativeRasterizationPostDepthCoverage_  = {} ) VULKAN_HPP_NOEXCEPT
      : primitiveOverestimationSize( primitiveOverestimationSize_ )
      , maxExtraPrimitiveOverestimationSize( maxExtraPrimitiveOverestimationSize_ )
      , extraPrimitiveOverestimationSizeGranularity( extraPrimitiveOverestimationSizeGranularity_ )
      , primitiveUnderestimation( primitiveUnderestimation_ )
      , conservativePointAndLineRasterization( conservativePointAndLineRasterization_ )
      , degenerateTrianglesRasterized( degenerateTrianglesRasterized_ )
      , degenerateLinesRasterized( degenerateLinesRasterized_ )
      , fullyCoveredFragmentShaderInputVariable( fullyCoveredFragmentShaderInputVariable_ )
      , conservativeRasterizationPostDepthCoverage( conservativeRasterizationPostDepthCoverage_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceConservativeRasterizationPropertiesEXT(
      PhysicalDeviceConservativeRasterizationPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceConservativeRasterizationPropertiesEXT(
      VkPhysicalDeviceConservativeRasterizationPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceConservativeRasterizationPropertiesEXT(
          *reinterpret_cast<PhysicalDeviceConservativeRasterizationPropertiesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceConservativeRasterizationPropertiesEXT &
                            operator=( PhysicalDeviceConservativeRasterizationPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceConservativeRasterizationPropertiesEXT &
      operator=( VkPhysicalDeviceConservativeRasterizationPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this =
        *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceConservativeRasterizationPropertiesEXT const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceConservativeRasterizationPropertiesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceConservativeRasterizationPropertiesEXT *>( this );
    }

    operator VkPhysicalDeviceConservativeRasterizationPropertiesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceConservativeRasterizationPropertiesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceConservativeRasterizationPropertiesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceConservativeRasterizationPropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( primitiveOverestimationSize == rhs.primitiveOverestimationSize ) &&
             ( maxExtraPrimitiveOverestimationSize == rhs.maxExtraPrimitiveOverestimationSize ) &&
             ( extraPrimitiveOverestimationSizeGranularity == rhs.extraPrimitiveOverestimationSizeGranularity ) &&
             ( primitiveUnderestimation == rhs.primitiveUnderestimation ) &&
             ( conservativePointAndLineRasterization == rhs.conservativePointAndLineRasterization ) &&
             ( degenerateTrianglesRasterized == rhs.degenerateTrianglesRasterized ) &&
             ( degenerateLinesRasterized == rhs.degenerateLinesRasterized ) &&
             ( fullyCoveredFragmentShaderInputVariable == rhs.fullyCoveredFragmentShaderInputVariable ) &&
             ( conservativeRasterizationPostDepthCoverage == rhs.conservativeRasterizationPostDepthCoverage );
    }

    bool operator!=( PhysicalDeviceConservativeRasterizationPropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceConservativeRasterizationPropertiesEXT;
    void *                              pNext = {};
    float                               primitiveOverestimationSize                 = {};
    float                               maxExtraPrimitiveOverestimationSize         = {};
    float                               extraPrimitiveOverestimationSizeGranularity = {};
    VULKAN_HPP_NAMESPACE::Bool32        primitiveUnderestimation                    = {};
    VULKAN_HPP_NAMESPACE::Bool32        conservativePointAndLineRasterization       = {};
    VULKAN_HPP_NAMESPACE::Bool32        degenerateTrianglesRasterized               = {};
    VULKAN_HPP_NAMESPACE::Bool32        degenerateLinesRasterized                   = {};
    VULKAN_HPP_NAMESPACE::Bool32        fullyCoveredFragmentShaderInputVariable     = {};
    VULKAN_HPP_NAMESPACE::Bool32        conservativeRasterizationPostDepthCoverage  = {};
  };
  static_assert( sizeof( PhysicalDeviceConservativeRasterizationPropertiesEXT ) ==
                   sizeof( VkPhysicalDeviceConservativeRasterizationPropertiesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceConservativeRasterizationPropertiesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceConservativeRasterizationPropertiesEXT>
  {
    using Type = PhysicalDeviceConservativeRasterizationPropertiesEXT;
  };

  struct PhysicalDeviceCooperativeMatrixFeaturesNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceCooperativeMatrixFeaturesNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceCooperativeMatrixFeaturesNV(
      VULKAN_HPP_NAMESPACE::Bool32 cooperativeMatrix_                   = {},
      VULKAN_HPP_NAMESPACE::Bool32 cooperativeMatrixRobustBufferAccess_ = {} ) VULKAN_HPP_NOEXCEPT
      : cooperativeMatrix( cooperativeMatrix_ )
      , cooperativeMatrixRobustBufferAccess( cooperativeMatrixRobustBufferAccess_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceCooperativeMatrixFeaturesNV(
      PhysicalDeviceCooperativeMatrixFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceCooperativeMatrixFeaturesNV( VkPhysicalDeviceCooperativeMatrixFeaturesNV const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceCooperativeMatrixFeaturesNV(
          *reinterpret_cast<PhysicalDeviceCooperativeMatrixFeaturesNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceCooperativeMatrixFeaturesNV &
                            operator=( PhysicalDeviceCooperativeMatrixFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceCooperativeMatrixFeaturesNV &
      operator=( VkPhysicalDeviceCooperativeMatrixFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceCooperativeMatrixFeaturesNV const *>( &rhs );
      return *this;
    }

    PhysicalDeviceCooperativeMatrixFeaturesNV & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceCooperativeMatrixFeaturesNV &
      setCooperativeMatrix( VULKAN_HPP_NAMESPACE::Bool32 cooperativeMatrix_ ) VULKAN_HPP_NOEXCEPT
    {
      cooperativeMatrix = cooperativeMatrix_;
      return *this;
    }

    PhysicalDeviceCooperativeMatrixFeaturesNV & setCooperativeMatrixRobustBufferAccess(
      VULKAN_HPP_NAMESPACE::Bool32 cooperativeMatrixRobustBufferAccess_ ) VULKAN_HPP_NOEXCEPT
    {
      cooperativeMatrixRobustBufferAccess = cooperativeMatrixRobustBufferAccess_;
      return *this;
    }

    operator VkPhysicalDeviceCooperativeMatrixFeaturesNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceCooperativeMatrixFeaturesNV *>( this );
    }

    operator VkPhysicalDeviceCooperativeMatrixFeaturesNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceCooperativeMatrixFeaturesNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceCooperativeMatrixFeaturesNV const & ) const = default;
#else
    bool operator==( PhysicalDeviceCooperativeMatrixFeaturesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( cooperativeMatrix == rhs.cooperativeMatrix ) &&
             ( cooperativeMatrixRobustBufferAccess == rhs.cooperativeMatrixRobustBufferAccess );
    }

    bool operator!=( PhysicalDeviceCooperativeMatrixFeaturesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType             = StructureType::ePhysicalDeviceCooperativeMatrixFeaturesNV;
    void *                              pNext             = {};
    VULKAN_HPP_NAMESPACE::Bool32        cooperativeMatrix = {};
    VULKAN_HPP_NAMESPACE::Bool32        cooperativeMatrixRobustBufferAccess = {};
  };
  static_assert( sizeof( PhysicalDeviceCooperativeMatrixFeaturesNV ) ==
                   sizeof( VkPhysicalDeviceCooperativeMatrixFeaturesNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceCooperativeMatrixFeaturesNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceCooperativeMatrixFeaturesNV>
  {
    using Type = PhysicalDeviceCooperativeMatrixFeaturesNV;
  };

  struct PhysicalDeviceCooperativeMatrixPropertiesNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceCooperativeMatrixPropertiesNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceCooperativeMatrixPropertiesNV(
      VULKAN_HPP_NAMESPACE::ShaderStageFlags cooperativeMatrixSupportedStages_ = {} ) VULKAN_HPP_NOEXCEPT
      : cooperativeMatrixSupportedStages( cooperativeMatrixSupportedStages_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceCooperativeMatrixPropertiesNV(
      PhysicalDeviceCooperativeMatrixPropertiesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceCooperativeMatrixPropertiesNV( VkPhysicalDeviceCooperativeMatrixPropertiesNV const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceCooperativeMatrixPropertiesNV(
          *reinterpret_cast<PhysicalDeviceCooperativeMatrixPropertiesNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceCooperativeMatrixPropertiesNV &
                            operator=( PhysicalDeviceCooperativeMatrixPropertiesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceCooperativeMatrixPropertiesNV &
      operator=( VkPhysicalDeviceCooperativeMatrixPropertiesNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceCooperativeMatrixPropertiesNV const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceCooperativeMatrixPropertiesNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceCooperativeMatrixPropertiesNV *>( this );
    }

    operator VkPhysicalDeviceCooperativeMatrixPropertiesNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceCooperativeMatrixPropertiesNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceCooperativeMatrixPropertiesNV const & ) const = default;
#else
    bool operator==( PhysicalDeviceCooperativeMatrixPropertiesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( cooperativeMatrixSupportedStages == rhs.cooperativeMatrixSupportedStages );
    }

    bool operator!=( PhysicalDeviceCooperativeMatrixPropertiesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType    sType = StructureType::ePhysicalDeviceCooperativeMatrixPropertiesNV;
    void *                                 pNext = {};
    VULKAN_HPP_NAMESPACE::ShaderStageFlags cooperativeMatrixSupportedStages = {};
  };
  static_assert( sizeof( PhysicalDeviceCooperativeMatrixPropertiesNV ) ==
                   sizeof( VkPhysicalDeviceCooperativeMatrixPropertiesNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceCooperativeMatrixPropertiesNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceCooperativeMatrixPropertiesNV>
  {
    using Type = PhysicalDeviceCooperativeMatrixPropertiesNV;
  };

  struct PhysicalDeviceCornerSampledImageFeaturesNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceCornerSampledImageFeaturesNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceCornerSampledImageFeaturesNV(
      VULKAN_HPP_NAMESPACE::Bool32 cornerSampledImage_ = {} ) VULKAN_HPP_NOEXCEPT
      : cornerSampledImage( cornerSampledImage_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceCornerSampledImageFeaturesNV(
      PhysicalDeviceCornerSampledImageFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceCornerSampledImageFeaturesNV( VkPhysicalDeviceCornerSampledImageFeaturesNV const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceCornerSampledImageFeaturesNV(
          *reinterpret_cast<PhysicalDeviceCornerSampledImageFeaturesNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceCornerSampledImageFeaturesNV &
                            operator=( PhysicalDeviceCornerSampledImageFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceCornerSampledImageFeaturesNV &
      operator=( VkPhysicalDeviceCornerSampledImageFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceCornerSampledImageFeaturesNV const *>( &rhs );
      return *this;
    }

    PhysicalDeviceCornerSampledImageFeaturesNV & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceCornerSampledImageFeaturesNV &
      setCornerSampledImage( VULKAN_HPP_NAMESPACE::Bool32 cornerSampledImage_ ) VULKAN_HPP_NOEXCEPT
    {
      cornerSampledImage = cornerSampledImage_;
      return *this;
    }

    operator VkPhysicalDeviceCornerSampledImageFeaturesNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceCornerSampledImageFeaturesNV *>( this );
    }

    operator VkPhysicalDeviceCornerSampledImageFeaturesNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceCornerSampledImageFeaturesNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceCornerSampledImageFeaturesNV const & ) const = default;
#else
    bool operator==( PhysicalDeviceCornerSampledImageFeaturesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( cornerSampledImage == rhs.cornerSampledImage );
    }

    bool operator!=( PhysicalDeviceCornerSampledImageFeaturesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType              = StructureType::ePhysicalDeviceCornerSampledImageFeaturesNV;
    void *                              pNext              = {};
    VULKAN_HPP_NAMESPACE::Bool32        cornerSampledImage = {};
  };
  static_assert( sizeof( PhysicalDeviceCornerSampledImageFeaturesNV ) ==
                   sizeof( VkPhysicalDeviceCornerSampledImageFeaturesNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceCornerSampledImageFeaturesNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceCornerSampledImageFeaturesNV>
  {
    using Type = PhysicalDeviceCornerSampledImageFeaturesNV;
  };

  struct PhysicalDeviceCoverageReductionModeFeaturesNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceCoverageReductionModeFeaturesNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceCoverageReductionModeFeaturesNV(
      VULKAN_HPP_NAMESPACE::Bool32 coverageReductionMode_ = {} ) VULKAN_HPP_NOEXCEPT
      : coverageReductionMode( coverageReductionMode_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceCoverageReductionModeFeaturesNV(
      PhysicalDeviceCoverageReductionModeFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceCoverageReductionModeFeaturesNV( VkPhysicalDeviceCoverageReductionModeFeaturesNV const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceCoverageReductionModeFeaturesNV(
          *reinterpret_cast<PhysicalDeviceCoverageReductionModeFeaturesNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceCoverageReductionModeFeaturesNV &
                            operator=( PhysicalDeviceCoverageReductionModeFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceCoverageReductionModeFeaturesNV &
      operator=( VkPhysicalDeviceCoverageReductionModeFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceCoverageReductionModeFeaturesNV const *>( &rhs );
      return *this;
    }

    PhysicalDeviceCoverageReductionModeFeaturesNV & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceCoverageReductionModeFeaturesNV &
      setCoverageReductionMode( VULKAN_HPP_NAMESPACE::Bool32 coverageReductionMode_ ) VULKAN_HPP_NOEXCEPT
    {
      coverageReductionMode = coverageReductionMode_;
      return *this;
    }

    operator VkPhysicalDeviceCoverageReductionModeFeaturesNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceCoverageReductionModeFeaturesNV *>( this );
    }

    operator VkPhysicalDeviceCoverageReductionModeFeaturesNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceCoverageReductionModeFeaturesNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceCoverageReductionModeFeaturesNV const & ) const = default;
#else
    bool operator==( PhysicalDeviceCoverageReductionModeFeaturesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( coverageReductionMode == rhs.coverageReductionMode );
    }

    bool operator!=( PhysicalDeviceCoverageReductionModeFeaturesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceCoverageReductionModeFeaturesNV;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        coverageReductionMode = {};
  };
  static_assert( sizeof( PhysicalDeviceCoverageReductionModeFeaturesNV ) ==
                   sizeof( VkPhysicalDeviceCoverageReductionModeFeaturesNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceCoverageReductionModeFeaturesNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceCoverageReductionModeFeaturesNV>
  {
    using Type = PhysicalDeviceCoverageReductionModeFeaturesNV;
  };

  struct PhysicalDeviceCustomBorderColorFeaturesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceCustomBorderColorFeaturesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceCustomBorderColorFeaturesEXT(
      VULKAN_HPP_NAMESPACE::Bool32 customBorderColors_             = {},
      VULKAN_HPP_NAMESPACE::Bool32 customBorderColorWithoutFormat_ = {} ) VULKAN_HPP_NOEXCEPT
      : customBorderColors( customBorderColors_ )
      , customBorderColorWithoutFormat( customBorderColorWithoutFormat_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceCustomBorderColorFeaturesEXT(
      PhysicalDeviceCustomBorderColorFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceCustomBorderColorFeaturesEXT( VkPhysicalDeviceCustomBorderColorFeaturesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceCustomBorderColorFeaturesEXT(
          *reinterpret_cast<PhysicalDeviceCustomBorderColorFeaturesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceCustomBorderColorFeaturesEXT &
                            operator=( PhysicalDeviceCustomBorderColorFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceCustomBorderColorFeaturesEXT &
      operator=( VkPhysicalDeviceCustomBorderColorFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceCustomBorderColorFeaturesEXT const *>( &rhs );
      return *this;
    }

    PhysicalDeviceCustomBorderColorFeaturesEXT & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceCustomBorderColorFeaturesEXT &
      setCustomBorderColors( VULKAN_HPP_NAMESPACE::Bool32 customBorderColors_ ) VULKAN_HPP_NOEXCEPT
    {
      customBorderColors = customBorderColors_;
      return *this;
    }

    PhysicalDeviceCustomBorderColorFeaturesEXT & setCustomBorderColorWithoutFormat(
      VULKAN_HPP_NAMESPACE::Bool32 customBorderColorWithoutFormat_ ) VULKAN_HPP_NOEXCEPT
    {
      customBorderColorWithoutFormat = customBorderColorWithoutFormat_;
      return *this;
    }

    operator VkPhysicalDeviceCustomBorderColorFeaturesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceCustomBorderColorFeaturesEXT *>( this );
    }

    operator VkPhysicalDeviceCustomBorderColorFeaturesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceCustomBorderColorFeaturesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceCustomBorderColorFeaturesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceCustomBorderColorFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( customBorderColors == rhs.customBorderColors ) &&
             ( customBorderColorWithoutFormat == rhs.customBorderColorWithoutFormat );
    }

    bool operator!=( PhysicalDeviceCustomBorderColorFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType              = StructureType::ePhysicalDeviceCustomBorderColorFeaturesEXT;
    void *                              pNext              = {};
    VULKAN_HPP_NAMESPACE::Bool32        customBorderColors = {};
    VULKAN_HPP_NAMESPACE::Bool32        customBorderColorWithoutFormat = {};
  };
  static_assert( sizeof( PhysicalDeviceCustomBorderColorFeaturesEXT ) ==
                   sizeof( VkPhysicalDeviceCustomBorderColorFeaturesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceCustomBorderColorFeaturesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceCustomBorderColorFeaturesEXT>
  {
    using Type = PhysicalDeviceCustomBorderColorFeaturesEXT;
  };

  struct PhysicalDeviceCustomBorderColorPropertiesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceCustomBorderColorPropertiesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      PhysicalDeviceCustomBorderColorPropertiesEXT( uint32_t maxCustomBorderColorSamplers_ = {} ) VULKAN_HPP_NOEXCEPT
      : maxCustomBorderColorSamplers( maxCustomBorderColorSamplers_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceCustomBorderColorPropertiesEXT(
      PhysicalDeviceCustomBorderColorPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceCustomBorderColorPropertiesEXT( VkPhysicalDeviceCustomBorderColorPropertiesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceCustomBorderColorPropertiesEXT(
          *reinterpret_cast<PhysicalDeviceCustomBorderColorPropertiesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceCustomBorderColorPropertiesEXT &
                            operator=( PhysicalDeviceCustomBorderColorPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceCustomBorderColorPropertiesEXT &
      operator=( VkPhysicalDeviceCustomBorderColorPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceCustomBorderColorPropertiesEXT const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceCustomBorderColorPropertiesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceCustomBorderColorPropertiesEXT *>( this );
    }

    operator VkPhysicalDeviceCustomBorderColorPropertiesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceCustomBorderColorPropertiesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceCustomBorderColorPropertiesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceCustomBorderColorPropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( maxCustomBorderColorSamplers == rhs.maxCustomBorderColorSamplers );
    }

    bool operator!=( PhysicalDeviceCustomBorderColorPropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceCustomBorderColorPropertiesEXT;
    void *                              pNext = {};
    uint32_t                            maxCustomBorderColorSamplers = {};
  };
  static_assert( sizeof( PhysicalDeviceCustomBorderColorPropertiesEXT ) ==
                   sizeof( VkPhysicalDeviceCustomBorderColorPropertiesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceCustomBorderColorPropertiesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceCustomBorderColorPropertiesEXT>
  {
    using Type = PhysicalDeviceCustomBorderColorPropertiesEXT;
  };

  struct PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV(
      VULKAN_HPP_NAMESPACE::Bool32 dedicatedAllocationImageAliasing_ = {} ) VULKAN_HPP_NOEXCEPT
      : dedicatedAllocationImageAliasing( dedicatedAllocationImageAliasing_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV(
      PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV(
      VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV(
          *reinterpret_cast<PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV &
                            operator=( PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV &
      operator=( VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV const *>(
        &rhs );
      return *this;
    }

    PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV & setDedicatedAllocationImageAliasing(
      VULKAN_HPP_NAMESPACE::Bool32 dedicatedAllocationImageAliasing_ ) VULKAN_HPP_NOEXCEPT
    {
      dedicatedAllocationImageAliasing = dedicatedAllocationImageAliasing_;
      return *this;
    }

    operator VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV *>( this );
    }

    operator VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV const & ) const = default;
#else
    bool operator==( PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( dedicatedAllocationImageAliasing == rhs.dedicatedAllocationImageAliasing );
    }

    bool operator!=( PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType =
      StructureType::ePhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV;
    void *                       pNext                            = {};
    VULKAN_HPP_NAMESPACE::Bool32 dedicatedAllocationImageAliasing = {};
  };
  static_assert( sizeof( PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV ) ==
                   sizeof( VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV>
  {
    using Type = PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV;
  };

  struct PhysicalDeviceDepthClipEnableFeaturesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceDepthClipEnableFeaturesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      PhysicalDeviceDepthClipEnableFeaturesEXT( VULKAN_HPP_NAMESPACE::Bool32 depthClipEnable_ = {} ) VULKAN_HPP_NOEXCEPT
      : depthClipEnable( depthClipEnable_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceDepthClipEnableFeaturesEXT(
      PhysicalDeviceDepthClipEnableFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceDepthClipEnableFeaturesEXT( VkPhysicalDeviceDepthClipEnableFeaturesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceDepthClipEnableFeaturesEXT(
          *reinterpret_cast<PhysicalDeviceDepthClipEnableFeaturesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceDepthClipEnableFeaturesEXT &
                            operator=( PhysicalDeviceDepthClipEnableFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceDepthClipEnableFeaturesEXT &
      operator=( VkPhysicalDeviceDepthClipEnableFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceDepthClipEnableFeaturesEXT const *>( &rhs );
      return *this;
    }

    PhysicalDeviceDepthClipEnableFeaturesEXT & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceDepthClipEnableFeaturesEXT &
      setDepthClipEnable( VULKAN_HPP_NAMESPACE::Bool32 depthClipEnable_ ) VULKAN_HPP_NOEXCEPT
    {
      depthClipEnable = depthClipEnable_;
      return *this;
    }

    operator VkPhysicalDeviceDepthClipEnableFeaturesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceDepthClipEnableFeaturesEXT *>( this );
    }

    operator VkPhysicalDeviceDepthClipEnableFeaturesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceDepthClipEnableFeaturesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceDepthClipEnableFeaturesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceDepthClipEnableFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( depthClipEnable == rhs.depthClipEnable );
    }

    bool operator!=( PhysicalDeviceDepthClipEnableFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType           = StructureType::ePhysicalDeviceDepthClipEnableFeaturesEXT;
    void *                              pNext           = {};
    VULKAN_HPP_NAMESPACE::Bool32        depthClipEnable = {};
  };
  static_assert( sizeof( PhysicalDeviceDepthClipEnableFeaturesEXT ) ==
                   sizeof( VkPhysicalDeviceDepthClipEnableFeaturesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceDepthClipEnableFeaturesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceDepthClipEnableFeaturesEXT>
  {
    using Type = PhysicalDeviceDepthClipEnableFeaturesEXT;
  };

  struct PhysicalDeviceDepthStencilResolveProperties
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceDepthStencilResolveProperties;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceDepthStencilResolveProperties(
      VULKAN_HPP_NAMESPACE::ResolveModeFlags supportedDepthResolveModes_   = {},
      VULKAN_HPP_NAMESPACE::ResolveModeFlags supportedStencilResolveModes_ = {},
      VULKAN_HPP_NAMESPACE::Bool32           independentResolveNone_       = {},
      VULKAN_HPP_NAMESPACE::Bool32           independentResolve_           = {} ) VULKAN_HPP_NOEXCEPT
      : supportedDepthResolveModes( supportedDepthResolveModes_ )
      , supportedStencilResolveModes( supportedStencilResolveModes_ )
      , independentResolveNone( independentResolveNone_ )
      , independentResolve( independentResolve_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceDepthStencilResolveProperties(
      PhysicalDeviceDepthStencilResolveProperties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceDepthStencilResolveProperties( VkPhysicalDeviceDepthStencilResolveProperties const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceDepthStencilResolveProperties(
          *reinterpret_cast<PhysicalDeviceDepthStencilResolveProperties const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceDepthStencilResolveProperties &
                            operator=( PhysicalDeviceDepthStencilResolveProperties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceDepthStencilResolveProperties &
      operator=( VkPhysicalDeviceDepthStencilResolveProperties const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceDepthStencilResolveProperties const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceDepthStencilResolveProperties const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceDepthStencilResolveProperties *>( this );
    }

    operator VkPhysicalDeviceDepthStencilResolveProperties &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceDepthStencilResolveProperties *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceDepthStencilResolveProperties const & ) const = default;
#else
    bool operator==( PhysicalDeviceDepthStencilResolveProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( supportedDepthResolveModes == rhs.supportedDepthResolveModes ) &&
             ( supportedStencilResolveModes == rhs.supportedStencilResolveModes ) &&
             ( independentResolveNone == rhs.independentResolveNone ) &&
             ( independentResolve == rhs.independentResolve );
    }

    bool operator!=( PhysicalDeviceDepthStencilResolveProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType    sType = StructureType::ePhysicalDeviceDepthStencilResolveProperties;
    void *                                 pNext = {};
    VULKAN_HPP_NAMESPACE::ResolveModeFlags supportedDepthResolveModes   = {};
    VULKAN_HPP_NAMESPACE::ResolveModeFlags supportedStencilResolveModes = {};
    VULKAN_HPP_NAMESPACE::Bool32           independentResolveNone       = {};
    VULKAN_HPP_NAMESPACE::Bool32           independentResolve           = {};
  };
  static_assert( sizeof( PhysicalDeviceDepthStencilResolveProperties ) ==
                   sizeof( VkPhysicalDeviceDepthStencilResolveProperties ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceDepthStencilResolveProperties>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceDepthStencilResolveProperties>
  {
    using Type = PhysicalDeviceDepthStencilResolveProperties;
  };
  using PhysicalDeviceDepthStencilResolvePropertiesKHR = PhysicalDeviceDepthStencilResolveProperties;

  struct PhysicalDeviceDescriptorIndexingFeatures
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceDescriptorIndexingFeatures;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceDescriptorIndexingFeatures(
      VULKAN_HPP_NAMESPACE::Bool32 shaderInputAttachmentArrayDynamicIndexing_          = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderUniformTexelBufferArrayDynamicIndexing_       = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderStorageTexelBufferArrayDynamicIndexing_       = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderUniformBufferArrayNonUniformIndexing_         = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderSampledImageArrayNonUniformIndexing_          = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderStorageBufferArrayNonUniformIndexing_         = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderStorageImageArrayNonUniformIndexing_          = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderInputAttachmentArrayNonUniformIndexing_       = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderUniformTexelBufferArrayNonUniformIndexing_    = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderStorageTexelBufferArrayNonUniformIndexing_    = {},
      VULKAN_HPP_NAMESPACE::Bool32 descriptorBindingUniformBufferUpdateAfterBind_      = {},
      VULKAN_HPP_NAMESPACE::Bool32 descriptorBindingSampledImageUpdateAfterBind_       = {},
      VULKAN_HPP_NAMESPACE::Bool32 descriptorBindingStorageImageUpdateAfterBind_       = {},
      VULKAN_HPP_NAMESPACE::Bool32 descriptorBindingStorageBufferUpdateAfterBind_      = {},
      VULKAN_HPP_NAMESPACE::Bool32 descriptorBindingUniformTexelBufferUpdateAfterBind_ = {},
      VULKAN_HPP_NAMESPACE::Bool32 descriptorBindingStorageTexelBufferUpdateAfterBind_ = {},
      VULKAN_HPP_NAMESPACE::Bool32 descriptorBindingUpdateUnusedWhilePending_          = {},
      VULKAN_HPP_NAMESPACE::Bool32 descriptorBindingPartiallyBound_                    = {},
      VULKAN_HPP_NAMESPACE::Bool32 descriptorBindingVariableDescriptorCount_           = {},
      VULKAN_HPP_NAMESPACE::Bool32 runtimeDescriptorArray_                             = {} ) VULKAN_HPP_NOEXCEPT
      : shaderInputAttachmentArrayDynamicIndexing( shaderInputAttachmentArrayDynamicIndexing_ )
      , shaderUniformTexelBufferArrayDynamicIndexing( shaderUniformTexelBufferArrayDynamicIndexing_ )
      , shaderStorageTexelBufferArrayDynamicIndexing( shaderStorageTexelBufferArrayDynamicIndexing_ )
      , shaderUniformBufferArrayNonUniformIndexing( shaderUniformBufferArrayNonUniformIndexing_ )
      , shaderSampledImageArrayNonUniformIndexing( shaderSampledImageArrayNonUniformIndexing_ )
      , shaderStorageBufferArrayNonUniformIndexing( shaderStorageBufferArrayNonUniformIndexing_ )
      , shaderStorageImageArrayNonUniformIndexing( shaderStorageImageArrayNonUniformIndexing_ )
      , shaderInputAttachmentArrayNonUniformIndexing( shaderInputAttachmentArrayNonUniformIndexing_ )
      , shaderUniformTexelBufferArrayNonUniformIndexing( shaderUniformTexelBufferArrayNonUniformIndexing_ )
      , shaderStorageTexelBufferArrayNonUniformIndexing( shaderStorageTexelBufferArrayNonUniformIndexing_ )
      , descriptorBindingUniformBufferUpdateAfterBind( descriptorBindingUniformBufferUpdateAfterBind_ )
      , descriptorBindingSampledImageUpdateAfterBind( descriptorBindingSampledImageUpdateAfterBind_ )
      , descriptorBindingStorageImageUpdateAfterBind( descriptorBindingStorageImageUpdateAfterBind_ )
      , descriptorBindingStorageBufferUpdateAfterBind( descriptorBindingStorageBufferUpdateAfterBind_ )
      , descriptorBindingUniformTexelBufferUpdateAfterBind( descriptorBindingUniformTexelBufferUpdateAfterBind_ )
      , descriptorBindingStorageTexelBufferUpdateAfterBind( descriptorBindingStorageTexelBufferUpdateAfterBind_ )
      , descriptorBindingUpdateUnusedWhilePending( descriptorBindingUpdateUnusedWhilePending_ )
      , descriptorBindingPartiallyBound( descriptorBindingPartiallyBound_ )
      , descriptorBindingVariableDescriptorCount( descriptorBindingVariableDescriptorCount_ )
      , runtimeDescriptorArray( runtimeDescriptorArray_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceDescriptorIndexingFeatures(
      PhysicalDeviceDescriptorIndexingFeatures const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceDescriptorIndexingFeatures( VkPhysicalDeviceDescriptorIndexingFeatures const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceDescriptorIndexingFeatures(
          *reinterpret_cast<PhysicalDeviceDescriptorIndexingFeatures const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceDescriptorIndexingFeatures &
                            operator=( PhysicalDeviceDescriptorIndexingFeatures const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceDescriptorIndexingFeatures &
      operator=( VkPhysicalDeviceDescriptorIndexingFeatures const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceDescriptorIndexingFeatures const *>( &rhs );
      return *this;
    }

    PhysicalDeviceDescriptorIndexingFeatures & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceDescriptorIndexingFeatures & setShaderInputAttachmentArrayDynamicIndexing(
      VULKAN_HPP_NAMESPACE::Bool32 shaderInputAttachmentArrayDynamicIndexing_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderInputAttachmentArrayDynamicIndexing = shaderInputAttachmentArrayDynamicIndexing_;
      return *this;
    }

    PhysicalDeviceDescriptorIndexingFeatures & setShaderUniformTexelBufferArrayDynamicIndexing(
      VULKAN_HPP_NAMESPACE::Bool32 shaderUniformTexelBufferArrayDynamicIndexing_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderUniformTexelBufferArrayDynamicIndexing = shaderUniformTexelBufferArrayDynamicIndexing_;
      return *this;
    }

    PhysicalDeviceDescriptorIndexingFeatures & setShaderStorageTexelBufferArrayDynamicIndexing(
      VULKAN_HPP_NAMESPACE::Bool32 shaderStorageTexelBufferArrayDynamicIndexing_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderStorageTexelBufferArrayDynamicIndexing = shaderStorageTexelBufferArrayDynamicIndexing_;
      return *this;
    }

    PhysicalDeviceDescriptorIndexingFeatures & setShaderUniformBufferArrayNonUniformIndexing(
      VULKAN_HPP_NAMESPACE::Bool32 shaderUniformBufferArrayNonUniformIndexing_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderUniformBufferArrayNonUniformIndexing = shaderUniformBufferArrayNonUniformIndexing_;
      return *this;
    }

    PhysicalDeviceDescriptorIndexingFeatures & setShaderSampledImageArrayNonUniformIndexing(
      VULKAN_HPP_NAMESPACE::Bool32 shaderSampledImageArrayNonUniformIndexing_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderSampledImageArrayNonUniformIndexing = shaderSampledImageArrayNonUniformIndexing_;
      return *this;
    }

    PhysicalDeviceDescriptorIndexingFeatures & setShaderStorageBufferArrayNonUniformIndexing(
      VULKAN_HPP_NAMESPACE::Bool32 shaderStorageBufferArrayNonUniformIndexing_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderStorageBufferArrayNonUniformIndexing = shaderStorageBufferArrayNonUniformIndexing_;
      return *this;
    }

    PhysicalDeviceDescriptorIndexingFeatures & setShaderStorageImageArrayNonUniformIndexing(
      VULKAN_HPP_NAMESPACE::Bool32 shaderStorageImageArrayNonUniformIndexing_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderStorageImageArrayNonUniformIndexing = shaderStorageImageArrayNonUniformIndexing_;
      return *this;
    }

    PhysicalDeviceDescriptorIndexingFeatures & setShaderInputAttachmentArrayNonUniformIndexing(
      VULKAN_HPP_NAMESPACE::Bool32 shaderInputAttachmentArrayNonUniformIndexing_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderInputAttachmentArrayNonUniformIndexing = shaderInputAttachmentArrayNonUniformIndexing_;
      return *this;
    }

    PhysicalDeviceDescriptorIndexingFeatures & setShaderUniformTexelBufferArrayNonUniformIndexing(
      VULKAN_HPP_NAMESPACE::Bool32 shaderUniformTexelBufferArrayNonUniformIndexing_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderUniformTexelBufferArrayNonUniformIndexing = shaderUniformTexelBufferArrayNonUniformIndexing_;
      return *this;
    }

    PhysicalDeviceDescriptorIndexingFeatures & setShaderStorageTexelBufferArrayNonUniformIndexing(
      VULKAN_HPP_NAMESPACE::Bool32 shaderStorageTexelBufferArrayNonUniformIndexing_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderStorageTexelBufferArrayNonUniformIndexing = shaderStorageTexelBufferArrayNonUniformIndexing_;
      return *this;
    }

    PhysicalDeviceDescriptorIndexingFeatures & setDescriptorBindingUniformBufferUpdateAfterBind(
      VULKAN_HPP_NAMESPACE::Bool32 descriptorBindingUniformBufferUpdateAfterBind_ ) VULKAN_HPP_NOEXCEPT
    {
      descriptorBindingUniformBufferUpdateAfterBind = descriptorBindingUniformBufferUpdateAfterBind_;
      return *this;
    }

    PhysicalDeviceDescriptorIndexingFeatures & setDescriptorBindingSampledImageUpdateAfterBind(
      VULKAN_HPP_NAMESPACE::Bool32 descriptorBindingSampledImageUpdateAfterBind_ ) VULKAN_HPP_NOEXCEPT
    {
      descriptorBindingSampledImageUpdateAfterBind = descriptorBindingSampledImageUpdateAfterBind_;
      return *this;
    }

    PhysicalDeviceDescriptorIndexingFeatures & setDescriptorBindingStorageImageUpdateAfterBind(
      VULKAN_HPP_NAMESPACE::Bool32 descriptorBindingStorageImageUpdateAfterBind_ ) VULKAN_HPP_NOEXCEPT
    {
      descriptorBindingStorageImageUpdateAfterBind = descriptorBindingStorageImageUpdateAfterBind_;
      return *this;
    }

    PhysicalDeviceDescriptorIndexingFeatures & setDescriptorBindingStorageBufferUpdateAfterBind(
      VULKAN_HPP_NAMESPACE::Bool32 descriptorBindingStorageBufferUpdateAfterBind_ ) VULKAN_HPP_NOEXCEPT
    {
      descriptorBindingStorageBufferUpdateAfterBind = descriptorBindingStorageBufferUpdateAfterBind_;
      return *this;
    }

    PhysicalDeviceDescriptorIndexingFeatures & setDescriptorBindingUniformTexelBufferUpdateAfterBind(
      VULKAN_HPP_NAMESPACE::Bool32 descriptorBindingUniformTexelBufferUpdateAfterBind_ ) VULKAN_HPP_NOEXCEPT
    {
      descriptorBindingUniformTexelBufferUpdateAfterBind = descriptorBindingUniformTexelBufferUpdateAfterBind_;
      return *this;
    }

    PhysicalDeviceDescriptorIndexingFeatures & setDescriptorBindingStorageTexelBufferUpdateAfterBind(
      VULKAN_HPP_NAMESPACE::Bool32 descriptorBindingStorageTexelBufferUpdateAfterBind_ ) VULKAN_HPP_NOEXCEPT
    {
      descriptorBindingStorageTexelBufferUpdateAfterBind = descriptorBindingStorageTexelBufferUpdateAfterBind_;
      return *this;
    }

    PhysicalDeviceDescriptorIndexingFeatures & setDescriptorBindingUpdateUnusedWhilePending(
      VULKAN_HPP_NAMESPACE::Bool32 descriptorBindingUpdateUnusedWhilePending_ ) VULKAN_HPP_NOEXCEPT
    {
      descriptorBindingUpdateUnusedWhilePending = descriptorBindingUpdateUnusedWhilePending_;
      return *this;
    }

    PhysicalDeviceDescriptorIndexingFeatures & setDescriptorBindingPartiallyBound(
      VULKAN_HPP_NAMESPACE::Bool32 descriptorBindingPartiallyBound_ ) VULKAN_HPP_NOEXCEPT
    {
      descriptorBindingPartiallyBound = descriptorBindingPartiallyBound_;
      return *this;
    }

    PhysicalDeviceDescriptorIndexingFeatures & setDescriptorBindingVariableDescriptorCount(
      VULKAN_HPP_NAMESPACE::Bool32 descriptorBindingVariableDescriptorCount_ ) VULKAN_HPP_NOEXCEPT
    {
      descriptorBindingVariableDescriptorCount = descriptorBindingVariableDescriptorCount_;
      return *this;
    }

    PhysicalDeviceDescriptorIndexingFeatures &
      setRuntimeDescriptorArray( VULKAN_HPP_NAMESPACE::Bool32 runtimeDescriptorArray_ ) VULKAN_HPP_NOEXCEPT
    {
      runtimeDescriptorArray = runtimeDescriptorArray_;
      return *this;
    }

    operator VkPhysicalDeviceDescriptorIndexingFeatures const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceDescriptorIndexingFeatures *>( this );
    }

    operator VkPhysicalDeviceDescriptorIndexingFeatures &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceDescriptorIndexingFeatures *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceDescriptorIndexingFeatures const & ) const = default;
#else
    bool operator==( PhysicalDeviceDescriptorIndexingFeatures const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( shaderInputAttachmentArrayDynamicIndexing == rhs.shaderInputAttachmentArrayDynamicIndexing ) &&
             ( shaderUniformTexelBufferArrayDynamicIndexing == rhs.shaderUniformTexelBufferArrayDynamicIndexing ) &&
             ( shaderStorageTexelBufferArrayDynamicIndexing == rhs.shaderStorageTexelBufferArrayDynamicIndexing ) &&
             ( shaderUniformBufferArrayNonUniformIndexing == rhs.shaderUniformBufferArrayNonUniformIndexing ) &&
             ( shaderSampledImageArrayNonUniformIndexing == rhs.shaderSampledImageArrayNonUniformIndexing ) &&
             ( shaderStorageBufferArrayNonUniformIndexing == rhs.shaderStorageBufferArrayNonUniformIndexing ) &&
             ( shaderStorageImageArrayNonUniformIndexing == rhs.shaderStorageImageArrayNonUniformIndexing ) &&
             ( shaderInputAttachmentArrayNonUniformIndexing == rhs.shaderInputAttachmentArrayNonUniformIndexing ) &&
             ( shaderUniformTexelBufferArrayNonUniformIndexing ==
               rhs.shaderUniformTexelBufferArrayNonUniformIndexing ) &&
             ( shaderStorageTexelBufferArrayNonUniformIndexing ==
               rhs.shaderStorageTexelBufferArrayNonUniformIndexing ) &&
             ( descriptorBindingUniformBufferUpdateAfterBind == rhs.descriptorBindingUniformBufferUpdateAfterBind ) &&
             ( descriptorBindingSampledImageUpdateAfterBind == rhs.descriptorBindingSampledImageUpdateAfterBind ) &&
             ( descriptorBindingStorageImageUpdateAfterBind == rhs.descriptorBindingStorageImageUpdateAfterBind ) &&
             ( descriptorBindingStorageBufferUpdateAfterBind == rhs.descriptorBindingStorageBufferUpdateAfterBind ) &&
             ( descriptorBindingUniformTexelBufferUpdateAfterBind ==
               rhs.descriptorBindingUniformTexelBufferUpdateAfterBind ) &&
             ( descriptorBindingStorageTexelBufferUpdateAfterBind ==
               rhs.descriptorBindingStorageTexelBufferUpdateAfterBind ) &&
             ( descriptorBindingUpdateUnusedWhilePending == rhs.descriptorBindingUpdateUnusedWhilePending ) &&
             ( descriptorBindingPartiallyBound == rhs.descriptorBindingPartiallyBound ) &&
             ( descriptorBindingVariableDescriptorCount == rhs.descriptorBindingVariableDescriptorCount ) &&
             ( runtimeDescriptorArray == rhs.runtimeDescriptorArray );
    }

    bool operator!=( PhysicalDeviceDescriptorIndexingFeatures const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceDescriptorIndexingFeatures;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderInputAttachmentArrayDynamicIndexing          = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderUniformTexelBufferArrayDynamicIndexing       = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderStorageTexelBufferArrayDynamicIndexing       = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderUniformBufferArrayNonUniformIndexing         = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderSampledImageArrayNonUniformIndexing          = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderStorageBufferArrayNonUniformIndexing         = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderStorageImageArrayNonUniformIndexing          = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderInputAttachmentArrayNonUniformIndexing       = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderUniformTexelBufferArrayNonUniformIndexing    = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderStorageTexelBufferArrayNonUniformIndexing    = {};
    VULKAN_HPP_NAMESPACE::Bool32        descriptorBindingUniformBufferUpdateAfterBind      = {};
    VULKAN_HPP_NAMESPACE::Bool32        descriptorBindingSampledImageUpdateAfterBind       = {};
    VULKAN_HPP_NAMESPACE::Bool32        descriptorBindingStorageImageUpdateAfterBind       = {};
    VULKAN_HPP_NAMESPACE::Bool32        descriptorBindingStorageBufferUpdateAfterBind      = {};
    VULKAN_HPP_NAMESPACE::Bool32        descriptorBindingUniformTexelBufferUpdateAfterBind = {};
    VULKAN_HPP_NAMESPACE::Bool32        descriptorBindingStorageTexelBufferUpdateAfterBind = {};
    VULKAN_HPP_NAMESPACE::Bool32        descriptorBindingUpdateUnusedWhilePending          = {};
    VULKAN_HPP_NAMESPACE::Bool32        descriptorBindingPartiallyBound                    = {};
    VULKAN_HPP_NAMESPACE::Bool32        descriptorBindingVariableDescriptorCount           = {};
    VULKAN_HPP_NAMESPACE::Bool32        runtimeDescriptorArray                             = {};
  };
  static_assert( sizeof( PhysicalDeviceDescriptorIndexingFeatures ) ==
                   sizeof( VkPhysicalDeviceDescriptorIndexingFeatures ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceDescriptorIndexingFeatures>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceDescriptorIndexingFeatures>
  {
    using Type = PhysicalDeviceDescriptorIndexingFeatures;
  };
  using PhysicalDeviceDescriptorIndexingFeaturesEXT = PhysicalDeviceDescriptorIndexingFeatures;

  struct PhysicalDeviceDescriptorIndexingProperties
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceDescriptorIndexingProperties;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceDescriptorIndexingProperties(
      uint32_t                     maxUpdateAfterBindDescriptorsInAllPools_              = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderUniformBufferArrayNonUniformIndexingNative_     = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderSampledImageArrayNonUniformIndexingNative_      = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderStorageBufferArrayNonUniformIndexingNative_     = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderStorageImageArrayNonUniformIndexingNative_      = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderInputAttachmentArrayNonUniformIndexingNative_   = {},
      VULKAN_HPP_NAMESPACE::Bool32 robustBufferAccessUpdateAfterBind_                    = {},
      VULKAN_HPP_NAMESPACE::Bool32 quadDivergentImplicitLod_                             = {},
      uint32_t                     maxPerStageDescriptorUpdateAfterBindSamplers_         = {},
      uint32_t                     maxPerStageDescriptorUpdateAfterBindUniformBuffers_   = {},
      uint32_t                     maxPerStageDescriptorUpdateAfterBindStorageBuffers_   = {},
      uint32_t                     maxPerStageDescriptorUpdateAfterBindSampledImages_    = {},
      uint32_t                     maxPerStageDescriptorUpdateAfterBindStorageImages_    = {},
      uint32_t                     maxPerStageDescriptorUpdateAfterBindInputAttachments_ = {},
      uint32_t                     maxPerStageUpdateAfterBindResources_                  = {},
      uint32_t                     maxDescriptorSetUpdateAfterBindSamplers_              = {},
      uint32_t                     maxDescriptorSetUpdateAfterBindUniformBuffers_        = {},
      uint32_t                     maxDescriptorSetUpdateAfterBindUniformBuffersDynamic_ = {},
      uint32_t                     maxDescriptorSetUpdateAfterBindStorageBuffers_        = {},
      uint32_t                     maxDescriptorSetUpdateAfterBindStorageBuffersDynamic_ = {},
      uint32_t                     maxDescriptorSetUpdateAfterBindSampledImages_         = {},
      uint32_t                     maxDescriptorSetUpdateAfterBindStorageImages_         = {},
      uint32_t                     maxDescriptorSetUpdateAfterBindInputAttachments_      = {} ) VULKAN_HPP_NOEXCEPT
      : maxUpdateAfterBindDescriptorsInAllPools( maxUpdateAfterBindDescriptorsInAllPools_ )
      , shaderUniformBufferArrayNonUniformIndexingNative( shaderUniformBufferArrayNonUniformIndexingNative_ )
      , shaderSampledImageArrayNonUniformIndexingNative( shaderSampledImageArrayNonUniformIndexingNative_ )
      , shaderStorageBufferArrayNonUniformIndexingNative( shaderStorageBufferArrayNonUniformIndexingNative_ )
      , shaderStorageImageArrayNonUniformIndexingNative( shaderStorageImageArrayNonUniformIndexingNative_ )
      , shaderInputAttachmentArrayNonUniformIndexingNative( shaderInputAttachmentArrayNonUniformIndexingNative_ )
      , robustBufferAccessUpdateAfterBind( robustBufferAccessUpdateAfterBind_ )
      , quadDivergentImplicitLod( quadDivergentImplicitLod_ )
      , maxPerStageDescriptorUpdateAfterBindSamplers( maxPerStageDescriptorUpdateAfterBindSamplers_ )
      , maxPerStageDescriptorUpdateAfterBindUniformBuffers( maxPerStageDescriptorUpdateAfterBindUniformBuffers_ )
      , maxPerStageDescriptorUpdateAfterBindStorageBuffers( maxPerStageDescriptorUpdateAfterBindStorageBuffers_ )
      , maxPerStageDescriptorUpdateAfterBindSampledImages( maxPerStageDescriptorUpdateAfterBindSampledImages_ )
      , maxPerStageDescriptorUpdateAfterBindStorageImages( maxPerStageDescriptorUpdateAfterBindStorageImages_ )
      , maxPerStageDescriptorUpdateAfterBindInputAttachments( maxPerStageDescriptorUpdateAfterBindInputAttachments_ )
      , maxPerStageUpdateAfterBindResources( maxPerStageUpdateAfterBindResources_ )
      , maxDescriptorSetUpdateAfterBindSamplers( maxDescriptorSetUpdateAfterBindSamplers_ )
      , maxDescriptorSetUpdateAfterBindUniformBuffers( maxDescriptorSetUpdateAfterBindUniformBuffers_ )
      , maxDescriptorSetUpdateAfterBindUniformBuffersDynamic( maxDescriptorSetUpdateAfterBindUniformBuffersDynamic_ )
      , maxDescriptorSetUpdateAfterBindStorageBuffers( maxDescriptorSetUpdateAfterBindStorageBuffers_ )
      , maxDescriptorSetUpdateAfterBindStorageBuffersDynamic( maxDescriptorSetUpdateAfterBindStorageBuffersDynamic_ )
      , maxDescriptorSetUpdateAfterBindSampledImages( maxDescriptorSetUpdateAfterBindSampledImages_ )
      , maxDescriptorSetUpdateAfterBindStorageImages( maxDescriptorSetUpdateAfterBindStorageImages_ )
      , maxDescriptorSetUpdateAfterBindInputAttachments( maxDescriptorSetUpdateAfterBindInputAttachments_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceDescriptorIndexingProperties(
      PhysicalDeviceDescriptorIndexingProperties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceDescriptorIndexingProperties( VkPhysicalDeviceDescriptorIndexingProperties const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceDescriptorIndexingProperties(
          *reinterpret_cast<PhysicalDeviceDescriptorIndexingProperties const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceDescriptorIndexingProperties &
                            operator=( PhysicalDeviceDescriptorIndexingProperties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceDescriptorIndexingProperties &
      operator=( VkPhysicalDeviceDescriptorIndexingProperties const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceDescriptorIndexingProperties const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceDescriptorIndexingProperties const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceDescriptorIndexingProperties *>( this );
    }

    operator VkPhysicalDeviceDescriptorIndexingProperties &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceDescriptorIndexingProperties *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceDescriptorIndexingProperties const & ) const = default;
#else
    bool operator==( PhysicalDeviceDescriptorIndexingProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( maxUpdateAfterBindDescriptorsInAllPools == rhs.maxUpdateAfterBindDescriptorsInAllPools ) &&
             ( shaderUniformBufferArrayNonUniformIndexingNative ==
               rhs.shaderUniformBufferArrayNonUniformIndexingNative ) &&
             ( shaderSampledImageArrayNonUniformIndexingNative ==
               rhs.shaderSampledImageArrayNonUniformIndexingNative ) &&
             ( shaderStorageBufferArrayNonUniformIndexingNative ==
               rhs.shaderStorageBufferArrayNonUniformIndexingNative ) &&
             ( shaderStorageImageArrayNonUniformIndexingNative ==
               rhs.shaderStorageImageArrayNonUniformIndexingNative ) &&
             ( shaderInputAttachmentArrayNonUniformIndexingNative ==
               rhs.shaderInputAttachmentArrayNonUniformIndexingNative ) &&
             ( robustBufferAccessUpdateAfterBind == rhs.robustBufferAccessUpdateAfterBind ) &&
             ( quadDivergentImplicitLod == rhs.quadDivergentImplicitLod ) &&
             ( maxPerStageDescriptorUpdateAfterBindSamplers == rhs.maxPerStageDescriptorUpdateAfterBindSamplers ) &&
             ( maxPerStageDescriptorUpdateAfterBindUniformBuffers ==
               rhs.maxPerStageDescriptorUpdateAfterBindUniformBuffers ) &&
             ( maxPerStageDescriptorUpdateAfterBindStorageBuffers ==
               rhs.maxPerStageDescriptorUpdateAfterBindStorageBuffers ) &&
             ( maxPerStageDescriptorUpdateAfterBindSampledImages ==
               rhs.maxPerStageDescriptorUpdateAfterBindSampledImages ) &&
             ( maxPerStageDescriptorUpdateAfterBindStorageImages ==
               rhs.maxPerStageDescriptorUpdateAfterBindStorageImages ) &&
             ( maxPerStageDescriptorUpdateAfterBindInputAttachments ==
               rhs.maxPerStageDescriptorUpdateAfterBindInputAttachments ) &&
             ( maxPerStageUpdateAfterBindResources == rhs.maxPerStageUpdateAfterBindResources ) &&
             ( maxDescriptorSetUpdateAfterBindSamplers == rhs.maxDescriptorSetUpdateAfterBindSamplers ) &&
             ( maxDescriptorSetUpdateAfterBindUniformBuffers == rhs.maxDescriptorSetUpdateAfterBindUniformBuffers ) &&
             ( maxDescriptorSetUpdateAfterBindUniformBuffersDynamic ==
               rhs.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic ) &&
             ( maxDescriptorSetUpdateAfterBindStorageBuffers == rhs.maxDescriptorSetUpdateAfterBindStorageBuffers ) &&
             ( maxDescriptorSetUpdateAfterBindStorageBuffersDynamic ==
               rhs.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic ) &&
             ( maxDescriptorSetUpdateAfterBindSampledImages == rhs.maxDescriptorSetUpdateAfterBindSampledImages ) &&
             ( maxDescriptorSetUpdateAfterBindStorageImages == rhs.maxDescriptorSetUpdateAfterBindStorageImages ) &&
             ( maxDescriptorSetUpdateAfterBindInputAttachments == rhs.maxDescriptorSetUpdateAfterBindInputAttachments );
    }

    bool operator!=( PhysicalDeviceDescriptorIndexingProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceDescriptorIndexingProperties;
    void *                              pNext = {};
    uint32_t                            maxUpdateAfterBindDescriptorsInAllPools              = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderUniformBufferArrayNonUniformIndexingNative     = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderSampledImageArrayNonUniformIndexingNative      = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderStorageBufferArrayNonUniformIndexingNative     = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderStorageImageArrayNonUniformIndexingNative      = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderInputAttachmentArrayNonUniformIndexingNative   = {};
    VULKAN_HPP_NAMESPACE::Bool32        robustBufferAccessUpdateAfterBind                    = {};
    VULKAN_HPP_NAMESPACE::Bool32        quadDivergentImplicitLod                             = {};
    uint32_t                            maxPerStageDescriptorUpdateAfterBindSamplers         = {};
    uint32_t                            maxPerStageDescriptorUpdateAfterBindUniformBuffers   = {};
    uint32_t                            maxPerStageDescriptorUpdateAfterBindStorageBuffers   = {};
    uint32_t                            maxPerStageDescriptorUpdateAfterBindSampledImages    = {};
    uint32_t                            maxPerStageDescriptorUpdateAfterBindStorageImages    = {};
    uint32_t                            maxPerStageDescriptorUpdateAfterBindInputAttachments = {};
    uint32_t                            maxPerStageUpdateAfterBindResources                  = {};
    uint32_t                            maxDescriptorSetUpdateAfterBindSamplers              = {};
    uint32_t                            maxDescriptorSetUpdateAfterBindUniformBuffers        = {};
    uint32_t                            maxDescriptorSetUpdateAfterBindUniformBuffersDynamic = {};
    uint32_t                            maxDescriptorSetUpdateAfterBindStorageBuffers        = {};
    uint32_t                            maxDescriptorSetUpdateAfterBindStorageBuffersDynamic = {};
    uint32_t                            maxDescriptorSetUpdateAfterBindSampledImages         = {};
    uint32_t                            maxDescriptorSetUpdateAfterBindStorageImages         = {};
    uint32_t                            maxDescriptorSetUpdateAfterBindInputAttachments      = {};
  };
  static_assert( sizeof( PhysicalDeviceDescriptorIndexingProperties ) ==
                   sizeof( VkPhysicalDeviceDescriptorIndexingProperties ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceDescriptorIndexingProperties>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceDescriptorIndexingProperties>
  {
    using Type = PhysicalDeviceDescriptorIndexingProperties;
  };
  using PhysicalDeviceDescriptorIndexingPropertiesEXT = PhysicalDeviceDescriptorIndexingProperties;

  struct PhysicalDeviceDeviceGeneratedCommandsFeaturesNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceDeviceGeneratedCommandsFeaturesNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceDeviceGeneratedCommandsFeaturesNV(
      VULKAN_HPP_NAMESPACE::Bool32 deviceGeneratedCommands_ = {} ) VULKAN_HPP_NOEXCEPT
      : deviceGeneratedCommands( deviceGeneratedCommands_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceDeviceGeneratedCommandsFeaturesNV(
      PhysicalDeviceDeviceGeneratedCommandsFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceDeviceGeneratedCommandsFeaturesNV( VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceDeviceGeneratedCommandsFeaturesNV(
          *reinterpret_cast<PhysicalDeviceDeviceGeneratedCommandsFeaturesNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceDeviceGeneratedCommandsFeaturesNV &
                            operator=( PhysicalDeviceDeviceGeneratedCommandsFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceDeviceGeneratedCommandsFeaturesNV &
      operator=( VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceDeviceGeneratedCommandsFeaturesNV const *>( &rhs );
      return *this;
    }

    PhysicalDeviceDeviceGeneratedCommandsFeaturesNV & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceDeviceGeneratedCommandsFeaturesNV &
      setDeviceGeneratedCommands( VULKAN_HPP_NAMESPACE::Bool32 deviceGeneratedCommands_ ) VULKAN_HPP_NOEXCEPT
    {
      deviceGeneratedCommands = deviceGeneratedCommands_;
      return *this;
    }

    operator VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV *>( this );
    }

    operator VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceDeviceGeneratedCommandsFeaturesNV const & ) const = default;
#else
    bool operator==( PhysicalDeviceDeviceGeneratedCommandsFeaturesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( deviceGeneratedCommands == rhs.deviceGeneratedCommands );
    }

    bool operator!=( PhysicalDeviceDeviceGeneratedCommandsFeaturesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceDeviceGeneratedCommandsFeaturesNV;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        deviceGeneratedCommands = {};
  };
  static_assert( sizeof( PhysicalDeviceDeviceGeneratedCommandsFeaturesNV ) ==
                   sizeof( VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceDeviceGeneratedCommandsFeaturesNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceDeviceGeneratedCommandsFeaturesNV>
  {
    using Type = PhysicalDeviceDeviceGeneratedCommandsFeaturesNV;
  };

  struct PhysicalDeviceDeviceGeneratedCommandsPropertiesNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceDeviceGeneratedCommandsPropertiesNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceDeviceGeneratedCommandsPropertiesNV(
      uint32_t maxGraphicsShaderGroupCount_              = {},
      uint32_t maxIndirectSequenceCount_                 = {},
      uint32_t maxIndirectCommandsTokenCount_            = {},
      uint32_t maxIndirectCommandsStreamCount_           = {},
      uint32_t maxIndirectCommandsTokenOffset_           = {},
      uint32_t maxIndirectCommandsStreamStride_          = {},
      uint32_t minSequencesCountBufferOffsetAlignment_   = {},
      uint32_t minSequencesIndexBufferOffsetAlignment_   = {},
      uint32_t minIndirectCommandsBufferOffsetAlignment_ = {} ) VULKAN_HPP_NOEXCEPT
      : maxGraphicsShaderGroupCount( maxGraphicsShaderGroupCount_ )
      , maxIndirectSequenceCount( maxIndirectSequenceCount_ )
      , maxIndirectCommandsTokenCount( maxIndirectCommandsTokenCount_ )
      , maxIndirectCommandsStreamCount( maxIndirectCommandsStreamCount_ )
      , maxIndirectCommandsTokenOffset( maxIndirectCommandsTokenOffset_ )
      , maxIndirectCommandsStreamStride( maxIndirectCommandsStreamStride_ )
      , minSequencesCountBufferOffsetAlignment( minSequencesCountBufferOffsetAlignment_ )
      , minSequencesIndexBufferOffsetAlignment( minSequencesIndexBufferOffsetAlignment_ )
      , minIndirectCommandsBufferOffsetAlignment( minIndirectCommandsBufferOffsetAlignment_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceDeviceGeneratedCommandsPropertiesNV(
      PhysicalDeviceDeviceGeneratedCommandsPropertiesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceDeviceGeneratedCommandsPropertiesNV( VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceDeviceGeneratedCommandsPropertiesNV(
          *reinterpret_cast<PhysicalDeviceDeviceGeneratedCommandsPropertiesNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceDeviceGeneratedCommandsPropertiesNV &
                            operator=( PhysicalDeviceDeviceGeneratedCommandsPropertiesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceDeviceGeneratedCommandsPropertiesNV &
      operator=( VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this =
        *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceDeviceGeneratedCommandsPropertiesNV const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV *>( this );
    }

    operator VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceDeviceGeneratedCommandsPropertiesNV const & ) const = default;
#else
    bool operator==( PhysicalDeviceDeviceGeneratedCommandsPropertiesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( maxGraphicsShaderGroupCount == rhs.maxGraphicsShaderGroupCount ) &&
             ( maxIndirectSequenceCount == rhs.maxIndirectSequenceCount ) &&
             ( maxIndirectCommandsTokenCount == rhs.maxIndirectCommandsTokenCount ) &&
             ( maxIndirectCommandsStreamCount == rhs.maxIndirectCommandsStreamCount ) &&
             ( maxIndirectCommandsTokenOffset == rhs.maxIndirectCommandsTokenOffset ) &&
             ( maxIndirectCommandsStreamStride == rhs.maxIndirectCommandsStreamStride ) &&
             ( minSequencesCountBufferOffsetAlignment == rhs.minSequencesCountBufferOffsetAlignment ) &&
             ( minSequencesIndexBufferOffsetAlignment == rhs.minSequencesIndexBufferOffsetAlignment ) &&
             ( minIndirectCommandsBufferOffsetAlignment == rhs.minIndirectCommandsBufferOffsetAlignment );
    }

    bool operator!=( PhysicalDeviceDeviceGeneratedCommandsPropertiesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceDeviceGeneratedCommandsPropertiesNV;
    void *                              pNext = {};
    uint32_t                            maxGraphicsShaderGroupCount              = {};
    uint32_t                            maxIndirectSequenceCount                 = {};
    uint32_t                            maxIndirectCommandsTokenCount            = {};
    uint32_t                            maxIndirectCommandsStreamCount           = {};
    uint32_t                            maxIndirectCommandsTokenOffset           = {};
    uint32_t                            maxIndirectCommandsStreamStride          = {};
    uint32_t                            minSequencesCountBufferOffsetAlignment   = {};
    uint32_t                            minSequencesIndexBufferOffsetAlignment   = {};
    uint32_t                            minIndirectCommandsBufferOffsetAlignment = {};
  };
  static_assert( sizeof( PhysicalDeviceDeviceGeneratedCommandsPropertiesNV ) ==
                   sizeof( VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceDeviceGeneratedCommandsPropertiesNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceDeviceGeneratedCommandsPropertiesNV>
  {
    using Type = PhysicalDeviceDeviceGeneratedCommandsPropertiesNV;
  };

  struct PhysicalDeviceDeviceMemoryReportFeaturesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceDeviceMemoryReportFeaturesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceDeviceMemoryReportFeaturesEXT(
      VULKAN_HPP_NAMESPACE::Bool32 deviceMemoryReport_ = {} ) VULKAN_HPP_NOEXCEPT
      : deviceMemoryReport( deviceMemoryReport_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceDeviceMemoryReportFeaturesEXT(
      PhysicalDeviceDeviceMemoryReportFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceDeviceMemoryReportFeaturesEXT( VkPhysicalDeviceDeviceMemoryReportFeaturesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceDeviceMemoryReportFeaturesEXT(
          *reinterpret_cast<PhysicalDeviceDeviceMemoryReportFeaturesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceDeviceMemoryReportFeaturesEXT &
                            operator=( PhysicalDeviceDeviceMemoryReportFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceDeviceMemoryReportFeaturesEXT &
      operator=( VkPhysicalDeviceDeviceMemoryReportFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceDeviceMemoryReportFeaturesEXT const *>( &rhs );
      return *this;
    }

    PhysicalDeviceDeviceMemoryReportFeaturesEXT & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceDeviceMemoryReportFeaturesEXT &
      setDeviceMemoryReport( VULKAN_HPP_NAMESPACE::Bool32 deviceMemoryReport_ ) VULKAN_HPP_NOEXCEPT
    {
      deviceMemoryReport = deviceMemoryReport_;
      return *this;
    }

    operator VkPhysicalDeviceDeviceMemoryReportFeaturesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceDeviceMemoryReportFeaturesEXT *>( this );
    }

    operator VkPhysicalDeviceDeviceMemoryReportFeaturesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceDeviceMemoryReportFeaturesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceDeviceMemoryReportFeaturesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceDeviceMemoryReportFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( deviceMemoryReport == rhs.deviceMemoryReport );
    }

    bool operator!=( PhysicalDeviceDeviceMemoryReportFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceDeviceMemoryReportFeaturesEXT;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        deviceMemoryReport = {};
  };
  static_assert( sizeof( PhysicalDeviceDeviceMemoryReportFeaturesEXT ) ==
                   sizeof( VkPhysicalDeviceDeviceMemoryReportFeaturesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceDeviceMemoryReportFeaturesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceDeviceMemoryReportFeaturesEXT>
  {
    using Type = PhysicalDeviceDeviceMemoryReportFeaturesEXT;
  };

  struct PhysicalDeviceDiagnosticsConfigFeaturesNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceDiagnosticsConfigFeaturesNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceDiagnosticsConfigFeaturesNV(
      VULKAN_HPP_NAMESPACE::Bool32 diagnosticsConfig_ = {} ) VULKAN_HPP_NOEXCEPT
      : diagnosticsConfig( diagnosticsConfig_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceDiagnosticsConfigFeaturesNV(
      PhysicalDeviceDiagnosticsConfigFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceDiagnosticsConfigFeaturesNV( VkPhysicalDeviceDiagnosticsConfigFeaturesNV const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceDiagnosticsConfigFeaturesNV(
          *reinterpret_cast<PhysicalDeviceDiagnosticsConfigFeaturesNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceDiagnosticsConfigFeaturesNV &
                            operator=( PhysicalDeviceDiagnosticsConfigFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceDiagnosticsConfigFeaturesNV &
      operator=( VkPhysicalDeviceDiagnosticsConfigFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceDiagnosticsConfigFeaturesNV const *>( &rhs );
      return *this;
    }

    PhysicalDeviceDiagnosticsConfigFeaturesNV & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceDiagnosticsConfigFeaturesNV &
      setDiagnosticsConfig( VULKAN_HPP_NAMESPACE::Bool32 diagnosticsConfig_ ) VULKAN_HPP_NOEXCEPT
    {
      diagnosticsConfig = diagnosticsConfig_;
      return *this;
    }

    operator VkPhysicalDeviceDiagnosticsConfigFeaturesNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceDiagnosticsConfigFeaturesNV *>( this );
    }

    operator VkPhysicalDeviceDiagnosticsConfigFeaturesNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceDiagnosticsConfigFeaturesNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceDiagnosticsConfigFeaturesNV const & ) const = default;
#else
    bool operator==( PhysicalDeviceDiagnosticsConfigFeaturesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( diagnosticsConfig == rhs.diagnosticsConfig );
    }

    bool operator!=( PhysicalDeviceDiagnosticsConfigFeaturesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType             = StructureType::ePhysicalDeviceDiagnosticsConfigFeaturesNV;
    void *                              pNext             = {};
    VULKAN_HPP_NAMESPACE::Bool32        diagnosticsConfig = {};
  };
  static_assert( sizeof( PhysicalDeviceDiagnosticsConfigFeaturesNV ) ==
                   sizeof( VkPhysicalDeviceDiagnosticsConfigFeaturesNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceDiagnosticsConfigFeaturesNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceDiagnosticsConfigFeaturesNV>
  {
    using Type = PhysicalDeviceDiagnosticsConfigFeaturesNV;
  };

  struct PhysicalDeviceDiscardRectanglePropertiesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceDiscardRectanglePropertiesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      PhysicalDeviceDiscardRectanglePropertiesEXT( uint32_t maxDiscardRectangles_ = {} ) VULKAN_HPP_NOEXCEPT
      : maxDiscardRectangles( maxDiscardRectangles_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceDiscardRectanglePropertiesEXT(
      PhysicalDeviceDiscardRectanglePropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceDiscardRectanglePropertiesEXT( VkPhysicalDeviceDiscardRectanglePropertiesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceDiscardRectanglePropertiesEXT(
          *reinterpret_cast<PhysicalDeviceDiscardRectanglePropertiesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceDiscardRectanglePropertiesEXT &
                            operator=( PhysicalDeviceDiscardRectanglePropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceDiscardRectanglePropertiesEXT &
      operator=( VkPhysicalDeviceDiscardRectanglePropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceDiscardRectanglePropertiesEXT const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceDiscardRectanglePropertiesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceDiscardRectanglePropertiesEXT *>( this );
    }

    operator VkPhysicalDeviceDiscardRectanglePropertiesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceDiscardRectanglePropertiesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceDiscardRectanglePropertiesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceDiscardRectanglePropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( maxDiscardRectangles == rhs.maxDiscardRectangles );
    }

    bool operator!=( PhysicalDeviceDiscardRectanglePropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceDiscardRectanglePropertiesEXT;
    void *                              pNext = {};
    uint32_t                            maxDiscardRectangles = {};
  };
  static_assert( sizeof( PhysicalDeviceDiscardRectanglePropertiesEXT ) ==
                   sizeof( VkPhysicalDeviceDiscardRectanglePropertiesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceDiscardRectanglePropertiesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceDiscardRectanglePropertiesEXT>
  {
    using Type = PhysicalDeviceDiscardRectanglePropertiesEXT;
  };

  struct PhysicalDeviceDriverProperties
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::ePhysicalDeviceDriverProperties;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceDriverProperties(
      VULKAN_HPP_NAMESPACE::DriverId                    driverID_   = VULKAN_HPP_NAMESPACE::DriverId::eAmdProprietary,
      std::array<char, VK_MAX_DRIVER_NAME_SIZE> const & driverName_ = {},
      std::array<char, VK_MAX_DRIVER_INFO_SIZE> const & driverInfo_ = {},
      VULKAN_HPP_NAMESPACE::ConformanceVersion          conformanceVersion_ = {} ) VULKAN_HPP_NOEXCEPT
      : driverID( driverID_ )
      , driverName( driverName_ )
      , driverInfo( driverInfo_ )
      , conformanceVersion( conformanceVersion_ )
    {}

    VULKAN_HPP_CONSTEXPR_14
      PhysicalDeviceDriverProperties( PhysicalDeviceDriverProperties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceDriverProperties( VkPhysicalDeviceDriverProperties const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceDriverProperties( *reinterpret_cast<PhysicalDeviceDriverProperties const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceDriverProperties &
                            operator=( PhysicalDeviceDriverProperties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceDriverProperties & operator=( VkPhysicalDeviceDriverProperties const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceDriverProperties const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceDriverProperties const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceDriverProperties *>( this );
    }

    operator VkPhysicalDeviceDriverProperties &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceDriverProperties *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceDriverProperties const & ) const = default;
#else
    bool operator==( PhysicalDeviceDriverProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( driverID == rhs.driverID ) &&
             ( driverName == rhs.driverName ) && ( driverInfo == rhs.driverInfo ) &&
             ( conformanceVersion == rhs.conformanceVersion );
    }

    bool operator!=( PhysicalDeviceDriverProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType    = StructureType::ePhysicalDeviceDriverProperties;
    void *                              pNext    = {};
    VULKAN_HPP_NAMESPACE::DriverId      driverID = VULKAN_HPP_NAMESPACE::DriverId::eAmdProprietary;
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<char, VK_MAX_DRIVER_NAME_SIZE> driverName         = {};
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<char, VK_MAX_DRIVER_INFO_SIZE> driverInfo         = {};
    VULKAN_HPP_NAMESPACE::ConformanceVersion                            conformanceVersion = {};
  };
  static_assert( sizeof( PhysicalDeviceDriverProperties ) == sizeof( VkPhysicalDeviceDriverProperties ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceDriverProperties>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceDriverProperties>
  {
    using Type = PhysicalDeviceDriverProperties;
  };
  using PhysicalDeviceDriverPropertiesKHR = PhysicalDeviceDriverProperties;

  struct PhysicalDeviceDrmPropertiesEXT
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::ePhysicalDeviceDrmPropertiesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceDrmPropertiesEXT( VULKAN_HPP_NAMESPACE::Bool32 hasPrimary_   = {},
                                                         VULKAN_HPP_NAMESPACE::Bool32 hasRender_    = {},
                                                         int64_t                      primaryMajor_ = {},
                                                         int64_t                      primaryMinor_ = {},
                                                         int64_t                      renderMajor_  = {},
                                                         int64_t renderMinor_ = {} ) VULKAN_HPP_NOEXCEPT
      : hasPrimary( hasPrimary_ )
      , hasRender( hasRender_ )
      , primaryMajor( primaryMajor_ )
      , primaryMinor( primaryMinor_ )
      , renderMajor( renderMajor_ )
      , renderMinor( renderMinor_ )
    {}

    VULKAN_HPP_CONSTEXPR
      PhysicalDeviceDrmPropertiesEXT( PhysicalDeviceDrmPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceDrmPropertiesEXT( VkPhysicalDeviceDrmPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceDrmPropertiesEXT( *reinterpret_cast<PhysicalDeviceDrmPropertiesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceDrmPropertiesEXT &
                            operator=( PhysicalDeviceDrmPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceDrmPropertiesEXT & operator=( VkPhysicalDeviceDrmPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceDrmPropertiesEXT const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceDrmPropertiesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceDrmPropertiesEXT *>( this );
    }

    operator VkPhysicalDeviceDrmPropertiesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceDrmPropertiesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceDrmPropertiesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceDrmPropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( hasPrimary == rhs.hasPrimary ) &&
             ( hasRender == rhs.hasRender ) && ( primaryMajor == rhs.primaryMajor ) &&
             ( primaryMinor == rhs.primaryMinor ) && ( renderMajor == rhs.renderMajor ) &&
             ( renderMinor == rhs.renderMinor );
    }

    bool operator!=( PhysicalDeviceDrmPropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType        = StructureType::ePhysicalDeviceDrmPropertiesEXT;
    void *                              pNext        = {};
    VULKAN_HPP_NAMESPACE::Bool32        hasPrimary   = {};
    VULKAN_HPP_NAMESPACE::Bool32        hasRender    = {};
    int64_t                             primaryMajor = {};
    int64_t                             primaryMinor = {};
    int64_t                             renderMajor  = {};
    int64_t                             renderMinor  = {};
  };
  static_assert( sizeof( PhysicalDeviceDrmPropertiesEXT ) == sizeof( VkPhysicalDeviceDrmPropertiesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceDrmPropertiesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceDrmPropertiesEXT>
  {
    using Type = PhysicalDeviceDrmPropertiesEXT;
  };

  struct PhysicalDeviceExclusiveScissorFeaturesNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceExclusiveScissorFeaturesNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceExclusiveScissorFeaturesNV( VULKAN_HPP_NAMESPACE::Bool32 exclusiveScissor_ = {} )
      VULKAN_HPP_NOEXCEPT : exclusiveScissor( exclusiveScissor_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceExclusiveScissorFeaturesNV(
      PhysicalDeviceExclusiveScissorFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceExclusiveScissorFeaturesNV( VkPhysicalDeviceExclusiveScissorFeaturesNV const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceExclusiveScissorFeaturesNV(
          *reinterpret_cast<PhysicalDeviceExclusiveScissorFeaturesNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceExclusiveScissorFeaturesNV &
                            operator=( PhysicalDeviceExclusiveScissorFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceExclusiveScissorFeaturesNV &
      operator=( VkPhysicalDeviceExclusiveScissorFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceExclusiveScissorFeaturesNV const *>( &rhs );
      return *this;
    }

    PhysicalDeviceExclusiveScissorFeaturesNV & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceExclusiveScissorFeaturesNV &
      setExclusiveScissor( VULKAN_HPP_NAMESPACE::Bool32 exclusiveScissor_ ) VULKAN_HPP_NOEXCEPT
    {
      exclusiveScissor = exclusiveScissor_;
      return *this;
    }

    operator VkPhysicalDeviceExclusiveScissorFeaturesNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceExclusiveScissorFeaturesNV *>( this );
    }

    operator VkPhysicalDeviceExclusiveScissorFeaturesNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceExclusiveScissorFeaturesNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceExclusiveScissorFeaturesNV const & ) const = default;
#else
    bool operator==( PhysicalDeviceExclusiveScissorFeaturesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( exclusiveScissor == rhs.exclusiveScissor );
    }

    bool operator!=( PhysicalDeviceExclusiveScissorFeaturesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType            = StructureType::ePhysicalDeviceExclusiveScissorFeaturesNV;
    void *                              pNext            = {};
    VULKAN_HPP_NAMESPACE::Bool32        exclusiveScissor = {};
  };
  static_assert( sizeof( PhysicalDeviceExclusiveScissorFeaturesNV ) ==
                   sizeof( VkPhysicalDeviceExclusiveScissorFeaturesNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceExclusiveScissorFeaturesNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceExclusiveScissorFeaturesNV>
  {
    using Type = PhysicalDeviceExclusiveScissorFeaturesNV;
  };

  struct PhysicalDeviceExtendedDynamicState2FeaturesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceExtendedDynamicState2FeaturesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceExtendedDynamicState2FeaturesEXT(
      VULKAN_HPP_NAMESPACE::Bool32 extendedDynamicState2_                   = {},
      VULKAN_HPP_NAMESPACE::Bool32 extendedDynamicState2LogicOp_            = {},
      VULKAN_HPP_NAMESPACE::Bool32 extendedDynamicState2PatchControlPoints_ = {} ) VULKAN_HPP_NOEXCEPT
      : extendedDynamicState2( extendedDynamicState2_ )
      , extendedDynamicState2LogicOp( extendedDynamicState2LogicOp_ )
      , extendedDynamicState2PatchControlPoints( extendedDynamicState2PatchControlPoints_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceExtendedDynamicState2FeaturesEXT(
      PhysicalDeviceExtendedDynamicState2FeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceExtendedDynamicState2FeaturesEXT( VkPhysicalDeviceExtendedDynamicState2FeaturesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceExtendedDynamicState2FeaturesEXT(
          *reinterpret_cast<PhysicalDeviceExtendedDynamicState2FeaturesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceExtendedDynamicState2FeaturesEXT &
                            operator=( PhysicalDeviceExtendedDynamicState2FeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceExtendedDynamicState2FeaturesEXT &
      operator=( VkPhysicalDeviceExtendedDynamicState2FeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceExtendedDynamicState2FeaturesEXT const *>( &rhs );
      return *this;
    }

    PhysicalDeviceExtendedDynamicState2FeaturesEXT & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceExtendedDynamicState2FeaturesEXT &
      setExtendedDynamicState2( VULKAN_HPP_NAMESPACE::Bool32 extendedDynamicState2_ ) VULKAN_HPP_NOEXCEPT
    {
      extendedDynamicState2 = extendedDynamicState2_;
      return *this;
    }

    PhysicalDeviceExtendedDynamicState2FeaturesEXT &
      setExtendedDynamicState2LogicOp( VULKAN_HPP_NAMESPACE::Bool32 extendedDynamicState2LogicOp_ ) VULKAN_HPP_NOEXCEPT
    {
      extendedDynamicState2LogicOp = extendedDynamicState2LogicOp_;
      return *this;
    }

    PhysicalDeviceExtendedDynamicState2FeaturesEXT & setExtendedDynamicState2PatchControlPoints(
      VULKAN_HPP_NAMESPACE::Bool32 extendedDynamicState2PatchControlPoints_ ) VULKAN_HPP_NOEXCEPT
    {
      extendedDynamicState2PatchControlPoints = extendedDynamicState2PatchControlPoints_;
      return *this;
    }

    operator VkPhysicalDeviceExtendedDynamicState2FeaturesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceExtendedDynamicState2FeaturesEXT *>( this );
    }

    operator VkPhysicalDeviceExtendedDynamicState2FeaturesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceExtendedDynamicState2FeaturesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceExtendedDynamicState2FeaturesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceExtendedDynamicState2FeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( extendedDynamicState2 == rhs.extendedDynamicState2 ) &&
             ( extendedDynamicState2LogicOp == rhs.extendedDynamicState2LogicOp ) &&
             ( extendedDynamicState2PatchControlPoints == rhs.extendedDynamicState2PatchControlPoints );
    }

    bool operator!=( PhysicalDeviceExtendedDynamicState2FeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceExtendedDynamicState2FeaturesEXT;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        extendedDynamicState2                   = {};
    VULKAN_HPP_NAMESPACE::Bool32        extendedDynamicState2LogicOp            = {};
    VULKAN_HPP_NAMESPACE::Bool32        extendedDynamicState2PatchControlPoints = {};
  };
  static_assert( sizeof( PhysicalDeviceExtendedDynamicState2FeaturesEXT ) ==
                   sizeof( VkPhysicalDeviceExtendedDynamicState2FeaturesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceExtendedDynamicState2FeaturesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceExtendedDynamicState2FeaturesEXT>
  {
    using Type = PhysicalDeviceExtendedDynamicState2FeaturesEXT;
  };

  struct PhysicalDeviceExtendedDynamicStateFeaturesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceExtendedDynamicStateFeaturesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceExtendedDynamicStateFeaturesEXT(
      VULKAN_HPP_NAMESPACE::Bool32 extendedDynamicState_ = {} ) VULKAN_HPP_NOEXCEPT
      : extendedDynamicState( extendedDynamicState_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceExtendedDynamicStateFeaturesEXT(
      PhysicalDeviceExtendedDynamicStateFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceExtendedDynamicStateFeaturesEXT( VkPhysicalDeviceExtendedDynamicStateFeaturesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceExtendedDynamicStateFeaturesEXT(
          *reinterpret_cast<PhysicalDeviceExtendedDynamicStateFeaturesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceExtendedDynamicStateFeaturesEXT &
                            operator=( PhysicalDeviceExtendedDynamicStateFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceExtendedDynamicStateFeaturesEXT &
      operator=( VkPhysicalDeviceExtendedDynamicStateFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceExtendedDynamicStateFeaturesEXT const *>( &rhs );
      return *this;
    }

    PhysicalDeviceExtendedDynamicStateFeaturesEXT & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceExtendedDynamicStateFeaturesEXT &
      setExtendedDynamicState( VULKAN_HPP_NAMESPACE::Bool32 extendedDynamicState_ ) VULKAN_HPP_NOEXCEPT
    {
      extendedDynamicState = extendedDynamicState_;
      return *this;
    }

    operator VkPhysicalDeviceExtendedDynamicStateFeaturesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceExtendedDynamicStateFeaturesEXT *>( this );
    }

    operator VkPhysicalDeviceExtendedDynamicStateFeaturesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceExtendedDynamicStateFeaturesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceExtendedDynamicStateFeaturesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceExtendedDynamicStateFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( extendedDynamicState == rhs.extendedDynamicState );
    }

    bool operator!=( PhysicalDeviceExtendedDynamicStateFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceExtendedDynamicStateFeaturesEXT;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        extendedDynamicState = {};
  };
  static_assert( sizeof( PhysicalDeviceExtendedDynamicStateFeaturesEXT ) ==
                   sizeof( VkPhysicalDeviceExtendedDynamicStateFeaturesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceExtendedDynamicStateFeaturesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceExtendedDynamicStateFeaturesEXT>
  {
    using Type = PhysicalDeviceExtendedDynamicStateFeaturesEXT;
  };

  struct PhysicalDeviceExternalBufferInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::ePhysicalDeviceExternalBufferInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceExternalBufferInfo(
      VULKAN_HPP_NAMESPACE::BufferCreateFlags                flags_ = {},
      VULKAN_HPP_NAMESPACE::BufferUsageFlags                 usage_ = {},
      VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagBits handleType_ =
        VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagBits::eOpaqueFd ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , usage( usage_ )
      , handleType( handleType_ )
    {}

    VULKAN_HPP_CONSTEXPR
      PhysicalDeviceExternalBufferInfo( PhysicalDeviceExternalBufferInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceExternalBufferInfo( VkPhysicalDeviceExternalBufferInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceExternalBufferInfo( *reinterpret_cast<PhysicalDeviceExternalBufferInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceExternalBufferInfo &
                            operator=( PhysicalDeviceExternalBufferInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceExternalBufferInfo & operator=( VkPhysicalDeviceExternalBufferInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceExternalBufferInfo const *>( &rhs );
      return *this;
    }

    PhysicalDeviceExternalBufferInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceExternalBufferInfo & setFlags( VULKAN_HPP_NAMESPACE::BufferCreateFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    PhysicalDeviceExternalBufferInfo & setUsage( VULKAN_HPP_NAMESPACE::BufferUsageFlags usage_ ) VULKAN_HPP_NOEXCEPT
    {
      usage = usage_;
      return *this;
    }

    PhysicalDeviceExternalBufferInfo &
      setHandleType( VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagBits handleType_ ) VULKAN_HPP_NOEXCEPT
    {
      handleType = handleType_;
      return *this;
    }

    operator VkPhysicalDeviceExternalBufferInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceExternalBufferInfo *>( this );
    }

    operator VkPhysicalDeviceExternalBufferInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceExternalBufferInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceExternalBufferInfo const & ) const = default;
#else
    bool operator==( PhysicalDeviceExternalBufferInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) && ( usage == rhs.usage ) &&
             ( handleType == rhs.handleType );
    }

    bool operator!=( PhysicalDeviceExternalBufferInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                    sType = StructureType::ePhysicalDeviceExternalBufferInfo;
    const void *                                           pNext = {};
    VULKAN_HPP_NAMESPACE::BufferCreateFlags                flags = {};
    VULKAN_HPP_NAMESPACE::BufferUsageFlags                 usage = {};
    VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagBits handleType =
      VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagBits::eOpaqueFd;
  };
  static_assert( sizeof( PhysicalDeviceExternalBufferInfo ) == sizeof( VkPhysicalDeviceExternalBufferInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceExternalBufferInfo>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceExternalBufferInfo>
  {
    using Type = PhysicalDeviceExternalBufferInfo;
  };
  using PhysicalDeviceExternalBufferInfoKHR = PhysicalDeviceExternalBufferInfo;

  struct PhysicalDeviceExternalFenceInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::ePhysicalDeviceExternalFenceInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceExternalFenceInfo(
      VULKAN_HPP_NAMESPACE::ExternalFenceHandleTypeFlagBits handleType_ =
        VULKAN_HPP_NAMESPACE::ExternalFenceHandleTypeFlagBits::eOpaqueFd ) VULKAN_HPP_NOEXCEPT
      : handleType( handleType_ )
    {}

    VULKAN_HPP_CONSTEXPR
      PhysicalDeviceExternalFenceInfo( PhysicalDeviceExternalFenceInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceExternalFenceInfo( VkPhysicalDeviceExternalFenceInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceExternalFenceInfo( *reinterpret_cast<PhysicalDeviceExternalFenceInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceExternalFenceInfo &
                            operator=( PhysicalDeviceExternalFenceInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceExternalFenceInfo & operator=( VkPhysicalDeviceExternalFenceInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceExternalFenceInfo const *>( &rhs );
      return *this;
    }

    PhysicalDeviceExternalFenceInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceExternalFenceInfo &
      setHandleType( VULKAN_HPP_NAMESPACE::ExternalFenceHandleTypeFlagBits handleType_ ) VULKAN_HPP_NOEXCEPT
    {
      handleType = handleType_;
      return *this;
    }

    operator VkPhysicalDeviceExternalFenceInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceExternalFenceInfo *>( this );
    }

    operator VkPhysicalDeviceExternalFenceInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceExternalFenceInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceExternalFenceInfo const & ) const = default;
#else
    bool operator==( PhysicalDeviceExternalFenceInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( handleType == rhs.handleType );
    }

    bool operator!=( PhysicalDeviceExternalFenceInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                   sType = StructureType::ePhysicalDeviceExternalFenceInfo;
    const void *                                          pNext = {};
    VULKAN_HPP_NAMESPACE::ExternalFenceHandleTypeFlagBits handleType =
      VULKAN_HPP_NAMESPACE::ExternalFenceHandleTypeFlagBits::eOpaqueFd;
  };
  static_assert( sizeof( PhysicalDeviceExternalFenceInfo ) == sizeof( VkPhysicalDeviceExternalFenceInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceExternalFenceInfo>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceExternalFenceInfo>
  {
    using Type = PhysicalDeviceExternalFenceInfo;
  };
  using PhysicalDeviceExternalFenceInfoKHR = PhysicalDeviceExternalFenceInfo;

  struct PhysicalDeviceExternalImageFormatInfo
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceExternalImageFormatInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceExternalImageFormatInfo(
      VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagBits handleType_ =
        VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagBits::eOpaqueFd ) VULKAN_HPP_NOEXCEPT
      : handleType( handleType_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceExternalImageFormatInfo( PhysicalDeviceExternalImageFormatInfo const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceExternalImageFormatInfo( VkPhysicalDeviceExternalImageFormatInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceExternalImageFormatInfo(
          *reinterpret_cast<PhysicalDeviceExternalImageFormatInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceExternalImageFormatInfo &
                            operator=( PhysicalDeviceExternalImageFormatInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceExternalImageFormatInfo &
      operator=( VkPhysicalDeviceExternalImageFormatInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceExternalImageFormatInfo const *>( &rhs );
      return *this;
    }

    PhysicalDeviceExternalImageFormatInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceExternalImageFormatInfo &
      setHandleType( VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagBits handleType_ ) VULKAN_HPP_NOEXCEPT
    {
      handleType = handleType_;
      return *this;
    }

    operator VkPhysicalDeviceExternalImageFormatInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceExternalImageFormatInfo *>( this );
    }

    operator VkPhysicalDeviceExternalImageFormatInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceExternalImageFormatInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceExternalImageFormatInfo const & ) const = default;
#else
    bool operator==( PhysicalDeviceExternalImageFormatInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( handleType == rhs.handleType );
    }

    bool operator!=( PhysicalDeviceExternalImageFormatInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceExternalImageFormatInfo;
    const void *                        pNext = {};
    VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagBits handleType =
      VULKAN_HPP_NAMESPACE::ExternalMemoryHandleTypeFlagBits::eOpaqueFd;
  };
  static_assert( sizeof( PhysicalDeviceExternalImageFormatInfo ) == sizeof( VkPhysicalDeviceExternalImageFormatInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceExternalImageFormatInfo>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceExternalImageFormatInfo>
  {
    using Type = PhysicalDeviceExternalImageFormatInfo;
  };
  using PhysicalDeviceExternalImageFormatInfoKHR = PhysicalDeviceExternalImageFormatInfo;

  struct PhysicalDeviceExternalMemoryHostPropertiesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceExternalMemoryHostPropertiesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceExternalMemoryHostPropertiesEXT(
      VULKAN_HPP_NAMESPACE::DeviceSize minImportedHostPointerAlignment_ = {} ) VULKAN_HPP_NOEXCEPT
      : minImportedHostPointerAlignment( minImportedHostPointerAlignment_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceExternalMemoryHostPropertiesEXT(
      PhysicalDeviceExternalMemoryHostPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceExternalMemoryHostPropertiesEXT( VkPhysicalDeviceExternalMemoryHostPropertiesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceExternalMemoryHostPropertiesEXT(
          *reinterpret_cast<PhysicalDeviceExternalMemoryHostPropertiesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceExternalMemoryHostPropertiesEXT &
                            operator=( PhysicalDeviceExternalMemoryHostPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceExternalMemoryHostPropertiesEXT &
      operator=( VkPhysicalDeviceExternalMemoryHostPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceExternalMemoryHostPropertiesEXT const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceExternalMemoryHostPropertiesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceExternalMemoryHostPropertiesEXT *>( this );
    }

    operator VkPhysicalDeviceExternalMemoryHostPropertiesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceExternalMemoryHostPropertiesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceExternalMemoryHostPropertiesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceExternalMemoryHostPropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( minImportedHostPointerAlignment == rhs.minImportedHostPointerAlignment );
    }

    bool operator!=( PhysicalDeviceExternalMemoryHostPropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceExternalMemoryHostPropertiesEXT;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::DeviceSize    minImportedHostPointerAlignment = {};
  };
  static_assert( sizeof( PhysicalDeviceExternalMemoryHostPropertiesEXT ) ==
                   sizeof( VkPhysicalDeviceExternalMemoryHostPropertiesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceExternalMemoryHostPropertiesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceExternalMemoryHostPropertiesEXT>
  {
    using Type = PhysicalDeviceExternalMemoryHostPropertiesEXT;
  };

  struct PhysicalDeviceExternalSemaphoreInfo
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceExternalSemaphoreInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceExternalSemaphoreInfo(
      VULKAN_HPP_NAMESPACE::ExternalSemaphoreHandleTypeFlagBits handleType_ =
        VULKAN_HPP_NAMESPACE::ExternalSemaphoreHandleTypeFlagBits::eOpaqueFd ) VULKAN_HPP_NOEXCEPT
      : handleType( handleType_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceExternalSemaphoreInfo( PhysicalDeviceExternalSemaphoreInfo const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceExternalSemaphoreInfo( VkPhysicalDeviceExternalSemaphoreInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceExternalSemaphoreInfo( *reinterpret_cast<PhysicalDeviceExternalSemaphoreInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceExternalSemaphoreInfo &
                            operator=( PhysicalDeviceExternalSemaphoreInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceExternalSemaphoreInfo &
      operator=( VkPhysicalDeviceExternalSemaphoreInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceExternalSemaphoreInfo const *>( &rhs );
      return *this;
    }

    PhysicalDeviceExternalSemaphoreInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceExternalSemaphoreInfo &
      setHandleType( VULKAN_HPP_NAMESPACE::ExternalSemaphoreHandleTypeFlagBits handleType_ ) VULKAN_HPP_NOEXCEPT
    {
      handleType = handleType_;
      return *this;
    }

    operator VkPhysicalDeviceExternalSemaphoreInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceExternalSemaphoreInfo *>( this );
    }

    operator VkPhysicalDeviceExternalSemaphoreInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceExternalSemaphoreInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceExternalSemaphoreInfo const & ) const = default;
#else
    bool operator==( PhysicalDeviceExternalSemaphoreInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( handleType == rhs.handleType );
    }

    bool operator!=( PhysicalDeviceExternalSemaphoreInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceExternalSemaphoreInfo;
    const void *                        pNext = {};
    VULKAN_HPP_NAMESPACE::ExternalSemaphoreHandleTypeFlagBits handleType =
      VULKAN_HPP_NAMESPACE::ExternalSemaphoreHandleTypeFlagBits::eOpaqueFd;
  };
  static_assert( sizeof( PhysicalDeviceExternalSemaphoreInfo ) == sizeof( VkPhysicalDeviceExternalSemaphoreInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceExternalSemaphoreInfo>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceExternalSemaphoreInfo>
  {
    using Type = PhysicalDeviceExternalSemaphoreInfo;
  };
  using PhysicalDeviceExternalSemaphoreInfoKHR = PhysicalDeviceExternalSemaphoreInfo;

  struct PhysicalDeviceFeatures2
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::ePhysicalDeviceFeatures2;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      PhysicalDeviceFeatures2( VULKAN_HPP_NAMESPACE::PhysicalDeviceFeatures features_ = {} ) VULKAN_HPP_NOEXCEPT
      : features( features_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceFeatures2( PhysicalDeviceFeatures2 const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceFeatures2( VkPhysicalDeviceFeatures2 const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceFeatures2( *reinterpret_cast<PhysicalDeviceFeatures2 const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceFeatures2 &
                            operator=( PhysicalDeviceFeatures2 const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceFeatures2 & operator=( VkPhysicalDeviceFeatures2 const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceFeatures2 const *>( &rhs );
      return *this;
    }

    PhysicalDeviceFeatures2 & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceFeatures2 &
      setFeatures( VULKAN_HPP_NAMESPACE::PhysicalDeviceFeatures const & features_ ) VULKAN_HPP_NOEXCEPT
    {
      features = features_;
      return *this;
    }

    operator VkPhysicalDeviceFeatures2 const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceFeatures2 *>( this );
    }

    operator VkPhysicalDeviceFeatures2 &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceFeatures2 *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceFeatures2 const & ) const = default;
#else
    bool operator==( PhysicalDeviceFeatures2 const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( features == rhs.features );
    }

    bool operator!=( PhysicalDeviceFeatures2 const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType          sType    = StructureType::ePhysicalDeviceFeatures2;
    void *                                       pNext    = {};
    VULKAN_HPP_NAMESPACE::PhysicalDeviceFeatures features = {};
  };
  static_assert( sizeof( PhysicalDeviceFeatures2 ) == sizeof( VkPhysicalDeviceFeatures2 ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceFeatures2>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceFeatures2>
  {
    using Type = PhysicalDeviceFeatures2;
  };
  using PhysicalDeviceFeatures2KHR = PhysicalDeviceFeatures2;

  struct PhysicalDeviceFloatControlsProperties
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceFloatControlsProperties;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceFloatControlsProperties(
      VULKAN_HPP_NAMESPACE::ShaderFloatControlsIndependence denormBehaviorIndependence_ =
        VULKAN_HPP_NAMESPACE::ShaderFloatControlsIndependence::e32BitOnly,
      VULKAN_HPP_NAMESPACE::ShaderFloatControlsIndependence roundingModeIndependence_ =
        VULKAN_HPP_NAMESPACE::ShaderFloatControlsIndependence::e32BitOnly,
      VULKAN_HPP_NAMESPACE::Bool32 shaderSignedZeroInfNanPreserveFloat16_ = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderSignedZeroInfNanPreserveFloat32_ = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderSignedZeroInfNanPreserveFloat64_ = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderDenormPreserveFloat16_           = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderDenormPreserveFloat32_           = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderDenormPreserveFloat64_           = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderDenormFlushToZeroFloat16_        = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderDenormFlushToZeroFloat32_        = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderDenormFlushToZeroFloat64_        = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderRoundingModeRTEFloat16_          = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderRoundingModeRTEFloat32_          = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderRoundingModeRTEFloat64_          = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderRoundingModeRTZFloat16_          = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderRoundingModeRTZFloat32_          = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderRoundingModeRTZFloat64_          = {} ) VULKAN_HPP_NOEXCEPT
      : denormBehaviorIndependence( denormBehaviorIndependence_ )
      , roundingModeIndependence( roundingModeIndependence_ )
      , shaderSignedZeroInfNanPreserveFloat16( shaderSignedZeroInfNanPreserveFloat16_ )
      , shaderSignedZeroInfNanPreserveFloat32( shaderSignedZeroInfNanPreserveFloat32_ )
      , shaderSignedZeroInfNanPreserveFloat64( shaderSignedZeroInfNanPreserveFloat64_ )
      , shaderDenormPreserveFloat16( shaderDenormPreserveFloat16_ )
      , shaderDenormPreserveFloat32( shaderDenormPreserveFloat32_ )
      , shaderDenormPreserveFloat64( shaderDenormPreserveFloat64_ )
      , shaderDenormFlushToZeroFloat16( shaderDenormFlushToZeroFloat16_ )
      , shaderDenormFlushToZeroFloat32( shaderDenormFlushToZeroFloat32_ )
      , shaderDenormFlushToZeroFloat64( shaderDenormFlushToZeroFloat64_ )
      , shaderRoundingModeRTEFloat16( shaderRoundingModeRTEFloat16_ )
      , shaderRoundingModeRTEFloat32( shaderRoundingModeRTEFloat32_ )
      , shaderRoundingModeRTEFloat64( shaderRoundingModeRTEFloat64_ )
      , shaderRoundingModeRTZFloat16( shaderRoundingModeRTZFloat16_ )
      , shaderRoundingModeRTZFloat32( shaderRoundingModeRTZFloat32_ )
      , shaderRoundingModeRTZFloat64( shaderRoundingModeRTZFloat64_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceFloatControlsProperties( PhysicalDeviceFloatControlsProperties const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceFloatControlsProperties( VkPhysicalDeviceFloatControlsProperties const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceFloatControlsProperties(
          *reinterpret_cast<PhysicalDeviceFloatControlsProperties const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceFloatControlsProperties &
                            operator=( PhysicalDeviceFloatControlsProperties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceFloatControlsProperties &
      operator=( VkPhysicalDeviceFloatControlsProperties const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceFloatControlsProperties const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceFloatControlsProperties const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceFloatControlsProperties *>( this );
    }

    operator VkPhysicalDeviceFloatControlsProperties &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceFloatControlsProperties *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceFloatControlsProperties const & ) const = default;
#else
    bool operator==( PhysicalDeviceFloatControlsProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( denormBehaviorIndependence == rhs.denormBehaviorIndependence ) &&
             ( roundingModeIndependence == rhs.roundingModeIndependence ) &&
             ( shaderSignedZeroInfNanPreserveFloat16 == rhs.shaderSignedZeroInfNanPreserveFloat16 ) &&
             ( shaderSignedZeroInfNanPreserveFloat32 == rhs.shaderSignedZeroInfNanPreserveFloat32 ) &&
             ( shaderSignedZeroInfNanPreserveFloat64 == rhs.shaderSignedZeroInfNanPreserveFloat64 ) &&
             ( shaderDenormPreserveFloat16 == rhs.shaderDenormPreserveFloat16 ) &&
             ( shaderDenormPreserveFloat32 == rhs.shaderDenormPreserveFloat32 ) &&
             ( shaderDenormPreserveFloat64 == rhs.shaderDenormPreserveFloat64 ) &&
             ( shaderDenormFlushToZeroFloat16 == rhs.shaderDenormFlushToZeroFloat16 ) &&
             ( shaderDenormFlushToZeroFloat32 == rhs.shaderDenormFlushToZeroFloat32 ) &&
             ( shaderDenormFlushToZeroFloat64 == rhs.shaderDenormFlushToZeroFloat64 ) &&
             ( shaderRoundingModeRTEFloat16 == rhs.shaderRoundingModeRTEFloat16 ) &&
             ( shaderRoundingModeRTEFloat32 == rhs.shaderRoundingModeRTEFloat32 ) &&
             ( shaderRoundingModeRTEFloat64 == rhs.shaderRoundingModeRTEFloat64 ) &&
             ( shaderRoundingModeRTZFloat16 == rhs.shaderRoundingModeRTZFloat16 ) &&
             ( shaderRoundingModeRTZFloat32 == rhs.shaderRoundingModeRTZFloat32 ) &&
             ( shaderRoundingModeRTZFloat64 == rhs.shaderRoundingModeRTZFloat64 );
    }

    bool operator!=( PhysicalDeviceFloatControlsProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                   sType = StructureType::ePhysicalDeviceFloatControlsProperties;
    void *                                                pNext = {};
    VULKAN_HPP_NAMESPACE::ShaderFloatControlsIndependence denormBehaviorIndependence =
      VULKAN_HPP_NAMESPACE::ShaderFloatControlsIndependence::e32BitOnly;
    VULKAN_HPP_NAMESPACE::ShaderFloatControlsIndependence roundingModeIndependence =
      VULKAN_HPP_NAMESPACE::ShaderFloatControlsIndependence::e32BitOnly;
    VULKAN_HPP_NAMESPACE::Bool32 shaderSignedZeroInfNanPreserveFloat16 = {};
    VULKAN_HPP_NAMESPACE::Bool32 shaderSignedZeroInfNanPreserveFloat32 = {};
    VULKAN_HPP_NAMESPACE::Bool32 shaderSignedZeroInfNanPreserveFloat64 = {};
    VULKAN_HPP_NAMESPACE::Bool32 shaderDenormPreserveFloat16           = {};
    VULKAN_HPP_NAMESPACE::Bool32 shaderDenormPreserveFloat32           = {};
    VULKAN_HPP_NAMESPACE::Bool32 shaderDenormPreserveFloat64           = {};
    VULKAN_HPP_NAMESPACE::Bool32 shaderDenormFlushToZeroFloat16        = {};
    VULKAN_HPP_NAMESPACE::Bool32 shaderDenormFlushToZeroFloat32        = {};
    VULKAN_HPP_NAMESPACE::Bool32 shaderDenormFlushToZeroFloat64        = {};
    VULKAN_HPP_NAMESPACE::Bool32 shaderRoundingModeRTEFloat16          = {};
    VULKAN_HPP_NAMESPACE::Bool32 shaderRoundingModeRTEFloat32          = {};
    VULKAN_HPP_NAMESPACE::Bool32 shaderRoundingModeRTEFloat64          = {};
    VULKAN_HPP_NAMESPACE::Bool32 shaderRoundingModeRTZFloat16          = {};
    VULKAN_HPP_NAMESPACE::Bool32 shaderRoundingModeRTZFloat32          = {};
    VULKAN_HPP_NAMESPACE::Bool32 shaderRoundingModeRTZFloat64          = {};
  };
  static_assert( sizeof( PhysicalDeviceFloatControlsProperties ) == sizeof( VkPhysicalDeviceFloatControlsProperties ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceFloatControlsProperties>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceFloatControlsProperties>
  {
    using Type = PhysicalDeviceFloatControlsProperties;
  };
  using PhysicalDeviceFloatControlsPropertiesKHR = PhysicalDeviceFloatControlsProperties;

  struct PhysicalDeviceFragmentDensityMap2FeaturesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceFragmentDensityMap2FeaturesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceFragmentDensityMap2FeaturesEXT(
      VULKAN_HPP_NAMESPACE::Bool32 fragmentDensityMapDeferred_ = {} ) VULKAN_HPP_NOEXCEPT
      : fragmentDensityMapDeferred( fragmentDensityMapDeferred_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceFragmentDensityMap2FeaturesEXT(
      PhysicalDeviceFragmentDensityMap2FeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceFragmentDensityMap2FeaturesEXT( VkPhysicalDeviceFragmentDensityMap2FeaturesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceFragmentDensityMap2FeaturesEXT(
          *reinterpret_cast<PhysicalDeviceFragmentDensityMap2FeaturesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceFragmentDensityMap2FeaturesEXT &
                            operator=( PhysicalDeviceFragmentDensityMap2FeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceFragmentDensityMap2FeaturesEXT &
      operator=( VkPhysicalDeviceFragmentDensityMap2FeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceFragmentDensityMap2FeaturesEXT const *>( &rhs );
      return *this;
    }

    PhysicalDeviceFragmentDensityMap2FeaturesEXT & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceFragmentDensityMap2FeaturesEXT &
      setFragmentDensityMapDeferred( VULKAN_HPP_NAMESPACE::Bool32 fragmentDensityMapDeferred_ ) VULKAN_HPP_NOEXCEPT
    {
      fragmentDensityMapDeferred = fragmentDensityMapDeferred_;
      return *this;
    }

    operator VkPhysicalDeviceFragmentDensityMap2FeaturesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceFragmentDensityMap2FeaturesEXT *>( this );
    }

    operator VkPhysicalDeviceFragmentDensityMap2FeaturesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceFragmentDensityMap2FeaturesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceFragmentDensityMap2FeaturesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceFragmentDensityMap2FeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( fragmentDensityMapDeferred == rhs.fragmentDensityMapDeferred );
    }

    bool operator!=( PhysicalDeviceFragmentDensityMap2FeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceFragmentDensityMap2FeaturesEXT;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        fragmentDensityMapDeferred = {};
  };
  static_assert( sizeof( PhysicalDeviceFragmentDensityMap2FeaturesEXT ) ==
                   sizeof( VkPhysicalDeviceFragmentDensityMap2FeaturesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceFragmentDensityMap2FeaturesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceFragmentDensityMap2FeaturesEXT>
  {
    using Type = PhysicalDeviceFragmentDensityMap2FeaturesEXT;
  };

  struct PhysicalDeviceFragmentDensityMap2PropertiesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceFragmentDensityMap2PropertiesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceFragmentDensityMap2PropertiesEXT(
      VULKAN_HPP_NAMESPACE::Bool32 subsampledLoads_                           = {},
      VULKAN_HPP_NAMESPACE::Bool32 subsampledCoarseReconstructionEarlyAccess_ = {},
      uint32_t                     maxSubsampledArrayLayers_                  = {},
      uint32_t                     maxDescriptorSetSubsampledSamplers_        = {} ) VULKAN_HPP_NOEXCEPT
      : subsampledLoads( subsampledLoads_ )
      , subsampledCoarseReconstructionEarlyAccess( subsampledCoarseReconstructionEarlyAccess_ )
      , maxSubsampledArrayLayers( maxSubsampledArrayLayers_ )
      , maxDescriptorSetSubsampledSamplers( maxDescriptorSetSubsampledSamplers_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceFragmentDensityMap2PropertiesEXT(
      PhysicalDeviceFragmentDensityMap2PropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceFragmentDensityMap2PropertiesEXT( VkPhysicalDeviceFragmentDensityMap2PropertiesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceFragmentDensityMap2PropertiesEXT(
          *reinterpret_cast<PhysicalDeviceFragmentDensityMap2PropertiesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceFragmentDensityMap2PropertiesEXT &
                            operator=( PhysicalDeviceFragmentDensityMap2PropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceFragmentDensityMap2PropertiesEXT &
      operator=( VkPhysicalDeviceFragmentDensityMap2PropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceFragmentDensityMap2PropertiesEXT const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceFragmentDensityMap2PropertiesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceFragmentDensityMap2PropertiesEXT *>( this );
    }

    operator VkPhysicalDeviceFragmentDensityMap2PropertiesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceFragmentDensityMap2PropertiesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceFragmentDensityMap2PropertiesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceFragmentDensityMap2PropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( subsampledLoads == rhs.subsampledLoads ) &&
             ( subsampledCoarseReconstructionEarlyAccess == rhs.subsampledCoarseReconstructionEarlyAccess ) &&
             ( maxSubsampledArrayLayers == rhs.maxSubsampledArrayLayers ) &&
             ( maxDescriptorSetSubsampledSamplers == rhs.maxDescriptorSetSubsampledSamplers );
    }

    bool operator!=( PhysicalDeviceFragmentDensityMap2PropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceFragmentDensityMap2PropertiesEXT;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        subsampledLoads                           = {};
    VULKAN_HPP_NAMESPACE::Bool32        subsampledCoarseReconstructionEarlyAccess = {};
    uint32_t                            maxSubsampledArrayLayers                  = {};
    uint32_t                            maxDescriptorSetSubsampledSamplers        = {};
  };
  static_assert( sizeof( PhysicalDeviceFragmentDensityMap2PropertiesEXT ) ==
                   sizeof( VkPhysicalDeviceFragmentDensityMap2PropertiesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceFragmentDensityMap2PropertiesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceFragmentDensityMap2PropertiesEXT>
  {
    using Type = PhysicalDeviceFragmentDensityMap2PropertiesEXT;
  };

  struct PhysicalDeviceFragmentDensityMapFeaturesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceFragmentDensityMapFeaturesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceFragmentDensityMapFeaturesEXT(
      VULKAN_HPP_NAMESPACE::Bool32 fragmentDensityMap_                    = {},
      VULKAN_HPP_NAMESPACE::Bool32 fragmentDensityMapDynamic_             = {},
      VULKAN_HPP_NAMESPACE::Bool32 fragmentDensityMapNonSubsampledImages_ = {} ) VULKAN_HPP_NOEXCEPT
      : fragmentDensityMap( fragmentDensityMap_ )
      , fragmentDensityMapDynamic( fragmentDensityMapDynamic_ )
      , fragmentDensityMapNonSubsampledImages( fragmentDensityMapNonSubsampledImages_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceFragmentDensityMapFeaturesEXT(
      PhysicalDeviceFragmentDensityMapFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceFragmentDensityMapFeaturesEXT( VkPhysicalDeviceFragmentDensityMapFeaturesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceFragmentDensityMapFeaturesEXT(
          *reinterpret_cast<PhysicalDeviceFragmentDensityMapFeaturesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceFragmentDensityMapFeaturesEXT &
                            operator=( PhysicalDeviceFragmentDensityMapFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceFragmentDensityMapFeaturesEXT &
      operator=( VkPhysicalDeviceFragmentDensityMapFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceFragmentDensityMapFeaturesEXT const *>( &rhs );
      return *this;
    }

    PhysicalDeviceFragmentDensityMapFeaturesEXT & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceFragmentDensityMapFeaturesEXT &
      setFragmentDensityMap( VULKAN_HPP_NAMESPACE::Bool32 fragmentDensityMap_ ) VULKAN_HPP_NOEXCEPT
    {
      fragmentDensityMap = fragmentDensityMap_;
      return *this;
    }

    PhysicalDeviceFragmentDensityMapFeaturesEXT &
      setFragmentDensityMapDynamic( VULKAN_HPP_NAMESPACE::Bool32 fragmentDensityMapDynamic_ ) VULKAN_HPP_NOEXCEPT
    {
      fragmentDensityMapDynamic = fragmentDensityMapDynamic_;
      return *this;
    }

    PhysicalDeviceFragmentDensityMapFeaturesEXT & setFragmentDensityMapNonSubsampledImages(
      VULKAN_HPP_NAMESPACE::Bool32 fragmentDensityMapNonSubsampledImages_ ) VULKAN_HPP_NOEXCEPT
    {
      fragmentDensityMapNonSubsampledImages = fragmentDensityMapNonSubsampledImages_;
      return *this;
    }

    operator VkPhysicalDeviceFragmentDensityMapFeaturesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceFragmentDensityMapFeaturesEXT *>( this );
    }

    operator VkPhysicalDeviceFragmentDensityMapFeaturesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceFragmentDensityMapFeaturesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceFragmentDensityMapFeaturesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceFragmentDensityMapFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( fragmentDensityMap == rhs.fragmentDensityMap ) &&
             ( fragmentDensityMapDynamic == rhs.fragmentDensityMapDynamic ) &&
             ( fragmentDensityMapNonSubsampledImages == rhs.fragmentDensityMapNonSubsampledImages );
    }

    bool operator!=( PhysicalDeviceFragmentDensityMapFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceFragmentDensityMapFeaturesEXT;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        fragmentDensityMap                    = {};
    VULKAN_HPP_NAMESPACE::Bool32        fragmentDensityMapDynamic             = {};
    VULKAN_HPP_NAMESPACE::Bool32        fragmentDensityMapNonSubsampledImages = {};
  };
  static_assert( sizeof( PhysicalDeviceFragmentDensityMapFeaturesEXT ) ==
                   sizeof( VkPhysicalDeviceFragmentDensityMapFeaturesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceFragmentDensityMapFeaturesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceFragmentDensityMapFeaturesEXT>
  {
    using Type = PhysicalDeviceFragmentDensityMapFeaturesEXT;
  };

  struct PhysicalDeviceFragmentDensityMapPropertiesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceFragmentDensityMapPropertiesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceFragmentDensityMapPropertiesEXT(
      VULKAN_HPP_NAMESPACE::Extent2D minFragmentDensityTexelSize_ = {},
      VULKAN_HPP_NAMESPACE::Extent2D maxFragmentDensityTexelSize_ = {},
      VULKAN_HPP_NAMESPACE::Bool32   fragmentDensityInvocations_  = {} ) VULKAN_HPP_NOEXCEPT
      : minFragmentDensityTexelSize( minFragmentDensityTexelSize_ )
      , maxFragmentDensityTexelSize( maxFragmentDensityTexelSize_ )
      , fragmentDensityInvocations( fragmentDensityInvocations_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceFragmentDensityMapPropertiesEXT(
      PhysicalDeviceFragmentDensityMapPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceFragmentDensityMapPropertiesEXT( VkPhysicalDeviceFragmentDensityMapPropertiesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceFragmentDensityMapPropertiesEXT(
          *reinterpret_cast<PhysicalDeviceFragmentDensityMapPropertiesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceFragmentDensityMapPropertiesEXT &
                            operator=( PhysicalDeviceFragmentDensityMapPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceFragmentDensityMapPropertiesEXT &
      operator=( VkPhysicalDeviceFragmentDensityMapPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceFragmentDensityMapPropertiesEXT const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceFragmentDensityMapPropertiesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceFragmentDensityMapPropertiesEXT *>( this );
    }

    operator VkPhysicalDeviceFragmentDensityMapPropertiesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceFragmentDensityMapPropertiesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceFragmentDensityMapPropertiesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceFragmentDensityMapPropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( minFragmentDensityTexelSize == rhs.minFragmentDensityTexelSize ) &&
             ( maxFragmentDensityTexelSize == rhs.maxFragmentDensityTexelSize ) &&
             ( fragmentDensityInvocations == rhs.fragmentDensityInvocations );
    }

    bool operator!=( PhysicalDeviceFragmentDensityMapPropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceFragmentDensityMapPropertiesEXT;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Extent2D      minFragmentDensityTexelSize = {};
    VULKAN_HPP_NAMESPACE::Extent2D      maxFragmentDensityTexelSize = {};
    VULKAN_HPP_NAMESPACE::Bool32        fragmentDensityInvocations  = {};
  };
  static_assert( sizeof( PhysicalDeviceFragmentDensityMapPropertiesEXT ) ==
                   sizeof( VkPhysicalDeviceFragmentDensityMapPropertiesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceFragmentDensityMapPropertiesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceFragmentDensityMapPropertiesEXT>
  {
    using Type = PhysicalDeviceFragmentDensityMapPropertiesEXT;
  };

  struct PhysicalDeviceFragmentShaderBarycentricFeaturesNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceFragmentShaderBarycentricFeaturesNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceFragmentShaderBarycentricFeaturesNV(
      VULKAN_HPP_NAMESPACE::Bool32 fragmentShaderBarycentric_ = {} ) VULKAN_HPP_NOEXCEPT
      : fragmentShaderBarycentric( fragmentShaderBarycentric_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceFragmentShaderBarycentricFeaturesNV(
      PhysicalDeviceFragmentShaderBarycentricFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceFragmentShaderBarycentricFeaturesNV( VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceFragmentShaderBarycentricFeaturesNV(
          *reinterpret_cast<PhysicalDeviceFragmentShaderBarycentricFeaturesNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceFragmentShaderBarycentricFeaturesNV &
                            operator=( PhysicalDeviceFragmentShaderBarycentricFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceFragmentShaderBarycentricFeaturesNV &
      operator=( VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this =
        *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceFragmentShaderBarycentricFeaturesNV const *>( &rhs );
      return *this;
    }

    PhysicalDeviceFragmentShaderBarycentricFeaturesNV & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceFragmentShaderBarycentricFeaturesNV &
      setFragmentShaderBarycentric( VULKAN_HPP_NAMESPACE::Bool32 fragmentShaderBarycentric_ ) VULKAN_HPP_NOEXCEPT
    {
      fragmentShaderBarycentric = fragmentShaderBarycentric_;
      return *this;
    }

    operator VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV *>( this );
    }

    operator VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceFragmentShaderBarycentricFeaturesNV const & ) const = default;
#else
    bool operator==( PhysicalDeviceFragmentShaderBarycentricFeaturesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( fragmentShaderBarycentric == rhs.fragmentShaderBarycentric );
    }

    bool operator!=( PhysicalDeviceFragmentShaderBarycentricFeaturesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceFragmentShaderBarycentricFeaturesNV;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        fragmentShaderBarycentric = {};
  };
  static_assert( sizeof( PhysicalDeviceFragmentShaderBarycentricFeaturesNV ) ==
                   sizeof( VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceFragmentShaderBarycentricFeaturesNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceFragmentShaderBarycentricFeaturesNV>
  {
    using Type = PhysicalDeviceFragmentShaderBarycentricFeaturesNV;
  };

  struct PhysicalDeviceFragmentShaderInterlockFeaturesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceFragmentShaderInterlockFeaturesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceFragmentShaderInterlockFeaturesEXT(
      VULKAN_HPP_NAMESPACE::Bool32 fragmentShaderSampleInterlock_      = {},
      VULKAN_HPP_NAMESPACE::Bool32 fragmentShaderPixelInterlock_       = {},
      VULKAN_HPP_NAMESPACE::Bool32 fragmentShaderShadingRateInterlock_ = {} ) VULKAN_HPP_NOEXCEPT
      : fragmentShaderSampleInterlock( fragmentShaderSampleInterlock_ )
      , fragmentShaderPixelInterlock( fragmentShaderPixelInterlock_ )
      , fragmentShaderShadingRateInterlock( fragmentShaderShadingRateInterlock_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceFragmentShaderInterlockFeaturesEXT(
      PhysicalDeviceFragmentShaderInterlockFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceFragmentShaderInterlockFeaturesEXT( VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceFragmentShaderInterlockFeaturesEXT(
          *reinterpret_cast<PhysicalDeviceFragmentShaderInterlockFeaturesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceFragmentShaderInterlockFeaturesEXT &
                            operator=( PhysicalDeviceFragmentShaderInterlockFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceFragmentShaderInterlockFeaturesEXT &
      operator=( VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceFragmentShaderInterlockFeaturesEXT const *>( &rhs );
      return *this;
    }

    PhysicalDeviceFragmentShaderInterlockFeaturesEXT & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceFragmentShaderInterlockFeaturesEXT & setFragmentShaderSampleInterlock(
      VULKAN_HPP_NAMESPACE::Bool32 fragmentShaderSampleInterlock_ ) VULKAN_HPP_NOEXCEPT
    {
      fragmentShaderSampleInterlock = fragmentShaderSampleInterlock_;
      return *this;
    }

    PhysicalDeviceFragmentShaderInterlockFeaturesEXT &
      setFragmentShaderPixelInterlock( VULKAN_HPP_NAMESPACE::Bool32 fragmentShaderPixelInterlock_ ) VULKAN_HPP_NOEXCEPT
    {
      fragmentShaderPixelInterlock = fragmentShaderPixelInterlock_;
      return *this;
    }

    PhysicalDeviceFragmentShaderInterlockFeaturesEXT & setFragmentShaderShadingRateInterlock(
      VULKAN_HPP_NAMESPACE::Bool32 fragmentShaderShadingRateInterlock_ ) VULKAN_HPP_NOEXCEPT
    {
      fragmentShaderShadingRateInterlock = fragmentShaderShadingRateInterlock_;
      return *this;
    }

    operator VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT *>( this );
    }

    operator VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceFragmentShaderInterlockFeaturesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceFragmentShaderInterlockFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( fragmentShaderSampleInterlock == rhs.fragmentShaderSampleInterlock ) &&
             ( fragmentShaderPixelInterlock == rhs.fragmentShaderPixelInterlock ) &&
             ( fragmentShaderShadingRateInterlock == rhs.fragmentShaderShadingRateInterlock );
    }

    bool operator!=( PhysicalDeviceFragmentShaderInterlockFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceFragmentShaderInterlockFeaturesEXT;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        fragmentShaderSampleInterlock      = {};
    VULKAN_HPP_NAMESPACE::Bool32        fragmentShaderPixelInterlock       = {};
    VULKAN_HPP_NAMESPACE::Bool32        fragmentShaderShadingRateInterlock = {};
  };
  static_assert( sizeof( PhysicalDeviceFragmentShaderInterlockFeaturesEXT ) ==
                   sizeof( VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceFragmentShaderInterlockFeaturesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceFragmentShaderInterlockFeaturesEXT>
  {
    using Type = PhysicalDeviceFragmentShaderInterlockFeaturesEXT;
  };

  struct PhysicalDeviceFragmentShadingRateEnumsFeaturesNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceFragmentShadingRateEnumsFeaturesNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceFragmentShadingRateEnumsFeaturesNV(
      VULKAN_HPP_NAMESPACE::Bool32 fragmentShadingRateEnums_         = {},
      VULKAN_HPP_NAMESPACE::Bool32 supersampleFragmentShadingRates_  = {},
      VULKAN_HPP_NAMESPACE::Bool32 noInvocationFragmentShadingRates_ = {} ) VULKAN_HPP_NOEXCEPT
      : fragmentShadingRateEnums( fragmentShadingRateEnums_ )
      , supersampleFragmentShadingRates( supersampleFragmentShadingRates_ )
      , noInvocationFragmentShadingRates( noInvocationFragmentShadingRates_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceFragmentShadingRateEnumsFeaturesNV(
      PhysicalDeviceFragmentShadingRateEnumsFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceFragmentShadingRateEnumsFeaturesNV( VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceFragmentShadingRateEnumsFeaturesNV(
          *reinterpret_cast<PhysicalDeviceFragmentShadingRateEnumsFeaturesNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceFragmentShadingRateEnumsFeaturesNV &
                            operator=( PhysicalDeviceFragmentShadingRateEnumsFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceFragmentShadingRateEnumsFeaturesNV &
      operator=( VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceFragmentShadingRateEnumsFeaturesNV const *>( &rhs );
      return *this;
    }

    PhysicalDeviceFragmentShadingRateEnumsFeaturesNV & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceFragmentShadingRateEnumsFeaturesNV &
      setFragmentShadingRateEnums( VULKAN_HPP_NAMESPACE::Bool32 fragmentShadingRateEnums_ ) VULKAN_HPP_NOEXCEPT
    {
      fragmentShadingRateEnums = fragmentShadingRateEnums_;
      return *this;
    }

    PhysicalDeviceFragmentShadingRateEnumsFeaturesNV & setSupersampleFragmentShadingRates(
      VULKAN_HPP_NAMESPACE::Bool32 supersampleFragmentShadingRates_ ) VULKAN_HPP_NOEXCEPT
    {
      supersampleFragmentShadingRates = supersampleFragmentShadingRates_;
      return *this;
    }

    PhysicalDeviceFragmentShadingRateEnumsFeaturesNV & setNoInvocationFragmentShadingRates(
      VULKAN_HPP_NAMESPACE::Bool32 noInvocationFragmentShadingRates_ ) VULKAN_HPP_NOEXCEPT
    {
      noInvocationFragmentShadingRates = noInvocationFragmentShadingRates_;
      return *this;
    }

    operator VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV *>( this );
    }

    operator VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceFragmentShadingRateEnumsFeaturesNV const & ) const = default;
#else
    bool operator==( PhysicalDeviceFragmentShadingRateEnumsFeaturesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( fragmentShadingRateEnums == rhs.fragmentShadingRateEnums ) &&
             ( supersampleFragmentShadingRates == rhs.supersampleFragmentShadingRates ) &&
             ( noInvocationFragmentShadingRates == rhs.noInvocationFragmentShadingRates );
    }

    bool operator!=( PhysicalDeviceFragmentShadingRateEnumsFeaturesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceFragmentShadingRateEnumsFeaturesNV;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        fragmentShadingRateEnums         = {};
    VULKAN_HPP_NAMESPACE::Bool32        supersampleFragmentShadingRates  = {};
    VULKAN_HPP_NAMESPACE::Bool32        noInvocationFragmentShadingRates = {};
  };
  static_assert( sizeof( PhysicalDeviceFragmentShadingRateEnumsFeaturesNV ) ==
                   sizeof( VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceFragmentShadingRateEnumsFeaturesNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceFragmentShadingRateEnumsFeaturesNV>
  {
    using Type = PhysicalDeviceFragmentShadingRateEnumsFeaturesNV;
  };

  struct PhysicalDeviceFragmentShadingRateEnumsPropertiesNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceFragmentShadingRateEnumsPropertiesNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceFragmentShadingRateEnumsPropertiesNV(
      VULKAN_HPP_NAMESPACE::SampleCountFlagBits maxFragmentShadingRateInvocationCount_ =
        VULKAN_HPP_NAMESPACE::SampleCountFlagBits::e1 ) VULKAN_HPP_NOEXCEPT
      : maxFragmentShadingRateInvocationCount( maxFragmentShadingRateInvocationCount_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceFragmentShadingRateEnumsPropertiesNV(
      PhysicalDeviceFragmentShadingRateEnumsPropertiesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceFragmentShadingRateEnumsPropertiesNV(
      VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceFragmentShadingRateEnumsPropertiesNV(
          *reinterpret_cast<PhysicalDeviceFragmentShadingRateEnumsPropertiesNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceFragmentShadingRateEnumsPropertiesNV &
                            operator=( PhysicalDeviceFragmentShadingRateEnumsPropertiesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceFragmentShadingRateEnumsPropertiesNV &
      operator=( VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this =
        *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceFragmentShadingRateEnumsPropertiesNV const *>( &rhs );
      return *this;
    }

    PhysicalDeviceFragmentShadingRateEnumsPropertiesNV & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceFragmentShadingRateEnumsPropertiesNV & setMaxFragmentShadingRateInvocationCount(
      VULKAN_HPP_NAMESPACE::SampleCountFlagBits maxFragmentShadingRateInvocationCount_ ) VULKAN_HPP_NOEXCEPT
    {
      maxFragmentShadingRateInvocationCount = maxFragmentShadingRateInvocationCount_;
      return *this;
    }

    operator VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV *>( this );
    }

    operator VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceFragmentShadingRateEnumsPropertiesNV const & ) const = default;
#else
    bool operator==( PhysicalDeviceFragmentShadingRateEnumsPropertiesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( maxFragmentShadingRateInvocationCount == rhs.maxFragmentShadingRateInvocationCount );
    }

    bool operator!=( PhysicalDeviceFragmentShadingRateEnumsPropertiesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceFragmentShadingRateEnumsPropertiesNV;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::SampleCountFlagBits maxFragmentShadingRateInvocationCount =
      VULKAN_HPP_NAMESPACE::SampleCountFlagBits::e1;
  };
  static_assert( sizeof( PhysicalDeviceFragmentShadingRateEnumsPropertiesNV ) ==
                   sizeof( VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceFragmentShadingRateEnumsPropertiesNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceFragmentShadingRateEnumsPropertiesNV>
  {
    using Type = PhysicalDeviceFragmentShadingRateEnumsPropertiesNV;
  };

  struct PhysicalDeviceFragmentShadingRateFeaturesKHR
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceFragmentShadingRateFeaturesKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceFragmentShadingRateFeaturesKHR(
      VULKAN_HPP_NAMESPACE::Bool32 pipelineFragmentShadingRate_   = {},
      VULKAN_HPP_NAMESPACE::Bool32 primitiveFragmentShadingRate_  = {},
      VULKAN_HPP_NAMESPACE::Bool32 attachmentFragmentShadingRate_ = {} ) VULKAN_HPP_NOEXCEPT
      : pipelineFragmentShadingRate( pipelineFragmentShadingRate_ )
      , primitiveFragmentShadingRate( primitiveFragmentShadingRate_ )
      , attachmentFragmentShadingRate( attachmentFragmentShadingRate_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceFragmentShadingRateFeaturesKHR(
      PhysicalDeviceFragmentShadingRateFeaturesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceFragmentShadingRateFeaturesKHR( VkPhysicalDeviceFragmentShadingRateFeaturesKHR const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceFragmentShadingRateFeaturesKHR(
          *reinterpret_cast<PhysicalDeviceFragmentShadingRateFeaturesKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceFragmentShadingRateFeaturesKHR &
                            operator=( PhysicalDeviceFragmentShadingRateFeaturesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceFragmentShadingRateFeaturesKHR &
      operator=( VkPhysicalDeviceFragmentShadingRateFeaturesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceFragmentShadingRateFeaturesKHR const *>( &rhs );
      return *this;
    }

    PhysicalDeviceFragmentShadingRateFeaturesKHR & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceFragmentShadingRateFeaturesKHR &
      setPipelineFragmentShadingRate( VULKAN_HPP_NAMESPACE::Bool32 pipelineFragmentShadingRate_ ) VULKAN_HPP_NOEXCEPT
    {
      pipelineFragmentShadingRate = pipelineFragmentShadingRate_;
      return *this;
    }

    PhysicalDeviceFragmentShadingRateFeaturesKHR &
      setPrimitiveFragmentShadingRate( VULKAN_HPP_NAMESPACE::Bool32 primitiveFragmentShadingRate_ ) VULKAN_HPP_NOEXCEPT
    {
      primitiveFragmentShadingRate = primitiveFragmentShadingRate_;
      return *this;
    }

    PhysicalDeviceFragmentShadingRateFeaturesKHR & setAttachmentFragmentShadingRate(
      VULKAN_HPP_NAMESPACE::Bool32 attachmentFragmentShadingRate_ ) VULKAN_HPP_NOEXCEPT
    {
      attachmentFragmentShadingRate = attachmentFragmentShadingRate_;
      return *this;
    }

    operator VkPhysicalDeviceFragmentShadingRateFeaturesKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceFragmentShadingRateFeaturesKHR *>( this );
    }

    operator VkPhysicalDeviceFragmentShadingRateFeaturesKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceFragmentShadingRateFeaturesKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceFragmentShadingRateFeaturesKHR const & ) const = default;
#else
    bool operator==( PhysicalDeviceFragmentShadingRateFeaturesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( pipelineFragmentShadingRate == rhs.pipelineFragmentShadingRate ) &&
             ( primitiveFragmentShadingRate == rhs.primitiveFragmentShadingRate ) &&
             ( attachmentFragmentShadingRate == rhs.attachmentFragmentShadingRate );
    }

    bool operator!=( PhysicalDeviceFragmentShadingRateFeaturesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceFragmentShadingRateFeaturesKHR;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        pipelineFragmentShadingRate   = {};
    VULKAN_HPP_NAMESPACE::Bool32        primitiveFragmentShadingRate  = {};
    VULKAN_HPP_NAMESPACE::Bool32        attachmentFragmentShadingRate = {};
  };
  static_assert( sizeof( PhysicalDeviceFragmentShadingRateFeaturesKHR ) ==
                   sizeof( VkPhysicalDeviceFragmentShadingRateFeaturesKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceFragmentShadingRateFeaturesKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceFragmentShadingRateFeaturesKHR>
  {
    using Type = PhysicalDeviceFragmentShadingRateFeaturesKHR;
  };

  struct PhysicalDeviceFragmentShadingRateKHR
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceFragmentShadingRateKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      PhysicalDeviceFragmentShadingRateKHR( VULKAN_HPP_NAMESPACE::SampleCountFlags sampleCounts_ = {},
                                            VULKAN_HPP_NAMESPACE::Extent2D fragmentSize_ = {} ) VULKAN_HPP_NOEXCEPT
      : sampleCounts( sampleCounts_ )
      , fragmentSize( fragmentSize_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceFragmentShadingRateKHR( PhysicalDeviceFragmentShadingRateKHR const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceFragmentShadingRateKHR( VkPhysicalDeviceFragmentShadingRateKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceFragmentShadingRateKHR( *reinterpret_cast<PhysicalDeviceFragmentShadingRateKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceFragmentShadingRateKHR &
                            operator=( PhysicalDeviceFragmentShadingRateKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceFragmentShadingRateKHR &
      operator=( VkPhysicalDeviceFragmentShadingRateKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceFragmentShadingRateKHR const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceFragmentShadingRateKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceFragmentShadingRateKHR *>( this );
    }

    operator VkPhysicalDeviceFragmentShadingRateKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceFragmentShadingRateKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceFragmentShadingRateKHR const & ) const = default;
#else
    bool operator==( PhysicalDeviceFragmentShadingRateKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( sampleCounts == rhs.sampleCounts ) &&
             ( fragmentSize == rhs.fragmentSize );
    }

    bool operator!=( PhysicalDeviceFragmentShadingRateKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType    sType        = StructureType::ePhysicalDeviceFragmentShadingRateKHR;
    void *                                 pNext        = {};
    VULKAN_HPP_NAMESPACE::SampleCountFlags sampleCounts = {};
    VULKAN_HPP_NAMESPACE::Extent2D         fragmentSize = {};
  };
  static_assert( sizeof( PhysicalDeviceFragmentShadingRateKHR ) == sizeof( VkPhysicalDeviceFragmentShadingRateKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceFragmentShadingRateKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceFragmentShadingRateKHR>
  {
    using Type = PhysicalDeviceFragmentShadingRateKHR;
  };

  struct PhysicalDeviceFragmentShadingRatePropertiesKHR
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceFragmentShadingRatePropertiesKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceFragmentShadingRatePropertiesKHR(
      VULKAN_HPP_NAMESPACE::Extent2D            minFragmentShadingRateAttachmentTexelSize_            = {},
      VULKAN_HPP_NAMESPACE::Extent2D            maxFragmentShadingRateAttachmentTexelSize_            = {},
      uint32_t                                  maxFragmentShadingRateAttachmentTexelSizeAspectRatio_ = {},
      VULKAN_HPP_NAMESPACE::Bool32              primitiveFragmentShadingRateWithMultipleViewports_    = {},
      VULKAN_HPP_NAMESPACE::Bool32              layeredShadingRateAttachments_                        = {},
      VULKAN_HPP_NAMESPACE::Bool32              fragmentShadingRateNonTrivialCombinerOps_             = {},
      VULKAN_HPP_NAMESPACE::Extent2D            maxFragmentSize_                                      = {},
      uint32_t                                  maxFragmentSizeAspectRatio_                           = {},
      uint32_t                                  maxFragmentShadingRateCoverageSamples_                = {},
      VULKAN_HPP_NAMESPACE::SampleCountFlagBits maxFragmentShadingRateRasterizationSamples_ =
        VULKAN_HPP_NAMESPACE::SampleCountFlagBits::e1,
      VULKAN_HPP_NAMESPACE::Bool32 fragmentShadingRateWithShaderDepthStencilWrites_  = {},
      VULKAN_HPP_NAMESPACE::Bool32 fragmentShadingRateWithSampleMask_                = {},
      VULKAN_HPP_NAMESPACE::Bool32 fragmentShadingRateWithShaderSampleMask_          = {},
      VULKAN_HPP_NAMESPACE::Bool32 fragmentShadingRateWithConservativeRasterization_ = {},
      VULKAN_HPP_NAMESPACE::Bool32 fragmentShadingRateWithFragmentShaderInterlock_   = {},
      VULKAN_HPP_NAMESPACE::Bool32 fragmentShadingRateWithCustomSampleLocations_     = {},
      VULKAN_HPP_NAMESPACE::Bool32 fragmentShadingRateStrictMultiplyCombiner_        = {} ) VULKAN_HPP_NOEXCEPT
      : minFragmentShadingRateAttachmentTexelSize( minFragmentShadingRateAttachmentTexelSize_ )
      , maxFragmentShadingRateAttachmentTexelSize( maxFragmentShadingRateAttachmentTexelSize_ )
      , maxFragmentShadingRateAttachmentTexelSizeAspectRatio( maxFragmentShadingRateAttachmentTexelSizeAspectRatio_ )
      , primitiveFragmentShadingRateWithMultipleViewports( primitiveFragmentShadingRateWithMultipleViewports_ )
      , layeredShadingRateAttachments( layeredShadingRateAttachments_ )
      , fragmentShadingRateNonTrivialCombinerOps( fragmentShadingRateNonTrivialCombinerOps_ )
      , maxFragmentSize( maxFragmentSize_ )
      , maxFragmentSizeAspectRatio( maxFragmentSizeAspectRatio_ )
      , maxFragmentShadingRateCoverageSamples( maxFragmentShadingRateCoverageSamples_ )
      , maxFragmentShadingRateRasterizationSamples( maxFragmentShadingRateRasterizationSamples_ )
      , fragmentShadingRateWithShaderDepthStencilWrites( fragmentShadingRateWithShaderDepthStencilWrites_ )
      , fragmentShadingRateWithSampleMask( fragmentShadingRateWithSampleMask_ )
      , fragmentShadingRateWithShaderSampleMask( fragmentShadingRateWithShaderSampleMask_ )
      , fragmentShadingRateWithConservativeRasterization( fragmentShadingRateWithConservativeRasterization_ )
      , fragmentShadingRateWithFragmentShaderInterlock( fragmentShadingRateWithFragmentShaderInterlock_ )
      , fragmentShadingRateWithCustomSampleLocations( fragmentShadingRateWithCustomSampleLocations_ )
      , fragmentShadingRateStrictMultiplyCombiner( fragmentShadingRateStrictMultiplyCombiner_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceFragmentShadingRatePropertiesKHR(
      PhysicalDeviceFragmentShadingRatePropertiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceFragmentShadingRatePropertiesKHR( VkPhysicalDeviceFragmentShadingRatePropertiesKHR const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceFragmentShadingRatePropertiesKHR(
          *reinterpret_cast<PhysicalDeviceFragmentShadingRatePropertiesKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceFragmentShadingRatePropertiesKHR &
                            operator=( PhysicalDeviceFragmentShadingRatePropertiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceFragmentShadingRatePropertiesKHR &
      operator=( VkPhysicalDeviceFragmentShadingRatePropertiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceFragmentShadingRatePropertiesKHR const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceFragmentShadingRatePropertiesKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceFragmentShadingRatePropertiesKHR *>( this );
    }

    operator VkPhysicalDeviceFragmentShadingRatePropertiesKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceFragmentShadingRatePropertiesKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceFragmentShadingRatePropertiesKHR const & ) const = default;
#else
    bool operator==( PhysicalDeviceFragmentShadingRatePropertiesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( minFragmentShadingRateAttachmentTexelSize == rhs.minFragmentShadingRateAttachmentTexelSize ) &&
             ( maxFragmentShadingRateAttachmentTexelSize == rhs.maxFragmentShadingRateAttachmentTexelSize ) &&
             ( maxFragmentShadingRateAttachmentTexelSizeAspectRatio ==
               rhs.maxFragmentShadingRateAttachmentTexelSizeAspectRatio ) &&
             ( primitiveFragmentShadingRateWithMultipleViewports ==
               rhs.primitiveFragmentShadingRateWithMultipleViewports ) &&
             ( layeredShadingRateAttachments == rhs.layeredShadingRateAttachments ) &&
             ( fragmentShadingRateNonTrivialCombinerOps == rhs.fragmentShadingRateNonTrivialCombinerOps ) &&
             ( maxFragmentSize == rhs.maxFragmentSize ) &&
             ( maxFragmentSizeAspectRatio == rhs.maxFragmentSizeAspectRatio ) &&
             ( maxFragmentShadingRateCoverageSamples == rhs.maxFragmentShadingRateCoverageSamples ) &&
             ( maxFragmentShadingRateRasterizationSamples == rhs.maxFragmentShadingRateRasterizationSamples ) &&
             ( fragmentShadingRateWithShaderDepthStencilWrites ==
               rhs.fragmentShadingRateWithShaderDepthStencilWrites ) &&
             ( fragmentShadingRateWithSampleMask == rhs.fragmentShadingRateWithSampleMask ) &&
             ( fragmentShadingRateWithShaderSampleMask == rhs.fragmentShadingRateWithShaderSampleMask ) &&
             ( fragmentShadingRateWithConservativeRasterization ==
               rhs.fragmentShadingRateWithConservativeRasterization ) &&
             ( fragmentShadingRateWithFragmentShaderInterlock == rhs.fragmentShadingRateWithFragmentShaderInterlock ) &&
             ( fragmentShadingRateWithCustomSampleLocations == rhs.fragmentShadingRateWithCustomSampleLocations ) &&
             ( fragmentShadingRateStrictMultiplyCombiner == rhs.fragmentShadingRateStrictMultiplyCombiner );
    }

    bool operator!=( PhysicalDeviceFragmentShadingRatePropertiesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType       sType = StructureType::ePhysicalDeviceFragmentShadingRatePropertiesKHR;
    void *                                    pNext = {};
    VULKAN_HPP_NAMESPACE::Extent2D            minFragmentShadingRateAttachmentTexelSize            = {};
    VULKAN_HPP_NAMESPACE::Extent2D            maxFragmentShadingRateAttachmentTexelSize            = {};
    uint32_t                                  maxFragmentShadingRateAttachmentTexelSizeAspectRatio = {};
    VULKAN_HPP_NAMESPACE::Bool32              primitiveFragmentShadingRateWithMultipleViewports    = {};
    VULKAN_HPP_NAMESPACE::Bool32              layeredShadingRateAttachments                        = {};
    VULKAN_HPP_NAMESPACE::Bool32              fragmentShadingRateNonTrivialCombinerOps             = {};
    VULKAN_HPP_NAMESPACE::Extent2D            maxFragmentSize                                      = {};
    uint32_t                                  maxFragmentSizeAspectRatio                           = {};
    uint32_t                                  maxFragmentShadingRateCoverageSamples                = {};
    VULKAN_HPP_NAMESPACE::SampleCountFlagBits maxFragmentShadingRateRasterizationSamples =
      VULKAN_HPP_NAMESPACE::SampleCountFlagBits::e1;
    VULKAN_HPP_NAMESPACE::Bool32 fragmentShadingRateWithShaderDepthStencilWrites  = {};
    VULKAN_HPP_NAMESPACE::Bool32 fragmentShadingRateWithSampleMask                = {};
    VULKAN_HPP_NAMESPACE::Bool32 fragmentShadingRateWithShaderSampleMask          = {};
    VULKAN_HPP_NAMESPACE::Bool32 fragmentShadingRateWithConservativeRasterization = {};
    VULKAN_HPP_NAMESPACE::Bool32 fragmentShadingRateWithFragmentShaderInterlock   = {};
    VULKAN_HPP_NAMESPACE::Bool32 fragmentShadingRateWithCustomSampleLocations     = {};
    VULKAN_HPP_NAMESPACE::Bool32 fragmentShadingRateStrictMultiplyCombiner        = {};
  };
  static_assert( sizeof( PhysicalDeviceFragmentShadingRatePropertiesKHR ) ==
                   sizeof( VkPhysicalDeviceFragmentShadingRatePropertiesKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceFragmentShadingRatePropertiesKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceFragmentShadingRatePropertiesKHR>
  {
    using Type = PhysicalDeviceFragmentShadingRatePropertiesKHR;
  };

  struct PhysicalDeviceGlobalPriorityQueryFeaturesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceGlobalPriorityQueryFeaturesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceGlobalPriorityQueryFeaturesEXT(
      VULKAN_HPP_NAMESPACE::Bool32 globalPriorityQuery_ = {} ) VULKAN_HPP_NOEXCEPT
      : globalPriorityQuery( globalPriorityQuery_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceGlobalPriorityQueryFeaturesEXT(
      PhysicalDeviceGlobalPriorityQueryFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceGlobalPriorityQueryFeaturesEXT( VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceGlobalPriorityQueryFeaturesEXT(
          *reinterpret_cast<PhysicalDeviceGlobalPriorityQueryFeaturesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceGlobalPriorityQueryFeaturesEXT &
                            operator=( PhysicalDeviceGlobalPriorityQueryFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceGlobalPriorityQueryFeaturesEXT &
      operator=( VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceGlobalPriorityQueryFeaturesEXT const *>( &rhs );
      return *this;
    }

    PhysicalDeviceGlobalPriorityQueryFeaturesEXT & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceGlobalPriorityQueryFeaturesEXT &
      setGlobalPriorityQuery( VULKAN_HPP_NAMESPACE::Bool32 globalPriorityQuery_ ) VULKAN_HPP_NOEXCEPT
    {
      globalPriorityQuery = globalPriorityQuery_;
      return *this;
    }

    operator VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT *>( this );
    }

    operator VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceGlobalPriorityQueryFeaturesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceGlobalPriorityQueryFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( globalPriorityQuery == rhs.globalPriorityQuery );
    }

    bool operator!=( PhysicalDeviceGlobalPriorityQueryFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceGlobalPriorityQueryFeaturesEXT;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        globalPriorityQuery = {};
  };
  static_assert( sizeof( PhysicalDeviceGlobalPriorityQueryFeaturesEXT ) ==
                   sizeof( VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceGlobalPriorityQueryFeaturesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceGlobalPriorityQueryFeaturesEXT>
  {
    using Type = PhysicalDeviceGlobalPriorityQueryFeaturesEXT;
  };

  struct PhysicalDeviceGroupProperties
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::ePhysicalDeviceGroupProperties;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceGroupProperties(
      uint32_t                                                                           physicalDeviceCount_ = {},
      std::array<VULKAN_HPP_NAMESPACE::PhysicalDevice, VK_MAX_DEVICE_GROUP_SIZE> const & physicalDevices_     = {},
      VULKAN_HPP_NAMESPACE::Bool32 subsetAllocation_ = {} ) VULKAN_HPP_NOEXCEPT
      : physicalDeviceCount( physicalDeviceCount_ )
      , physicalDevices( physicalDevices_ )
      , subsetAllocation( subsetAllocation_ )
    {}

    VULKAN_HPP_CONSTEXPR_14
      PhysicalDeviceGroupProperties( PhysicalDeviceGroupProperties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceGroupProperties( VkPhysicalDeviceGroupProperties const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceGroupProperties( *reinterpret_cast<PhysicalDeviceGroupProperties const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceGroupProperties &
                            operator=( PhysicalDeviceGroupProperties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceGroupProperties & operator=( VkPhysicalDeviceGroupProperties const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceGroupProperties const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceGroupProperties const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceGroupProperties *>( this );
    }

    operator VkPhysicalDeviceGroupProperties &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceGroupProperties *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceGroupProperties const & ) const = default;
#else
    bool operator==( PhysicalDeviceGroupProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( physicalDeviceCount == rhs.physicalDeviceCount ) &&
             ( physicalDevices == rhs.physicalDevices ) && ( subsetAllocation == rhs.subsetAllocation );
    }

    bool operator!=( PhysicalDeviceGroupProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType               = StructureType::ePhysicalDeviceGroupProperties;
    void *                              pNext               = {};
    uint32_t                            physicalDeviceCount = {};
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<VULKAN_HPP_NAMESPACE::PhysicalDevice, VK_MAX_DEVICE_GROUP_SIZE>
                                 physicalDevices  = {};
    VULKAN_HPP_NAMESPACE::Bool32 subsetAllocation = {};
  };
  static_assert( sizeof( PhysicalDeviceGroupProperties ) == sizeof( VkPhysicalDeviceGroupProperties ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceGroupProperties>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceGroupProperties>
  {
    using Type = PhysicalDeviceGroupProperties;
  };
  using PhysicalDeviceGroupPropertiesKHR = PhysicalDeviceGroupProperties;

  struct PhysicalDeviceHostQueryResetFeatures
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceHostQueryResetFeatures;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      PhysicalDeviceHostQueryResetFeatures( VULKAN_HPP_NAMESPACE::Bool32 hostQueryReset_ = {} ) VULKAN_HPP_NOEXCEPT
      : hostQueryReset( hostQueryReset_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceHostQueryResetFeatures( PhysicalDeviceHostQueryResetFeatures const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceHostQueryResetFeatures( VkPhysicalDeviceHostQueryResetFeatures const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceHostQueryResetFeatures( *reinterpret_cast<PhysicalDeviceHostQueryResetFeatures const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceHostQueryResetFeatures &
                            operator=( PhysicalDeviceHostQueryResetFeatures const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceHostQueryResetFeatures &
      operator=( VkPhysicalDeviceHostQueryResetFeatures const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceHostQueryResetFeatures const *>( &rhs );
      return *this;
    }

    PhysicalDeviceHostQueryResetFeatures & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceHostQueryResetFeatures &
      setHostQueryReset( VULKAN_HPP_NAMESPACE::Bool32 hostQueryReset_ ) VULKAN_HPP_NOEXCEPT
    {
      hostQueryReset = hostQueryReset_;
      return *this;
    }

    operator VkPhysicalDeviceHostQueryResetFeatures const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceHostQueryResetFeatures *>( this );
    }

    operator VkPhysicalDeviceHostQueryResetFeatures &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceHostQueryResetFeatures *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceHostQueryResetFeatures const & ) const = default;
#else
    bool operator==( PhysicalDeviceHostQueryResetFeatures const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( hostQueryReset == rhs.hostQueryReset );
    }

    bool operator!=( PhysicalDeviceHostQueryResetFeatures const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType          = StructureType::ePhysicalDeviceHostQueryResetFeatures;
    void *                              pNext          = {};
    VULKAN_HPP_NAMESPACE::Bool32        hostQueryReset = {};
  };
  static_assert( sizeof( PhysicalDeviceHostQueryResetFeatures ) == sizeof( VkPhysicalDeviceHostQueryResetFeatures ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceHostQueryResetFeatures>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceHostQueryResetFeatures>
  {
    using Type = PhysicalDeviceHostQueryResetFeatures;
  };
  using PhysicalDeviceHostQueryResetFeaturesEXT = PhysicalDeviceHostQueryResetFeatures;

  struct PhysicalDeviceIDProperties
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::ePhysicalDeviceIdProperties;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR_14
      PhysicalDeviceIDProperties( std::array<uint8_t, VK_UUID_SIZE> const & deviceUUID_      = {},
                                  std::array<uint8_t, VK_UUID_SIZE> const & driverUUID_      = {},
                                  std::array<uint8_t, VK_LUID_SIZE> const & deviceLUID_      = {},
                                  uint32_t                                  deviceNodeMask_  = {},
                                  VULKAN_HPP_NAMESPACE::Bool32              deviceLUIDValid_ = {} ) VULKAN_HPP_NOEXCEPT
      : deviceUUID( deviceUUID_ )
      , driverUUID( driverUUID_ )
      , deviceLUID( deviceLUID_ )
      , deviceNodeMask( deviceNodeMask_ )
      , deviceLUIDValid( deviceLUIDValid_ )
    {}

    VULKAN_HPP_CONSTEXPR_14
      PhysicalDeviceIDProperties( PhysicalDeviceIDProperties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceIDProperties( VkPhysicalDeviceIDProperties const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceIDProperties( *reinterpret_cast<PhysicalDeviceIDProperties const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceIDProperties &
                            operator=( PhysicalDeviceIDProperties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceIDProperties & operator=( VkPhysicalDeviceIDProperties const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceIDProperties const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceIDProperties const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceIDProperties *>( this );
    }

    operator VkPhysicalDeviceIDProperties &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceIDProperties *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceIDProperties const & ) const = default;
#else
    bool operator==( PhysicalDeviceIDProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( deviceUUID == rhs.deviceUUID ) &&
             ( driverUUID == rhs.driverUUID ) && ( deviceLUID == rhs.deviceLUID ) &&
             ( deviceNodeMask == rhs.deviceNodeMask ) && ( deviceLUIDValid == rhs.deviceLUIDValid );
    }

    bool operator!=( PhysicalDeviceIDProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                         sType      = StructureType::ePhysicalDeviceIdProperties;
    void *                                                      pNext      = {};
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<uint8_t, VK_UUID_SIZE> deviceUUID = {};
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<uint8_t, VK_UUID_SIZE> driverUUID = {};
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<uint8_t, VK_LUID_SIZE> deviceLUID = {};
    uint32_t                                                    deviceNodeMask  = {};
    VULKAN_HPP_NAMESPACE::Bool32                                deviceLUIDValid = {};
  };
  static_assert( sizeof( PhysicalDeviceIDProperties ) == sizeof( VkPhysicalDeviceIDProperties ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceIDProperties>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceIdProperties>
  {
    using Type = PhysicalDeviceIDProperties;
  };
  using PhysicalDeviceIDPropertiesKHR = PhysicalDeviceIDProperties;

  struct PhysicalDeviceImageDrmFormatModifierInfoEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceImageDrmFormatModifierInfoEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceImageDrmFormatModifierInfoEXT(
      uint64_t                          drmFormatModifier_     = {},
      VULKAN_HPP_NAMESPACE::SharingMode sharingMode_           = VULKAN_HPP_NAMESPACE::SharingMode::eExclusive,
      uint32_t                          queueFamilyIndexCount_ = {},
      const uint32_t *                  pQueueFamilyIndices_   = {} ) VULKAN_HPP_NOEXCEPT
      : drmFormatModifier( drmFormatModifier_ )
      , sharingMode( sharingMode_ )
      , queueFamilyIndexCount( queueFamilyIndexCount_ )
      , pQueueFamilyIndices( pQueueFamilyIndices_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceImageDrmFormatModifierInfoEXT(
      PhysicalDeviceImageDrmFormatModifierInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceImageDrmFormatModifierInfoEXT( VkPhysicalDeviceImageDrmFormatModifierInfoEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceImageDrmFormatModifierInfoEXT(
          *reinterpret_cast<PhysicalDeviceImageDrmFormatModifierInfoEXT const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    PhysicalDeviceImageDrmFormatModifierInfoEXT(
      uint64_t                                                              drmFormatModifier_,
      VULKAN_HPP_NAMESPACE::SharingMode                                     sharingMode_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const & queueFamilyIndices_ )
      : drmFormatModifier( drmFormatModifier_ )
      , sharingMode( sharingMode_ )
      , queueFamilyIndexCount( static_cast<uint32_t>( queueFamilyIndices_.size() ) )
      , pQueueFamilyIndices( queueFamilyIndices_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceImageDrmFormatModifierInfoEXT &
                            operator=( PhysicalDeviceImageDrmFormatModifierInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceImageDrmFormatModifierInfoEXT &
      operator=( VkPhysicalDeviceImageDrmFormatModifierInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceImageDrmFormatModifierInfoEXT const *>( &rhs );
      return *this;
    }

    PhysicalDeviceImageDrmFormatModifierInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceImageDrmFormatModifierInfoEXT &
      setDrmFormatModifier( uint64_t drmFormatModifier_ ) VULKAN_HPP_NOEXCEPT
    {
      drmFormatModifier = drmFormatModifier_;
      return *this;
    }

    PhysicalDeviceImageDrmFormatModifierInfoEXT &
      setSharingMode( VULKAN_HPP_NAMESPACE::SharingMode sharingMode_ ) VULKAN_HPP_NOEXCEPT
    {
      sharingMode = sharingMode_;
      return *this;
    }

    PhysicalDeviceImageDrmFormatModifierInfoEXT &
      setQueueFamilyIndexCount( uint32_t queueFamilyIndexCount_ ) VULKAN_HPP_NOEXCEPT
    {
      queueFamilyIndexCount = queueFamilyIndexCount_;
      return *this;
    }

    PhysicalDeviceImageDrmFormatModifierInfoEXT &
      setPQueueFamilyIndices( const uint32_t * pQueueFamilyIndices_ ) VULKAN_HPP_NOEXCEPT
    {
      pQueueFamilyIndices = pQueueFamilyIndices_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    PhysicalDeviceImageDrmFormatModifierInfoEXT & setQueueFamilyIndices(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const & queueFamilyIndices_ ) VULKAN_HPP_NOEXCEPT
    {
      queueFamilyIndexCount = static_cast<uint32_t>( queueFamilyIndices_.size() );
      pQueueFamilyIndices   = queueFamilyIndices_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkPhysicalDeviceImageDrmFormatModifierInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceImageDrmFormatModifierInfoEXT *>( this );
    }

    operator VkPhysicalDeviceImageDrmFormatModifierInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceImageDrmFormatModifierInfoEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceImageDrmFormatModifierInfoEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceImageDrmFormatModifierInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( drmFormatModifier == rhs.drmFormatModifier ) &&
             ( sharingMode == rhs.sharingMode ) && ( queueFamilyIndexCount == rhs.queueFamilyIndexCount ) &&
             ( pQueueFamilyIndices == rhs.pQueueFamilyIndices );
    }

    bool operator!=( PhysicalDeviceImageDrmFormatModifierInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType             = StructureType::ePhysicalDeviceImageDrmFormatModifierInfoEXT;
    const void *                        pNext             = {};
    uint64_t                            drmFormatModifier = {};
    VULKAN_HPP_NAMESPACE::SharingMode   sharingMode       = VULKAN_HPP_NAMESPACE::SharingMode::eExclusive;
    uint32_t                            queueFamilyIndexCount = {};
    const uint32_t *                    pQueueFamilyIndices   = {};
  };
  static_assert( sizeof( PhysicalDeviceImageDrmFormatModifierInfoEXT ) ==
                   sizeof( VkPhysicalDeviceImageDrmFormatModifierInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceImageDrmFormatModifierInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceImageDrmFormatModifierInfoEXT>
  {
    using Type = PhysicalDeviceImageDrmFormatModifierInfoEXT;
  };

  struct PhysicalDeviceImageFormatInfo2
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::ePhysicalDeviceImageFormatInfo2;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceImageFormatInfo2(
      VULKAN_HPP_NAMESPACE::Format           format_ = VULKAN_HPP_NAMESPACE::Format::eUndefined,
      VULKAN_HPP_NAMESPACE::ImageType        type_   = VULKAN_HPP_NAMESPACE::ImageType::e1D,
      VULKAN_HPP_NAMESPACE::ImageTiling      tiling_ = VULKAN_HPP_NAMESPACE::ImageTiling::eOptimal,
      VULKAN_HPP_NAMESPACE::ImageUsageFlags  usage_  = {},
      VULKAN_HPP_NAMESPACE::ImageCreateFlags flags_  = {} ) VULKAN_HPP_NOEXCEPT
      : format( format_ )
      , type( type_ )
      , tiling( tiling_ )
      , usage( usage_ )
      , flags( flags_ )
    {}

    VULKAN_HPP_CONSTEXPR
      PhysicalDeviceImageFormatInfo2( PhysicalDeviceImageFormatInfo2 const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceImageFormatInfo2( VkPhysicalDeviceImageFormatInfo2 const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceImageFormatInfo2( *reinterpret_cast<PhysicalDeviceImageFormatInfo2 const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceImageFormatInfo2 &
                            operator=( PhysicalDeviceImageFormatInfo2 const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceImageFormatInfo2 & operator=( VkPhysicalDeviceImageFormatInfo2 const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceImageFormatInfo2 const *>( &rhs );
      return *this;
    }

    PhysicalDeviceImageFormatInfo2 & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceImageFormatInfo2 & setFormat( VULKAN_HPP_NAMESPACE::Format format_ ) VULKAN_HPP_NOEXCEPT
    {
      format = format_;
      return *this;
    }

    PhysicalDeviceImageFormatInfo2 & setType( VULKAN_HPP_NAMESPACE::ImageType type_ ) VULKAN_HPP_NOEXCEPT
    {
      type = type_;
      return *this;
    }

    PhysicalDeviceImageFormatInfo2 & setTiling( VULKAN_HPP_NAMESPACE::ImageTiling tiling_ ) VULKAN_HPP_NOEXCEPT
    {
      tiling = tiling_;
      return *this;
    }

    PhysicalDeviceImageFormatInfo2 & setUsage( VULKAN_HPP_NAMESPACE::ImageUsageFlags usage_ ) VULKAN_HPP_NOEXCEPT
    {
      usage = usage_;
      return *this;
    }

    PhysicalDeviceImageFormatInfo2 & setFlags( VULKAN_HPP_NAMESPACE::ImageCreateFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    operator VkPhysicalDeviceImageFormatInfo2 const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceImageFormatInfo2 *>( this );
    }

    operator VkPhysicalDeviceImageFormatInfo2 &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceImageFormatInfo2 *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceImageFormatInfo2 const & ) const = default;
#else
    bool operator==( PhysicalDeviceImageFormatInfo2 const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( format == rhs.format ) && ( type == rhs.type ) &&
             ( tiling == rhs.tiling ) && ( usage == rhs.usage ) && ( flags == rhs.flags );
    }

    bool operator!=( PhysicalDeviceImageFormatInfo2 const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType    sType  = StructureType::ePhysicalDeviceImageFormatInfo2;
    const void *                           pNext  = {};
    VULKAN_HPP_NAMESPACE::Format           format = VULKAN_HPP_NAMESPACE::Format::eUndefined;
    VULKAN_HPP_NAMESPACE::ImageType        type   = VULKAN_HPP_NAMESPACE::ImageType::e1D;
    VULKAN_HPP_NAMESPACE::ImageTiling      tiling = VULKAN_HPP_NAMESPACE::ImageTiling::eOptimal;
    VULKAN_HPP_NAMESPACE::ImageUsageFlags  usage  = {};
    VULKAN_HPP_NAMESPACE::ImageCreateFlags flags  = {};
  };
  static_assert( sizeof( PhysicalDeviceImageFormatInfo2 ) == sizeof( VkPhysicalDeviceImageFormatInfo2 ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceImageFormatInfo2>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceImageFormatInfo2>
  {
    using Type = PhysicalDeviceImageFormatInfo2;
  };
  using PhysicalDeviceImageFormatInfo2KHR = PhysicalDeviceImageFormatInfo2;

  struct PhysicalDeviceImageRobustnessFeaturesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceImageRobustnessFeaturesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceImageRobustnessFeaturesEXT(
      VULKAN_HPP_NAMESPACE::Bool32 robustImageAccess_ = {} ) VULKAN_HPP_NOEXCEPT
      : robustImageAccess( robustImageAccess_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceImageRobustnessFeaturesEXT(
      PhysicalDeviceImageRobustnessFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceImageRobustnessFeaturesEXT( VkPhysicalDeviceImageRobustnessFeaturesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceImageRobustnessFeaturesEXT(
          *reinterpret_cast<PhysicalDeviceImageRobustnessFeaturesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceImageRobustnessFeaturesEXT &
                            operator=( PhysicalDeviceImageRobustnessFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceImageRobustnessFeaturesEXT &
      operator=( VkPhysicalDeviceImageRobustnessFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceImageRobustnessFeaturesEXT const *>( &rhs );
      return *this;
    }

    PhysicalDeviceImageRobustnessFeaturesEXT & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceImageRobustnessFeaturesEXT &
      setRobustImageAccess( VULKAN_HPP_NAMESPACE::Bool32 robustImageAccess_ ) VULKAN_HPP_NOEXCEPT
    {
      robustImageAccess = robustImageAccess_;
      return *this;
    }

    operator VkPhysicalDeviceImageRobustnessFeaturesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceImageRobustnessFeaturesEXT *>( this );
    }

    operator VkPhysicalDeviceImageRobustnessFeaturesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceImageRobustnessFeaturesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceImageRobustnessFeaturesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceImageRobustnessFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( robustImageAccess == rhs.robustImageAccess );
    }

    bool operator!=( PhysicalDeviceImageRobustnessFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType             = StructureType::ePhysicalDeviceImageRobustnessFeaturesEXT;
    void *                              pNext             = {};
    VULKAN_HPP_NAMESPACE::Bool32        robustImageAccess = {};
  };
  static_assert( sizeof( PhysicalDeviceImageRobustnessFeaturesEXT ) ==
                   sizeof( VkPhysicalDeviceImageRobustnessFeaturesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceImageRobustnessFeaturesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceImageRobustnessFeaturesEXT>
  {
    using Type = PhysicalDeviceImageRobustnessFeaturesEXT;
  };

  struct PhysicalDeviceImageViewImageFormatInfoEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceImageViewImageFormatInfoEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      PhysicalDeviceImageViewImageFormatInfoEXT( VULKAN_HPP_NAMESPACE::ImageViewType imageViewType_ =
                                                   VULKAN_HPP_NAMESPACE::ImageViewType::e1D ) VULKAN_HPP_NOEXCEPT
      : imageViewType( imageViewType_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceImageViewImageFormatInfoEXT(
      PhysicalDeviceImageViewImageFormatInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceImageViewImageFormatInfoEXT( VkPhysicalDeviceImageViewImageFormatInfoEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceImageViewImageFormatInfoEXT(
          *reinterpret_cast<PhysicalDeviceImageViewImageFormatInfoEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceImageViewImageFormatInfoEXT &
                            operator=( PhysicalDeviceImageViewImageFormatInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceImageViewImageFormatInfoEXT &
      operator=( VkPhysicalDeviceImageViewImageFormatInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceImageViewImageFormatInfoEXT const *>( &rhs );
      return *this;
    }

    PhysicalDeviceImageViewImageFormatInfoEXT & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceImageViewImageFormatInfoEXT &
      setImageViewType( VULKAN_HPP_NAMESPACE::ImageViewType imageViewType_ ) VULKAN_HPP_NOEXCEPT
    {
      imageViewType = imageViewType_;
      return *this;
    }

    operator VkPhysicalDeviceImageViewImageFormatInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceImageViewImageFormatInfoEXT *>( this );
    }

    operator VkPhysicalDeviceImageViewImageFormatInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceImageViewImageFormatInfoEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceImageViewImageFormatInfoEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceImageViewImageFormatInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( imageViewType == rhs.imageViewType );
    }

    bool operator!=( PhysicalDeviceImageViewImageFormatInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType         = StructureType::ePhysicalDeviceImageViewImageFormatInfoEXT;
    void *                              pNext         = {};
    VULKAN_HPP_NAMESPACE::ImageViewType imageViewType = VULKAN_HPP_NAMESPACE::ImageViewType::e1D;
  };
  static_assert( sizeof( PhysicalDeviceImageViewImageFormatInfoEXT ) ==
                   sizeof( VkPhysicalDeviceImageViewImageFormatInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceImageViewImageFormatInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceImageViewImageFormatInfoEXT>
  {
    using Type = PhysicalDeviceImageViewImageFormatInfoEXT;
  };

  struct PhysicalDeviceImagelessFramebufferFeatures
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceImagelessFramebufferFeatures;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceImagelessFramebufferFeatures(
      VULKAN_HPP_NAMESPACE::Bool32 imagelessFramebuffer_ = {} ) VULKAN_HPP_NOEXCEPT
      : imagelessFramebuffer( imagelessFramebuffer_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceImagelessFramebufferFeatures(
      PhysicalDeviceImagelessFramebufferFeatures const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceImagelessFramebufferFeatures( VkPhysicalDeviceImagelessFramebufferFeatures const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceImagelessFramebufferFeatures(
          *reinterpret_cast<PhysicalDeviceImagelessFramebufferFeatures const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceImagelessFramebufferFeatures &
                            operator=( PhysicalDeviceImagelessFramebufferFeatures const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceImagelessFramebufferFeatures &
      operator=( VkPhysicalDeviceImagelessFramebufferFeatures const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceImagelessFramebufferFeatures const *>( &rhs );
      return *this;
    }

    PhysicalDeviceImagelessFramebufferFeatures & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceImagelessFramebufferFeatures &
      setImagelessFramebuffer( VULKAN_HPP_NAMESPACE::Bool32 imagelessFramebuffer_ ) VULKAN_HPP_NOEXCEPT
    {
      imagelessFramebuffer = imagelessFramebuffer_;
      return *this;
    }

    operator VkPhysicalDeviceImagelessFramebufferFeatures const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceImagelessFramebufferFeatures *>( this );
    }

    operator VkPhysicalDeviceImagelessFramebufferFeatures &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceImagelessFramebufferFeatures *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceImagelessFramebufferFeatures const & ) const = default;
#else
    bool operator==( PhysicalDeviceImagelessFramebufferFeatures const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( imagelessFramebuffer == rhs.imagelessFramebuffer );
    }

    bool operator!=( PhysicalDeviceImagelessFramebufferFeatures const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceImagelessFramebufferFeatures;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        imagelessFramebuffer = {};
  };
  static_assert( sizeof( PhysicalDeviceImagelessFramebufferFeatures ) ==
                   sizeof( VkPhysicalDeviceImagelessFramebufferFeatures ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceImagelessFramebufferFeatures>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceImagelessFramebufferFeatures>
  {
    using Type = PhysicalDeviceImagelessFramebufferFeatures;
  };
  using PhysicalDeviceImagelessFramebufferFeaturesKHR = PhysicalDeviceImagelessFramebufferFeatures;

  struct PhysicalDeviceIndexTypeUint8FeaturesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceIndexTypeUint8FeaturesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      PhysicalDeviceIndexTypeUint8FeaturesEXT( VULKAN_HPP_NAMESPACE::Bool32 indexTypeUint8_ = {} ) VULKAN_HPP_NOEXCEPT
      : indexTypeUint8( indexTypeUint8_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceIndexTypeUint8FeaturesEXT( PhysicalDeviceIndexTypeUint8FeaturesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceIndexTypeUint8FeaturesEXT( VkPhysicalDeviceIndexTypeUint8FeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceIndexTypeUint8FeaturesEXT(
          *reinterpret_cast<PhysicalDeviceIndexTypeUint8FeaturesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceIndexTypeUint8FeaturesEXT &
                            operator=( PhysicalDeviceIndexTypeUint8FeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceIndexTypeUint8FeaturesEXT &
      operator=( VkPhysicalDeviceIndexTypeUint8FeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceIndexTypeUint8FeaturesEXT const *>( &rhs );
      return *this;
    }

    PhysicalDeviceIndexTypeUint8FeaturesEXT & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceIndexTypeUint8FeaturesEXT &
      setIndexTypeUint8( VULKAN_HPP_NAMESPACE::Bool32 indexTypeUint8_ ) VULKAN_HPP_NOEXCEPT
    {
      indexTypeUint8 = indexTypeUint8_;
      return *this;
    }

    operator VkPhysicalDeviceIndexTypeUint8FeaturesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceIndexTypeUint8FeaturesEXT *>( this );
    }

    operator VkPhysicalDeviceIndexTypeUint8FeaturesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceIndexTypeUint8FeaturesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceIndexTypeUint8FeaturesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceIndexTypeUint8FeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( indexTypeUint8 == rhs.indexTypeUint8 );
    }

    bool operator!=( PhysicalDeviceIndexTypeUint8FeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType          = StructureType::ePhysicalDeviceIndexTypeUint8FeaturesEXT;
    void *                              pNext          = {};
    VULKAN_HPP_NAMESPACE::Bool32        indexTypeUint8 = {};
  };
  static_assert( sizeof( PhysicalDeviceIndexTypeUint8FeaturesEXT ) ==
                   sizeof( VkPhysicalDeviceIndexTypeUint8FeaturesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceIndexTypeUint8FeaturesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceIndexTypeUint8FeaturesEXT>
  {
    using Type = PhysicalDeviceIndexTypeUint8FeaturesEXT;
  };

  struct PhysicalDeviceInheritedViewportScissorFeaturesNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceInheritedViewportScissorFeaturesNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceInheritedViewportScissorFeaturesNV(
      VULKAN_HPP_NAMESPACE::Bool32 inheritedViewportScissor2D_ = {} ) VULKAN_HPP_NOEXCEPT
      : inheritedViewportScissor2D( inheritedViewportScissor2D_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceInheritedViewportScissorFeaturesNV(
      PhysicalDeviceInheritedViewportScissorFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceInheritedViewportScissorFeaturesNV( VkPhysicalDeviceInheritedViewportScissorFeaturesNV const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceInheritedViewportScissorFeaturesNV(
          *reinterpret_cast<PhysicalDeviceInheritedViewportScissorFeaturesNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceInheritedViewportScissorFeaturesNV &
                            operator=( PhysicalDeviceInheritedViewportScissorFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceInheritedViewportScissorFeaturesNV &
      operator=( VkPhysicalDeviceInheritedViewportScissorFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceInheritedViewportScissorFeaturesNV const *>( &rhs );
      return *this;
    }

    PhysicalDeviceInheritedViewportScissorFeaturesNV & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceInheritedViewportScissorFeaturesNV &
      setInheritedViewportScissor2D( VULKAN_HPP_NAMESPACE::Bool32 inheritedViewportScissor2D_ ) VULKAN_HPP_NOEXCEPT
    {
      inheritedViewportScissor2D = inheritedViewportScissor2D_;
      return *this;
    }

    operator VkPhysicalDeviceInheritedViewportScissorFeaturesNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceInheritedViewportScissorFeaturesNV *>( this );
    }

    operator VkPhysicalDeviceInheritedViewportScissorFeaturesNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceInheritedViewportScissorFeaturesNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceInheritedViewportScissorFeaturesNV const & ) const = default;
#else
    bool operator==( PhysicalDeviceInheritedViewportScissorFeaturesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( inheritedViewportScissor2D == rhs.inheritedViewportScissor2D );
    }

    bool operator!=( PhysicalDeviceInheritedViewportScissorFeaturesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceInheritedViewportScissorFeaturesNV;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        inheritedViewportScissor2D = {};
  };
  static_assert( sizeof( PhysicalDeviceInheritedViewportScissorFeaturesNV ) ==
                   sizeof( VkPhysicalDeviceInheritedViewportScissorFeaturesNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceInheritedViewportScissorFeaturesNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceInheritedViewportScissorFeaturesNV>
  {
    using Type = PhysicalDeviceInheritedViewportScissorFeaturesNV;
  };

  struct PhysicalDeviceInlineUniformBlockFeaturesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceInlineUniformBlockFeaturesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceInlineUniformBlockFeaturesEXT(
      VULKAN_HPP_NAMESPACE::Bool32 inlineUniformBlock_                                 = {},
      VULKAN_HPP_NAMESPACE::Bool32 descriptorBindingInlineUniformBlockUpdateAfterBind_ = {} ) VULKAN_HPP_NOEXCEPT
      : inlineUniformBlock( inlineUniformBlock_ )
      , descriptorBindingInlineUniformBlockUpdateAfterBind( descriptorBindingInlineUniformBlockUpdateAfterBind_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceInlineUniformBlockFeaturesEXT(
      PhysicalDeviceInlineUniformBlockFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceInlineUniformBlockFeaturesEXT( VkPhysicalDeviceInlineUniformBlockFeaturesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceInlineUniformBlockFeaturesEXT(
          *reinterpret_cast<PhysicalDeviceInlineUniformBlockFeaturesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceInlineUniformBlockFeaturesEXT &
                            operator=( PhysicalDeviceInlineUniformBlockFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceInlineUniformBlockFeaturesEXT &
      operator=( VkPhysicalDeviceInlineUniformBlockFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceInlineUniformBlockFeaturesEXT const *>( &rhs );
      return *this;
    }

    PhysicalDeviceInlineUniformBlockFeaturesEXT & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceInlineUniformBlockFeaturesEXT &
      setInlineUniformBlock( VULKAN_HPP_NAMESPACE::Bool32 inlineUniformBlock_ ) VULKAN_HPP_NOEXCEPT
    {
      inlineUniformBlock = inlineUniformBlock_;
      return *this;
    }

    PhysicalDeviceInlineUniformBlockFeaturesEXT & setDescriptorBindingInlineUniformBlockUpdateAfterBind(
      VULKAN_HPP_NAMESPACE::Bool32 descriptorBindingInlineUniformBlockUpdateAfterBind_ ) VULKAN_HPP_NOEXCEPT
    {
      descriptorBindingInlineUniformBlockUpdateAfterBind = descriptorBindingInlineUniformBlockUpdateAfterBind_;
      return *this;
    }

    operator VkPhysicalDeviceInlineUniformBlockFeaturesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceInlineUniformBlockFeaturesEXT *>( this );
    }

    operator VkPhysicalDeviceInlineUniformBlockFeaturesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceInlineUniformBlockFeaturesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceInlineUniformBlockFeaturesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceInlineUniformBlockFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( inlineUniformBlock == rhs.inlineUniformBlock ) &&
             ( descriptorBindingInlineUniformBlockUpdateAfterBind ==
               rhs.descriptorBindingInlineUniformBlockUpdateAfterBind );
    }

    bool operator!=( PhysicalDeviceInlineUniformBlockFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceInlineUniformBlockFeaturesEXT;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        inlineUniformBlock                                 = {};
    VULKAN_HPP_NAMESPACE::Bool32        descriptorBindingInlineUniformBlockUpdateAfterBind = {};
  };
  static_assert( sizeof( PhysicalDeviceInlineUniformBlockFeaturesEXT ) ==
                   sizeof( VkPhysicalDeviceInlineUniformBlockFeaturesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceInlineUniformBlockFeaturesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceInlineUniformBlockFeaturesEXT>
  {
    using Type = PhysicalDeviceInlineUniformBlockFeaturesEXT;
  };

  struct PhysicalDeviceInlineUniformBlockPropertiesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceInlineUniformBlockPropertiesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceInlineUniformBlockPropertiesEXT(
      uint32_t maxInlineUniformBlockSize_                               = {},
      uint32_t maxPerStageDescriptorInlineUniformBlocks_                = {},
      uint32_t maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks_ = {},
      uint32_t maxDescriptorSetInlineUniformBlocks_                     = {},
      uint32_t maxDescriptorSetUpdateAfterBindInlineUniformBlocks_      = {} ) VULKAN_HPP_NOEXCEPT
      : maxInlineUniformBlockSize( maxInlineUniformBlockSize_ )
      , maxPerStageDescriptorInlineUniformBlocks( maxPerStageDescriptorInlineUniformBlocks_ )
      , maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks(
          maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks_ )
      , maxDescriptorSetInlineUniformBlocks( maxDescriptorSetInlineUniformBlocks_ )
      , maxDescriptorSetUpdateAfterBindInlineUniformBlocks( maxDescriptorSetUpdateAfterBindInlineUniformBlocks_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceInlineUniformBlockPropertiesEXT(
      PhysicalDeviceInlineUniformBlockPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceInlineUniformBlockPropertiesEXT( VkPhysicalDeviceInlineUniformBlockPropertiesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceInlineUniformBlockPropertiesEXT(
          *reinterpret_cast<PhysicalDeviceInlineUniformBlockPropertiesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceInlineUniformBlockPropertiesEXT &
                            operator=( PhysicalDeviceInlineUniformBlockPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceInlineUniformBlockPropertiesEXT &
      operator=( VkPhysicalDeviceInlineUniformBlockPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceInlineUniformBlockPropertiesEXT const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceInlineUniformBlockPropertiesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceInlineUniformBlockPropertiesEXT *>( this );
    }

    operator VkPhysicalDeviceInlineUniformBlockPropertiesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceInlineUniformBlockPropertiesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceInlineUniformBlockPropertiesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceInlineUniformBlockPropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( maxInlineUniformBlockSize == rhs.maxInlineUniformBlockSize ) &&
             ( maxPerStageDescriptorInlineUniformBlocks == rhs.maxPerStageDescriptorInlineUniformBlocks ) &&
             ( maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks ==
               rhs.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks ) &&
             ( maxDescriptorSetInlineUniformBlocks == rhs.maxDescriptorSetInlineUniformBlocks ) &&
             ( maxDescriptorSetUpdateAfterBindInlineUniformBlocks ==
               rhs.maxDescriptorSetUpdateAfterBindInlineUniformBlocks );
    }

    bool operator!=( PhysicalDeviceInlineUniformBlockPropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceInlineUniformBlockPropertiesEXT;
    void *                              pNext = {};
    uint32_t                            maxInlineUniformBlockSize                               = {};
    uint32_t                            maxPerStageDescriptorInlineUniformBlocks                = {};
    uint32_t                            maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks = {};
    uint32_t                            maxDescriptorSetInlineUniformBlocks                     = {};
    uint32_t                            maxDescriptorSetUpdateAfterBindInlineUniformBlocks      = {};
  };
  static_assert( sizeof( PhysicalDeviceInlineUniformBlockPropertiesEXT ) ==
                   sizeof( VkPhysicalDeviceInlineUniformBlockPropertiesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceInlineUniformBlockPropertiesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceInlineUniformBlockPropertiesEXT>
  {
    using Type = PhysicalDeviceInlineUniformBlockPropertiesEXT;
  };

  struct PhysicalDeviceLimits
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR_14
      PhysicalDeviceLimits( uint32_t                         maxImageDimension1D_                             = {},
                            uint32_t                         maxImageDimension2D_                             = {},
                            uint32_t                         maxImageDimension3D_                             = {},
                            uint32_t                         maxImageDimensionCube_                           = {},
                            uint32_t                         maxImageArrayLayers_                             = {},
                            uint32_t                         maxTexelBufferElements_                          = {},
                            uint32_t                         maxUniformBufferRange_                           = {},
                            uint32_t                         maxStorageBufferRange_                           = {},
                            uint32_t                         maxPushConstantsSize_                            = {},
                            uint32_t                         maxMemoryAllocationCount_                        = {},
                            uint32_t                         maxSamplerAllocationCount_                       = {},
                            VULKAN_HPP_NAMESPACE::DeviceSize bufferImageGranularity_                          = {},
                            VULKAN_HPP_NAMESPACE::DeviceSize sparseAddressSpaceSize_                          = {},
                            uint32_t                         maxBoundDescriptorSets_                          = {},
                            uint32_t                         maxPerStageDescriptorSamplers_                   = {},
                            uint32_t                         maxPerStageDescriptorUniformBuffers_             = {},
                            uint32_t                         maxPerStageDescriptorStorageBuffers_             = {},
                            uint32_t                         maxPerStageDescriptorSampledImages_              = {},
                            uint32_t                         maxPerStageDescriptorStorageImages_              = {},
                            uint32_t                         maxPerStageDescriptorInputAttachments_           = {},
                            uint32_t                         maxPerStageResources_                            = {},
                            uint32_t                         maxDescriptorSetSamplers_                        = {},
                            uint32_t                         maxDescriptorSetUniformBuffers_                  = {},
                            uint32_t                         maxDescriptorSetUniformBuffersDynamic_           = {},
                            uint32_t                         maxDescriptorSetStorageBuffers_                  = {},
                            uint32_t                         maxDescriptorSetStorageBuffersDynamic_           = {},
                            uint32_t                         maxDescriptorSetSampledImages_                   = {},
                            uint32_t                         maxDescriptorSetStorageImages_                   = {},
                            uint32_t                         maxDescriptorSetInputAttachments_                = {},
                            uint32_t                         maxVertexInputAttributes_                        = {},
                            uint32_t                         maxVertexInputBindings_                          = {},
                            uint32_t                         maxVertexInputAttributeOffset_                   = {},
                            uint32_t                         maxVertexInputBindingStride_                     = {},
                            uint32_t                         maxVertexOutputComponents_                       = {},
                            uint32_t                         maxTessellationGenerationLevel_                  = {},
                            uint32_t                         maxTessellationPatchSize_                        = {},
                            uint32_t                         maxTessellationControlPerVertexInputComponents_  = {},
                            uint32_t                         maxTessellationControlPerVertexOutputComponents_ = {},
                            uint32_t                         maxTessellationControlPerPatchOutputComponents_  = {},
                            uint32_t                         maxTessellationControlTotalOutputComponents_     = {},
                            uint32_t                         maxTessellationEvaluationInputComponents_        = {},
                            uint32_t                         maxTessellationEvaluationOutputComponents_       = {},
                            uint32_t                         maxGeometryShaderInvocations_                    = {},
                            uint32_t                         maxGeometryInputComponents_                      = {},
                            uint32_t                         maxGeometryOutputComponents_                     = {},
                            uint32_t                         maxGeometryOutputVertices_                       = {},
                            uint32_t                         maxGeometryTotalOutputComponents_                = {},
                            uint32_t                         maxFragmentInputComponents_                      = {},
                            uint32_t                         maxFragmentOutputAttachments_                    = {},
                            uint32_t                         maxFragmentDualSrcAttachments_                   = {},
                            uint32_t                         maxFragmentCombinedOutputResources_              = {},
                            uint32_t                         maxComputeSharedMemorySize_                      = {},
                            std::array<uint32_t, 3> const &  maxComputeWorkGroupCount_                        = {},
                            uint32_t                         maxComputeWorkGroupInvocations_                  = {},
                            std::array<uint32_t, 3> const &  maxComputeWorkGroupSize_                         = {},
                            uint32_t                         subPixelPrecisionBits_                           = {},
                            uint32_t                         subTexelPrecisionBits_                           = {},
                            uint32_t                         mipmapPrecisionBits_                             = {},
                            uint32_t                         maxDrawIndexedIndexValue_                        = {},
                            uint32_t                         maxDrawIndirectCount_                            = {},
                            float                            maxSamplerLodBias_                               = {},
                            float                            maxSamplerAnisotropy_                            = {},
                            uint32_t                         maxViewports_                                    = {},
                            std::array<uint32_t, 2> const &  maxViewportDimensions_                           = {},
                            std::array<float, 2> const &     viewportBoundsRange_                             = {},
                            uint32_t                         viewportSubPixelBits_                            = {},
                            size_t                           minMemoryMapAlignment_                           = {},
                            VULKAN_HPP_NAMESPACE::DeviceSize minTexelBufferOffsetAlignment_                   = {},
                            VULKAN_HPP_NAMESPACE::DeviceSize minUniformBufferOffsetAlignment_                 = {},
                            VULKAN_HPP_NAMESPACE::DeviceSize minStorageBufferOffsetAlignment_                 = {},
                            int32_t                          minTexelOffset_                                  = {},
                            uint32_t                         maxTexelOffset_                                  = {},
                            int32_t                          minTexelGatherOffset_                            = {},
                            uint32_t                         maxTexelGatherOffset_                            = {},
                            float                            minInterpolationOffset_                          = {},
                            float                            maxInterpolationOffset_                          = {},
                            uint32_t                         subPixelInterpolationOffsetBits_                 = {},
                            uint32_t                         maxFramebufferWidth_                             = {},
                            uint32_t                         maxFramebufferHeight_                            = {},
                            uint32_t                         maxFramebufferLayers_                            = {},
                            VULKAN_HPP_NAMESPACE::SampleCountFlags framebufferColorSampleCounts_              = {},
                            VULKAN_HPP_NAMESPACE::SampleCountFlags framebufferDepthSampleCounts_              = {},
                            VULKAN_HPP_NAMESPACE::SampleCountFlags framebufferStencilSampleCounts_            = {},
                            VULKAN_HPP_NAMESPACE::SampleCountFlags framebufferNoAttachmentsSampleCounts_      = {},
                            uint32_t                               maxColorAttachments_                       = {},
                            VULKAN_HPP_NAMESPACE::SampleCountFlags sampledImageColorSampleCounts_             = {},
                            VULKAN_HPP_NAMESPACE::SampleCountFlags sampledImageIntegerSampleCounts_           = {},
                            VULKAN_HPP_NAMESPACE::SampleCountFlags sampledImageDepthSampleCounts_             = {},
                            VULKAN_HPP_NAMESPACE::SampleCountFlags sampledImageStencilSampleCounts_           = {},
                            VULKAN_HPP_NAMESPACE::SampleCountFlags storageImageSampleCounts_                  = {},
                            uint32_t                               maxSampleMaskWords_                        = {},
                            VULKAN_HPP_NAMESPACE::Bool32           timestampComputeAndGraphics_               = {},
                            float                                  timestampPeriod_                           = {},
                            uint32_t                               maxClipDistances_                          = {},
                            uint32_t                               maxCullDistances_                          = {},
                            uint32_t                               maxCombinedClipAndCullDistances_           = {},
                            uint32_t                               discreteQueuePriorities_                   = {},
                            std::array<float, 2> const &           pointSizeRange_                            = {},
                            std::array<float, 2> const &           lineWidthRange_                            = {},
                            float                                  pointSizeGranularity_                      = {},
                            float                                  lineWidthGranularity_                      = {},
                            VULKAN_HPP_NAMESPACE::Bool32           strictLines_                               = {},
                            VULKAN_HPP_NAMESPACE::Bool32           standardSampleLocations_                   = {},
                            VULKAN_HPP_NAMESPACE::DeviceSize       optimalBufferCopyOffsetAlignment_          = {},
                            VULKAN_HPP_NAMESPACE::DeviceSize       optimalBufferCopyRowPitchAlignment_        = {},
                            VULKAN_HPP_NAMESPACE::DeviceSize       nonCoherentAtomSize_ = {} ) VULKAN_HPP_NOEXCEPT
      : maxImageDimension1D( maxImageDimension1D_ )
      , maxImageDimension2D( maxImageDimension2D_ )
      , maxImageDimension3D( maxImageDimension3D_ )
      , maxImageDimensionCube( maxImageDimensionCube_ )
      , maxImageArrayLayers( maxImageArrayLayers_ )
      , maxTexelBufferElements( maxTexelBufferElements_ )
      , maxUniformBufferRange( maxUniformBufferRange_ )
      , maxStorageBufferRange( maxStorageBufferRange_ )
      , maxPushConstantsSize( maxPushConstantsSize_ )
      , maxMemoryAllocationCount( maxMemoryAllocationCount_ )
      , maxSamplerAllocationCount( maxSamplerAllocationCount_ )
      , bufferImageGranularity( bufferImageGranularity_ )
      , sparseAddressSpaceSize( sparseAddressSpaceSize_ )
      , maxBoundDescriptorSets( maxBoundDescriptorSets_ )
      , maxPerStageDescriptorSamplers( maxPerStageDescriptorSamplers_ )
      , maxPerStageDescriptorUniformBuffers( maxPerStageDescriptorUniformBuffers_ )
      , maxPerStageDescriptorStorageBuffers( maxPerStageDescriptorStorageBuffers_ )
      , maxPerStageDescriptorSampledImages( maxPerStageDescriptorSampledImages_ )
      , maxPerStageDescriptorStorageImages( maxPerStageDescriptorStorageImages_ )
      , maxPerStageDescriptorInputAttachments( maxPerStageDescriptorInputAttachments_ )
      , maxPerStageResources( maxPerStageResources_ )
      , maxDescriptorSetSamplers( maxDescriptorSetSamplers_ )
      , maxDescriptorSetUniformBuffers( maxDescriptorSetUniformBuffers_ )
      , maxDescriptorSetUniformBuffersDynamic( maxDescriptorSetUniformBuffersDynamic_ )
      , maxDescriptorSetStorageBuffers( maxDescriptorSetStorageBuffers_ )
      , maxDescriptorSetStorageBuffersDynamic( maxDescriptorSetStorageBuffersDynamic_ )
      , maxDescriptorSetSampledImages( maxDescriptorSetSampledImages_ )
      , maxDescriptorSetStorageImages( maxDescriptorSetStorageImages_ )
      , maxDescriptorSetInputAttachments( maxDescriptorSetInputAttachments_ )
      , maxVertexInputAttributes( maxVertexInputAttributes_ )
      , maxVertexInputBindings( maxVertexInputBindings_ )
      , maxVertexInputAttributeOffset( maxVertexInputAttributeOffset_ )
      , maxVertexInputBindingStride( maxVertexInputBindingStride_ )
      , maxVertexOutputComponents( maxVertexOutputComponents_ )
      , maxTessellationGenerationLevel( maxTessellationGenerationLevel_ )
      , maxTessellationPatchSize( maxTessellationPatchSize_ )
      , maxTessellationControlPerVertexInputComponents( maxTessellationControlPerVertexInputComponents_ )
      , maxTessellationControlPerVertexOutputComponents( maxTessellationControlPerVertexOutputComponents_ )
      , maxTessellationControlPerPatchOutputComponents( maxTessellationControlPerPatchOutputComponents_ )
      , maxTessellationControlTotalOutputComponents( maxTessellationControlTotalOutputComponents_ )
      , maxTessellationEvaluationInputComponents( maxTessellationEvaluationInputComponents_ )
      , maxTessellationEvaluationOutputComponents( maxTessellationEvaluationOutputComponents_ )
      , maxGeometryShaderInvocations( maxGeometryShaderInvocations_ )
      , maxGeometryInputComponents( maxGeometryInputComponents_ )
      , maxGeometryOutputComponents( maxGeometryOutputComponents_ )
      , maxGeometryOutputVertices( maxGeometryOutputVertices_ )
      , maxGeometryTotalOutputComponents( maxGeometryTotalOutputComponents_ )
      , maxFragmentInputComponents( maxFragmentInputComponents_ )
      , maxFragmentOutputAttachments( maxFragmentOutputAttachments_ )
      , maxFragmentDualSrcAttachments( maxFragmentDualSrcAttachments_ )
      , maxFragmentCombinedOutputResources( maxFragmentCombinedOutputResources_ )
      , maxComputeSharedMemorySize( maxComputeSharedMemorySize_ )
      , maxComputeWorkGroupCount( maxComputeWorkGroupCount_ )
      , maxComputeWorkGroupInvocations( maxComputeWorkGroupInvocations_ )
      , maxComputeWorkGroupSize( maxComputeWorkGroupSize_ )
      , subPixelPrecisionBits( subPixelPrecisionBits_ )
      , subTexelPrecisionBits( subTexelPrecisionBits_ )
      , mipmapPrecisionBits( mipmapPrecisionBits_ )
      , maxDrawIndexedIndexValue( maxDrawIndexedIndexValue_ )
      , maxDrawIndirectCount( maxDrawIndirectCount_ )
      , maxSamplerLodBias( maxSamplerLodBias_ )
      , maxSamplerAnisotropy( maxSamplerAnisotropy_ )
      , maxViewports( maxViewports_ )
      , maxViewportDimensions( maxViewportDimensions_ )
      , viewportBoundsRange( viewportBoundsRange_ )
      , viewportSubPixelBits( viewportSubPixelBits_ )
      , minMemoryMapAlignment( minMemoryMapAlignment_ )
      , minTexelBufferOffsetAlignment( minTexelBufferOffsetAlignment_ )
      , minUniformBufferOffsetAlignment( minUniformBufferOffsetAlignment_ )
      , minStorageBufferOffsetAlignment( minStorageBufferOffsetAlignment_ )
      , minTexelOffset( minTexelOffset_ )
      , maxTexelOffset( maxTexelOffset_ )
      , minTexelGatherOffset( minTexelGatherOffset_ )
      , maxTexelGatherOffset( maxTexelGatherOffset_ )
      , minInterpolationOffset( minInterpolationOffset_ )
      , maxInterpolationOffset( maxInterpolationOffset_ )
      , subPixelInterpolationOffsetBits( subPixelInterpolationOffsetBits_ )
      , maxFramebufferWidth( maxFramebufferWidth_ )
      , maxFramebufferHeight( maxFramebufferHeight_ )
      , maxFramebufferLayers( maxFramebufferLayers_ )
      , framebufferColorSampleCounts( framebufferColorSampleCounts_ )
      , framebufferDepthSampleCounts( framebufferDepthSampleCounts_ )
      , framebufferStencilSampleCounts( framebufferStencilSampleCounts_ )
      , framebufferNoAttachmentsSampleCounts( framebufferNoAttachmentsSampleCounts_ )
      , maxColorAttachments( maxColorAttachments_ )
      , sampledImageColorSampleCounts( sampledImageColorSampleCounts_ )
      , sampledImageIntegerSampleCounts( sampledImageIntegerSampleCounts_ )
      , sampledImageDepthSampleCounts( sampledImageDepthSampleCounts_ )
      , sampledImageStencilSampleCounts( sampledImageStencilSampleCounts_ )
      , storageImageSampleCounts( storageImageSampleCounts_ )
      , maxSampleMaskWords( maxSampleMaskWords_ )
      , timestampComputeAndGraphics( timestampComputeAndGraphics_ )
      , timestampPeriod( timestampPeriod_ )
      , maxClipDistances( maxClipDistances_ )
      , maxCullDistances( maxCullDistances_ )
      , maxCombinedClipAndCullDistances( maxCombinedClipAndCullDistances_ )
      , discreteQueuePriorities( discreteQueuePriorities_ )
      , pointSizeRange( pointSizeRange_ )
      , lineWidthRange( lineWidthRange_ )
      , pointSizeGranularity( pointSizeGranularity_ )
      , lineWidthGranularity( lineWidthGranularity_ )
      , strictLines( strictLines_ )
      , standardSampleLocations( standardSampleLocations_ )
      , optimalBufferCopyOffsetAlignment( optimalBufferCopyOffsetAlignment_ )
      , optimalBufferCopyRowPitchAlignment( optimalBufferCopyRowPitchAlignment_ )
      , nonCoherentAtomSize( nonCoherentAtomSize_ )
    {}

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceLimits( PhysicalDeviceLimits const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceLimits( VkPhysicalDeviceLimits const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceLimits( *reinterpret_cast<PhysicalDeviceLimits const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceLimits &
                            operator=( PhysicalDeviceLimits const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceLimits & operator=( VkPhysicalDeviceLimits const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceLimits const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceLimits const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceLimits *>( this );
    }

    operator VkPhysicalDeviceLimits &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceLimits *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceLimits const & ) const = default;
#else
    bool operator==( PhysicalDeviceLimits const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( maxImageDimension1D == rhs.maxImageDimension1D ) && ( maxImageDimension2D == rhs.maxImageDimension2D ) &&
             ( maxImageDimension3D == rhs.maxImageDimension3D ) &&
             ( maxImageDimensionCube == rhs.maxImageDimensionCube ) &&
             ( maxImageArrayLayers == rhs.maxImageArrayLayers ) &&
             ( maxTexelBufferElements == rhs.maxTexelBufferElements ) &&
             ( maxUniformBufferRange == rhs.maxUniformBufferRange ) &&
             ( maxStorageBufferRange == rhs.maxStorageBufferRange ) &&
             ( maxPushConstantsSize == rhs.maxPushConstantsSize ) &&
             ( maxMemoryAllocationCount == rhs.maxMemoryAllocationCount ) &&
             ( maxSamplerAllocationCount == rhs.maxSamplerAllocationCount ) &&
             ( bufferImageGranularity == rhs.bufferImageGranularity ) &&
             ( sparseAddressSpaceSize == rhs.sparseAddressSpaceSize ) &&
             ( maxBoundDescriptorSets == rhs.maxBoundDescriptorSets ) &&
             ( maxPerStageDescriptorSamplers == rhs.maxPerStageDescriptorSamplers ) &&
             ( maxPerStageDescriptorUniformBuffers == rhs.maxPerStageDescriptorUniformBuffers ) &&
             ( maxPerStageDescriptorStorageBuffers == rhs.maxPerStageDescriptorStorageBuffers ) &&
             ( maxPerStageDescriptorSampledImages == rhs.maxPerStageDescriptorSampledImages ) &&
             ( maxPerStageDescriptorStorageImages == rhs.maxPerStageDescriptorStorageImages ) &&
             ( maxPerStageDescriptorInputAttachments == rhs.maxPerStageDescriptorInputAttachments ) &&
             ( maxPerStageResources == rhs.maxPerStageResources ) &&
             ( maxDescriptorSetSamplers == rhs.maxDescriptorSetSamplers ) &&
             ( maxDescriptorSetUniformBuffers == rhs.maxDescriptorSetUniformBuffers ) &&
             ( maxDescriptorSetUniformBuffersDynamic == rhs.maxDescriptorSetUniformBuffersDynamic ) &&
             ( maxDescriptorSetStorageBuffers == rhs.maxDescriptorSetStorageBuffers ) &&
             ( maxDescriptorSetStorageBuffersDynamic == rhs.maxDescriptorSetStorageBuffersDynamic ) &&
             ( maxDescriptorSetSampledImages == rhs.maxDescriptorSetSampledImages ) &&
             ( maxDescriptorSetStorageImages == rhs.maxDescriptorSetStorageImages ) &&
             ( maxDescriptorSetInputAttachments == rhs.maxDescriptorSetInputAttachments ) &&
             ( maxVertexInputAttributes == rhs.maxVertexInputAttributes ) &&
             ( maxVertexInputBindings == rhs.maxVertexInputBindings ) &&
             ( maxVertexInputAttributeOffset == rhs.maxVertexInputAttributeOffset ) &&
             ( maxVertexInputBindingStride == rhs.maxVertexInputBindingStride ) &&
             ( maxVertexOutputComponents == rhs.maxVertexOutputComponents ) &&
             ( maxTessellationGenerationLevel == rhs.maxTessellationGenerationLevel ) &&
             ( maxTessellationPatchSize == rhs.maxTessellationPatchSize ) &&
             ( maxTessellationControlPerVertexInputComponents == rhs.maxTessellationControlPerVertexInputComponents ) &&
             ( maxTessellationControlPerVertexOutputComponents ==
               rhs.maxTessellationControlPerVertexOutputComponents ) &&
             ( maxTessellationControlPerPatchOutputComponents == rhs.maxTessellationControlPerPatchOutputComponents ) &&
             ( maxTessellationControlTotalOutputComponents == rhs.maxTessellationControlTotalOutputComponents ) &&
             ( maxTessellationEvaluationInputComponents == rhs.maxTessellationEvaluationInputComponents ) &&
             ( maxTessellationEvaluationOutputComponents == rhs.maxTessellationEvaluationOutputComponents ) &&
             ( maxGeometryShaderInvocations == rhs.maxGeometryShaderInvocations ) &&
             ( maxGeometryInputComponents == rhs.maxGeometryInputComponents ) &&
             ( maxGeometryOutputComponents == rhs.maxGeometryOutputComponents ) &&
             ( maxGeometryOutputVertices == rhs.maxGeometryOutputVertices ) &&
             ( maxGeometryTotalOutputComponents == rhs.maxGeometryTotalOutputComponents ) &&
             ( maxFragmentInputComponents == rhs.maxFragmentInputComponents ) &&
             ( maxFragmentOutputAttachments == rhs.maxFragmentOutputAttachments ) &&
             ( maxFragmentDualSrcAttachments == rhs.maxFragmentDualSrcAttachments ) &&
             ( maxFragmentCombinedOutputResources == rhs.maxFragmentCombinedOutputResources ) &&
             ( maxComputeSharedMemorySize == rhs.maxComputeSharedMemorySize ) &&
             ( maxComputeWorkGroupCount == rhs.maxComputeWorkGroupCount ) &&
             ( maxComputeWorkGroupInvocations == rhs.maxComputeWorkGroupInvocations ) &&
             ( maxComputeWorkGroupSize == rhs.maxComputeWorkGroupSize ) &&
             ( subPixelPrecisionBits == rhs.subPixelPrecisionBits ) &&
             ( subTexelPrecisionBits == rhs.subTexelPrecisionBits ) &&
             ( mipmapPrecisionBits == rhs.mipmapPrecisionBits ) &&
             ( maxDrawIndexedIndexValue == rhs.maxDrawIndexedIndexValue ) &&
             ( maxDrawIndirectCount == rhs.maxDrawIndirectCount ) && ( maxSamplerLodBias == rhs.maxSamplerLodBias ) &&
             ( maxSamplerAnisotropy == rhs.maxSamplerAnisotropy ) && ( maxViewports == rhs.maxViewports ) &&
             ( maxViewportDimensions == rhs.maxViewportDimensions ) &&
             ( viewportBoundsRange == rhs.viewportBoundsRange ) &&
             ( viewportSubPixelBits == rhs.viewportSubPixelBits ) &&
             ( minMemoryMapAlignment == rhs.minMemoryMapAlignment ) &&
             ( minTexelBufferOffsetAlignment == rhs.minTexelBufferOffsetAlignment ) &&
             ( minUniformBufferOffsetAlignment == rhs.minUniformBufferOffsetAlignment ) &&
             ( minStorageBufferOffsetAlignment == rhs.minStorageBufferOffsetAlignment ) &&
             ( minTexelOffset == rhs.minTexelOffset ) && ( maxTexelOffset == rhs.maxTexelOffset ) &&
             ( minTexelGatherOffset == rhs.minTexelGatherOffset ) &&
             ( maxTexelGatherOffset == rhs.maxTexelGatherOffset ) &&
             ( minInterpolationOffset == rhs.minInterpolationOffset ) &&
             ( maxInterpolationOffset == rhs.maxInterpolationOffset ) &&
             ( subPixelInterpolationOffsetBits == rhs.subPixelInterpolationOffsetBits ) &&
             ( maxFramebufferWidth == rhs.maxFramebufferWidth ) &&
             ( maxFramebufferHeight == rhs.maxFramebufferHeight ) &&
             ( maxFramebufferLayers == rhs.maxFramebufferLayers ) &&
             ( framebufferColorSampleCounts == rhs.framebufferColorSampleCounts ) &&
             ( framebufferDepthSampleCounts == rhs.framebufferDepthSampleCounts ) &&
             ( framebufferStencilSampleCounts == rhs.framebufferStencilSampleCounts ) &&
             ( framebufferNoAttachmentsSampleCounts == rhs.framebufferNoAttachmentsSampleCounts ) &&
             ( maxColorAttachments == rhs.maxColorAttachments ) &&
             ( sampledImageColorSampleCounts == rhs.sampledImageColorSampleCounts ) &&
             ( sampledImageIntegerSampleCounts == rhs.sampledImageIntegerSampleCounts ) &&
             ( sampledImageDepthSampleCounts == rhs.sampledImageDepthSampleCounts ) &&
             ( sampledImageStencilSampleCounts == rhs.sampledImageStencilSampleCounts ) &&
             ( storageImageSampleCounts == rhs.storageImageSampleCounts ) &&
             ( maxSampleMaskWords == rhs.maxSampleMaskWords ) &&
             ( timestampComputeAndGraphics == rhs.timestampComputeAndGraphics ) &&
             ( timestampPeriod == rhs.timestampPeriod ) && ( maxClipDistances == rhs.maxClipDistances ) &&
             ( maxCullDistances == rhs.maxCullDistances ) &&
             ( maxCombinedClipAndCullDistances == rhs.maxCombinedClipAndCullDistances ) &&
             ( discreteQueuePriorities == rhs.discreteQueuePriorities ) && ( pointSizeRange == rhs.pointSizeRange ) &&
             ( lineWidthRange == rhs.lineWidthRange ) && ( pointSizeGranularity == rhs.pointSizeGranularity ) &&
             ( lineWidthGranularity == rhs.lineWidthGranularity ) && ( strictLines == rhs.strictLines ) &&
             ( standardSampleLocations == rhs.standardSampleLocations ) &&
             ( optimalBufferCopyOffsetAlignment == rhs.optimalBufferCopyOffsetAlignment ) &&
             ( optimalBufferCopyRowPitchAlignment == rhs.optimalBufferCopyRowPitchAlignment ) &&
             ( nonCoherentAtomSize == rhs.nonCoherentAtomSize );
    }

    bool operator!=( PhysicalDeviceLimits const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    uint32_t                                          maxImageDimension1D                             = {};
    uint32_t                                          maxImageDimension2D                             = {};
    uint32_t                                          maxImageDimension3D                             = {};
    uint32_t                                          maxImageDimensionCube                           = {};
    uint32_t                                          maxImageArrayLayers                             = {};
    uint32_t                                          maxTexelBufferElements                          = {};
    uint32_t                                          maxUniformBufferRange                           = {};
    uint32_t                                          maxStorageBufferRange                           = {};
    uint32_t                                          maxPushConstantsSize                            = {};
    uint32_t                                          maxMemoryAllocationCount                        = {};
    uint32_t                                          maxSamplerAllocationCount                       = {};
    VULKAN_HPP_NAMESPACE::DeviceSize                  bufferImageGranularity                          = {};
    VULKAN_HPP_NAMESPACE::DeviceSize                  sparseAddressSpaceSize                          = {};
    uint32_t                                          maxBoundDescriptorSets                          = {};
    uint32_t                                          maxPerStageDescriptorSamplers                   = {};
    uint32_t                                          maxPerStageDescriptorUniformBuffers             = {};
    uint32_t                                          maxPerStageDescriptorStorageBuffers             = {};
    uint32_t                                          maxPerStageDescriptorSampledImages              = {};
    uint32_t                                          maxPerStageDescriptorStorageImages              = {};
    uint32_t                                          maxPerStageDescriptorInputAttachments           = {};
    uint32_t                                          maxPerStageResources                            = {};
    uint32_t                                          maxDescriptorSetSamplers                        = {};
    uint32_t                                          maxDescriptorSetUniformBuffers                  = {};
    uint32_t                                          maxDescriptorSetUniformBuffersDynamic           = {};
    uint32_t                                          maxDescriptorSetStorageBuffers                  = {};
    uint32_t                                          maxDescriptorSetStorageBuffersDynamic           = {};
    uint32_t                                          maxDescriptorSetSampledImages                   = {};
    uint32_t                                          maxDescriptorSetStorageImages                   = {};
    uint32_t                                          maxDescriptorSetInputAttachments                = {};
    uint32_t                                          maxVertexInputAttributes                        = {};
    uint32_t                                          maxVertexInputBindings                          = {};
    uint32_t                                          maxVertexInputAttributeOffset                   = {};
    uint32_t                                          maxVertexInputBindingStride                     = {};
    uint32_t                                          maxVertexOutputComponents                       = {};
    uint32_t                                          maxTessellationGenerationLevel                  = {};
    uint32_t                                          maxTessellationPatchSize                        = {};
    uint32_t                                          maxTessellationControlPerVertexInputComponents  = {};
    uint32_t                                          maxTessellationControlPerVertexOutputComponents = {};
    uint32_t                                          maxTessellationControlPerPatchOutputComponents  = {};
    uint32_t                                          maxTessellationControlTotalOutputComponents     = {};
    uint32_t                                          maxTessellationEvaluationInputComponents        = {};
    uint32_t                                          maxTessellationEvaluationOutputComponents       = {};
    uint32_t                                          maxGeometryShaderInvocations                    = {};
    uint32_t                                          maxGeometryInputComponents                      = {};
    uint32_t                                          maxGeometryOutputComponents                     = {};
    uint32_t                                          maxGeometryOutputVertices                       = {};
    uint32_t                                          maxGeometryTotalOutputComponents                = {};
    uint32_t                                          maxFragmentInputComponents                      = {};
    uint32_t                                          maxFragmentOutputAttachments                    = {};
    uint32_t                                          maxFragmentDualSrcAttachments                   = {};
    uint32_t                                          maxFragmentCombinedOutputResources              = {};
    uint32_t                                          maxComputeSharedMemorySize                      = {};
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<uint32_t, 3> maxComputeWorkGroupCount                        = {};
    uint32_t                                          maxComputeWorkGroupInvocations                  = {};
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<uint32_t, 3> maxComputeWorkGroupSize                         = {};
    uint32_t                                          subPixelPrecisionBits                           = {};
    uint32_t                                          subTexelPrecisionBits                           = {};
    uint32_t                                          mipmapPrecisionBits                             = {};
    uint32_t                                          maxDrawIndexedIndexValue                        = {};
    uint32_t                                          maxDrawIndirectCount                            = {};
    float                                             maxSamplerLodBias                               = {};
    float                                             maxSamplerAnisotropy                            = {};
    uint32_t                                          maxViewports                                    = {};
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<uint32_t, 2> maxViewportDimensions                           = {};
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<float, 2>    viewportBoundsRange                             = {};
    uint32_t                                          viewportSubPixelBits                            = {};
    size_t                                            minMemoryMapAlignment                           = {};
    VULKAN_HPP_NAMESPACE::DeviceSize                  minTexelBufferOffsetAlignment                   = {};
    VULKAN_HPP_NAMESPACE::DeviceSize                  minUniformBufferOffsetAlignment                 = {};
    VULKAN_HPP_NAMESPACE::DeviceSize                  minStorageBufferOffsetAlignment                 = {};
    int32_t                                           minTexelOffset                                  = {};
    uint32_t                                          maxTexelOffset                                  = {};
    int32_t                                           minTexelGatherOffset                            = {};
    uint32_t                                          maxTexelGatherOffset                            = {};
    float                                             minInterpolationOffset                          = {};
    float                                             maxInterpolationOffset                          = {};
    uint32_t                                          subPixelInterpolationOffsetBits                 = {};
    uint32_t                                          maxFramebufferWidth                             = {};
    uint32_t                                          maxFramebufferHeight                            = {};
    uint32_t                                          maxFramebufferLayers                            = {};
    VULKAN_HPP_NAMESPACE::SampleCountFlags            framebufferColorSampleCounts                    = {};
    VULKAN_HPP_NAMESPACE::SampleCountFlags            framebufferDepthSampleCounts                    = {};
    VULKAN_HPP_NAMESPACE::SampleCountFlags            framebufferStencilSampleCounts                  = {};
    VULKAN_HPP_NAMESPACE::SampleCountFlags            framebufferNoAttachmentsSampleCounts            = {};
    uint32_t                                          maxColorAttachments                             = {};
    VULKAN_HPP_NAMESPACE::SampleCountFlags            sampledImageColorSampleCounts                   = {};
    VULKAN_HPP_NAMESPACE::SampleCountFlags            sampledImageIntegerSampleCounts                 = {};
    VULKAN_HPP_NAMESPACE::SampleCountFlags            sampledImageDepthSampleCounts                   = {};
    VULKAN_HPP_NAMESPACE::SampleCountFlags            sampledImageStencilSampleCounts                 = {};
    VULKAN_HPP_NAMESPACE::SampleCountFlags            storageImageSampleCounts                        = {};
    uint32_t                                          maxSampleMaskWords                              = {};
    VULKAN_HPP_NAMESPACE::Bool32                      timestampComputeAndGraphics                     = {};
    float                                             timestampPeriod                                 = {};
    uint32_t                                          maxClipDistances                                = {};
    uint32_t                                          maxCullDistances                                = {};
    uint32_t                                          maxCombinedClipAndCullDistances                 = {};
    uint32_t                                          discreteQueuePriorities                         = {};
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<float, 2>    pointSizeRange                                  = {};
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<float, 2>    lineWidthRange                                  = {};
    float                                             pointSizeGranularity                            = {};
    float                                             lineWidthGranularity                            = {};
    VULKAN_HPP_NAMESPACE::Bool32                      strictLines                                     = {};
    VULKAN_HPP_NAMESPACE::Bool32                      standardSampleLocations                         = {};
    VULKAN_HPP_NAMESPACE::DeviceSize                  optimalBufferCopyOffsetAlignment                = {};
    VULKAN_HPP_NAMESPACE::DeviceSize                  optimalBufferCopyRowPitchAlignment              = {};
    VULKAN_HPP_NAMESPACE::DeviceSize                  nonCoherentAtomSize                             = {};
  };
  static_assert( sizeof( PhysicalDeviceLimits ) == sizeof( VkPhysicalDeviceLimits ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceLimits>::value, "struct wrapper is not a standard layout!" );

  struct PhysicalDeviceLineRasterizationFeaturesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceLineRasterizationFeaturesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceLineRasterizationFeaturesEXT(
      VULKAN_HPP_NAMESPACE::Bool32 rectangularLines_         = {},
      VULKAN_HPP_NAMESPACE::Bool32 bresenhamLines_           = {},
      VULKAN_HPP_NAMESPACE::Bool32 smoothLines_              = {},
      VULKAN_HPP_NAMESPACE::Bool32 stippledRectangularLines_ = {},
      VULKAN_HPP_NAMESPACE::Bool32 stippledBresenhamLines_   = {},
      VULKAN_HPP_NAMESPACE::Bool32 stippledSmoothLines_      = {} ) VULKAN_HPP_NOEXCEPT
      : rectangularLines( rectangularLines_ )
      , bresenhamLines( bresenhamLines_ )
      , smoothLines( smoothLines_ )
      , stippledRectangularLines( stippledRectangularLines_ )
      , stippledBresenhamLines( stippledBresenhamLines_ )
      , stippledSmoothLines( stippledSmoothLines_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceLineRasterizationFeaturesEXT(
      PhysicalDeviceLineRasterizationFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceLineRasterizationFeaturesEXT( VkPhysicalDeviceLineRasterizationFeaturesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceLineRasterizationFeaturesEXT(
          *reinterpret_cast<PhysicalDeviceLineRasterizationFeaturesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceLineRasterizationFeaturesEXT &
                            operator=( PhysicalDeviceLineRasterizationFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceLineRasterizationFeaturesEXT &
      operator=( VkPhysicalDeviceLineRasterizationFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceLineRasterizationFeaturesEXT const *>( &rhs );
      return *this;
    }

    PhysicalDeviceLineRasterizationFeaturesEXT & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceLineRasterizationFeaturesEXT &
      setRectangularLines( VULKAN_HPP_NAMESPACE::Bool32 rectangularLines_ ) VULKAN_HPP_NOEXCEPT
    {
      rectangularLines = rectangularLines_;
      return *this;
    }

    PhysicalDeviceLineRasterizationFeaturesEXT &
      setBresenhamLines( VULKAN_HPP_NAMESPACE::Bool32 bresenhamLines_ ) VULKAN_HPP_NOEXCEPT
    {
      bresenhamLines = bresenhamLines_;
      return *this;
    }

    PhysicalDeviceLineRasterizationFeaturesEXT &
      setSmoothLines( VULKAN_HPP_NAMESPACE::Bool32 smoothLines_ ) VULKAN_HPP_NOEXCEPT
    {
      smoothLines = smoothLines_;
      return *this;
    }

    PhysicalDeviceLineRasterizationFeaturesEXT &
      setStippledRectangularLines( VULKAN_HPP_NAMESPACE::Bool32 stippledRectangularLines_ ) VULKAN_HPP_NOEXCEPT
    {
      stippledRectangularLines = stippledRectangularLines_;
      return *this;
    }

    PhysicalDeviceLineRasterizationFeaturesEXT &
      setStippledBresenhamLines( VULKAN_HPP_NAMESPACE::Bool32 stippledBresenhamLines_ ) VULKAN_HPP_NOEXCEPT
    {
      stippledBresenhamLines = stippledBresenhamLines_;
      return *this;
    }

    PhysicalDeviceLineRasterizationFeaturesEXT &
      setStippledSmoothLines( VULKAN_HPP_NAMESPACE::Bool32 stippledSmoothLines_ ) VULKAN_HPP_NOEXCEPT
    {
      stippledSmoothLines = stippledSmoothLines_;
      return *this;
    }

    operator VkPhysicalDeviceLineRasterizationFeaturesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceLineRasterizationFeaturesEXT *>( this );
    }

    operator VkPhysicalDeviceLineRasterizationFeaturesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceLineRasterizationFeaturesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceLineRasterizationFeaturesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceLineRasterizationFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( rectangularLines == rhs.rectangularLines ) &&
             ( bresenhamLines == rhs.bresenhamLines ) && ( smoothLines == rhs.smoothLines ) &&
             ( stippledRectangularLines == rhs.stippledRectangularLines ) &&
             ( stippledBresenhamLines == rhs.stippledBresenhamLines ) &&
             ( stippledSmoothLines == rhs.stippledSmoothLines );
    }

    bool operator!=( PhysicalDeviceLineRasterizationFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType            = StructureType::ePhysicalDeviceLineRasterizationFeaturesEXT;
    void *                              pNext            = {};
    VULKAN_HPP_NAMESPACE::Bool32        rectangularLines = {};
    VULKAN_HPP_NAMESPACE::Bool32        bresenhamLines   = {};
    VULKAN_HPP_NAMESPACE::Bool32        smoothLines      = {};
    VULKAN_HPP_NAMESPACE::Bool32        stippledRectangularLines = {};
    VULKAN_HPP_NAMESPACE::Bool32        stippledBresenhamLines   = {};
    VULKAN_HPP_NAMESPACE::Bool32        stippledSmoothLines      = {};
  };
  static_assert( sizeof( PhysicalDeviceLineRasterizationFeaturesEXT ) ==
                   sizeof( VkPhysicalDeviceLineRasterizationFeaturesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceLineRasterizationFeaturesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceLineRasterizationFeaturesEXT>
  {
    using Type = PhysicalDeviceLineRasterizationFeaturesEXT;
  };

  struct PhysicalDeviceLineRasterizationPropertiesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceLineRasterizationPropertiesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      PhysicalDeviceLineRasterizationPropertiesEXT( uint32_t lineSubPixelPrecisionBits_ = {} ) VULKAN_HPP_NOEXCEPT
      : lineSubPixelPrecisionBits( lineSubPixelPrecisionBits_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceLineRasterizationPropertiesEXT(
      PhysicalDeviceLineRasterizationPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceLineRasterizationPropertiesEXT( VkPhysicalDeviceLineRasterizationPropertiesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceLineRasterizationPropertiesEXT(
          *reinterpret_cast<PhysicalDeviceLineRasterizationPropertiesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceLineRasterizationPropertiesEXT &
                            operator=( PhysicalDeviceLineRasterizationPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceLineRasterizationPropertiesEXT &
      operator=( VkPhysicalDeviceLineRasterizationPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceLineRasterizationPropertiesEXT const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceLineRasterizationPropertiesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceLineRasterizationPropertiesEXT *>( this );
    }

    operator VkPhysicalDeviceLineRasterizationPropertiesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceLineRasterizationPropertiesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceLineRasterizationPropertiesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceLineRasterizationPropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( lineSubPixelPrecisionBits == rhs.lineSubPixelPrecisionBits );
    }

    bool operator!=( PhysicalDeviceLineRasterizationPropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceLineRasterizationPropertiesEXT;
    void *                              pNext = {};
    uint32_t                            lineSubPixelPrecisionBits = {};
  };
  static_assert( sizeof( PhysicalDeviceLineRasterizationPropertiesEXT ) ==
                   sizeof( VkPhysicalDeviceLineRasterizationPropertiesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceLineRasterizationPropertiesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceLineRasterizationPropertiesEXT>
  {
    using Type = PhysicalDeviceLineRasterizationPropertiesEXT;
  };

  struct PhysicalDeviceMaintenance3Properties
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceMaintenance3Properties;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceMaintenance3Properties(
      uint32_t                         maxPerSetDescriptors_    = {},
      VULKAN_HPP_NAMESPACE::DeviceSize maxMemoryAllocationSize_ = {} ) VULKAN_HPP_NOEXCEPT
      : maxPerSetDescriptors( maxPerSetDescriptors_ )
      , maxMemoryAllocationSize( maxMemoryAllocationSize_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceMaintenance3Properties( PhysicalDeviceMaintenance3Properties const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceMaintenance3Properties( VkPhysicalDeviceMaintenance3Properties const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceMaintenance3Properties( *reinterpret_cast<PhysicalDeviceMaintenance3Properties const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceMaintenance3Properties &
                            operator=( PhysicalDeviceMaintenance3Properties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceMaintenance3Properties &
      operator=( VkPhysicalDeviceMaintenance3Properties const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceMaintenance3Properties const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceMaintenance3Properties const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceMaintenance3Properties *>( this );
    }

    operator VkPhysicalDeviceMaintenance3Properties &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceMaintenance3Properties *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceMaintenance3Properties const & ) const = default;
#else
    bool operator==( PhysicalDeviceMaintenance3Properties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( maxPerSetDescriptors == rhs.maxPerSetDescriptors ) &&
             ( maxMemoryAllocationSize == rhs.maxMemoryAllocationSize );
    }

    bool operator!=( PhysicalDeviceMaintenance3Properties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType                   = StructureType::ePhysicalDeviceMaintenance3Properties;
    void *                              pNext                   = {};
    uint32_t                            maxPerSetDescriptors    = {};
    VULKAN_HPP_NAMESPACE::DeviceSize    maxMemoryAllocationSize = {};
  };
  static_assert( sizeof( PhysicalDeviceMaintenance3Properties ) == sizeof( VkPhysicalDeviceMaintenance3Properties ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceMaintenance3Properties>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceMaintenance3Properties>
  {
    using Type = PhysicalDeviceMaintenance3Properties;
  };
  using PhysicalDeviceMaintenance3PropertiesKHR = PhysicalDeviceMaintenance3Properties;

  struct PhysicalDeviceMemoryBudgetPropertiesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceMemoryBudgetPropertiesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceMemoryBudgetPropertiesEXT(
      std::array<VULKAN_HPP_NAMESPACE::DeviceSize, VK_MAX_MEMORY_HEAPS> const & heapBudget_ = {},
      std::array<VULKAN_HPP_NAMESPACE::DeviceSize, VK_MAX_MEMORY_HEAPS> const & heapUsage_  = {} ) VULKAN_HPP_NOEXCEPT
      : heapBudget( heapBudget_ )
      , heapUsage( heapUsage_ )
    {}

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceMemoryBudgetPropertiesEXT(
      PhysicalDeviceMemoryBudgetPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceMemoryBudgetPropertiesEXT( VkPhysicalDeviceMemoryBudgetPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceMemoryBudgetPropertiesEXT(
          *reinterpret_cast<PhysicalDeviceMemoryBudgetPropertiesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceMemoryBudgetPropertiesEXT &
                            operator=( PhysicalDeviceMemoryBudgetPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceMemoryBudgetPropertiesEXT &
      operator=( VkPhysicalDeviceMemoryBudgetPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceMemoryBudgetPropertiesEXT const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceMemoryBudgetPropertiesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceMemoryBudgetPropertiesEXT *>( this );
    }

    operator VkPhysicalDeviceMemoryBudgetPropertiesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceMemoryBudgetPropertiesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceMemoryBudgetPropertiesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceMemoryBudgetPropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( heapBudget == rhs.heapBudget ) &&
             ( heapUsage == rhs.heapUsage );
    }

    bool operator!=( PhysicalDeviceMemoryBudgetPropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceMemoryBudgetPropertiesEXT;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<VULKAN_HPP_NAMESPACE::DeviceSize, VK_MAX_MEMORY_HEAPS> heapBudget = {};
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<VULKAN_HPP_NAMESPACE::DeviceSize, VK_MAX_MEMORY_HEAPS> heapUsage  = {};
  };
  static_assert( sizeof( PhysicalDeviceMemoryBudgetPropertiesEXT ) ==
                   sizeof( VkPhysicalDeviceMemoryBudgetPropertiesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceMemoryBudgetPropertiesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceMemoryBudgetPropertiesEXT>
  {
    using Type = PhysicalDeviceMemoryBudgetPropertiesEXT;
  };

  struct PhysicalDeviceMemoryPriorityFeaturesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceMemoryPriorityFeaturesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      PhysicalDeviceMemoryPriorityFeaturesEXT( VULKAN_HPP_NAMESPACE::Bool32 memoryPriority_ = {} ) VULKAN_HPP_NOEXCEPT
      : memoryPriority( memoryPriority_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceMemoryPriorityFeaturesEXT( PhysicalDeviceMemoryPriorityFeaturesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceMemoryPriorityFeaturesEXT( VkPhysicalDeviceMemoryPriorityFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceMemoryPriorityFeaturesEXT(
          *reinterpret_cast<PhysicalDeviceMemoryPriorityFeaturesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceMemoryPriorityFeaturesEXT &
                            operator=( PhysicalDeviceMemoryPriorityFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceMemoryPriorityFeaturesEXT &
      operator=( VkPhysicalDeviceMemoryPriorityFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceMemoryPriorityFeaturesEXT const *>( &rhs );
      return *this;
    }

    PhysicalDeviceMemoryPriorityFeaturesEXT & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceMemoryPriorityFeaturesEXT &
      setMemoryPriority( VULKAN_HPP_NAMESPACE::Bool32 memoryPriority_ ) VULKAN_HPP_NOEXCEPT
    {
      memoryPriority = memoryPriority_;
      return *this;
    }

    operator VkPhysicalDeviceMemoryPriorityFeaturesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceMemoryPriorityFeaturesEXT *>( this );
    }

    operator VkPhysicalDeviceMemoryPriorityFeaturesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceMemoryPriorityFeaturesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceMemoryPriorityFeaturesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceMemoryPriorityFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( memoryPriority == rhs.memoryPriority );
    }

    bool operator!=( PhysicalDeviceMemoryPriorityFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType          = StructureType::ePhysicalDeviceMemoryPriorityFeaturesEXT;
    void *                              pNext          = {};
    VULKAN_HPP_NAMESPACE::Bool32        memoryPriority = {};
  };
  static_assert( sizeof( PhysicalDeviceMemoryPriorityFeaturesEXT ) ==
                   sizeof( VkPhysicalDeviceMemoryPriorityFeaturesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceMemoryPriorityFeaturesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceMemoryPriorityFeaturesEXT>
  {
    using Type = PhysicalDeviceMemoryPriorityFeaturesEXT;
  };

  struct PhysicalDeviceMemoryProperties
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceMemoryProperties(
      uint32_t                                                                  memoryTypeCount_ = {},
      std::array<VULKAN_HPP_NAMESPACE::MemoryType, VK_MAX_MEMORY_TYPES> const & memoryTypes_     = {},
      uint32_t                                                                  memoryHeapCount_ = {},
      std::array<VULKAN_HPP_NAMESPACE::MemoryHeap, VK_MAX_MEMORY_HEAPS> const & memoryHeaps_ = {} ) VULKAN_HPP_NOEXCEPT
      : memoryTypeCount( memoryTypeCount_ )
      , memoryTypes( memoryTypes_ )
      , memoryHeapCount( memoryHeapCount_ )
      , memoryHeaps( memoryHeaps_ )
    {}

    VULKAN_HPP_CONSTEXPR_14
      PhysicalDeviceMemoryProperties( PhysicalDeviceMemoryProperties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceMemoryProperties( VkPhysicalDeviceMemoryProperties const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceMemoryProperties( *reinterpret_cast<PhysicalDeviceMemoryProperties const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceMemoryProperties &
                            operator=( PhysicalDeviceMemoryProperties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceMemoryProperties & operator=( VkPhysicalDeviceMemoryProperties const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceMemoryProperties const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceMemoryProperties const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceMemoryProperties *>( this );
    }

    operator VkPhysicalDeviceMemoryProperties &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceMemoryProperties *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceMemoryProperties const & ) const = default;
#else
    bool operator==( PhysicalDeviceMemoryProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( memoryTypeCount == rhs.memoryTypeCount ) && ( memoryTypes == rhs.memoryTypes ) &&
             ( memoryHeapCount == rhs.memoryHeapCount ) && ( memoryHeaps == rhs.memoryHeaps );
    }

    bool operator!=( PhysicalDeviceMemoryProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    uint32_t                                                                                    memoryTypeCount = {};
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<VULKAN_HPP_NAMESPACE::MemoryType, VK_MAX_MEMORY_TYPES> memoryTypes     = {};
    uint32_t                                                                                    memoryHeapCount = {};
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<VULKAN_HPP_NAMESPACE::MemoryHeap, VK_MAX_MEMORY_HEAPS> memoryHeaps     = {};
  };
  static_assert( sizeof( PhysicalDeviceMemoryProperties ) == sizeof( VkPhysicalDeviceMemoryProperties ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceMemoryProperties>::value,
                 "struct wrapper is not a standard layout!" );

  struct PhysicalDeviceMemoryProperties2
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::ePhysicalDeviceMemoryProperties2;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceMemoryProperties2(
      VULKAN_HPP_NAMESPACE::PhysicalDeviceMemoryProperties memoryProperties_ = {} ) VULKAN_HPP_NOEXCEPT
      : memoryProperties( memoryProperties_ )
    {}

    VULKAN_HPP_CONSTEXPR_14
      PhysicalDeviceMemoryProperties2( PhysicalDeviceMemoryProperties2 const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceMemoryProperties2( VkPhysicalDeviceMemoryProperties2 const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceMemoryProperties2( *reinterpret_cast<PhysicalDeviceMemoryProperties2 const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceMemoryProperties2 &
                            operator=( PhysicalDeviceMemoryProperties2 const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceMemoryProperties2 & operator=( VkPhysicalDeviceMemoryProperties2 const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceMemoryProperties2 const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceMemoryProperties2 const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceMemoryProperties2 *>( this );
    }

    operator VkPhysicalDeviceMemoryProperties2 &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceMemoryProperties2 *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceMemoryProperties2 const & ) const = default;
#else
    bool operator==( PhysicalDeviceMemoryProperties2 const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( memoryProperties == rhs.memoryProperties );
    }

    bool operator!=( PhysicalDeviceMemoryProperties2 const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                  sType = StructureType::ePhysicalDeviceMemoryProperties2;
    void *                                               pNext = {};
    VULKAN_HPP_NAMESPACE::PhysicalDeviceMemoryProperties memoryProperties = {};
  };
  static_assert( sizeof( PhysicalDeviceMemoryProperties2 ) == sizeof( VkPhysicalDeviceMemoryProperties2 ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceMemoryProperties2>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceMemoryProperties2>
  {
    using Type = PhysicalDeviceMemoryProperties2;
  };
  using PhysicalDeviceMemoryProperties2KHR = PhysicalDeviceMemoryProperties2;

  struct PhysicalDeviceMeshShaderFeaturesNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceMeshShaderFeaturesNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      PhysicalDeviceMeshShaderFeaturesNV( VULKAN_HPP_NAMESPACE::Bool32 taskShader_ = {},
                                          VULKAN_HPP_NAMESPACE::Bool32 meshShader_ = {} ) VULKAN_HPP_NOEXCEPT
      : taskShader( taskShader_ )
      , meshShader( meshShader_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceMeshShaderFeaturesNV( PhysicalDeviceMeshShaderFeaturesNV const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceMeshShaderFeaturesNV( VkPhysicalDeviceMeshShaderFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceMeshShaderFeaturesNV( *reinterpret_cast<PhysicalDeviceMeshShaderFeaturesNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceMeshShaderFeaturesNV &
                            operator=( PhysicalDeviceMeshShaderFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceMeshShaderFeaturesNV &
      operator=( VkPhysicalDeviceMeshShaderFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceMeshShaderFeaturesNV const *>( &rhs );
      return *this;
    }

    PhysicalDeviceMeshShaderFeaturesNV & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceMeshShaderFeaturesNV & setTaskShader( VULKAN_HPP_NAMESPACE::Bool32 taskShader_ ) VULKAN_HPP_NOEXCEPT
    {
      taskShader = taskShader_;
      return *this;
    }

    PhysicalDeviceMeshShaderFeaturesNV & setMeshShader( VULKAN_HPP_NAMESPACE::Bool32 meshShader_ ) VULKAN_HPP_NOEXCEPT
    {
      meshShader = meshShader_;
      return *this;
    }

    operator VkPhysicalDeviceMeshShaderFeaturesNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceMeshShaderFeaturesNV *>( this );
    }

    operator VkPhysicalDeviceMeshShaderFeaturesNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceMeshShaderFeaturesNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceMeshShaderFeaturesNV const & ) const = default;
#else
    bool operator==( PhysicalDeviceMeshShaderFeaturesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( taskShader == rhs.taskShader ) &&
             ( meshShader == rhs.meshShader );
    }

    bool operator!=( PhysicalDeviceMeshShaderFeaturesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType      = StructureType::ePhysicalDeviceMeshShaderFeaturesNV;
    void *                              pNext      = {};
    VULKAN_HPP_NAMESPACE::Bool32        taskShader = {};
    VULKAN_HPP_NAMESPACE::Bool32        meshShader = {};
  };
  static_assert( sizeof( PhysicalDeviceMeshShaderFeaturesNV ) == sizeof( VkPhysicalDeviceMeshShaderFeaturesNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceMeshShaderFeaturesNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceMeshShaderFeaturesNV>
  {
    using Type = PhysicalDeviceMeshShaderFeaturesNV;
  };

  struct PhysicalDeviceMeshShaderPropertiesNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceMeshShaderPropertiesNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR_14
      PhysicalDeviceMeshShaderPropertiesNV( uint32_t                        maxDrawMeshTasksCount_          = {},
                                            uint32_t                        maxTaskWorkGroupInvocations_    = {},
                                            std::array<uint32_t, 3> const & maxTaskWorkGroupSize_           = {},
                                            uint32_t                        maxTaskTotalMemorySize_         = {},
                                            uint32_t                        maxTaskOutputCount_             = {},
                                            uint32_t                        maxMeshWorkGroupInvocations_    = {},
                                            std::array<uint32_t, 3> const & maxMeshWorkGroupSize_           = {},
                                            uint32_t                        maxMeshTotalMemorySize_         = {},
                                            uint32_t                        maxMeshOutputVertices_          = {},
                                            uint32_t                        maxMeshOutputPrimitives_        = {},
                                            uint32_t                        maxMeshMultiviewViewCount_      = {},
                                            uint32_t                        meshOutputPerVertexGranularity_ = {},
                                            uint32_t meshOutputPerPrimitiveGranularity_ = {} ) VULKAN_HPP_NOEXCEPT
      : maxDrawMeshTasksCount( maxDrawMeshTasksCount_ )
      , maxTaskWorkGroupInvocations( maxTaskWorkGroupInvocations_ )
      , maxTaskWorkGroupSize( maxTaskWorkGroupSize_ )
      , maxTaskTotalMemorySize( maxTaskTotalMemorySize_ )
      , maxTaskOutputCount( maxTaskOutputCount_ )
      , maxMeshWorkGroupInvocations( maxMeshWorkGroupInvocations_ )
      , maxMeshWorkGroupSize( maxMeshWorkGroupSize_ )
      , maxMeshTotalMemorySize( maxMeshTotalMemorySize_ )
      , maxMeshOutputVertices( maxMeshOutputVertices_ )
      , maxMeshOutputPrimitives( maxMeshOutputPrimitives_ )
      , maxMeshMultiviewViewCount( maxMeshMultiviewViewCount_ )
      , meshOutputPerVertexGranularity( meshOutputPerVertexGranularity_ )
      , meshOutputPerPrimitiveGranularity( meshOutputPerPrimitiveGranularity_ )
    {}

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceMeshShaderPropertiesNV( PhysicalDeviceMeshShaderPropertiesNV const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceMeshShaderPropertiesNV( VkPhysicalDeviceMeshShaderPropertiesNV const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceMeshShaderPropertiesNV( *reinterpret_cast<PhysicalDeviceMeshShaderPropertiesNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceMeshShaderPropertiesNV &
                            operator=( PhysicalDeviceMeshShaderPropertiesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceMeshShaderPropertiesNV &
      operator=( VkPhysicalDeviceMeshShaderPropertiesNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceMeshShaderPropertiesNV const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceMeshShaderPropertiesNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceMeshShaderPropertiesNV *>( this );
    }

    operator VkPhysicalDeviceMeshShaderPropertiesNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceMeshShaderPropertiesNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceMeshShaderPropertiesNV const & ) const = default;
#else
    bool operator==( PhysicalDeviceMeshShaderPropertiesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( maxDrawMeshTasksCount == rhs.maxDrawMeshTasksCount ) &&
             ( maxTaskWorkGroupInvocations == rhs.maxTaskWorkGroupInvocations ) &&
             ( maxTaskWorkGroupSize == rhs.maxTaskWorkGroupSize ) &&
             ( maxTaskTotalMemorySize == rhs.maxTaskTotalMemorySize ) &&
             ( maxTaskOutputCount == rhs.maxTaskOutputCount ) &&
             ( maxMeshWorkGroupInvocations == rhs.maxMeshWorkGroupInvocations ) &&
             ( maxMeshWorkGroupSize == rhs.maxMeshWorkGroupSize ) &&
             ( maxMeshTotalMemorySize == rhs.maxMeshTotalMemorySize ) &&
             ( maxMeshOutputVertices == rhs.maxMeshOutputVertices ) &&
             ( maxMeshOutputPrimitives == rhs.maxMeshOutputPrimitives ) &&
             ( maxMeshMultiviewViewCount == rhs.maxMeshMultiviewViewCount ) &&
             ( meshOutputPerVertexGranularity == rhs.meshOutputPerVertexGranularity ) &&
             ( meshOutputPerPrimitiveGranularity == rhs.meshOutputPerPrimitiveGranularity );
    }

    bool operator!=( PhysicalDeviceMeshShaderPropertiesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType               sType = StructureType::ePhysicalDeviceMeshShaderPropertiesNV;
    void *                                            pNext = {};
    uint32_t                                          maxDrawMeshTasksCount             = {};
    uint32_t                                          maxTaskWorkGroupInvocations       = {};
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<uint32_t, 3> maxTaskWorkGroupSize              = {};
    uint32_t                                          maxTaskTotalMemorySize            = {};
    uint32_t                                          maxTaskOutputCount                = {};
    uint32_t                                          maxMeshWorkGroupInvocations       = {};
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<uint32_t, 3> maxMeshWorkGroupSize              = {};
    uint32_t                                          maxMeshTotalMemorySize            = {};
    uint32_t                                          maxMeshOutputVertices             = {};
    uint32_t                                          maxMeshOutputPrimitives           = {};
    uint32_t                                          maxMeshMultiviewViewCount         = {};
    uint32_t                                          meshOutputPerVertexGranularity    = {};
    uint32_t                                          meshOutputPerPrimitiveGranularity = {};
  };
  static_assert( sizeof( PhysicalDeviceMeshShaderPropertiesNV ) == sizeof( VkPhysicalDeviceMeshShaderPropertiesNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceMeshShaderPropertiesNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceMeshShaderPropertiesNV>
  {
    using Type = PhysicalDeviceMeshShaderPropertiesNV;
  };

  struct PhysicalDeviceMultiDrawFeaturesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceMultiDrawFeaturesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      PhysicalDeviceMultiDrawFeaturesEXT( VULKAN_HPP_NAMESPACE::Bool32 multiDraw_ = {} ) VULKAN_HPP_NOEXCEPT
      : multiDraw( multiDraw_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceMultiDrawFeaturesEXT( PhysicalDeviceMultiDrawFeaturesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceMultiDrawFeaturesEXT( VkPhysicalDeviceMultiDrawFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceMultiDrawFeaturesEXT( *reinterpret_cast<PhysicalDeviceMultiDrawFeaturesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceMultiDrawFeaturesEXT &
                            operator=( PhysicalDeviceMultiDrawFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceMultiDrawFeaturesEXT &
      operator=( VkPhysicalDeviceMultiDrawFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceMultiDrawFeaturesEXT const *>( &rhs );
      return *this;
    }

    PhysicalDeviceMultiDrawFeaturesEXT & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceMultiDrawFeaturesEXT & setMultiDraw( VULKAN_HPP_NAMESPACE::Bool32 multiDraw_ ) VULKAN_HPP_NOEXCEPT
    {
      multiDraw = multiDraw_;
      return *this;
    }

    operator VkPhysicalDeviceMultiDrawFeaturesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceMultiDrawFeaturesEXT *>( this );
    }

    operator VkPhysicalDeviceMultiDrawFeaturesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceMultiDrawFeaturesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceMultiDrawFeaturesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceMultiDrawFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( multiDraw == rhs.multiDraw );
    }

    bool operator!=( PhysicalDeviceMultiDrawFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType     = StructureType::ePhysicalDeviceMultiDrawFeaturesEXT;
    void *                              pNext     = {};
    VULKAN_HPP_NAMESPACE::Bool32        multiDraw = {};
  };
  static_assert( sizeof( PhysicalDeviceMultiDrawFeaturesEXT ) == sizeof( VkPhysicalDeviceMultiDrawFeaturesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceMultiDrawFeaturesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceMultiDrawFeaturesEXT>
  {
    using Type = PhysicalDeviceMultiDrawFeaturesEXT;
  };

  struct PhysicalDeviceMultiDrawPropertiesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceMultiDrawPropertiesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceMultiDrawPropertiesEXT( uint32_t maxMultiDrawCount_ = {} ) VULKAN_HPP_NOEXCEPT
      : maxMultiDrawCount( maxMultiDrawCount_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceMultiDrawPropertiesEXT( PhysicalDeviceMultiDrawPropertiesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceMultiDrawPropertiesEXT( VkPhysicalDeviceMultiDrawPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceMultiDrawPropertiesEXT( *reinterpret_cast<PhysicalDeviceMultiDrawPropertiesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceMultiDrawPropertiesEXT &
                            operator=( PhysicalDeviceMultiDrawPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceMultiDrawPropertiesEXT &
      operator=( VkPhysicalDeviceMultiDrawPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceMultiDrawPropertiesEXT const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceMultiDrawPropertiesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceMultiDrawPropertiesEXT *>( this );
    }

    operator VkPhysicalDeviceMultiDrawPropertiesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceMultiDrawPropertiesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceMultiDrawPropertiesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceMultiDrawPropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( maxMultiDrawCount == rhs.maxMultiDrawCount );
    }

    bool operator!=( PhysicalDeviceMultiDrawPropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType             = StructureType::ePhysicalDeviceMultiDrawPropertiesEXT;
    void *                              pNext             = {};
    uint32_t                            maxMultiDrawCount = {};
  };
  static_assert( sizeof( PhysicalDeviceMultiDrawPropertiesEXT ) == sizeof( VkPhysicalDeviceMultiDrawPropertiesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceMultiDrawPropertiesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceMultiDrawPropertiesEXT>
  {
    using Type = PhysicalDeviceMultiDrawPropertiesEXT;
  };

  struct PhysicalDeviceMultiviewFeatures
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::ePhysicalDeviceMultiviewFeatures;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceMultiviewFeatures(
      VULKAN_HPP_NAMESPACE::Bool32 multiview_                   = {},
      VULKAN_HPP_NAMESPACE::Bool32 multiviewGeometryShader_     = {},
      VULKAN_HPP_NAMESPACE::Bool32 multiviewTessellationShader_ = {} ) VULKAN_HPP_NOEXCEPT
      : multiview( multiview_ )
      , multiviewGeometryShader( multiviewGeometryShader_ )
      , multiviewTessellationShader( multiviewTessellationShader_ )
    {}

    VULKAN_HPP_CONSTEXPR
      PhysicalDeviceMultiviewFeatures( PhysicalDeviceMultiviewFeatures const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceMultiviewFeatures( VkPhysicalDeviceMultiviewFeatures const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceMultiviewFeatures( *reinterpret_cast<PhysicalDeviceMultiviewFeatures const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceMultiviewFeatures &
                            operator=( PhysicalDeviceMultiviewFeatures const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceMultiviewFeatures & operator=( VkPhysicalDeviceMultiviewFeatures const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceMultiviewFeatures const *>( &rhs );
      return *this;
    }

    PhysicalDeviceMultiviewFeatures & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceMultiviewFeatures & setMultiview( VULKAN_HPP_NAMESPACE::Bool32 multiview_ ) VULKAN_HPP_NOEXCEPT
    {
      multiview = multiview_;
      return *this;
    }

    PhysicalDeviceMultiviewFeatures &
      setMultiviewGeometryShader( VULKAN_HPP_NAMESPACE::Bool32 multiviewGeometryShader_ ) VULKAN_HPP_NOEXCEPT
    {
      multiviewGeometryShader = multiviewGeometryShader_;
      return *this;
    }

    PhysicalDeviceMultiviewFeatures &
      setMultiviewTessellationShader( VULKAN_HPP_NAMESPACE::Bool32 multiviewTessellationShader_ ) VULKAN_HPP_NOEXCEPT
    {
      multiviewTessellationShader = multiviewTessellationShader_;
      return *this;
    }

    operator VkPhysicalDeviceMultiviewFeatures const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceMultiviewFeatures *>( this );
    }

    operator VkPhysicalDeviceMultiviewFeatures &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceMultiviewFeatures *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceMultiviewFeatures const & ) const = default;
#else
    bool operator==( PhysicalDeviceMultiviewFeatures const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( multiview == rhs.multiview ) &&
             ( multiviewGeometryShader == rhs.multiviewGeometryShader ) &&
             ( multiviewTessellationShader == rhs.multiviewTessellationShader );
    }

    bool operator!=( PhysicalDeviceMultiviewFeatures const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType                       = StructureType::ePhysicalDeviceMultiviewFeatures;
    void *                              pNext                       = {};
    VULKAN_HPP_NAMESPACE::Bool32        multiview                   = {};
    VULKAN_HPP_NAMESPACE::Bool32        multiviewGeometryShader     = {};
    VULKAN_HPP_NAMESPACE::Bool32        multiviewTessellationShader = {};
  };
  static_assert( sizeof( PhysicalDeviceMultiviewFeatures ) == sizeof( VkPhysicalDeviceMultiviewFeatures ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceMultiviewFeatures>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceMultiviewFeatures>
  {
    using Type = PhysicalDeviceMultiviewFeatures;
  };
  using PhysicalDeviceMultiviewFeaturesKHR = PhysicalDeviceMultiviewFeatures;

  struct PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceMultiviewPerViewAttributesPropertiesNVX;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(
      VULKAN_HPP_NAMESPACE::Bool32 perViewPositionAllComponents_ = {} ) VULKAN_HPP_NOEXCEPT
      : perViewPositionAllComponents( perViewPositionAllComponents_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(
      PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(
      VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(
          *reinterpret_cast<PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX &
                            operator=( PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX &
      operator=( VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this =
        *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX *>( this );
    }

    operator VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX const & ) const = default;
#else
    bool operator==( PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( perViewPositionAllComponents == rhs.perViewPositionAllComponents );
    }

    bool operator!=( PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceMultiviewPerViewAttributesPropertiesNVX;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        perViewPositionAllComponents = {};
  };
  static_assert( sizeof( PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX ) ==
                   sizeof( VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceMultiviewPerViewAttributesPropertiesNVX>
  {
    using Type = PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX;
  };

  struct PhysicalDeviceMultiviewProperties
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceMultiviewProperties;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      PhysicalDeviceMultiviewProperties( uint32_t maxMultiviewViewCount_     = {},
                                         uint32_t maxMultiviewInstanceIndex_ = {} ) VULKAN_HPP_NOEXCEPT
      : maxMultiviewViewCount( maxMultiviewViewCount_ )
      , maxMultiviewInstanceIndex( maxMultiviewInstanceIndex_ )
    {}

    VULKAN_HPP_CONSTEXPR
      PhysicalDeviceMultiviewProperties( PhysicalDeviceMultiviewProperties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceMultiviewProperties( VkPhysicalDeviceMultiviewProperties const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceMultiviewProperties( *reinterpret_cast<PhysicalDeviceMultiviewProperties const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceMultiviewProperties &
                            operator=( PhysicalDeviceMultiviewProperties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceMultiviewProperties & operator=( VkPhysicalDeviceMultiviewProperties const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceMultiviewProperties const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceMultiviewProperties const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceMultiviewProperties *>( this );
    }

    operator VkPhysicalDeviceMultiviewProperties &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceMultiviewProperties *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceMultiviewProperties const & ) const = default;
#else
    bool operator==( PhysicalDeviceMultiviewProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( maxMultiviewViewCount == rhs.maxMultiviewViewCount ) &&
             ( maxMultiviewInstanceIndex == rhs.maxMultiviewInstanceIndex );
    }

    bool operator!=( PhysicalDeviceMultiviewProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType                     = StructureType::ePhysicalDeviceMultiviewProperties;
    void *                              pNext                     = {};
    uint32_t                            maxMultiviewViewCount     = {};
    uint32_t                            maxMultiviewInstanceIndex = {};
  };
  static_assert( sizeof( PhysicalDeviceMultiviewProperties ) == sizeof( VkPhysicalDeviceMultiviewProperties ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceMultiviewProperties>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceMultiviewProperties>
  {
    using Type = PhysicalDeviceMultiviewProperties;
  };
  using PhysicalDeviceMultiviewPropertiesKHR = PhysicalDeviceMultiviewProperties;

  struct PhysicalDeviceMutableDescriptorTypeFeaturesVALVE
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceMutableDescriptorTypeFeaturesVALVE;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceMutableDescriptorTypeFeaturesVALVE(
      VULKAN_HPP_NAMESPACE::Bool32 mutableDescriptorType_ = {} ) VULKAN_HPP_NOEXCEPT
      : mutableDescriptorType( mutableDescriptorType_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceMutableDescriptorTypeFeaturesVALVE(
      PhysicalDeviceMutableDescriptorTypeFeaturesVALVE const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceMutableDescriptorTypeFeaturesVALVE( VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceMutableDescriptorTypeFeaturesVALVE(
          *reinterpret_cast<PhysicalDeviceMutableDescriptorTypeFeaturesVALVE const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceMutableDescriptorTypeFeaturesVALVE &
                            operator=( PhysicalDeviceMutableDescriptorTypeFeaturesVALVE const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceMutableDescriptorTypeFeaturesVALVE &
      operator=( VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceMutableDescriptorTypeFeaturesVALVE const *>( &rhs );
      return *this;
    }

    PhysicalDeviceMutableDescriptorTypeFeaturesVALVE & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceMutableDescriptorTypeFeaturesVALVE &
      setMutableDescriptorType( VULKAN_HPP_NAMESPACE::Bool32 mutableDescriptorType_ ) VULKAN_HPP_NOEXCEPT
    {
      mutableDescriptorType = mutableDescriptorType_;
      return *this;
    }

    operator VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE *>( this );
    }

    operator VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceMutableDescriptorTypeFeaturesVALVE const & ) const = default;
#else
    bool operator==( PhysicalDeviceMutableDescriptorTypeFeaturesVALVE const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( mutableDescriptorType == rhs.mutableDescriptorType );
    }

    bool operator!=( PhysicalDeviceMutableDescriptorTypeFeaturesVALVE const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceMutableDescriptorTypeFeaturesVALVE;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        mutableDescriptorType = {};
  };
  static_assert( sizeof( PhysicalDeviceMutableDescriptorTypeFeaturesVALVE ) ==
                   sizeof( VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceMutableDescriptorTypeFeaturesVALVE>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceMutableDescriptorTypeFeaturesVALVE>
  {
    using Type = PhysicalDeviceMutableDescriptorTypeFeaturesVALVE;
  };

  struct PhysicalDevicePCIBusInfoPropertiesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDevicePciBusInfoPropertiesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDevicePCIBusInfoPropertiesEXT( uint32_t pciDomain_   = {},
                                                                uint32_t pciBus_      = {},
                                                                uint32_t pciDevice_   = {},
                                                                uint32_t pciFunction_ = {} ) VULKAN_HPP_NOEXCEPT
      : pciDomain( pciDomain_ )
      , pciBus( pciBus_ )
      , pciDevice( pciDevice_ )
      , pciFunction( pciFunction_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDevicePCIBusInfoPropertiesEXT( PhysicalDevicePCIBusInfoPropertiesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    PhysicalDevicePCIBusInfoPropertiesEXT( VkPhysicalDevicePCIBusInfoPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDevicePCIBusInfoPropertiesEXT(
          *reinterpret_cast<PhysicalDevicePCIBusInfoPropertiesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDevicePCIBusInfoPropertiesEXT &
                            operator=( PhysicalDevicePCIBusInfoPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDevicePCIBusInfoPropertiesEXT &
      operator=( VkPhysicalDevicePCIBusInfoPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDevicePCIBusInfoPropertiesEXT const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDevicePCIBusInfoPropertiesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDevicePCIBusInfoPropertiesEXT *>( this );
    }

    operator VkPhysicalDevicePCIBusInfoPropertiesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDevicePCIBusInfoPropertiesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDevicePCIBusInfoPropertiesEXT const & ) const = default;
#else
    bool operator==( PhysicalDevicePCIBusInfoPropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( pciDomain == rhs.pciDomain ) &&
             ( pciBus == rhs.pciBus ) && ( pciDevice == rhs.pciDevice ) && ( pciFunction == rhs.pciFunction );
    }

    bool operator!=( PhysicalDevicePCIBusInfoPropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType       = StructureType::ePhysicalDevicePciBusInfoPropertiesEXT;
    void *                              pNext       = {};
    uint32_t                            pciDomain   = {};
    uint32_t                            pciBus      = {};
    uint32_t                            pciDevice   = {};
    uint32_t                            pciFunction = {};
  };
  static_assert( sizeof( PhysicalDevicePCIBusInfoPropertiesEXT ) == sizeof( VkPhysicalDevicePCIBusInfoPropertiesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDevicePCIBusInfoPropertiesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDevicePciBusInfoPropertiesEXT>
  {
    using Type = PhysicalDevicePCIBusInfoPropertiesEXT;
  };

  struct PhysicalDevicePerformanceQueryFeaturesKHR
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDevicePerformanceQueryFeaturesKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDevicePerformanceQueryFeaturesKHR(
      VULKAN_HPP_NAMESPACE::Bool32 performanceCounterQueryPools_         = {},
      VULKAN_HPP_NAMESPACE::Bool32 performanceCounterMultipleQueryPools_ = {} ) VULKAN_HPP_NOEXCEPT
      : performanceCounterQueryPools( performanceCounterQueryPools_ )
      , performanceCounterMultipleQueryPools( performanceCounterMultipleQueryPools_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDevicePerformanceQueryFeaturesKHR(
      PhysicalDevicePerformanceQueryFeaturesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDevicePerformanceQueryFeaturesKHR( VkPhysicalDevicePerformanceQueryFeaturesKHR const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDevicePerformanceQueryFeaturesKHR(
          *reinterpret_cast<PhysicalDevicePerformanceQueryFeaturesKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDevicePerformanceQueryFeaturesKHR &
                            operator=( PhysicalDevicePerformanceQueryFeaturesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDevicePerformanceQueryFeaturesKHR &
      operator=( VkPhysicalDevicePerformanceQueryFeaturesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDevicePerformanceQueryFeaturesKHR const *>( &rhs );
      return *this;
    }

    PhysicalDevicePerformanceQueryFeaturesKHR & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDevicePerformanceQueryFeaturesKHR &
      setPerformanceCounterQueryPools( VULKAN_HPP_NAMESPACE::Bool32 performanceCounterQueryPools_ ) VULKAN_HPP_NOEXCEPT
    {
      performanceCounterQueryPools = performanceCounterQueryPools_;
      return *this;
    }

    PhysicalDevicePerformanceQueryFeaturesKHR & setPerformanceCounterMultipleQueryPools(
      VULKAN_HPP_NAMESPACE::Bool32 performanceCounterMultipleQueryPools_ ) VULKAN_HPP_NOEXCEPT
    {
      performanceCounterMultipleQueryPools = performanceCounterMultipleQueryPools_;
      return *this;
    }

    operator VkPhysicalDevicePerformanceQueryFeaturesKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDevicePerformanceQueryFeaturesKHR *>( this );
    }

    operator VkPhysicalDevicePerformanceQueryFeaturesKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDevicePerformanceQueryFeaturesKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDevicePerformanceQueryFeaturesKHR const & ) const = default;
#else
    bool operator==( PhysicalDevicePerformanceQueryFeaturesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( performanceCounterQueryPools == rhs.performanceCounterQueryPools ) &&
             ( performanceCounterMultipleQueryPools == rhs.performanceCounterMultipleQueryPools );
    }

    bool operator!=( PhysicalDevicePerformanceQueryFeaturesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDevicePerformanceQueryFeaturesKHR;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        performanceCounterQueryPools         = {};
    VULKAN_HPP_NAMESPACE::Bool32        performanceCounterMultipleQueryPools = {};
  };
  static_assert( sizeof( PhysicalDevicePerformanceQueryFeaturesKHR ) ==
                   sizeof( VkPhysicalDevicePerformanceQueryFeaturesKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDevicePerformanceQueryFeaturesKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDevicePerformanceQueryFeaturesKHR>
  {
    using Type = PhysicalDevicePerformanceQueryFeaturesKHR;
  };

  struct PhysicalDevicePerformanceQueryPropertiesKHR
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDevicePerformanceQueryPropertiesKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDevicePerformanceQueryPropertiesKHR(
      VULKAN_HPP_NAMESPACE::Bool32 allowCommandBufferQueryCopies_ = {} ) VULKAN_HPP_NOEXCEPT
      : allowCommandBufferQueryCopies( allowCommandBufferQueryCopies_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDevicePerformanceQueryPropertiesKHR(
      PhysicalDevicePerformanceQueryPropertiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDevicePerformanceQueryPropertiesKHR( VkPhysicalDevicePerformanceQueryPropertiesKHR const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDevicePerformanceQueryPropertiesKHR(
          *reinterpret_cast<PhysicalDevicePerformanceQueryPropertiesKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDevicePerformanceQueryPropertiesKHR &
                            operator=( PhysicalDevicePerformanceQueryPropertiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDevicePerformanceQueryPropertiesKHR &
      operator=( VkPhysicalDevicePerformanceQueryPropertiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDevicePerformanceQueryPropertiesKHR const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDevicePerformanceQueryPropertiesKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDevicePerformanceQueryPropertiesKHR *>( this );
    }

    operator VkPhysicalDevicePerformanceQueryPropertiesKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDevicePerformanceQueryPropertiesKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDevicePerformanceQueryPropertiesKHR const & ) const = default;
#else
    bool operator==( PhysicalDevicePerformanceQueryPropertiesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( allowCommandBufferQueryCopies == rhs.allowCommandBufferQueryCopies );
    }

    bool operator!=( PhysicalDevicePerformanceQueryPropertiesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDevicePerformanceQueryPropertiesKHR;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        allowCommandBufferQueryCopies = {};
  };
  static_assert( sizeof( PhysicalDevicePerformanceQueryPropertiesKHR ) ==
                   sizeof( VkPhysicalDevicePerformanceQueryPropertiesKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDevicePerformanceQueryPropertiesKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDevicePerformanceQueryPropertiesKHR>
  {
    using Type = PhysicalDevicePerformanceQueryPropertiesKHR;
  };

  struct PhysicalDevicePipelineCreationCacheControlFeaturesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDevicePipelineCreationCacheControlFeaturesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDevicePipelineCreationCacheControlFeaturesEXT(
      VULKAN_HPP_NAMESPACE::Bool32 pipelineCreationCacheControl_ = {} ) VULKAN_HPP_NOEXCEPT
      : pipelineCreationCacheControl( pipelineCreationCacheControl_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDevicePipelineCreationCacheControlFeaturesEXT(
      PhysicalDevicePipelineCreationCacheControlFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDevicePipelineCreationCacheControlFeaturesEXT(
      VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDevicePipelineCreationCacheControlFeaturesEXT(
          *reinterpret_cast<PhysicalDevicePipelineCreationCacheControlFeaturesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDevicePipelineCreationCacheControlFeaturesEXT &
                            operator=( PhysicalDevicePipelineCreationCacheControlFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDevicePipelineCreationCacheControlFeaturesEXT &
      operator=( VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this =
        *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDevicePipelineCreationCacheControlFeaturesEXT const *>( &rhs );
      return *this;
    }

    PhysicalDevicePipelineCreationCacheControlFeaturesEXT & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDevicePipelineCreationCacheControlFeaturesEXT &
      setPipelineCreationCacheControl( VULKAN_HPP_NAMESPACE::Bool32 pipelineCreationCacheControl_ ) VULKAN_HPP_NOEXCEPT
    {
      pipelineCreationCacheControl = pipelineCreationCacheControl_;
      return *this;
    }

    operator VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT *>( this );
    }

    operator VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDevicePipelineCreationCacheControlFeaturesEXT const & ) const = default;
#else
    bool operator==( PhysicalDevicePipelineCreationCacheControlFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( pipelineCreationCacheControl == rhs.pipelineCreationCacheControl );
    }

    bool operator!=( PhysicalDevicePipelineCreationCacheControlFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDevicePipelineCreationCacheControlFeaturesEXT;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        pipelineCreationCacheControl = {};
  };
  static_assert( sizeof( PhysicalDevicePipelineCreationCacheControlFeaturesEXT ) ==
                   sizeof( VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDevicePipelineCreationCacheControlFeaturesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDevicePipelineCreationCacheControlFeaturesEXT>
  {
    using Type = PhysicalDevicePipelineCreationCacheControlFeaturesEXT;
  };

  struct PhysicalDevicePipelineExecutablePropertiesFeaturesKHR
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDevicePipelineExecutablePropertiesFeaturesKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDevicePipelineExecutablePropertiesFeaturesKHR(
      VULKAN_HPP_NAMESPACE::Bool32 pipelineExecutableInfo_ = {} ) VULKAN_HPP_NOEXCEPT
      : pipelineExecutableInfo( pipelineExecutableInfo_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDevicePipelineExecutablePropertiesFeaturesKHR(
      PhysicalDevicePipelineExecutablePropertiesFeaturesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDevicePipelineExecutablePropertiesFeaturesKHR(
      VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDevicePipelineExecutablePropertiesFeaturesKHR(
          *reinterpret_cast<PhysicalDevicePipelineExecutablePropertiesFeaturesKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDevicePipelineExecutablePropertiesFeaturesKHR &
                            operator=( PhysicalDevicePipelineExecutablePropertiesFeaturesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDevicePipelineExecutablePropertiesFeaturesKHR &
      operator=( VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this =
        *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDevicePipelineExecutablePropertiesFeaturesKHR const *>( &rhs );
      return *this;
    }

    PhysicalDevicePipelineExecutablePropertiesFeaturesKHR & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDevicePipelineExecutablePropertiesFeaturesKHR &
      setPipelineExecutableInfo( VULKAN_HPP_NAMESPACE::Bool32 pipelineExecutableInfo_ ) VULKAN_HPP_NOEXCEPT
    {
      pipelineExecutableInfo = pipelineExecutableInfo_;
      return *this;
    }

    operator VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR *>( this );
    }

    operator VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDevicePipelineExecutablePropertiesFeaturesKHR const & ) const = default;
#else
    bool operator==( PhysicalDevicePipelineExecutablePropertiesFeaturesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( pipelineExecutableInfo == rhs.pipelineExecutableInfo );
    }

    bool operator!=( PhysicalDevicePipelineExecutablePropertiesFeaturesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDevicePipelineExecutablePropertiesFeaturesKHR;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        pipelineExecutableInfo = {};
  };
  static_assert( sizeof( PhysicalDevicePipelineExecutablePropertiesFeaturesKHR ) ==
                   sizeof( VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDevicePipelineExecutablePropertiesFeaturesKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDevicePipelineExecutablePropertiesFeaturesKHR>
  {
    using Type = PhysicalDevicePipelineExecutablePropertiesFeaturesKHR;
  };

  struct PhysicalDevicePointClippingProperties
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDevicePointClippingProperties;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDevicePointClippingProperties(
      VULKAN_HPP_NAMESPACE::PointClippingBehavior pointClippingBehavior_ =
        VULKAN_HPP_NAMESPACE::PointClippingBehavior::eAllClipPlanes ) VULKAN_HPP_NOEXCEPT
      : pointClippingBehavior( pointClippingBehavior_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDevicePointClippingProperties( PhysicalDevicePointClippingProperties const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    PhysicalDevicePointClippingProperties( VkPhysicalDevicePointClippingProperties const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDevicePointClippingProperties(
          *reinterpret_cast<PhysicalDevicePointClippingProperties const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDevicePointClippingProperties &
                            operator=( PhysicalDevicePointClippingProperties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDevicePointClippingProperties &
      operator=( VkPhysicalDevicePointClippingProperties const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDevicePointClippingProperties const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDevicePointClippingProperties const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDevicePointClippingProperties *>( this );
    }

    operator VkPhysicalDevicePointClippingProperties &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDevicePointClippingProperties *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDevicePointClippingProperties const & ) const = default;
#else
    bool operator==( PhysicalDevicePointClippingProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( pointClippingBehavior == rhs.pointClippingBehavior );
    }

    bool operator!=( PhysicalDevicePointClippingProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType         sType = StructureType::ePhysicalDevicePointClippingProperties;
    void *                                      pNext = {};
    VULKAN_HPP_NAMESPACE::PointClippingBehavior pointClippingBehavior =
      VULKAN_HPP_NAMESPACE::PointClippingBehavior::eAllClipPlanes;
  };
  static_assert( sizeof( PhysicalDevicePointClippingProperties ) == sizeof( VkPhysicalDevicePointClippingProperties ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDevicePointClippingProperties>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDevicePointClippingProperties>
  {
    using Type = PhysicalDevicePointClippingProperties;
  };
  using PhysicalDevicePointClippingPropertiesKHR = PhysicalDevicePointClippingProperties;

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  struct PhysicalDevicePortabilitySubsetFeaturesKHR
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDevicePortabilitySubsetFeaturesKHR;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDevicePortabilitySubsetFeaturesKHR(
      VULKAN_HPP_NAMESPACE::Bool32 constantAlphaColorBlendFactors_         = {},
      VULKAN_HPP_NAMESPACE::Bool32 events_                                 = {},
      VULKAN_HPP_NAMESPACE::Bool32 imageViewFormatReinterpretation_        = {},
      VULKAN_HPP_NAMESPACE::Bool32 imageViewFormatSwizzle_                 = {},
      VULKAN_HPP_NAMESPACE::Bool32 imageView2DOn3DImage_                   = {},
      VULKAN_HPP_NAMESPACE::Bool32 multisampleArrayImage_                  = {},
      VULKAN_HPP_NAMESPACE::Bool32 mutableComparisonSamplers_              = {},
      VULKAN_HPP_NAMESPACE::Bool32 pointPolygons_                          = {},
      VULKAN_HPP_NAMESPACE::Bool32 samplerMipLodBias_                      = {},
      VULKAN_HPP_NAMESPACE::Bool32 separateStencilMaskRef_                 = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderSampleRateInterpolationFunctions_ = {},
      VULKAN_HPP_NAMESPACE::Bool32 tessellationIsolines_                   = {},
      VULKAN_HPP_NAMESPACE::Bool32 tessellationPointMode_                  = {},
      VULKAN_HPP_NAMESPACE::Bool32 triangleFans_                           = {},
      VULKAN_HPP_NAMESPACE::Bool32 vertexAttributeAccessBeyondStride_      = {} ) VULKAN_HPP_NOEXCEPT
      : constantAlphaColorBlendFactors( constantAlphaColorBlendFactors_ )
      , events( events_ )
      , imageViewFormatReinterpretation( imageViewFormatReinterpretation_ )
      , imageViewFormatSwizzle( imageViewFormatSwizzle_ )
      , imageView2DOn3DImage( imageView2DOn3DImage_ )
      , multisampleArrayImage( multisampleArrayImage_ )
      , mutableComparisonSamplers( mutableComparisonSamplers_ )
      , pointPolygons( pointPolygons_ )
      , samplerMipLodBias( samplerMipLodBias_ )
      , separateStencilMaskRef( separateStencilMaskRef_ )
      , shaderSampleRateInterpolationFunctions( shaderSampleRateInterpolationFunctions_ )
      , tessellationIsolines( tessellationIsolines_ )
      , tessellationPointMode( tessellationPointMode_ )
      , triangleFans( triangleFans_ )
      , vertexAttributeAccessBeyondStride( vertexAttributeAccessBeyondStride_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDevicePortabilitySubsetFeaturesKHR(
      PhysicalDevicePortabilitySubsetFeaturesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDevicePortabilitySubsetFeaturesKHR( VkPhysicalDevicePortabilitySubsetFeaturesKHR const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDevicePortabilitySubsetFeaturesKHR(
          *reinterpret_cast<PhysicalDevicePortabilitySubsetFeaturesKHR const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDevicePortabilitySubsetFeaturesKHR &
                            operator=( PhysicalDevicePortabilitySubsetFeaturesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDevicePortabilitySubsetFeaturesKHR &
      operator=( VkPhysicalDevicePortabilitySubsetFeaturesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDevicePortabilitySubsetFeaturesKHR const *>( &rhs );
      return *this;
    }

    PhysicalDevicePortabilitySubsetFeaturesKHR & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDevicePortabilitySubsetFeaturesKHR & setConstantAlphaColorBlendFactors(
      VULKAN_HPP_NAMESPACE::Bool32 constantAlphaColorBlendFactors_ ) VULKAN_HPP_NOEXCEPT
    {
      constantAlphaColorBlendFactors = constantAlphaColorBlendFactors_;
      return *this;
    }

    PhysicalDevicePortabilitySubsetFeaturesKHR & setEvents( VULKAN_HPP_NAMESPACE::Bool32 events_ ) VULKAN_HPP_NOEXCEPT
    {
      events = events_;
      return *this;
    }

    PhysicalDevicePortabilitySubsetFeaturesKHR & setImageViewFormatReinterpretation(
      VULKAN_HPP_NAMESPACE::Bool32 imageViewFormatReinterpretation_ ) VULKAN_HPP_NOEXCEPT
    {
      imageViewFormatReinterpretation = imageViewFormatReinterpretation_;
      return *this;
    }

    PhysicalDevicePortabilitySubsetFeaturesKHR &
      setImageViewFormatSwizzle( VULKAN_HPP_NAMESPACE::Bool32 imageViewFormatSwizzle_ ) VULKAN_HPP_NOEXCEPT
    {
      imageViewFormatSwizzle = imageViewFormatSwizzle_;
      return *this;
    }

    PhysicalDevicePortabilitySubsetFeaturesKHR &
      setImageView2DOn3DImage( VULKAN_HPP_NAMESPACE::Bool32 imageView2DOn3DImage_ ) VULKAN_HPP_NOEXCEPT
    {
      imageView2DOn3DImage = imageView2DOn3DImage_;
      return *this;
    }

    PhysicalDevicePortabilitySubsetFeaturesKHR &
      setMultisampleArrayImage( VULKAN_HPP_NAMESPACE::Bool32 multisampleArrayImage_ ) VULKAN_HPP_NOEXCEPT
    {
      multisampleArrayImage = multisampleArrayImage_;
      return *this;
    }

    PhysicalDevicePortabilitySubsetFeaturesKHR &
      setMutableComparisonSamplers( VULKAN_HPP_NAMESPACE::Bool32 mutableComparisonSamplers_ ) VULKAN_HPP_NOEXCEPT
    {
      mutableComparisonSamplers = mutableComparisonSamplers_;
      return *this;
    }

    PhysicalDevicePortabilitySubsetFeaturesKHR &
      setPointPolygons( VULKAN_HPP_NAMESPACE::Bool32 pointPolygons_ ) VULKAN_HPP_NOEXCEPT
    {
      pointPolygons = pointPolygons_;
      return *this;
    }

    PhysicalDevicePortabilitySubsetFeaturesKHR &
      setSamplerMipLodBias( VULKAN_HPP_NAMESPACE::Bool32 samplerMipLodBias_ ) VULKAN_HPP_NOEXCEPT
    {
      samplerMipLodBias = samplerMipLodBias_;
      return *this;
    }

    PhysicalDevicePortabilitySubsetFeaturesKHR &
      setSeparateStencilMaskRef( VULKAN_HPP_NAMESPACE::Bool32 separateStencilMaskRef_ ) VULKAN_HPP_NOEXCEPT
    {
      separateStencilMaskRef = separateStencilMaskRef_;
      return *this;
    }

    PhysicalDevicePortabilitySubsetFeaturesKHR & setShaderSampleRateInterpolationFunctions(
      VULKAN_HPP_NAMESPACE::Bool32 shaderSampleRateInterpolationFunctions_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderSampleRateInterpolationFunctions = shaderSampleRateInterpolationFunctions_;
      return *this;
    }

    PhysicalDevicePortabilitySubsetFeaturesKHR &
      setTessellationIsolines( VULKAN_HPP_NAMESPACE::Bool32 tessellationIsolines_ ) VULKAN_HPP_NOEXCEPT
    {
      tessellationIsolines = tessellationIsolines_;
      return *this;
    }

    PhysicalDevicePortabilitySubsetFeaturesKHR &
      setTessellationPointMode( VULKAN_HPP_NAMESPACE::Bool32 tessellationPointMode_ ) VULKAN_HPP_NOEXCEPT
    {
      tessellationPointMode = tessellationPointMode_;
      return *this;
    }

    PhysicalDevicePortabilitySubsetFeaturesKHR &
      setTriangleFans( VULKAN_HPP_NAMESPACE::Bool32 triangleFans_ ) VULKAN_HPP_NOEXCEPT
    {
      triangleFans = triangleFans_;
      return *this;
    }

    PhysicalDevicePortabilitySubsetFeaturesKHR & setVertexAttributeAccessBeyondStride(
      VULKAN_HPP_NAMESPACE::Bool32 vertexAttributeAccessBeyondStride_ ) VULKAN_HPP_NOEXCEPT
    {
      vertexAttributeAccessBeyondStride = vertexAttributeAccessBeyondStride_;
      return *this;
    }

    operator VkPhysicalDevicePortabilitySubsetFeaturesKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDevicePortabilitySubsetFeaturesKHR *>( this );
    }

    operator VkPhysicalDevicePortabilitySubsetFeaturesKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDevicePortabilitySubsetFeaturesKHR *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDevicePortabilitySubsetFeaturesKHR const & ) const = default;
#  else
    bool operator==( PhysicalDevicePortabilitySubsetFeaturesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( constantAlphaColorBlendFactors == rhs.constantAlphaColorBlendFactors ) && ( events == rhs.events ) &&
             ( imageViewFormatReinterpretation == rhs.imageViewFormatReinterpretation ) &&
             ( imageViewFormatSwizzle == rhs.imageViewFormatSwizzle ) &&
             ( imageView2DOn3DImage == rhs.imageView2DOn3DImage ) &&
             ( multisampleArrayImage == rhs.multisampleArrayImage ) &&
             ( mutableComparisonSamplers == rhs.mutableComparisonSamplers ) && ( pointPolygons == rhs.pointPolygons ) &&
             ( samplerMipLodBias == rhs.samplerMipLodBias ) &&
             ( separateStencilMaskRef == rhs.separateStencilMaskRef ) &&
             ( shaderSampleRateInterpolationFunctions == rhs.shaderSampleRateInterpolationFunctions ) &&
             ( tessellationIsolines == rhs.tessellationIsolines ) &&
             ( tessellationPointMode == rhs.tessellationPointMode ) && ( triangleFans == rhs.triangleFans ) &&
             ( vertexAttributeAccessBeyondStride == rhs.vertexAttributeAccessBeyondStride );
    }

    bool operator!=( PhysicalDevicePortabilitySubsetFeaturesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDevicePortabilitySubsetFeaturesKHR;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        constantAlphaColorBlendFactors         = {};
    VULKAN_HPP_NAMESPACE::Bool32        events                                 = {};
    VULKAN_HPP_NAMESPACE::Bool32        imageViewFormatReinterpretation        = {};
    VULKAN_HPP_NAMESPACE::Bool32        imageViewFormatSwizzle                 = {};
    VULKAN_HPP_NAMESPACE::Bool32        imageView2DOn3DImage                   = {};
    VULKAN_HPP_NAMESPACE::Bool32        multisampleArrayImage                  = {};
    VULKAN_HPP_NAMESPACE::Bool32        mutableComparisonSamplers              = {};
    VULKAN_HPP_NAMESPACE::Bool32        pointPolygons                          = {};
    VULKAN_HPP_NAMESPACE::Bool32        samplerMipLodBias                      = {};
    VULKAN_HPP_NAMESPACE::Bool32        separateStencilMaskRef                 = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderSampleRateInterpolationFunctions = {};
    VULKAN_HPP_NAMESPACE::Bool32        tessellationIsolines                   = {};
    VULKAN_HPP_NAMESPACE::Bool32        tessellationPointMode                  = {};
    VULKAN_HPP_NAMESPACE::Bool32        triangleFans                           = {};
    VULKAN_HPP_NAMESPACE::Bool32        vertexAttributeAccessBeyondStride      = {};
  };
  static_assert( sizeof( PhysicalDevicePortabilitySubsetFeaturesKHR ) ==
                   sizeof( VkPhysicalDevicePortabilitySubsetFeaturesKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDevicePortabilitySubsetFeaturesKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDevicePortabilitySubsetFeaturesKHR>
  {
    using Type = PhysicalDevicePortabilitySubsetFeaturesKHR;
  };
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  struct PhysicalDevicePortabilitySubsetPropertiesKHR
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDevicePortabilitySubsetPropertiesKHR;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDevicePortabilitySubsetPropertiesKHR(
      uint32_t minVertexInputBindingStrideAlignment_ = {} ) VULKAN_HPP_NOEXCEPT
      : minVertexInputBindingStrideAlignment( minVertexInputBindingStrideAlignment_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDevicePortabilitySubsetPropertiesKHR(
      PhysicalDevicePortabilitySubsetPropertiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDevicePortabilitySubsetPropertiesKHR( VkPhysicalDevicePortabilitySubsetPropertiesKHR const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDevicePortabilitySubsetPropertiesKHR(
          *reinterpret_cast<PhysicalDevicePortabilitySubsetPropertiesKHR const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDevicePortabilitySubsetPropertiesKHR &
                            operator=( PhysicalDevicePortabilitySubsetPropertiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDevicePortabilitySubsetPropertiesKHR &
      operator=( VkPhysicalDevicePortabilitySubsetPropertiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDevicePortabilitySubsetPropertiesKHR const *>( &rhs );
      return *this;
    }

    PhysicalDevicePortabilitySubsetPropertiesKHR & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDevicePortabilitySubsetPropertiesKHR &
      setMinVertexInputBindingStrideAlignment( uint32_t minVertexInputBindingStrideAlignment_ ) VULKAN_HPP_NOEXCEPT
    {
      minVertexInputBindingStrideAlignment = minVertexInputBindingStrideAlignment_;
      return *this;
    }

    operator VkPhysicalDevicePortabilitySubsetPropertiesKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDevicePortabilitySubsetPropertiesKHR *>( this );
    }

    operator VkPhysicalDevicePortabilitySubsetPropertiesKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDevicePortabilitySubsetPropertiesKHR *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDevicePortabilitySubsetPropertiesKHR const & ) const = default;
#  else
    bool operator==( PhysicalDevicePortabilitySubsetPropertiesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( minVertexInputBindingStrideAlignment == rhs.minVertexInputBindingStrideAlignment );
    }

    bool operator!=( PhysicalDevicePortabilitySubsetPropertiesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDevicePortabilitySubsetPropertiesKHR;
    void *                              pNext = {};
    uint32_t                            minVertexInputBindingStrideAlignment = {};
  };
  static_assert( sizeof( PhysicalDevicePortabilitySubsetPropertiesKHR ) ==
                   sizeof( VkPhysicalDevicePortabilitySubsetPropertiesKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDevicePortabilitySubsetPropertiesKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDevicePortabilitySubsetPropertiesKHR>
  {
    using Type = PhysicalDevicePortabilitySubsetPropertiesKHR;
  };
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

  struct PhysicalDevicePrivateDataFeaturesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDevicePrivateDataFeaturesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      PhysicalDevicePrivateDataFeaturesEXT( VULKAN_HPP_NAMESPACE::Bool32 privateData_ = {} ) VULKAN_HPP_NOEXCEPT
      : privateData( privateData_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDevicePrivateDataFeaturesEXT( PhysicalDevicePrivateDataFeaturesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    PhysicalDevicePrivateDataFeaturesEXT( VkPhysicalDevicePrivateDataFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDevicePrivateDataFeaturesEXT( *reinterpret_cast<PhysicalDevicePrivateDataFeaturesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDevicePrivateDataFeaturesEXT &
                            operator=( PhysicalDevicePrivateDataFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDevicePrivateDataFeaturesEXT &
      operator=( VkPhysicalDevicePrivateDataFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDevicePrivateDataFeaturesEXT const *>( &rhs );
      return *this;
    }

    PhysicalDevicePrivateDataFeaturesEXT & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDevicePrivateDataFeaturesEXT &
      setPrivateData( VULKAN_HPP_NAMESPACE::Bool32 privateData_ ) VULKAN_HPP_NOEXCEPT
    {
      privateData = privateData_;
      return *this;
    }

    operator VkPhysicalDevicePrivateDataFeaturesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDevicePrivateDataFeaturesEXT *>( this );
    }

    operator VkPhysicalDevicePrivateDataFeaturesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDevicePrivateDataFeaturesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDevicePrivateDataFeaturesEXT const & ) const = default;
#else
    bool operator==( PhysicalDevicePrivateDataFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( privateData == rhs.privateData );
    }

    bool operator!=( PhysicalDevicePrivateDataFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType       = StructureType::ePhysicalDevicePrivateDataFeaturesEXT;
    void *                              pNext       = {};
    VULKAN_HPP_NAMESPACE::Bool32        privateData = {};
  };
  static_assert( sizeof( PhysicalDevicePrivateDataFeaturesEXT ) == sizeof( VkPhysicalDevicePrivateDataFeaturesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDevicePrivateDataFeaturesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDevicePrivateDataFeaturesEXT>
  {
    using Type = PhysicalDevicePrivateDataFeaturesEXT;
  };

  struct PhysicalDeviceSparseProperties
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceSparseProperties(
      VULKAN_HPP_NAMESPACE::Bool32 residencyStandard2DBlockShape_            = {},
      VULKAN_HPP_NAMESPACE::Bool32 residencyStandard2DMultisampleBlockShape_ = {},
      VULKAN_HPP_NAMESPACE::Bool32 residencyStandard3DBlockShape_            = {},
      VULKAN_HPP_NAMESPACE::Bool32 residencyAlignedMipSize_                  = {},
      VULKAN_HPP_NAMESPACE::Bool32 residencyNonResidentStrict_               = {} ) VULKAN_HPP_NOEXCEPT
      : residencyStandard2DBlockShape( residencyStandard2DBlockShape_ )
      , residencyStandard2DMultisampleBlockShape( residencyStandard2DMultisampleBlockShape_ )
      , residencyStandard3DBlockShape( residencyStandard3DBlockShape_ )
      , residencyAlignedMipSize( residencyAlignedMipSize_ )
      , residencyNonResidentStrict( residencyNonResidentStrict_ )
    {}

    VULKAN_HPP_CONSTEXPR
      PhysicalDeviceSparseProperties( PhysicalDeviceSparseProperties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceSparseProperties( VkPhysicalDeviceSparseProperties const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceSparseProperties( *reinterpret_cast<PhysicalDeviceSparseProperties const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceSparseProperties &
                            operator=( PhysicalDeviceSparseProperties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceSparseProperties & operator=( VkPhysicalDeviceSparseProperties const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceSparseProperties const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceSparseProperties const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceSparseProperties *>( this );
    }

    operator VkPhysicalDeviceSparseProperties &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceSparseProperties *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceSparseProperties const & ) const = default;
#else
    bool operator==( PhysicalDeviceSparseProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( residencyStandard2DBlockShape == rhs.residencyStandard2DBlockShape ) &&
             ( residencyStandard2DMultisampleBlockShape == rhs.residencyStandard2DMultisampleBlockShape ) &&
             ( residencyStandard3DBlockShape == rhs.residencyStandard3DBlockShape ) &&
             ( residencyAlignedMipSize == rhs.residencyAlignedMipSize ) &&
             ( residencyNonResidentStrict == rhs.residencyNonResidentStrict );
    }

    bool operator!=( PhysicalDeviceSparseProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::Bool32 residencyStandard2DBlockShape            = {};
    VULKAN_HPP_NAMESPACE::Bool32 residencyStandard2DMultisampleBlockShape = {};
    VULKAN_HPP_NAMESPACE::Bool32 residencyStandard3DBlockShape            = {};
    VULKAN_HPP_NAMESPACE::Bool32 residencyAlignedMipSize                  = {};
    VULKAN_HPP_NAMESPACE::Bool32 residencyNonResidentStrict               = {};
  };
  static_assert( sizeof( PhysicalDeviceSparseProperties ) == sizeof( VkPhysicalDeviceSparseProperties ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceSparseProperties>::value,
                 "struct wrapper is not a standard layout!" );

  struct PhysicalDeviceProperties
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceProperties(
      uint32_t                                 apiVersion_    = {},
      uint32_t                                 driverVersion_ = {},
      uint32_t                                 vendorID_      = {},
      uint32_t                                 deviceID_      = {},
      VULKAN_HPP_NAMESPACE::PhysicalDeviceType deviceType_    = VULKAN_HPP_NAMESPACE::PhysicalDeviceType::eOther,
      std::array<char, VK_MAX_PHYSICAL_DEVICE_NAME_SIZE> const & deviceName_        = {},
      std::array<uint8_t, VK_UUID_SIZE> const &                  pipelineCacheUUID_ = {},
      VULKAN_HPP_NAMESPACE::PhysicalDeviceLimits                 limits_            = {},
      VULKAN_HPP_NAMESPACE::PhysicalDeviceSparseProperties       sparseProperties_  = {} ) VULKAN_HPP_NOEXCEPT
      : apiVersion( apiVersion_ )
      , driverVersion( driverVersion_ )
      , vendorID( vendorID_ )
      , deviceID( deviceID_ )
      , deviceType( deviceType_ )
      , deviceName( deviceName_ )
      , pipelineCacheUUID( pipelineCacheUUID_ )
      , limits( limits_ )
      , sparseProperties( sparseProperties_ )
    {}

    VULKAN_HPP_CONSTEXPR_14
      PhysicalDeviceProperties( PhysicalDeviceProperties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceProperties( VkPhysicalDeviceProperties const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceProperties( *reinterpret_cast<PhysicalDeviceProperties const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceProperties &
                            operator=( PhysicalDeviceProperties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceProperties & operator=( VkPhysicalDeviceProperties const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceProperties const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceProperties const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceProperties *>( this );
    }

    operator VkPhysicalDeviceProperties &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceProperties *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceProperties const & ) const = default;
#else
    bool operator==( PhysicalDeviceProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( apiVersion == rhs.apiVersion ) && ( driverVersion == rhs.driverVersion ) &&
             ( vendorID == rhs.vendorID ) && ( deviceID == rhs.deviceID ) && ( deviceType == rhs.deviceType ) &&
             ( deviceName == rhs.deviceName ) && ( pipelineCacheUUID == rhs.pipelineCacheUUID ) &&
             ( limits == rhs.limits ) && ( sparseProperties == rhs.sparseProperties );
    }

    bool operator!=( PhysicalDeviceProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    uint32_t                                 apiVersion    = {};
    uint32_t                                 driverVersion = {};
    uint32_t                                 vendorID      = {};
    uint32_t                                 deviceID      = {};
    VULKAN_HPP_NAMESPACE::PhysicalDeviceType deviceType    = VULKAN_HPP_NAMESPACE::PhysicalDeviceType::eOther;
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<char, VK_MAX_PHYSICAL_DEVICE_NAME_SIZE> deviceName        = {};
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<uint8_t, VK_UUID_SIZE>                  pipelineCacheUUID = {};
    VULKAN_HPP_NAMESPACE::PhysicalDeviceLimits                                   limits            = {};
    VULKAN_HPP_NAMESPACE::PhysicalDeviceSparseProperties                         sparseProperties  = {};
  };
  static_assert( sizeof( PhysicalDeviceProperties ) == sizeof( VkPhysicalDeviceProperties ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceProperties>::value, "struct wrapper is not a standard layout!" );

  struct PhysicalDeviceProperties2
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::ePhysicalDeviceProperties2;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR_14
      PhysicalDeviceProperties2( VULKAN_HPP_NAMESPACE::PhysicalDeviceProperties properties_ = {} ) VULKAN_HPP_NOEXCEPT
      : properties( properties_ )
    {}

    VULKAN_HPP_CONSTEXPR_14
      PhysicalDeviceProperties2( PhysicalDeviceProperties2 const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceProperties2( VkPhysicalDeviceProperties2 const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceProperties2( *reinterpret_cast<PhysicalDeviceProperties2 const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceProperties2 &
                            operator=( PhysicalDeviceProperties2 const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceProperties2 & operator=( VkPhysicalDeviceProperties2 const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceProperties2 const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceProperties2 const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceProperties2 *>( this );
    }

    operator VkPhysicalDeviceProperties2 &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceProperties2 *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceProperties2 const & ) const = default;
#else
    bool operator==( PhysicalDeviceProperties2 const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( properties == rhs.properties );
    }

    bool operator!=( PhysicalDeviceProperties2 const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType            sType      = StructureType::ePhysicalDeviceProperties2;
    void *                                         pNext      = {};
    VULKAN_HPP_NAMESPACE::PhysicalDeviceProperties properties = {};
  };
  static_assert( sizeof( PhysicalDeviceProperties2 ) == sizeof( VkPhysicalDeviceProperties2 ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceProperties2>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceProperties2>
  {
    using Type = PhysicalDeviceProperties2;
  };
  using PhysicalDeviceProperties2KHR = PhysicalDeviceProperties2;

  struct PhysicalDeviceProtectedMemoryFeatures
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceProtectedMemoryFeatures;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      PhysicalDeviceProtectedMemoryFeatures( VULKAN_HPP_NAMESPACE::Bool32 protectedMemory_ = {} ) VULKAN_HPP_NOEXCEPT
      : protectedMemory( protectedMemory_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceProtectedMemoryFeatures( PhysicalDeviceProtectedMemoryFeatures const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceProtectedMemoryFeatures( VkPhysicalDeviceProtectedMemoryFeatures const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceProtectedMemoryFeatures(
          *reinterpret_cast<PhysicalDeviceProtectedMemoryFeatures const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceProtectedMemoryFeatures &
                            operator=( PhysicalDeviceProtectedMemoryFeatures const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceProtectedMemoryFeatures &
      operator=( VkPhysicalDeviceProtectedMemoryFeatures const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceProtectedMemoryFeatures const *>( &rhs );
      return *this;
    }

    PhysicalDeviceProtectedMemoryFeatures & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceProtectedMemoryFeatures &
      setProtectedMemory( VULKAN_HPP_NAMESPACE::Bool32 protectedMemory_ ) VULKAN_HPP_NOEXCEPT
    {
      protectedMemory = protectedMemory_;
      return *this;
    }

    operator VkPhysicalDeviceProtectedMemoryFeatures const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceProtectedMemoryFeatures *>( this );
    }

    operator VkPhysicalDeviceProtectedMemoryFeatures &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceProtectedMemoryFeatures *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceProtectedMemoryFeatures const & ) const = default;
#else
    bool operator==( PhysicalDeviceProtectedMemoryFeatures const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( protectedMemory == rhs.protectedMemory );
    }

    bool operator!=( PhysicalDeviceProtectedMemoryFeatures const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType           = StructureType::ePhysicalDeviceProtectedMemoryFeatures;
    void *                              pNext           = {};
    VULKAN_HPP_NAMESPACE::Bool32        protectedMemory = {};
  };
  static_assert( sizeof( PhysicalDeviceProtectedMemoryFeatures ) == sizeof( VkPhysicalDeviceProtectedMemoryFeatures ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceProtectedMemoryFeatures>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceProtectedMemoryFeatures>
  {
    using Type = PhysicalDeviceProtectedMemoryFeatures;
  };

  struct PhysicalDeviceProtectedMemoryProperties
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceProtectedMemoryProperties;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      PhysicalDeviceProtectedMemoryProperties( VULKAN_HPP_NAMESPACE::Bool32 protectedNoFault_ = {} ) VULKAN_HPP_NOEXCEPT
      : protectedNoFault( protectedNoFault_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceProtectedMemoryProperties( PhysicalDeviceProtectedMemoryProperties const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceProtectedMemoryProperties( VkPhysicalDeviceProtectedMemoryProperties const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceProtectedMemoryProperties(
          *reinterpret_cast<PhysicalDeviceProtectedMemoryProperties const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceProtectedMemoryProperties &
                            operator=( PhysicalDeviceProtectedMemoryProperties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceProtectedMemoryProperties &
      operator=( VkPhysicalDeviceProtectedMemoryProperties const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceProtectedMemoryProperties const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceProtectedMemoryProperties const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceProtectedMemoryProperties *>( this );
    }

    operator VkPhysicalDeviceProtectedMemoryProperties &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceProtectedMemoryProperties *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceProtectedMemoryProperties const & ) const = default;
#else
    bool operator==( PhysicalDeviceProtectedMemoryProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( protectedNoFault == rhs.protectedNoFault );
    }

    bool operator!=( PhysicalDeviceProtectedMemoryProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType            = StructureType::ePhysicalDeviceProtectedMemoryProperties;
    void *                              pNext            = {};
    VULKAN_HPP_NAMESPACE::Bool32        protectedNoFault = {};
  };
  static_assert( sizeof( PhysicalDeviceProtectedMemoryProperties ) ==
                   sizeof( VkPhysicalDeviceProtectedMemoryProperties ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceProtectedMemoryProperties>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceProtectedMemoryProperties>
  {
    using Type = PhysicalDeviceProtectedMemoryProperties;
  };

  struct PhysicalDeviceProvokingVertexFeaturesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceProvokingVertexFeaturesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceProvokingVertexFeaturesEXT(
      VULKAN_HPP_NAMESPACE::Bool32 provokingVertexLast_                       = {},
      VULKAN_HPP_NAMESPACE::Bool32 transformFeedbackPreservesProvokingVertex_ = {} ) VULKAN_HPP_NOEXCEPT
      : provokingVertexLast( provokingVertexLast_ )
      , transformFeedbackPreservesProvokingVertex( transformFeedbackPreservesProvokingVertex_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceProvokingVertexFeaturesEXT(
      PhysicalDeviceProvokingVertexFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceProvokingVertexFeaturesEXT( VkPhysicalDeviceProvokingVertexFeaturesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceProvokingVertexFeaturesEXT(
          *reinterpret_cast<PhysicalDeviceProvokingVertexFeaturesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceProvokingVertexFeaturesEXT &
                            operator=( PhysicalDeviceProvokingVertexFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceProvokingVertexFeaturesEXT &
      operator=( VkPhysicalDeviceProvokingVertexFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceProvokingVertexFeaturesEXT const *>( &rhs );
      return *this;
    }

    PhysicalDeviceProvokingVertexFeaturesEXT & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceProvokingVertexFeaturesEXT &
      setProvokingVertexLast( VULKAN_HPP_NAMESPACE::Bool32 provokingVertexLast_ ) VULKAN_HPP_NOEXCEPT
    {
      provokingVertexLast = provokingVertexLast_;
      return *this;
    }

    PhysicalDeviceProvokingVertexFeaturesEXT & setTransformFeedbackPreservesProvokingVertex(
      VULKAN_HPP_NAMESPACE::Bool32 transformFeedbackPreservesProvokingVertex_ ) VULKAN_HPP_NOEXCEPT
    {
      transformFeedbackPreservesProvokingVertex = transformFeedbackPreservesProvokingVertex_;
      return *this;
    }

    operator VkPhysicalDeviceProvokingVertexFeaturesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceProvokingVertexFeaturesEXT *>( this );
    }

    operator VkPhysicalDeviceProvokingVertexFeaturesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceProvokingVertexFeaturesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceProvokingVertexFeaturesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceProvokingVertexFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( provokingVertexLast == rhs.provokingVertexLast ) &&
             ( transformFeedbackPreservesProvokingVertex == rhs.transformFeedbackPreservesProvokingVertex );
    }

    bool operator!=( PhysicalDeviceProvokingVertexFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType               = StructureType::ePhysicalDeviceProvokingVertexFeaturesEXT;
    void *                              pNext               = {};
    VULKAN_HPP_NAMESPACE::Bool32        provokingVertexLast = {};
    VULKAN_HPP_NAMESPACE::Bool32        transformFeedbackPreservesProvokingVertex = {};
  };
  static_assert( sizeof( PhysicalDeviceProvokingVertexFeaturesEXT ) ==
                   sizeof( VkPhysicalDeviceProvokingVertexFeaturesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceProvokingVertexFeaturesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceProvokingVertexFeaturesEXT>
  {
    using Type = PhysicalDeviceProvokingVertexFeaturesEXT;
  };

  struct PhysicalDeviceProvokingVertexPropertiesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceProvokingVertexPropertiesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceProvokingVertexPropertiesEXT(
      VULKAN_HPP_NAMESPACE::Bool32 provokingVertexModePerPipeline_                       = {},
      VULKAN_HPP_NAMESPACE::Bool32 transformFeedbackPreservesTriangleFanProvokingVertex_ = {} ) VULKAN_HPP_NOEXCEPT
      : provokingVertexModePerPipeline( provokingVertexModePerPipeline_ )
      , transformFeedbackPreservesTriangleFanProvokingVertex( transformFeedbackPreservesTriangleFanProvokingVertex_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceProvokingVertexPropertiesEXT(
      PhysicalDeviceProvokingVertexPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceProvokingVertexPropertiesEXT( VkPhysicalDeviceProvokingVertexPropertiesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceProvokingVertexPropertiesEXT(
          *reinterpret_cast<PhysicalDeviceProvokingVertexPropertiesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceProvokingVertexPropertiesEXT &
                            operator=( PhysicalDeviceProvokingVertexPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceProvokingVertexPropertiesEXT &
      operator=( VkPhysicalDeviceProvokingVertexPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceProvokingVertexPropertiesEXT const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceProvokingVertexPropertiesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceProvokingVertexPropertiesEXT *>( this );
    }

    operator VkPhysicalDeviceProvokingVertexPropertiesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceProvokingVertexPropertiesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceProvokingVertexPropertiesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceProvokingVertexPropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( provokingVertexModePerPipeline == rhs.provokingVertexModePerPipeline ) &&
             ( transformFeedbackPreservesTriangleFanProvokingVertex ==
               rhs.transformFeedbackPreservesTriangleFanProvokingVertex );
    }

    bool operator!=( PhysicalDeviceProvokingVertexPropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceProvokingVertexPropertiesEXT;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        provokingVertexModePerPipeline                       = {};
    VULKAN_HPP_NAMESPACE::Bool32        transformFeedbackPreservesTriangleFanProvokingVertex = {};
  };
  static_assert( sizeof( PhysicalDeviceProvokingVertexPropertiesEXT ) ==
                   sizeof( VkPhysicalDeviceProvokingVertexPropertiesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceProvokingVertexPropertiesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceProvokingVertexPropertiesEXT>
  {
    using Type = PhysicalDeviceProvokingVertexPropertiesEXT;
  };

  struct PhysicalDevicePushDescriptorPropertiesKHR
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDevicePushDescriptorPropertiesKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      PhysicalDevicePushDescriptorPropertiesKHR( uint32_t maxPushDescriptors_ = {} ) VULKAN_HPP_NOEXCEPT
      : maxPushDescriptors( maxPushDescriptors_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDevicePushDescriptorPropertiesKHR(
      PhysicalDevicePushDescriptorPropertiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDevicePushDescriptorPropertiesKHR( VkPhysicalDevicePushDescriptorPropertiesKHR const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDevicePushDescriptorPropertiesKHR(
          *reinterpret_cast<PhysicalDevicePushDescriptorPropertiesKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDevicePushDescriptorPropertiesKHR &
                            operator=( PhysicalDevicePushDescriptorPropertiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDevicePushDescriptorPropertiesKHR &
      operator=( VkPhysicalDevicePushDescriptorPropertiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDevicePushDescriptorPropertiesKHR const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDevicePushDescriptorPropertiesKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDevicePushDescriptorPropertiesKHR *>( this );
    }

    operator VkPhysicalDevicePushDescriptorPropertiesKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDevicePushDescriptorPropertiesKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDevicePushDescriptorPropertiesKHR const & ) const = default;
#else
    bool operator==( PhysicalDevicePushDescriptorPropertiesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( maxPushDescriptors == rhs.maxPushDescriptors );
    }

    bool operator!=( PhysicalDevicePushDescriptorPropertiesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType              = StructureType::ePhysicalDevicePushDescriptorPropertiesKHR;
    void *                              pNext              = {};
    uint32_t                            maxPushDescriptors = {};
  };
  static_assert( sizeof( PhysicalDevicePushDescriptorPropertiesKHR ) ==
                   sizeof( VkPhysicalDevicePushDescriptorPropertiesKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDevicePushDescriptorPropertiesKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDevicePushDescriptorPropertiesKHR>
  {
    using Type = PhysicalDevicePushDescriptorPropertiesKHR;
  };

  struct PhysicalDeviceRayQueryFeaturesKHR
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceRayQueryFeaturesKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      PhysicalDeviceRayQueryFeaturesKHR( VULKAN_HPP_NAMESPACE::Bool32 rayQuery_ = {} ) VULKAN_HPP_NOEXCEPT
      : rayQuery( rayQuery_ )
    {}

    VULKAN_HPP_CONSTEXPR
      PhysicalDeviceRayQueryFeaturesKHR( PhysicalDeviceRayQueryFeaturesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceRayQueryFeaturesKHR( VkPhysicalDeviceRayQueryFeaturesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceRayQueryFeaturesKHR( *reinterpret_cast<PhysicalDeviceRayQueryFeaturesKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceRayQueryFeaturesKHR &
                            operator=( PhysicalDeviceRayQueryFeaturesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceRayQueryFeaturesKHR & operator=( VkPhysicalDeviceRayQueryFeaturesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceRayQueryFeaturesKHR const *>( &rhs );
      return *this;
    }

    PhysicalDeviceRayQueryFeaturesKHR & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceRayQueryFeaturesKHR & setRayQuery( VULKAN_HPP_NAMESPACE::Bool32 rayQuery_ ) VULKAN_HPP_NOEXCEPT
    {
      rayQuery = rayQuery_;
      return *this;
    }

    operator VkPhysicalDeviceRayQueryFeaturesKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceRayQueryFeaturesKHR *>( this );
    }

    operator VkPhysicalDeviceRayQueryFeaturesKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceRayQueryFeaturesKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceRayQueryFeaturesKHR const & ) const = default;
#else
    bool operator==( PhysicalDeviceRayQueryFeaturesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( rayQuery == rhs.rayQuery );
    }

    bool operator!=( PhysicalDeviceRayQueryFeaturesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType    = StructureType::ePhysicalDeviceRayQueryFeaturesKHR;
    void *                              pNext    = {};
    VULKAN_HPP_NAMESPACE::Bool32        rayQuery = {};
  };
  static_assert( sizeof( PhysicalDeviceRayQueryFeaturesKHR ) == sizeof( VkPhysicalDeviceRayQueryFeaturesKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceRayQueryFeaturesKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceRayQueryFeaturesKHR>
  {
    using Type = PhysicalDeviceRayQueryFeaturesKHR;
  };

  struct PhysicalDeviceRayTracingMotionBlurFeaturesNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceRayTracingMotionBlurFeaturesNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceRayTracingMotionBlurFeaturesNV(
      VULKAN_HPP_NAMESPACE::Bool32 rayTracingMotionBlur_                          = {},
      VULKAN_HPP_NAMESPACE::Bool32 rayTracingMotionBlurPipelineTraceRaysIndirect_ = {} ) VULKAN_HPP_NOEXCEPT
      : rayTracingMotionBlur( rayTracingMotionBlur_ )
      , rayTracingMotionBlurPipelineTraceRaysIndirect( rayTracingMotionBlurPipelineTraceRaysIndirect_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceRayTracingMotionBlurFeaturesNV(
      PhysicalDeviceRayTracingMotionBlurFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceRayTracingMotionBlurFeaturesNV( VkPhysicalDeviceRayTracingMotionBlurFeaturesNV const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceRayTracingMotionBlurFeaturesNV(
          *reinterpret_cast<PhysicalDeviceRayTracingMotionBlurFeaturesNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceRayTracingMotionBlurFeaturesNV &
                            operator=( PhysicalDeviceRayTracingMotionBlurFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceRayTracingMotionBlurFeaturesNV &
      operator=( VkPhysicalDeviceRayTracingMotionBlurFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceRayTracingMotionBlurFeaturesNV const *>( &rhs );
      return *this;
    }

    PhysicalDeviceRayTracingMotionBlurFeaturesNV & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceRayTracingMotionBlurFeaturesNV &
      setRayTracingMotionBlur( VULKAN_HPP_NAMESPACE::Bool32 rayTracingMotionBlur_ ) VULKAN_HPP_NOEXCEPT
    {
      rayTracingMotionBlur = rayTracingMotionBlur_;
      return *this;
    }

    PhysicalDeviceRayTracingMotionBlurFeaturesNV & setRayTracingMotionBlurPipelineTraceRaysIndirect(
      VULKAN_HPP_NAMESPACE::Bool32 rayTracingMotionBlurPipelineTraceRaysIndirect_ ) VULKAN_HPP_NOEXCEPT
    {
      rayTracingMotionBlurPipelineTraceRaysIndirect = rayTracingMotionBlurPipelineTraceRaysIndirect_;
      return *this;
    }

    operator VkPhysicalDeviceRayTracingMotionBlurFeaturesNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceRayTracingMotionBlurFeaturesNV *>( this );
    }

    operator VkPhysicalDeviceRayTracingMotionBlurFeaturesNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceRayTracingMotionBlurFeaturesNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceRayTracingMotionBlurFeaturesNV const & ) const = default;
#else
    bool operator==( PhysicalDeviceRayTracingMotionBlurFeaturesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( rayTracingMotionBlur == rhs.rayTracingMotionBlur ) &&
             ( rayTracingMotionBlurPipelineTraceRaysIndirect == rhs.rayTracingMotionBlurPipelineTraceRaysIndirect );
    }

    bool operator!=( PhysicalDeviceRayTracingMotionBlurFeaturesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceRayTracingMotionBlurFeaturesNV;
    const void *                        pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        rayTracingMotionBlur                          = {};
    VULKAN_HPP_NAMESPACE::Bool32        rayTracingMotionBlurPipelineTraceRaysIndirect = {};
  };
  static_assert( sizeof( PhysicalDeviceRayTracingMotionBlurFeaturesNV ) ==
                   sizeof( VkPhysicalDeviceRayTracingMotionBlurFeaturesNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceRayTracingMotionBlurFeaturesNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceRayTracingMotionBlurFeaturesNV>
  {
    using Type = PhysicalDeviceRayTracingMotionBlurFeaturesNV;
  };

  struct PhysicalDeviceRayTracingPipelineFeaturesKHR
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceRayTracingPipelineFeaturesKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceRayTracingPipelineFeaturesKHR(
      VULKAN_HPP_NAMESPACE::Bool32 rayTracingPipeline_                                    = {},
      VULKAN_HPP_NAMESPACE::Bool32 rayTracingPipelineShaderGroupHandleCaptureReplay_      = {},
      VULKAN_HPP_NAMESPACE::Bool32 rayTracingPipelineShaderGroupHandleCaptureReplayMixed_ = {},
      VULKAN_HPP_NAMESPACE::Bool32 rayTracingPipelineTraceRaysIndirect_                   = {},
      VULKAN_HPP_NAMESPACE::Bool32 rayTraversalPrimitiveCulling_                          = {} ) VULKAN_HPP_NOEXCEPT
      : rayTracingPipeline( rayTracingPipeline_ )
      , rayTracingPipelineShaderGroupHandleCaptureReplay( rayTracingPipelineShaderGroupHandleCaptureReplay_ )
      , rayTracingPipelineShaderGroupHandleCaptureReplayMixed( rayTracingPipelineShaderGroupHandleCaptureReplayMixed_ )
      , rayTracingPipelineTraceRaysIndirect( rayTracingPipelineTraceRaysIndirect_ )
      , rayTraversalPrimitiveCulling( rayTraversalPrimitiveCulling_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceRayTracingPipelineFeaturesKHR(
      PhysicalDeviceRayTracingPipelineFeaturesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceRayTracingPipelineFeaturesKHR( VkPhysicalDeviceRayTracingPipelineFeaturesKHR const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceRayTracingPipelineFeaturesKHR(
          *reinterpret_cast<PhysicalDeviceRayTracingPipelineFeaturesKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceRayTracingPipelineFeaturesKHR &
                            operator=( PhysicalDeviceRayTracingPipelineFeaturesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceRayTracingPipelineFeaturesKHR &
      operator=( VkPhysicalDeviceRayTracingPipelineFeaturesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceRayTracingPipelineFeaturesKHR const *>( &rhs );
      return *this;
    }

    PhysicalDeviceRayTracingPipelineFeaturesKHR & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceRayTracingPipelineFeaturesKHR &
      setRayTracingPipeline( VULKAN_HPP_NAMESPACE::Bool32 rayTracingPipeline_ ) VULKAN_HPP_NOEXCEPT
    {
      rayTracingPipeline = rayTracingPipeline_;
      return *this;
    }

    PhysicalDeviceRayTracingPipelineFeaturesKHR & setRayTracingPipelineShaderGroupHandleCaptureReplay(
      VULKAN_HPP_NAMESPACE::Bool32 rayTracingPipelineShaderGroupHandleCaptureReplay_ ) VULKAN_HPP_NOEXCEPT
    {
      rayTracingPipelineShaderGroupHandleCaptureReplay = rayTracingPipelineShaderGroupHandleCaptureReplay_;
      return *this;
    }

    PhysicalDeviceRayTracingPipelineFeaturesKHR & setRayTracingPipelineShaderGroupHandleCaptureReplayMixed(
      VULKAN_HPP_NAMESPACE::Bool32 rayTracingPipelineShaderGroupHandleCaptureReplayMixed_ ) VULKAN_HPP_NOEXCEPT
    {
      rayTracingPipelineShaderGroupHandleCaptureReplayMixed = rayTracingPipelineShaderGroupHandleCaptureReplayMixed_;
      return *this;
    }

    PhysicalDeviceRayTracingPipelineFeaturesKHR & setRayTracingPipelineTraceRaysIndirect(
      VULKAN_HPP_NAMESPACE::Bool32 rayTracingPipelineTraceRaysIndirect_ ) VULKAN_HPP_NOEXCEPT
    {
      rayTracingPipelineTraceRaysIndirect = rayTracingPipelineTraceRaysIndirect_;
      return *this;
    }

    PhysicalDeviceRayTracingPipelineFeaturesKHR &
      setRayTraversalPrimitiveCulling( VULKAN_HPP_NAMESPACE::Bool32 rayTraversalPrimitiveCulling_ ) VULKAN_HPP_NOEXCEPT
    {
      rayTraversalPrimitiveCulling = rayTraversalPrimitiveCulling_;
      return *this;
    }

    operator VkPhysicalDeviceRayTracingPipelineFeaturesKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceRayTracingPipelineFeaturesKHR *>( this );
    }

    operator VkPhysicalDeviceRayTracingPipelineFeaturesKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceRayTracingPipelineFeaturesKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceRayTracingPipelineFeaturesKHR const & ) const = default;
#else
    bool operator==( PhysicalDeviceRayTracingPipelineFeaturesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( rayTracingPipeline == rhs.rayTracingPipeline ) &&
             ( rayTracingPipelineShaderGroupHandleCaptureReplay ==
               rhs.rayTracingPipelineShaderGroupHandleCaptureReplay ) &&
             ( rayTracingPipelineShaderGroupHandleCaptureReplayMixed ==
               rhs.rayTracingPipelineShaderGroupHandleCaptureReplayMixed ) &&
             ( rayTracingPipelineTraceRaysIndirect == rhs.rayTracingPipelineTraceRaysIndirect ) &&
             ( rayTraversalPrimitiveCulling == rhs.rayTraversalPrimitiveCulling );
    }

    bool operator!=( PhysicalDeviceRayTracingPipelineFeaturesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceRayTracingPipelineFeaturesKHR;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        rayTracingPipeline                                    = {};
    VULKAN_HPP_NAMESPACE::Bool32        rayTracingPipelineShaderGroupHandleCaptureReplay      = {};
    VULKAN_HPP_NAMESPACE::Bool32        rayTracingPipelineShaderGroupHandleCaptureReplayMixed = {};
    VULKAN_HPP_NAMESPACE::Bool32        rayTracingPipelineTraceRaysIndirect                   = {};
    VULKAN_HPP_NAMESPACE::Bool32        rayTraversalPrimitiveCulling                          = {};
  };
  static_assert( sizeof( PhysicalDeviceRayTracingPipelineFeaturesKHR ) ==
                   sizeof( VkPhysicalDeviceRayTracingPipelineFeaturesKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceRayTracingPipelineFeaturesKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceRayTracingPipelineFeaturesKHR>
  {
    using Type = PhysicalDeviceRayTracingPipelineFeaturesKHR;
  };

  struct PhysicalDeviceRayTracingPipelinePropertiesKHR
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceRayTracingPipelinePropertiesKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      PhysicalDeviceRayTracingPipelinePropertiesKHR( uint32_t shaderGroupHandleSize_              = {},
                                                     uint32_t maxRayRecursionDepth_               = {},
                                                     uint32_t maxShaderGroupStride_               = {},
                                                     uint32_t shaderGroupBaseAlignment_           = {},
                                                     uint32_t shaderGroupHandleCaptureReplaySize_ = {},
                                                     uint32_t maxRayDispatchInvocationCount_      = {},
                                                     uint32_t shaderGroupHandleAlignment_         = {},
                                                     uint32_t maxRayHitAttributeSize_ = {} ) VULKAN_HPP_NOEXCEPT
      : shaderGroupHandleSize( shaderGroupHandleSize_ )
      , maxRayRecursionDepth( maxRayRecursionDepth_ )
      , maxShaderGroupStride( maxShaderGroupStride_ )
      , shaderGroupBaseAlignment( shaderGroupBaseAlignment_ )
      , shaderGroupHandleCaptureReplaySize( shaderGroupHandleCaptureReplaySize_ )
      , maxRayDispatchInvocationCount( maxRayDispatchInvocationCount_ )
      , shaderGroupHandleAlignment( shaderGroupHandleAlignment_ )
      , maxRayHitAttributeSize( maxRayHitAttributeSize_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceRayTracingPipelinePropertiesKHR(
      PhysicalDeviceRayTracingPipelinePropertiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceRayTracingPipelinePropertiesKHR( VkPhysicalDeviceRayTracingPipelinePropertiesKHR const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceRayTracingPipelinePropertiesKHR(
          *reinterpret_cast<PhysicalDeviceRayTracingPipelinePropertiesKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceRayTracingPipelinePropertiesKHR &
                            operator=( PhysicalDeviceRayTracingPipelinePropertiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceRayTracingPipelinePropertiesKHR &
      operator=( VkPhysicalDeviceRayTracingPipelinePropertiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceRayTracingPipelinePropertiesKHR const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceRayTracingPipelinePropertiesKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceRayTracingPipelinePropertiesKHR *>( this );
    }

    operator VkPhysicalDeviceRayTracingPipelinePropertiesKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceRayTracingPipelinePropertiesKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceRayTracingPipelinePropertiesKHR const & ) const = default;
#else
    bool operator==( PhysicalDeviceRayTracingPipelinePropertiesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( shaderGroupHandleSize == rhs.shaderGroupHandleSize ) &&
             ( maxRayRecursionDepth == rhs.maxRayRecursionDepth ) &&
             ( maxShaderGroupStride == rhs.maxShaderGroupStride ) &&
             ( shaderGroupBaseAlignment == rhs.shaderGroupBaseAlignment ) &&
             ( shaderGroupHandleCaptureReplaySize == rhs.shaderGroupHandleCaptureReplaySize ) &&
             ( maxRayDispatchInvocationCount == rhs.maxRayDispatchInvocationCount ) &&
             ( shaderGroupHandleAlignment == rhs.shaderGroupHandleAlignment ) &&
             ( maxRayHitAttributeSize == rhs.maxRayHitAttributeSize );
    }

    bool operator!=( PhysicalDeviceRayTracingPipelinePropertiesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceRayTracingPipelinePropertiesKHR;
    void *                              pNext = {};
    uint32_t                            shaderGroupHandleSize              = {};
    uint32_t                            maxRayRecursionDepth               = {};
    uint32_t                            maxShaderGroupStride               = {};
    uint32_t                            shaderGroupBaseAlignment           = {};
    uint32_t                            shaderGroupHandleCaptureReplaySize = {};
    uint32_t                            maxRayDispatchInvocationCount      = {};
    uint32_t                            shaderGroupHandleAlignment         = {};
    uint32_t                            maxRayHitAttributeSize             = {};
  };
  static_assert( sizeof( PhysicalDeviceRayTracingPipelinePropertiesKHR ) ==
                   sizeof( VkPhysicalDeviceRayTracingPipelinePropertiesKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceRayTracingPipelinePropertiesKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceRayTracingPipelinePropertiesKHR>
  {
    using Type = PhysicalDeviceRayTracingPipelinePropertiesKHR;
  };

  struct PhysicalDeviceRayTracingPropertiesNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceRayTracingPropertiesNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      PhysicalDeviceRayTracingPropertiesNV( uint32_t shaderGroupHandleSize_                  = {},
                                            uint32_t maxRecursionDepth_                      = {},
                                            uint32_t maxShaderGroupStride_                   = {},
                                            uint32_t shaderGroupBaseAlignment_               = {},
                                            uint64_t maxGeometryCount_                       = {},
                                            uint64_t maxInstanceCount_                       = {},
                                            uint64_t maxTriangleCount_                       = {},
                                            uint32_t maxDescriptorSetAccelerationStructures_ = {} ) VULKAN_HPP_NOEXCEPT
      : shaderGroupHandleSize( shaderGroupHandleSize_ )
      , maxRecursionDepth( maxRecursionDepth_ )
      , maxShaderGroupStride( maxShaderGroupStride_ )
      , shaderGroupBaseAlignment( shaderGroupBaseAlignment_ )
      , maxGeometryCount( maxGeometryCount_ )
      , maxInstanceCount( maxInstanceCount_ )
      , maxTriangleCount( maxTriangleCount_ )
      , maxDescriptorSetAccelerationStructures( maxDescriptorSetAccelerationStructures_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceRayTracingPropertiesNV( PhysicalDeviceRayTracingPropertiesNV const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceRayTracingPropertiesNV( VkPhysicalDeviceRayTracingPropertiesNV const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceRayTracingPropertiesNV( *reinterpret_cast<PhysicalDeviceRayTracingPropertiesNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceRayTracingPropertiesNV &
                            operator=( PhysicalDeviceRayTracingPropertiesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceRayTracingPropertiesNV &
      operator=( VkPhysicalDeviceRayTracingPropertiesNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceRayTracingPropertiesNV const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceRayTracingPropertiesNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceRayTracingPropertiesNV *>( this );
    }

    operator VkPhysicalDeviceRayTracingPropertiesNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceRayTracingPropertiesNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceRayTracingPropertiesNV const & ) const = default;
#else
    bool operator==( PhysicalDeviceRayTracingPropertiesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( shaderGroupHandleSize == rhs.shaderGroupHandleSize ) && ( maxRecursionDepth == rhs.maxRecursionDepth ) &&
             ( maxShaderGroupStride == rhs.maxShaderGroupStride ) &&
             ( shaderGroupBaseAlignment == rhs.shaderGroupBaseAlignment ) &&
             ( maxGeometryCount == rhs.maxGeometryCount ) && ( maxInstanceCount == rhs.maxInstanceCount ) &&
             ( maxTriangleCount == rhs.maxTriangleCount ) &&
             ( maxDescriptorSetAccelerationStructures == rhs.maxDescriptorSetAccelerationStructures );
    }

    bool operator!=( PhysicalDeviceRayTracingPropertiesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType                    = StructureType::ePhysicalDeviceRayTracingPropertiesNV;
    void *                              pNext                    = {};
    uint32_t                            shaderGroupHandleSize    = {};
    uint32_t                            maxRecursionDepth        = {};
    uint32_t                            maxShaderGroupStride     = {};
    uint32_t                            shaderGroupBaseAlignment = {};
    uint64_t                            maxGeometryCount         = {};
    uint64_t                            maxInstanceCount         = {};
    uint64_t                            maxTriangleCount         = {};
    uint32_t                            maxDescriptorSetAccelerationStructures = {};
  };
  static_assert( sizeof( PhysicalDeviceRayTracingPropertiesNV ) == sizeof( VkPhysicalDeviceRayTracingPropertiesNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceRayTracingPropertiesNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceRayTracingPropertiesNV>
  {
    using Type = PhysicalDeviceRayTracingPropertiesNV;
  };

  struct PhysicalDeviceRepresentativeFragmentTestFeaturesNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceRepresentativeFragmentTestFeaturesNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceRepresentativeFragmentTestFeaturesNV(
      VULKAN_HPP_NAMESPACE::Bool32 representativeFragmentTest_ = {} ) VULKAN_HPP_NOEXCEPT
      : representativeFragmentTest( representativeFragmentTest_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceRepresentativeFragmentTestFeaturesNV(
      PhysicalDeviceRepresentativeFragmentTestFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceRepresentativeFragmentTestFeaturesNV(
      VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceRepresentativeFragmentTestFeaturesNV(
          *reinterpret_cast<PhysicalDeviceRepresentativeFragmentTestFeaturesNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceRepresentativeFragmentTestFeaturesNV &
                            operator=( PhysicalDeviceRepresentativeFragmentTestFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceRepresentativeFragmentTestFeaturesNV &
      operator=( VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this =
        *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceRepresentativeFragmentTestFeaturesNV const *>( &rhs );
      return *this;
    }

    PhysicalDeviceRepresentativeFragmentTestFeaturesNV & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceRepresentativeFragmentTestFeaturesNV &
      setRepresentativeFragmentTest( VULKAN_HPP_NAMESPACE::Bool32 representativeFragmentTest_ ) VULKAN_HPP_NOEXCEPT
    {
      representativeFragmentTest = representativeFragmentTest_;
      return *this;
    }

    operator VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV *>( this );
    }

    operator VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceRepresentativeFragmentTestFeaturesNV const & ) const = default;
#else
    bool operator==( PhysicalDeviceRepresentativeFragmentTestFeaturesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( representativeFragmentTest == rhs.representativeFragmentTest );
    }

    bool operator!=( PhysicalDeviceRepresentativeFragmentTestFeaturesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceRepresentativeFragmentTestFeaturesNV;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        representativeFragmentTest = {};
  };
  static_assert( sizeof( PhysicalDeviceRepresentativeFragmentTestFeaturesNV ) ==
                   sizeof( VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceRepresentativeFragmentTestFeaturesNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceRepresentativeFragmentTestFeaturesNV>
  {
    using Type = PhysicalDeviceRepresentativeFragmentTestFeaturesNV;
  };

  struct PhysicalDeviceRobustness2FeaturesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceRobustness2FeaturesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      PhysicalDeviceRobustness2FeaturesEXT( VULKAN_HPP_NAMESPACE::Bool32 robustBufferAccess2_ = {},
                                            VULKAN_HPP_NAMESPACE::Bool32 robustImageAccess2_  = {},
                                            VULKAN_HPP_NAMESPACE::Bool32 nullDescriptor_      = {} ) VULKAN_HPP_NOEXCEPT
      : robustBufferAccess2( robustBufferAccess2_ )
      , robustImageAccess2( robustImageAccess2_ )
      , nullDescriptor( nullDescriptor_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceRobustness2FeaturesEXT( PhysicalDeviceRobustness2FeaturesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceRobustness2FeaturesEXT( VkPhysicalDeviceRobustness2FeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceRobustness2FeaturesEXT( *reinterpret_cast<PhysicalDeviceRobustness2FeaturesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceRobustness2FeaturesEXT &
                            operator=( PhysicalDeviceRobustness2FeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceRobustness2FeaturesEXT &
      operator=( VkPhysicalDeviceRobustness2FeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceRobustness2FeaturesEXT const *>( &rhs );
      return *this;
    }

    PhysicalDeviceRobustness2FeaturesEXT & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceRobustness2FeaturesEXT &
      setRobustBufferAccess2( VULKAN_HPP_NAMESPACE::Bool32 robustBufferAccess2_ ) VULKAN_HPP_NOEXCEPT
    {
      robustBufferAccess2 = robustBufferAccess2_;
      return *this;
    }

    PhysicalDeviceRobustness2FeaturesEXT &
      setRobustImageAccess2( VULKAN_HPP_NAMESPACE::Bool32 robustImageAccess2_ ) VULKAN_HPP_NOEXCEPT
    {
      robustImageAccess2 = robustImageAccess2_;
      return *this;
    }

    PhysicalDeviceRobustness2FeaturesEXT &
      setNullDescriptor( VULKAN_HPP_NAMESPACE::Bool32 nullDescriptor_ ) VULKAN_HPP_NOEXCEPT
    {
      nullDescriptor = nullDescriptor_;
      return *this;
    }

    operator VkPhysicalDeviceRobustness2FeaturesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceRobustness2FeaturesEXT *>( this );
    }

    operator VkPhysicalDeviceRobustness2FeaturesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceRobustness2FeaturesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceRobustness2FeaturesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceRobustness2FeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( robustBufferAccess2 == rhs.robustBufferAccess2 ) &&
             ( robustImageAccess2 == rhs.robustImageAccess2 ) && ( nullDescriptor == rhs.nullDescriptor );
    }

    bool operator!=( PhysicalDeviceRobustness2FeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType               = StructureType::ePhysicalDeviceRobustness2FeaturesEXT;
    void *                              pNext               = {};
    VULKAN_HPP_NAMESPACE::Bool32        robustBufferAccess2 = {};
    VULKAN_HPP_NAMESPACE::Bool32        robustImageAccess2  = {};
    VULKAN_HPP_NAMESPACE::Bool32        nullDescriptor      = {};
  };
  static_assert( sizeof( PhysicalDeviceRobustness2FeaturesEXT ) == sizeof( VkPhysicalDeviceRobustness2FeaturesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceRobustness2FeaturesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceRobustness2FeaturesEXT>
  {
    using Type = PhysicalDeviceRobustness2FeaturesEXT;
  };

  struct PhysicalDeviceRobustness2PropertiesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceRobustness2PropertiesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceRobustness2PropertiesEXT(
      VULKAN_HPP_NAMESPACE::DeviceSize robustStorageBufferAccessSizeAlignment_ = {},
      VULKAN_HPP_NAMESPACE::DeviceSize robustUniformBufferAccessSizeAlignment_ = {} ) VULKAN_HPP_NOEXCEPT
      : robustStorageBufferAccessSizeAlignment( robustStorageBufferAccessSizeAlignment_ )
      , robustUniformBufferAccessSizeAlignment( robustUniformBufferAccessSizeAlignment_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceRobustness2PropertiesEXT( PhysicalDeviceRobustness2PropertiesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceRobustness2PropertiesEXT( VkPhysicalDeviceRobustness2PropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceRobustness2PropertiesEXT(
          *reinterpret_cast<PhysicalDeviceRobustness2PropertiesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceRobustness2PropertiesEXT &
                            operator=( PhysicalDeviceRobustness2PropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceRobustness2PropertiesEXT &
      operator=( VkPhysicalDeviceRobustness2PropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceRobustness2PropertiesEXT const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceRobustness2PropertiesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceRobustness2PropertiesEXT *>( this );
    }

    operator VkPhysicalDeviceRobustness2PropertiesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceRobustness2PropertiesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceRobustness2PropertiesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceRobustness2PropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( robustStorageBufferAccessSizeAlignment == rhs.robustStorageBufferAccessSizeAlignment ) &&
             ( robustUniformBufferAccessSizeAlignment == rhs.robustUniformBufferAccessSizeAlignment );
    }

    bool operator!=( PhysicalDeviceRobustness2PropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceRobustness2PropertiesEXT;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::DeviceSize    robustStorageBufferAccessSizeAlignment = {};
    VULKAN_HPP_NAMESPACE::DeviceSize    robustUniformBufferAccessSizeAlignment = {};
  };
  static_assert( sizeof( PhysicalDeviceRobustness2PropertiesEXT ) == sizeof( VkPhysicalDeviceRobustness2PropertiesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceRobustness2PropertiesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceRobustness2PropertiesEXT>
  {
    using Type = PhysicalDeviceRobustness2PropertiesEXT;
  };

  struct PhysicalDeviceSampleLocationsPropertiesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceSampleLocationsPropertiesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceSampleLocationsPropertiesEXT(
      VULKAN_HPP_NAMESPACE::SampleCountFlags sampleLocationSampleCounts_    = {},
      VULKAN_HPP_NAMESPACE::Extent2D         maxSampleLocationGridSize_     = {},
      std::array<float, 2> const &           sampleLocationCoordinateRange_ = {},
      uint32_t                               sampleLocationSubPixelBits_    = {},
      VULKAN_HPP_NAMESPACE::Bool32           variableSampleLocations_       = {} ) VULKAN_HPP_NOEXCEPT
      : sampleLocationSampleCounts( sampleLocationSampleCounts_ )
      , maxSampleLocationGridSize( maxSampleLocationGridSize_ )
      , sampleLocationCoordinateRange( sampleLocationCoordinateRange_ )
      , sampleLocationSubPixelBits( sampleLocationSubPixelBits_ )
      , variableSampleLocations( variableSampleLocations_ )
    {}

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceSampleLocationsPropertiesEXT(
      PhysicalDeviceSampleLocationsPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceSampleLocationsPropertiesEXT( VkPhysicalDeviceSampleLocationsPropertiesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceSampleLocationsPropertiesEXT(
          *reinterpret_cast<PhysicalDeviceSampleLocationsPropertiesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceSampleLocationsPropertiesEXT &
                            operator=( PhysicalDeviceSampleLocationsPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceSampleLocationsPropertiesEXT &
      operator=( VkPhysicalDeviceSampleLocationsPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceSampleLocationsPropertiesEXT const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceSampleLocationsPropertiesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceSampleLocationsPropertiesEXT *>( this );
    }

    operator VkPhysicalDeviceSampleLocationsPropertiesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceSampleLocationsPropertiesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceSampleLocationsPropertiesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceSampleLocationsPropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( sampleLocationSampleCounts == rhs.sampleLocationSampleCounts ) &&
             ( maxSampleLocationGridSize == rhs.maxSampleLocationGridSize ) &&
             ( sampleLocationCoordinateRange == rhs.sampleLocationCoordinateRange ) &&
             ( sampleLocationSubPixelBits == rhs.sampleLocationSubPixelBits ) &&
             ( variableSampleLocations == rhs.variableSampleLocations );
    }

    bool operator!=( PhysicalDeviceSampleLocationsPropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType            sType = StructureType::ePhysicalDeviceSampleLocationsPropertiesEXT;
    void *                                         pNext = {};
    VULKAN_HPP_NAMESPACE::SampleCountFlags         sampleLocationSampleCounts    = {};
    VULKAN_HPP_NAMESPACE::Extent2D                 maxSampleLocationGridSize     = {};
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<float, 2> sampleLocationCoordinateRange = {};
    uint32_t                                       sampleLocationSubPixelBits    = {};
    VULKAN_HPP_NAMESPACE::Bool32                   variableSampleLocations       = {};
  };
  static_assert( sizeof( PhysicalDeviceSampleLocationsPropertiesEXT ) ==
                   sizeof( VkPhysicalDeviceSampleLocationsPropertiesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceSampleLocationsPropertiesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceSampleLocationsPropertiesEXT>
  {
    using Type = PhysicalDeviceSampleLocationsPropertiesEXT;
  };

  struct PhysicalDeviceSamplerFilterMinmaxProperties
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceSamplerFilterMinmaxProperties;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceSamplerFilterMinmaxProperties(
      VULKAN_HPP_NAMESPACE::Bool32 filterMinmaxSingleComponentFormats_ = {},
      VULKAN_HPP_NAMESPACE::Bool32 filterMinmaxImageComponentMapping_  = {} ) VULKAN_HPP_NOEXCEPT
      : filterMinmaxSingleComponentFormats( filterMinmaxSingleComponentFormats_ )
      , filterMinmaxImageComponentMapping( filterMinmaxImageComponentMapping_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceSamplerFilterMinmaxProperties(
      PhysicalDeviceSamplerFilterMinmaxProperties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceSamplerFilterMinmaxProperties( VkPhysicalDeviceSamplerFilterMinmaxProperties const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceSamplerFilterMinmaxProperties(
          *reinterpret_cast<PhysicalDeviceSamplerFilterMinmaxProperties const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceSamplerFilterMinmaxProperties &
                            operator=( PhysicalDeviceSamplerFilterMinmaxProperties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceSamplerFilterMinmaxProperties &
      operator=( VkPhysicalDeviceSamplerFilterMinmaxProperties const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceSamplerFilterMinmaxProperties const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceSamplerFilterMinmaxProperties const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceSamplerFilterMinmaxProperties *>( this );
    }

    operator VkPhysicalDeviceSamplerFilterMinmaxProperties &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceSamplerFilterMinmaxProperties *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceSamplerFilterMinmaxProperties const & ) const = default;
#else
    bool operator==( PhysicalDeviceSamplerFilterMinmaxProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( filterMinmaxSingleComponentFormats == rhs.filterMinmaxSingleComponentFormats ) &&
             ( filterMinmaxImageComponentMapping == rhs.filterMinmaxImageComponentMapping );
    }

    bool operator!=( PhysicalDeviceSamplerFilterMinmaxProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceSamplerFilterMinmaxProperties;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        filterMinmaxSingleComponentFormats = {};
    VULKAN_HPP_NAMESPACE::Bool32        filterMinmaxImageComponentMapping  = {};
  };
  static_assert( sizeof( PhysicalDeviceSamplerFilterMinmaxProperties ) ==
                   sizeof( VkPhysicalDeviceSamplerFilterMinmaxProperties ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceSamplerFilterMinmaxProperties>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceSamplerFilterMinmaxProperties>
  {
    using Type = PhysicalDeviceSamplerFilterMinmaxProperties;
  };
  using PhysicalDeviceSamplerFilterMinmaxPropertiesEXT = PhysicalDeviceSamplerFilterMinmaxProperties;

  struct PhysicalDeviceSamplerYcbcrConversionFeatures
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceSamplerYcbcrConversionFeatures;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceSamplerYcbcrConversionFeatures(
      VULKAN_HPP_NAMESPACE::Bool32 samplerYcbcrConversion_ = {} ) VULKAN_HPP_NOEXCEPT
      : samplerYcbcrConversion( samplerYcbcrConversion_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceSamplerYcbcrConversionFeatures(
      PhysicalDeviceSamplerYcbcrConversionFeatures const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceSamplerYcbcrConversionFeatures( VkPhysicalDeviceSamplerYcbcrConversionFeatures const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceSamplerYcbcrConversionFeatures(
          *reinterpret_cast<PhysicalDeviceSamplerYcbcrConversionFeatures const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceSamplerYcbcrConversionFeatures &
                            operator=( PhysicalDeviceSamplerYcbcrConversionFeatures const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceSamplerYcbcrConversionFeatures &
      operator=( VkPhysicalDeviceSamplerYcbcrConversionFeatures const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceSamplerYcbcrConversionFeatures const *>( &rhs );
      return *this;
    }

    PhysicalDeviceSamplerYcbcrConversionFeatures & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceSamplerYcbcrConversionFeatures &
      setSamplerYcbcrConversion( VULKAN_HPP_NAMESPACE::Bool32 samplerYcbcrConversion_ ) VULKAN_HPP_NOEXCEPT
    {
      samplerYcbcrConversion = samplerYcbcrConversion_;
      return *this;
    }

    operator VkPhysicalDeviceSamplerYcbcrConversionFeatures const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceSamplerYcbcrConversionFeatures *>( this );
    }

    operator VkPhysicalDeviceSamplerYcbcrConversionFeatures &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceSamplerYcbcrConversionFeatures *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceSamplerYcbcrConversionFeatures const & ) const = default;
#else
    bool operator==( PhysicalDeviceSamplerYcbcrConversionFeatures const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( samplerYcbcrConversion == rhs.samplerYcbcrConversion );
    }

    bool operator!=( PhysicalDeviceSamplerYcbcrConversionFeatures const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceSamplerYcbcrConversionFeatures;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        samplerYcbcrConversion = {};
  };
  static_assert( sizeof( PhysicalDeviceSamplerYcbcrConversionFeatures ) ==
                   sizeof( VkPhysicalDeviceSamplerYcbcrConversionFeatures ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceSamplerYcbcrConversionFeatures>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceSamplerYcbcrConversionFeatures>
  {
    using Type = PhysicalDeviceSamplerYcbcrConversionFeatures;
  };
  using PhysicalDeviceSamplerYcbcrConversionFeaturesKHR = PhysicalDeviceSamplerYcbcrConversionFeatures;

  struct PhysicalDeviceScalarBlockLayoutFeatures
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceScalarBlockLayoutFeatures;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceScalarBlockLayoutFeatures( VULKAN_HPP_NAMESPACE::Bool32 scalarBlockLayout_ = {} )
      VULKAN_HPP_NOEXCEPT : scalarBlockLayout( scalarBlockLayout_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceScalarBlockLayoutFeatures( PhysicalDeviceScalarBlockLayoutFeatures const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceScalarBlockLayoutFeatures( VkPhysicalDeviceScalarBlockLayoutFeatures const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceScalarBlockLayoutFeatures(
          *reinterpret_cast<PhysicalDeviceScalarBlockLayoutFeatures const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceScalarBlockLayoutFeatures &
                            operator=( PhysicalDeviceScalarBlockLayoutFeatures const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceScalarBlockLayoutFeatures &
      operator=( VkPhysicalDeviceScalarBlockLayoutFeatures const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceScalarBlockLayoutFeatures const *>( &rhs );
      return *this;
    }

    PhysicalDeviceScalarBlockLayoutFeatures & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceScalarBlockLayoutFeatures &
      setScalarBlockLayout( VULKAN_HPP_NAMESPACE::Bool32 scalarBlockLayout_ ) VULKAN_HPP_NOEXCEPT
    {
      scalarBlockLayout = scalarBlockLayout_;
      return *this;
    }

    operator VkPhysicalDeviceScalarBlockLayoutFeatures const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceScalarBlockLayoutFeatures *>( this );
    }

    operator VkPhysicalDeviceScalarBlockLayoutFeatures &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceScalarBlockLayoutFeatures *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceScalarBlockLayoutFeatures const & ) const = default;
#else
    bool operator==( PhysicalDeviceScalarBlockLayoutFeatures const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( scalarBlockLayout == rhs.scalarBlockLayout );
    }

    bool operator!=( PhysicalDeviceScalarBlockLayoutFeatures const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType             = StructureType::ePhysicalDeviceScalarBlockLayoutFeatures;
    void *                              pNext             = {};
    VULKAN_HPP_NAMESPACE::Bool32        scalarBlockLayout = {};
  };
  static_assert( sizeof( PhysicalDeviceScalarBlockLayoutFeatures ) ==
                   sizeof( VkPhysicalDeviceScalarBlockLayoutFeatures ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceScalarBlockLayoutFeatures>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceScalarBlockLayoutFeatures>
  {
    using Type = PhysicalDeviceScalarBlockLayoutFeatures;
  };
  using PhysicalDeviceScalarBlockLayoutFeaturesEXT = PhysicalDeviceScalarBlockLayoutFeatures;

  struct PhysicalDeviceSeparateDepthStencilLayoutsFeatures
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceSeparateDepthStencilLayoutsFeatures;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceSeparateDepthStencilLayoutsFeatures(
      VULKAN_HPP_NAMESPACE::Bool32 separateDepthStencilLayouts_ = {} ) VULKAN_HPP_NOEXCEPT
      : separateDepthStencilLayouts( separateDepthStencilLayouts_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceSeparateDepthStencilLayoutsFeatures(
      PhysicalDeviceSeparateDepthStencilLayoutsFeatures const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceSeparateDepthStencilLayoutsFeatures( VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceSeparateDepthStencilLayoutsFeatures(
          *reinterpret_cast<PhysicalDeviceSeparateDepthStencilLayoutsFeatures const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceSeparateDepthStencilLayoutsFeatures &
                            operator=( PhysicalDeviceSeparateDepthStencilLayoutsFeatures const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceSeparateDepthStencilLayoutsFeatures &
      operator=( VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this =
        *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceSeparateDepthStencilLayoutsFeatures const *>( &rhs );
      return *this;
    }

    PhysicalDeviceSeparateDepthStencilLayoutsFeatures & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceSeparateDepthStencilLayoutsFeatures &
      setSeparateDepthStencilLayouts( VULKAN_HPP_NAMESPACE::Bool32 separateDepthStencilLayouts_ ) VULKAN_HPP_NOEXCEPT
    {
      separateDepthStencilLayouts = separateDepthStencilLayouts_;
      return *this;
    }

    operator VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures *>( this );
    }

    operator VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceSeparateDepthStencilLayoutsFeatures const & ) const = default;
#else
    bool operator==( PhysicalDeviceSeparateDepthStencilLayoutsFeatures const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( separateDepthStencilLayouts == rhs.separateDepthStencilLayouts );
    }

    bool operator!=( PhysicalDeviceSeparateDepthStencilLayoutsFeatures const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceSeparateDepthStencilLayoutsFeatures;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        separateDepthStencilLayouts = {};
  };
  static_assert( sizeof( PhysicalDeviceSeparateDepthStencilLayoutsFeatures ) ==
                   sizeof( VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceSeparateDepthStencilLayoutsFeatures>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceSeparateDepthStencilLayoutsFeatures>
  {
    using Type = PhysicalDeviceSeparateDepthStencilLayoutsFeatures;
  };
  using PhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR = PhysicalDeviceSeparateDepthStencilLayoutsFeatures;

  struct PhysicalDeviceShaderAtomicFloatFeaturesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceShaderAtomicFloatFeaturesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceShaderAtomicFloatFeaturesEXT(
      VULKAN_HPP_NAMESPACE::Bool32 shaderBufferFloat32Atomics_   = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderBufferFloat32AtomicAdd_ = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderBufferFloat64Atomics_   = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderBufferFloat64AtomicAdd_ = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderSharedFloat32Atomics_   = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderSharedFloat32AtomicAdd_ = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderSharedFloat64Atomics_   = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderSharedFloat64AtomicAdd_ = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderImageFloat32Atomics_    = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderImageFloat32AtomicAdd_  = {},
      VULKAN_HPP_NAMESPACE::Bool32 sparseImageFloat32Atomics_    = {},
      VULKAN_HPP_NAMESPACE::Bool32 sparseImageFloat32AtomicAdd_  = {} ) VULKAN_HPP_NOEXCEPT
      : shaderBufferFloat32Atomics( shaderBufferFloat32Atomics_ )
      , shaderBufferFloat32AtomicAdd( shaderBufferFloat32AtomicAdd_ )
      , shaderBufferFloat64Atomics( shaderBufferFloat64Atomics_ )
      , shaderBufferFloat64AtomicAdd( shaderBufferFloat64AtomicAdd_ )
      , shaderSharedFloat32Atomics( shaderSharedFloat32Atomics_ )
      , shaderSharedFloat32AtomicAdd( shaderSharedFloat32AtomicAdd_ )
      , shaderSharedFloat64Atomics( shaderSharedFloat64Atomics_ )
      , shaderSharedFloat64AtomicAdd( shaderSharedFloat64AtomicAdd_ )
      , shaderImageFloat32Atomics( shaderImageFloat32Atomics_ )
      , shaderImageFloat32AtomicAdd( shaderImageFloat32AtomicAdd_ )
      , sparseImageFloat32Atomics( sparseImageFloat32Atomics_ )
      , sparseImageFloat32AtomicAdd( sparseImageFloat32AtomicAdd_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceShaderAtomicFloatFeaturesEXT(
      PhysicalDeviceShaderAtomicFloatFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceShaderAtomicFloatFeaturesEXT( VkPhysicalDeviceShaderAtomicFloatFeaturesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceShaderAtomicFloatFeaturesEXT(
          *reinterpret_cast<PhysicalDeviceShaderAtomicFloatFeaturesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceShaderAtomicFloatFeaturesEXT &
                            operator=( PhysicalDeviceShaderAtomicFloatFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceShaderAtomicFloatFeaturesEXT &
      operator=( VkPhysicalDeviceShaderAtomicFloatFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceShaderAtomicFloatFeaturesEXT const *>( &rhs );
      return *this;
    }

    PhysicalDeviceShaderAtomicFloatFeaturesEXT & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceShaderAtomicFloatFeaturesEXT &
      setShaderBufferFloat32Atomics( VULKAN_HPP_NAMESPACE::Bool32 shaderBufferFloat32Atomics_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderBufferFloat32Atomics = shaderBufferFloat32Atomics_;
      return *this;
    }

    PhysicalDeviceShaderAtomicFloatFeaturesEXT &
      setShaderBufferFloat32AtomicAdd( VULKAN_HPP_NAMESPACE::Bool32 shaderBufferFloat32AtomicAdd_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderBufferFloat32AtomicAdd = shaderBufferFloat32AtomicAdd_;
      return *this;
    }

    PhysicalDeviceShaderAtomicFloatFeaturesEXT &
      setShaderBufferFloat64Atomics( VULKAN_HPP_NAMESPACE::Bool32 shaderBufferFloat64Atomics_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderBufferFloat64Atomics = shaderBufferFloat64Atomics_;
      return *this;
    }

    PhysicalDeviceShaderAtomicFloatFeaturesEXT &
      setShaderBufferFloat64AtomicAdd( VULKAN_HPP_NAMESPACE::Bool32 shaderBufferFloat64AtomicAdd_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderBufferFloat64AtomicAdd = shaderBufferFloat64AtomicAdd_;
      return *this;
    }

    PhysicalDeviceShaderAtomicFloatFeaturesEXT &
      setShaderSharedFloat32Atomics( VULKAN_HPP_NAMESPACE::Bool32 shaderSharedFloat32Atomics_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderSharedFloat32Atomics = shaderSharedFloat32Atomics_;
      return *this;
    }

    PhysicalDeviceShaderAtomicFloatFeaturesEXT &
      setShaderSharedFloat32AtomicAdd( VULKAN_HPP_NAMESPACE::Bool32 shaderSharedFloat32AtomicAdd_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderSharedFloat32AtomicAdd = shaderSharedFloat32AtomicAdd_;
      return *this;
    }

    PhysicalDeviceShaderAtomicFloatFeaturesEXT &
      setShaderSharedFloat64Atomics( VULKAN_HPP_NAMESPACE::Bool32 shaderSharedFloat64Atomics_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderSharedFloat64Atomics = shaderSharedFloat64Atomics_;
      return *this;
    }

    PhysicalDeviceShaderAtomicFloatFeaturesEXT &
      setShaderSharedFloat64AtomicAdd( VULKAN_HPP_NAMESPACE::Bool32 shaderSharedFloat64AtomicAdd_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderSharedFloat64AtomicAdd = shaderSharedFloat64AtomicAdd_;
      return *this;
    }

    PhysicalDeviceShaderAtomicFloatFeaturesEXT &
      setShaderImageFloat32Atomics( VULKAN_HPP_NAMESPACE::Bool32 shaderImageFloat32Atomics_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderImageFloat32Atomics = shaderImageFloat32Atomics_;
      return *this;
    }

    PhysicalDeviceShaderAtomicFloatFeaturesEXT &
      setShaderImageFloat32AtomicAdd( VULKAN_HPP_NAMESPACE::Bool32 shaderImageFloat32AtomicAdd_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderImageFloat32AtomicAdd = shaderImageFloat32AtomicAdd_;
      return *this;
    }

    PhysicalDeviceShaderAtomicFloatFeaturesEXT &
      setSparseImageFloat32Atomics( VULKAN_HPP_NAMESPACE::Bool32 sparseImageFloat32Atomics_ ) VULKAN_HPP_NOEXCEPT
    {
      sparseImageFloat32Atomics = sparseImageFloat32Atomics_;
      return *this;
    }

    PhysicalDeviceShaderAtomicFloatFeaturesEXT &
      setSparseImageFloat32AtomicAdd( VULKAN_HPP_NAMESPACE::Bool32 sparseImageFloat32AtomicAdd_ ) VULKAN_HPP_NOEXCEPT
    {
      sparseImageFloat32AtomicAdd = sparseImageFloat32AtomicAdd_;
      return *this;
    }

    operator VkPhysicalDeviceShaderAtomicFloatFeaturesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceShaderAtomicFloatFeaturesEXT *>( this );
    }

    operator VkPhysicalDeviceShaderAtomicFloatFeaturesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceShaderAtomicFloatFeaturesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceShaderAtomicFloatFeaturesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceShaderAtomicFloatFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( shaderBufferFloat32Atomics == rhs.shaderBufferFloat32Atomics ) &&
             ( shaderBufferFloat32AtomicAdd == rhs.shaderBufferFloat32AtomicAdd ) &&
             ( shaderBufferFloat64Atomics == rhs.shaderBufferFloat64Atomics ) &&
             ( shaderBufferFloat64AtomicAdd == rhs.shaderBufferFloat64AtomicAdd ) &&
             ( shaderSharedFloat32Atomics == rhs.shaderSharedFloat32Atomics ) &&
             ( shaderSharedFloat32AtomicAdd == rhs.shaderSharedFloat32AtomicAdd ) &&
             ( shaderSharedFloat64Atomics == rhs.shaderSharedFloat64Atomics ) &&
             ( shaderSharedFloat64AtomicAdd == rhs.shaderSharedFloat64AtomicAdd ) &&
             ( shaderImageFloat32Atomics == rhs.shaderImageFloat32Atomics ) &&
             ( shaderImageFloat32AtomicAdd == rhs.shaderImageFloat32AtomicAdd ) &&
             ( sparseImageFloat32Atomics == rhs.sparseImageFloat32Atomics ) &&
             ( sparseImageFloat32AtomicAdd == rhs.sparseImageFloat32AtomicAdd );
    }

    bool operator!=( PhysicalDeviceShaderAtomicFloatFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceShaderAtomicFloatFeaturesEXT;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderBufferFloat32Atomics   = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderBufferFloat32AtomicAdd = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderBufferFloat64Atomics   = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderBufferFloat64AtomicAdd = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderSharedFloat32Atomics   = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderSharedFloat32AtomicAdd = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderSharedFloat64Atomics   = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderSharedFloat64AtomicAdd = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderImageFloat32Atomics    = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderImageFloat32AtomicAdd  = {};
    VULKAN_HPP_NAMESPACE::Bool32        sparseImageFloat32Atomics    = {};
    VULKAN_HPP_NAMESPACE::Bool32        sparseImageFloat32AtomicAdd  = {};
  };
  static_assert( sizeof( PhysicalDeviceShaderAtomicFloatFeaturesEXT ) ==
                   sizeof( VkPhysicalDeviceShaderAtomicFloatFeaturesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceShaderAtomicFloatFeaturesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceShaderAtomicFloatFeaturesEXT>
  {
    using Type = PhysicalDeviceShaderAtomicFloatFeaturesEXT;
  };

  struct PhysicalDeviceShaderAtomicInt64Features
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceShaderAtomicInt64Features;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceShaderAtomicInt64Features(
      VULKAN_HPP_NAMESPACE::Bool32 shaderBufferInt64Atomics_ = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderSharedInt64Atomics_ = {} ) VULKAN_HPP_NOEXCEPT
      : shaderBufferInt64Atomics( shaderBufferInt64Atomics_ )
      , shaderSharedInt64Atomics( shaderSharedInt64Atomics_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceShaderAtomicInt64Features( PhysicalDeviceShaderAtomicInt64Features const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceShaderAtomicInt64Features( VkPhysicalDeviceShaderAtomicInt64Features const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceShaderAtomicInt64Features(
          *reinterpret_cast<PhysicalDeviceShaderAtomicInt64Features const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceShaderAtomicInt64Features &
                            operator=( PhysicalDeviceShaderAtomicInt64Features const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceShaderAtomicInt64Features &
      operator=( VkPhysicalDeviceShaderAtomicInt64Features const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceShaderAtomicInt64Features const *>( &rhs );
      return *this;
    }

    PhysicalDeviceShaderAtomicInt64Features & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceShaderAtomicInt64Features &
      setShaderBufferInt64Atomics( VULKAN_HPP_NAMESPACE::Bool32 shaderBufferInt64Atomics_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderBufferInt64Atomics = shaderBufferInt64Atomics_;
      return *this;
    }

    PhysicalDeviceShaderAtomicInt64Features &
      setShaderSharedInt64Atomics( VULKAN_HPP_NAMESPACE::Bool32 shaderSharedInt64Atomics_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderSharedInt64Atomics = shaderSharedInt64Atomics_;
      return *this;
    }

    operator VkPhysicalDeviceShaderAtomicInt64Features const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceShaderAtomicInt64Features *>( this );
    }

    operator VkPhysicalDeviceShaderAtomicInt64Features &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceShaderAtomicInt64Features *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceShaderAtomicInt64Features const & ) const = default;
#else
    bool operator==( PhysicalDeviceShaderAtomicInt64Features const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( shaderBufferInt64Atomics == rhs.shaderBufferInt64Atomics ) &&
             ( shaderSharedInt64Atomics == rhs.shaderSharedInt64Atomics );
    }

    bool operator!=( PhysicalDeviceShaderAtomicInt64Features const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceShaderAtomicInt64Features;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderBufferInt64Atomics = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderSharedInt64Atomics = {};
  };
  static_assert( sizeof( PhysicalDeviceShaderAtomicInt64Features ) ==
                   sizeof( VkPhysicalDeviceShaderAtomicInt64Features ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceShaderAtomicInt64Features>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceShaderAtomicInt64Features>
  {
    using Type = PhysicalDeviceShaderAtomicInt64Features;
  };
  using PhysicalDeviceShaderAtomicInt64FeaturesKHR = PhysicalDeviceShaderAtomicInt64Features;

  struct PhysicalDeviceShaderClockFeaturesKHR
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceShaderClockFeaturesKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      PhysicalDeviceShaderClockFeaturesKHR( VULKAN_HPP_NAMESPACE::Bool32 shaderSubgroupClock_ = {},
                                            VULKAN_HPP_NAMESPACE::Bool32 shaderDeviceClock_   = {} ) VULKAN_HPP_NOEXCEPT
      : shaderSubgroupClock( shaderSubgroupClock_ )
      , shaderDeviceClock( shaderDeviceClock_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceShaderClockFeaturesKHR( PhysicalDeviceShaderClockFeaturesKHR const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceShaderClockFeaturesKHR( VkPhysicalDeviceShaderClockFeaturesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceShaderClockFeaturesKHR( *reinterpret_cast<PhysicalDeviceShaderClockFeaturesKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceShaderClockFeaturesKHR &
                            operator=( PhysicalDeviceShaderClockFeaturesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceShaderClockFeaturesKHR &
      operator=( VkPhysicalDeviceShaderClockFeaturesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceShaderClockFeaturesKHR const *>( &rhs );
      return *this;
    }

    PhysicalDeviceShaderClockFeaturesKHR & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceShaderClockFeaturesKHR &
      setShaderSubgroupClock( VULKAN_HPP_NAMESPACE::Bool32 shaderSubgroupClock_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderSubgroupClock = shaderSubgroupClock_;
      return *this;
    }

    PhysicalDeviceShaderClockFeaturesKHR &
      setShaderDeviceClock( VULKAN_HPP_NAMESPACE::Bool32 shaderDeviceClock_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderDeviceClock = shaderDeviceClock_;
      return *this;
    }

    operator VkPhysicalDeviceShaderClockFeaturesKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceShaderClockFeaturesKHR *>( this );
    }

    operator VkPhysicalDeviceShaderClockFeaturesKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceShaderClockFeaturesKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceShaderClockFeaturesKHR const & ) const = default;
#else
    bool operator==( PhysicalDeviceShaderClockFeaturesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( shaderSubgroupClock == rhs.shaderSubgroupClock ) &&
             ( shaderDeviceClock == rhs.shaderDeviceClock );
    }

    bool operator!=( PhysicalDeviceShaderClockFeaturesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType               = StructureType::ePhysicalDeviceShaderClockFeaturesKHR;
    void *                              pNext               = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderSubgroupClock = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderDeviceClock   = {};
  };
  static_assert( sizeof( PhysicalDeviceShaderClockFeaturesKHR ) == sizeof( VkPhysicalDeviceShaderClockFeaturesKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceShaderClockFeaturesKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceShaderClockFeaturesKHR>
  {
    using Type = PhysicalDeviceShaderClockFeaturesKHR;
  };

  struct PhysicalDeviceShaderCoreProperties2AMD
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceShaderCoreProperties2AMD;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceShaderCoreProperties2AMD(
      VULKAN_HPP_NAMESPACE::ShaderCorePropertiesFlagsAMD shaderCoreFeatures_     = {},
      uint32_t                                           activeComputeUnitCount_ = {} ) VULKAN_HPP_NOEXCEPT
      : shaderCoreFeatures( shaderCoreFeatures_ )
      , activeComputeUnitCount( activeComputeUnitCount_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceShaderCoreProperties2AMD( PhysicalDeviceShaderCoreProperties2AMD const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceShaderCoreProperties2AMD( VkPhysicalDeviceShaderCoreProperties2AMD const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceShaderCoreProperties2AMD(
          *reinterpret_cast<PhysicalDeviceShaderCoreProperties2AMD const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceShaderCoreProperties2AMD &
                            operator=( PhysicalDeviceShaderCoreProperties2AMD const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceShaderCoreProperties2AMD &
      operator=( VkPhysicalDeviceShaderCoreProperties2AMD const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceShaderCoreProperties2AMD const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceShaderCoreProperties2AMD const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceShaderCoreProperties2AMD *>( this );
    }

    operator VkPhysicalDeviceShaderCoreProperties2AMD &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceShaderCoreProperties2AMD *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceShaderCoreProperties2AMD const & ) const = default;
#else
    bool operator==( PhysicalDeviceShaderCoreProperties2AMD const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( shaderCoreFeatures == rhs.shaderCoreFeatures ) &&
             ( activeComputeUnitCount == rhs.activeComputeUnitCount );
    }

    bool operator!=( PhysicalDeviceShaderCoreProperties2AMD const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                sType = StructureType::ePhysicalDeviceShaderCoreProperties2AMD;
    void *                                             pNext = {};
    VULKAN_HPP_NAMESPACE::ShaderCorePropertiesFlagsAMD shaderCoreFeatures     = {};
    uint32_t                                           activeComputeUnitCount = {};
  };
  static_assert( sizeof( PhysicalDeviceShaderCoreProperties2AMD ) == sizeof( VkPhysicalDeviceShaderCoreProperties2AMD ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceShaderCoreProperties2AMD>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceShaderCoreProperties2AMD>
  {
    using Type = PhysicalDeviceShaderCoreProperties2AMD;
  };

  struct PhysicalDeviceShaderCorePropertiesAMD
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceShaderCorePropertiesAMD;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      PhysicalDeviceShaderCorePropertiesAMD( uint32_t shaderEngineCount_          = {},
                                             uint32_t shaderArraysPerEngineCount_ = {},
                                             uint32_t computeUnitsPerShaderArray_ = {},
                                             uint32_t simdPerComputeUnit_         = {},
                                             uint32_t wavefrontsPerSimd_          = {},
                                             uint32_t wavefrontSize_              = {},
                                             uint32_t sgprsPerSimd_               = {},
                                             uint32_t minSgprAllocation_          = {},
                                             uint32_t maxSgprAllocation_          = {},
                                             uint32_t sgprAllocationGranularity_  = {},
                                             uint32_t vgprsPerSimd_               = {},
                                             uint32_t minVgprAllocation_          = {},
                                             uint32_t maxVgprAllocation_          = {},
                                             uint32_t vgprAllocationGranularity_  = {} ) VULKAN_HPP_NOEXCEPT
      : shaderEngineCount( shaderEngineCount_ )
      , shaderArraysPerEngineCount( shaderArraysPerEngineCount_ )
      , computeUnitsPerShaderArray( computeUnitsPerShaderArray_ )
      , simdPerComputeUnit( simdPerComputeUnit_ )
      , wavefrontsPerSimd( wavefrontsPerSimd_ )
      , wavefrontSize( wavefrontSize_ )
      , sgprsPerSimd( sgprsPerSimd_ )
      , minSgprAllocation( minSgprAllocation_ )
      , maxSgprAllocation( maxSgprAllocation_ )
      , sgprAllocationGranularity( sgprAllocationGranularity_ )
      , vgprsPerSimd( vgprsPerSimd_ )
      , minVgprAllocation( minVgprAllocation_ )
      , maxVgprAllocation( maxVgprAllocation_ )
      , vgprAllocationGranularity( vgprAllocationGranularity_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceShaderCorePropertiesAMD( PhysicalDeviceShaderCorePropertiesAMD const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceShaderCorePropertiesAMD( VkPhysicalDeviceShaderCorePropertiesAMD const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceShaderCorePropertiesAMD(
          *reinterpret_cast<PhysicalDeviceShaderCorePropertiesAMD const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceShaderCorePropertiesAMD &
                            operator=( PhysicalDeviceShaderCorePropertiesAMD const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceShaderCorePropertiesAMD &
      operator=( VkPhysicalDeviceShaderCorePropertiesAMD const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceShaderCorePropertiesAMD const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceShaderCorePropertiesAMD const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceShaderCorePropertiesAMD *>( this );
    }

    operator VkPhysicalDeviceShaderCorePropertiesAMD &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceShaderCorePropertiesAMD *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceShaderCorePropertiesAMD const & ) const = default;
#else
    bool operator==( PhysicalDeviceShaderCorePropertiesAMD const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( shaderEngineCount == rhs.shaderEngineCount ) &&
             ( shaderArraysPerEngineCount == rhs.shaderArraysPerEngineCount ) &&
             ( computeUnitsPerShaderArray == rhs.computeUnitsPerShaderArray ) &&
             ( simdPerComputeUnit == rhs.simdPerComputeUnit ) && ( wavefrontsPerSimd == rhs.wavefrontsPerSimd ) &&
             ( wavefrontSize == rhs.wavefrontSize ) && ( sgprsPerSimd == rhs.sgprsPerSimd ) &&
             ( minSgprAllocation == rhs.minSgprAllocation ) && ( maxSgprAllocation == rhs.maxSgprAllocation ) &&
             ( sgprAllocationGranularity == rhs.sgprAllocationGranularity ) && ( vgprsPerSimd == rhs.vgprsPerSimd ) &&
             ( minVgprAllocation == rhs.minVgprAllocation ) && ( maxVgprAllocation == rhs.maxVgprAllocation ) &&
             ( vgprAllocationGranularity == rhs.vgprAllocationGranularity );
    }

    bool operator!=( PhysicalDeviceShaderCorePropertiesAMD const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType             = StructureType::ePhysicalDeviceShaderCorePropertiesAMD;
    void *                              pNext             = {};
    uint32_t                            shaderEngineCount = {};
    uint32_t                            shaderArraysPerEngineCount = {};
    uint32_t                            computeUnitsPerShaderArray = {};
    uint32_t                            simdPerComputeUnit         = {};
    uint32_t                            wavefrontsPerSimd          = {};
    uint32_t                            wavefrontSize              = {};
    uint32_t                            sgprsPerSimd               = {};
    uint32_t                            minSgprAllocation          = {};
    uint32_t                            maxSgprAllocation          = {};
    uint32_t                            sgprAllocationGranularity  = {};
    uint32_t                            vgprsPerSimd               = {};
    uint32_t                            minVgprAllocation          = {};
    uint32_t                            maxVgprAllocation          = {};
    uint32_t                            vgprAllocationGranularity  = {};
  };
  static_assert( sizeof( PhysicalDeviceShaderCorePropertiesAMD ) == sizeof( VkPhysicalDeviceShaderCorePropertiesAMD ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceShaderCorePropertiesAMD>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceShaderCorePropertiesAMD>
  {
    using Type = PhysicalDeviceShaderCorePropertiesAMD;
  };

  struct PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT(
      VULKAN_HPP_NAMESPACE::Bool32 shaderDemoteToHelperInvocation_ = {} ) VULKAN_HPP_NOEXCEPT
      : shaderDemoteToHelperInvocation( shaderDemoteToHelperInvocation_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT(
      PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT(
      VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT(
          *reinterpret_cast<PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT &
                            operator=( PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT &
      operator=( VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT const *>(
        &rhs );
      return *this;
    }

    PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT & setShaderDemoteToHelperInvocation(
      VULKAN_HPP_NAMESPACE::Bool32 shaderDemoteToHelperInvocation_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderDemoteToHelperInvocation = shaderDemoteToHelperInvocation_;
      return *this;
    }

    operator VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT *>( this );
    }

    operator VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( shaderDemoteToHelperInvocation == rhs.shaderDemoteToHelperInvocation );
    }

    bool operator!=( PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderDemoteToHelperInvocation = {};
  };
  static_assert( sizeof( PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT ) ==
                   sizeof( VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT>
  {
    using Type = PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT;
  };

  struct PhysicalDeviceShaderDrawParametersFeatures
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceShaderDrawParametersFeatures;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceShaderDrawParametersFeatures(
      VULKAN_HPP_NAMESPACE::Bool32 shaderDrawParameters_ = {} ) VULKAN_HPP_NOEXCEPT
      : shaderDrawParameters( shaderDrawParameters_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceShaderDrawParametersFeatures(
      PhysicalDeviceShaderDrawParametersFeatures const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceShaderDrawParametersFeatures( VkPhysicalDeviceShaderDrawParametersFeatures const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceShaderDrawParametersFeatures(
          *reinterpret_cast<PhysicalDeviceShaderDrawParametersFeatures const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceShaderDrawParametersFeatures &
                            operator=( PhysicalDeviceShaderDrawParametersFeatures const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceShaderDrawParametersFeatures &
      operator=( VkPhysicalDeviceShaderDrawParametersFeatures const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceShaderDrawParametersFeatures const *>( &rhs );
      return *this;
    }

    PhysicalDeviceShaderDrawParametersFeatures & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceShaderDrawParametersFeatures &
      setShaderDrawParameters( VULKAN_HPP_NAMESPACE::Bool32 shaderDrawParameters_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderDrawParameters = shaderDrawParameters_;
      return *this;
    }

    operator VkPhysicalDeviceShaderDrawParametersFeatures const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceShaderDrawParametersFeatures *>( this );
    }

    operator VkPhysicalDeviceShaderDrawParametersFeatures &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceShaderDrawParametersFeatures *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceShaderDrawParametersFeatures const & ) const = default;
#else
    bool operator==( PhysicalDeviceShaderDrawParametersFeatures const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( shaderDrawParameters == rhs.shaderDrawParameters );
    }

    bool operator!=( PhysicalDeviceShaderDrawParametersFeatures const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceShaderDrawParametersFeatures;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderDrawParameters = {};
  };
  static_assert( sizeof( PhysicalDeviceShaderDrawParametersFeatures ) ==
                   sizeof( VkPhysicalDeviceShaderDrawParametersFeatures ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceShaderDrawParametersFeatures>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceShaderDrawParametersFeatures>
  {
    using Type = PhysicalDeviceShaderDrawParametersFeatures;
  };
  using PhysicalDeviceShaderDrawParameterFeatures = PhysicalDeviceShaderDrawParametersFeatures;

  struct PhysicalDeviceShaderFloat16Int8Features
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceShaderFloat16Int8Features;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      PhysicalDeviceShaderFloat16Int8Features( VULKAN_HPP_NAMESPACE::Bool32 shaderFloat16_ = {},
                                               VULKAN_HPP_NAMESPACE::Bool32 shaderInt8_    = {} ) VULKAN_HPP_NOEXCEPT
      : shaderFloat16( shaderFloat16_ )
      , shaderInt8( shaderInt8_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceShaderFloat16Int8Features( PhysicalDeviceShaderFloat16Int8Features const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceShaderFloat16Int8Features( VkPhysicalDeviceShaderFloat16Int8Features const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceShaderFloat16Int8Features(
          *reinterpret_cast<PhysicalDeviceShaderFloat16Int8Features const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceShaderFloat16Int8Features &
                            operator=( PhysicalDeviceShaderFloat16Int8Features const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceShaderFloat16Int8Features &
      operator=( VkPhysicalDeviceShaderFloat16Int8Features const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceShaderFloat16Int8Features const *>( &rhs );
      return *this;
    }

    PhysicalDeviceShaderFloat16Int8Features & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceShaderFloat16Int8Features &
      setShaderFloat16( VULKAN_HPP_NAMESPACE::Bool32 shaderFloat16_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderFloat16 = shaderFloat16_;
      return *this;
    }

    PhysicalDeviceShaderFloat16Int8Features &
      setShaderInt8( VULKAN_HPP_NAMESPACE::Bool32 shaderInt8_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderInt8 = shaderInt8_;
      return *this;
    }

    operator VkPhysicalDeviceShaderFloat16Int8Features const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceShaderFloat16Int8Features *>( this );
    }

    operator VkPhysicalDeviceShaderFloat16Int8Features &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceShaderFloat16Int8Features *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceShaderFloat16Int8Features const & ) const = default;
#else
    bool operator==( PhysicalDeviceShaderFloat16Int8Features const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( shaderFloat16 == rhs.shaderFloat16 ) &&
             ( shaderInt8 == rhs.shaderInt8 );
    }

    bool operator!=( PhysicalDeviceShaderFloat16Int8Features const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType         = StructureType::ePhysicalDeviceShaderFloat16Int8Features;
    void *                              pNext         = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderFloat16 = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderInt8    = {};
  };
  static_assert( sizeof( PhysicalDeviceShaderFloat16Int8Features ) ==
                   sizeof( VkPhysicalDeviceShaderFloat16Int8Features ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceShaderFloat16Int8Features>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceShaderFloat16Int8Features>
  {
    using Type = PhysicalDeviceShaderFloat16Int8Features;
  };
  using PhysicalDeviceFloat16Int8FeaturesKHR       = PhysicalDeviceShaderFloat16Int8Features;
  using PhysicalDeviceShaderFloat16Int8FeaturesKHR = PhysicalDeviceShaderFloat16Int8Features;

  struct PhysicalDeviceShaderImageAtomicInt64FeaturesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceShaderImageAtomicInt64FeaturesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceShaderImageAtomicInt64FeaturesEXT(
      VULKAN_HPP_NAMESPACE::Bool32 shaderImageInt64Atomics_ = {},
      VULKAN_HPP_NAMESPACE::Bool32 sparseImageInt64Atomics_ = {} ) VULKAN_HPP_NOEXCEPT
      : shaderImageInt64Atomics( shaderImageInt64Atomics_ )
      , sparseImageInt64Atomics( sparseImageInt64Atomics_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceShaderImageAtomicInt64FeaturesEXT(
      PhysicalDeviceShaderImageAtomicInt64FeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceShaderImageAtomicInt64FeaturesEXT( VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceShaderImageAtomicInt64FeaturesEXT(
          *reinterpret_cast<PhysicalDeviceShaderImageAtomicInt64FeaturesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceShaderImageAtomicInt64FeaturesEXT &
                            operator=( PhysicalDeviceShaderImageAtomicInt64FeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceShaderImageAtomicInt64FeaturesEXT &
      operator=( VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceShaderImageAtomicInt64FeaturesEXT const *>( &rhs );
      return *this;
    }

    PhysicalDeviceShaderImageAtomicInt64FeaturesEXT & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceShaderImageAtomicInt64FeaturesEXT &
      setShaderImageInt64Atomics( VULKAN_HPP_NAMESPACE::Bool32 shaderImageInt64Atomics_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderImageInt64Atomics = shaderImageInt64Atomics_;
      return *this;
    }

    PhysicalDeviceShaderImageAtomicInt64FeaturesEXT &
      setSparseImageInt64Atomics( VULKAN_HPP_NAMESPACE::Bool32 sparseImageInt64Atomics_ ) VULKAN_HPP_NOEXCEPT
    {
      sparseImageInt64Atomics = sparseImageInt64Atomics_;
      return *this;
    }

    operator VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT *>( this );
    }

    operator VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceShaderImageAtomicInt64FeaturesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceShaderImageAtomicInt64FeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( shaderImageInt64Atomics == rhs.shaderImageInt64Atomics ) &&
             ( sparseImageInt64Atomics == rhs.sparseImageInt64Atomics );
    }

    bool operator!=( PhysicalDeviceShaderImageAtomicInt64FeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceShaderImageAtomicInt64FeaturesEXT;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderImageInt64Atomics = {};
    VULKAN_HPP_NAMESPACE::Bool32        sparseImageInt64Atomics = {};
  };
  static_assert( sizeof( PhysicalDeviceShaderImageAtomicInt64FeaturesEXT ) ==
                   sizeof( VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceShaderImageAtomicInt64FeaturesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceShaderImageAtomicInt64FeaturesEXT>
  {
    using Type = PhysicalDeviceShaderImageAtomicInt64FeaturesEXT;
  };

  struct PhysicalDeviceShaderImageFootprintFeaturesNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceShaderImageFootprintFeaturesNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceShaderImageFootprintFeaturesNV(
      VULKAN_HPP_NAMESPACE::Bool32 imageFootprint_ = {} ) VULKAN_HPP_NOEXCEPT : imageFootprint( imageFootprint_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceShaderImageFootprintFeaturesNV(
      PhysicalDeviceShaderImageFootprintFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceShaderImageFootprintFeaturesNV( VkPhysicalDeviceShaderImageFootprintFeaturesNV const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceShaderImageFootprintFeaturesNV(
          *reinterpret_cast<PhysicalDeviceShaderImageFootprintFeaturesNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceShaderImageFootprintFeaturesNV &
                            operator=( PhysicalDeviceShaderImageFootprintFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceShaderImageFootprintFeaturesNV &
      operator=( VkPhysicalDeviceShaderImageFootprintFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceShaderImageFootprintFeaturesNV const *>( &rhs );
      return *this;
    }

    PhysicalDeviceShaderImageFootprintFeaturesNV & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceShaderImageFootprintFeaturesNV &
      setImageFootprint( VULKAN_HPP_NAMESPACE::Bool32 imageFootprint_ ) VULKAN_HPP_NOEXCEPT
    {
      imageFootprint = imageFootprint_;
      return *this;
    }

    operator VkPhysicalDeviceShaderImageFootprintFeaturesNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceShaderImageFootprintFeaturesNV *>( this );
    }

    operator VkPhysicalDeviceShaderImageFootprintFeaturesNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceShaderImageFootprintFeaturesNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceShaderImageFootprintFeaturesNV const & ) const = default;
#else
    bool operator==( PhysicalDeviceShaderImageFootprintFeaturesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( imageFootprint == rhs.imageFootprint );
    }

    bool operator!=( PhysicalDeviceShaderImageFootprintFeaturesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType          = StructureType::ePhysicalDeviceShaderImageFootprintFeaturesNV;
    void *                              pNext          = {};
    VULKAN_HPP_NAMESPACE::Bool32        imageFootprint = {};
  };
  static_assert( sizeof( PhysicalDeviceShaderImageFootprintFeaturesNV ) ==
                   sizeof( VkPhysicalDeviceShaderImageFootprintFeaturesNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceShaderImageFootprintFeaturesNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceShaderImageFootprintFeaturesNV>
  {
    using Type = PhysicalDeviceShaderImageFootprintFeaturesNV;
  };

  struct PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceShaderIntegerFunctions2FeaturesINTEL;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(
      VULKAN_HPP_NAMESPACE::Bool32 shaderIntegerFunctions2_ = {} ) VULKAN_HPP_NOEXCEPT
      : shaderIntegerFunctions2( shaderIntegerFunctions2_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(
      PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(
      VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(
          *reinterpret_cast<PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL &
                            operator=( PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL &
      operator=( VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this =
        *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL const *>( &rhs );
      return *this;
    }

    PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL &
      setShaderIntegerFunctions2( VULKAN_HPP_NAMESPACE::Bool32 shaderIntegerFunctions2_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderIntegerFunctions2 = shaderIntegerFunctions2_;
      return *this;
    }

    operator VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL *>( this );
    }

    operator VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL const & ) const = default;
#else
    bool operator==( PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( shaderIntegerFunctions2 == rhs.shaderIntegerFunctions2 );
    }

    bool operator!=( PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceShaderIntegerFunctions2FeaturesINTEL;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderIntegerFunctions2 = {};
  };
  static_assert( sizeof( PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL ) ==
                   sizeof( VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceShaderIntegerFunctions2FeaturesINTEL>
  {
    using Type = PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL;
  };

  struct PhysicalDeviceShaderSMBuiltinsFeaturesNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceShaderSmBuiltinsFeaturesNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceShaderSMBuiltinsFeaturesNV( VULKAN_HPP_NAMESPACE::Bool32 shaderSMBuiltins_ = {} )
      VULKAN_HPP_NOEXCEPT : shaderSMBuiltins( shaderSMBuiltins_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceShaderSMBuiltinsFeaturesNV(
      PhysicalDeviceShaderSMBuiltinsFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceShaderSMBuiltinsFeaturesNV( VkPhysicalDeviceShaderSMBuiltinsFeaturesNV const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceShaderSMBuiltinsFeaturesNV(
          *reinterpret_cast<PhysicalDeviceShaderSMBuiltinsFeaturesNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceShaderSMBuiltinsFeaturesNV &
                            operator=( PhysicalDeviceShaderSMBuiltinsFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceShaderSMBuiltinsFeaturesNV &
      operator=( VkPhysicalDeviceShaderSMBuiltinsFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceShaderSMBuiltinsFeaturesNV const *>( &rhs );
      return *this;
    }

    PhysicalDeviceShaderSMBuiltinsFeaturesNV & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceShaderSMBuiltinsFeaturesNV &
      setShaderSMBuiltins( VULKAN_HPP_NAMESPACE::Bool32 shaderSMBuiltins_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderSMBuiltins = shaderSMBuiltins_;
      return *this;
    }

    operator VkPhysicalDeviceShaderSMBuiltinsFeaturesNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV *>( this );
    }

    operator VkPhysicalDeviceShaderSMBuiltinsFeaturesNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceShaderSMBuiltinsFeaturesNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceShaderSMBuiltinsFeaturesNV const & ) const = default;
#else
    bool operator==( PhysicalDeviceShaderSMBuiltinsFeaturesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( shaderSMBuiltins == rhs.shaderSMBuiltins );
    }

    bool operator!=( PhysicalDeviceShaderSMBuiltinsFeaturesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType            = StructureType::ePhysicalDeviceShaderSmBuiltinsFeaturesNV;
    void *                              pNext            = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderSMBuiltins = {};
  };
  static_assert( sizeof( PhysicalDeviceShaderSMBuiltinsFeaturesNV ) ==
                   sizeof( VkPhysicalDeviceShaderSMBuiltinsFeaturesNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceShaderSMBuiltinsFeaturesNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceShaderSmBuiltinsFeaturesNV>
  {
    using Type = PhysicalDeviceShaderSMBuiltinsFeaturesNV;
  };

  struct PhysicalDeviceShaderSMBuiltinsPropertiesNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceShaderSmBuiltinsPropertiesNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      PhysicalDeviceShaderSMBuiltinsPropertiesNV( uint32_t shaderSMCount_    = {},
                                                  uint32_t shaderWarpsPerSM_ = {} ) VULKAN_HPP_NOEXCEPT
      : shaderSMCount( shaderSMCount_ )
      , shaderWarpsPerSM( shaderWarpsPerSM_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceShaderSMBuiltinsPropertiesNV(
      PhysicalDeviceShaderSMBuiltinsPropertiesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceShaderSMBuiltinsPropertiesNV( VkPhysicalDeviceShaderSMBuiltinsPropertiesNV const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceShaderSMBuiltinsPropertiesNV(
          *reinterpret_cast<PhysicalDeviceShaderSMBuiltinsPropertiesNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceShaderSMBuiltinsPropertiesNV &
                            operator=( PhysicalDeviceShaderSMBuiltinsPropertiesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceShaderSMBuiltinsPropertiesNV &
      operator=( VkPhysicalDeviceShaderSMBuiltinsPropertiesNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceShaderSMBuiltinsPropertiesNV const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceShaderSMBuiltinsPropertiesNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceShaderSMBuiltinsPropertiesNV *>( this );
    }

    operator VkPhysicalDeviceShaderSMBuiltinsPropertiesNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceShaderSMBuiltinsPropertiesNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceShaderSMBuiltinsPropertiesNV const & ) const = default;
#else
    bool operator==( PhysicalDeviceShaderSMBuiltinsPropertiesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( shaderSMCount == rhs.shaderSMCount ) &&
             ( shaderWarpsPerSM == rhs.shaderWarpsPerSM );
    }

    bool operator!=( PhysicalDeviceShaderSMBuiltinsPropertiesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType            = StructureType::ePhysicalDeviceShaderSmBuiltinsPropertiesNV;
    void *                              pNext            = {};
    uint32_t                            shaderSMCount    = {};
    uint32_t                            shaderWarpsPerSM = {};
  };
  static_assert( sizeof( PhysicalDeviceShaderSMBuiltinsPropertiesNV ) ==
                   sizeof( VkPhysicalDeviceShaderSMBuiltinsPropertiesNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceShaderSMBuiltinsPropertiesNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceShaderSmBuiltinsPropertiesNV>
  {
    using Type = PhysicalDeviceShaderSMBuiltinsPropertiesNV;
  };

  struct PhysicalDeviceShaderSubgroupExtendedTypesFeatures
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceShaderSubgroupExtendedTypesFeatures;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceShaderSubgroupExtendedTypesFeatures(
      VULKAN_HPP_NAMESPACE::Bool32 shaderSubgroupExtendedTypes_ = {} ) VULKAN_HPP_NOEXCEPT
      : shaderSubgroupExtendedTypes( shaderSubgroupExtendedTypes_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceShaderSubgroupExtendedTypesFeatures(
      PhysicalDeviceShaderSubgroupExtendedTypesFeatures const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceShaderSubgroupExtendedTypesFeatures( VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceShaderSubgroupExtendedTypesFeatures(
          *reinterpret_cast<PhysicalDeviceShaderSubgroupExtendedTypesFeatures const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceShaderSubgroupExtendedTypesFeatures &
                            operator=( PhysicalDeviceShaderSubgroupExtendedTypesFeatures const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceShaderSubgroupExtendedTypesFeatures &
      operator=( VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this =
        *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceShaderSubgroupExtendedTypesFeatures const *>( &rhs );
      return *this;
    }

    PhysicalDeviceShaderSubgroupExtendedTypesFeatures & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceShaderSubgroupExtendedTypesFeatures &
      setShaderSubgroupExtendedTypes( VULKAN_HPP_NAMESPACE::Bool32 shaderSubgroupExtendedTypes_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderSubgroupExtendedTypes = shaderSubgroupExtendedTypes_;
      return *this;
    }

    operator VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures *>( this );
    }

    operator VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceShaderSubgroupExtendedTypesFeatures const & ) const = default;
#else
    bool operator==( PhysicalDeviceShaderSubgroupExtendedTypesFeatures const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( shaderSubgroupExtendedTypes == rhs.shaderSubgroupExtendedTypes );
    }

    bool operator!=( PhysicalDeviceShaderSubgroupExtendedTypesFeatures const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceShaderSubgroupExtendedTypesFeatures;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderSubgroupExtendedTypes = {};
  };
  static_assert( sizeof( PhysicalDeviceShaderSubgroupExtendedTypesFeatures ) ==
                   sizeof( VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceShaderSubgroupExtendedTypesFeatures>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceShaderSubgroupExtendedTypesFeatures>
  {
    using Type = PhysicalDeviceShaderSubgroupExtendedTypesFeatures;
  };
  using PhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR = PhysicalDeviceShaderSubgroupExtendedTypesFeatures;

  struct PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR(
      VULKAN_HPP_NAMESPACE::Bool32 shaderSubgroupUniformControlFlow_ = {} ) VULKAN_HPP_NOEXCEPT
      : shaderSubgroupUniformControlFlow( shaderSubgroupUniformControlFlow_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR(
      PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR(
      VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR(
          *reinterpret_cast<PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR &
                            operator=( PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR &
      operator=( VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this =
        *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR const *>(
          &rhs );
      return *this;
    }

    PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR & setShaderSubgroupUniformControlFlow(
      VULKAN_HPP_NAMESPACE::Bool32 shaderSubgroupUniformControlFlow_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderSubgroupUniformControlFlow = shaderSubgroupUniformControlFlow_;
      return *this;
    }

    operator VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR *>( this );
    }

    operator VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR const & ) const = default;
#else
    bool operator==( PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( shaderSubgroupUniformControlFlow == rhs.shaderSubgroupUniformControlFlow );
    }

    bool operator!=( PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType =
      StructureType::ePhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR;
    void *                       pNext                            = {};
    VULKAN_HPP_NAMESPACE::Bool32 shaderSubgroupUniformControlFlow = {};
  };
  static_assert( sizeof( PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR ) ==
                   sizeof( VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR>
  {
    using Type = PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR;
  };

  struct PhysicalDeviceShaderTerminateInvocationFeaturesKHR
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceShaderTerminateInvocationFeaturesKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceShaderTerminateInvocationFeaturesKHR(
      VULKAN_HPP_NAMESPACE::Bool32 shaderTerminateInvocation_ = {} ) VULKAN_HPP_NOEXCEPT
      : shaderTerminateInvocation( shaderTerminateInvocation_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceShaderTerminateInvocationFeaturesKHR(
      PhysicalDeviceShaderTerminateInvocationFeaturesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceShaderTerminateInvocationFeaturesKHR(
      VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceShaderTerminateInvocationFeaturesKHR(
          *reinterpret_cast<PhysicalDeviceShaderTerminateInvocationFeaturesKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceShaderTerminateInvocationFeaturesKHR &
                            operator=( PhysicalDeviceShaderTerminateInvocationFeaturesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceShaderTerminateInvocationFeaturesKHR &
      operator=( VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this =
        *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceShaderTerminateInvocationFeaturesKHR const *>( &rhs );
      return *this;
    }

    PhysicalDeviceShaderTerminateInvocationFeaturesKHR & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceShaderTerminateInvocationFeaturesKHR &
      setShaderTerminateInvocation( VULKAN_HPP_NAMESPACE::Bool32 shaderTerminateInvocation_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderTerminateInvocation = shaderTerminateInvocation_;
      return *this;
    }

    operator VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR *>( this );
    }

    operator VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceShaderTerminateInvocationFeaturesKHR const & ) const = default;
#else
    bool operator==( PhysicalDeviceShaderTerminateInvocationFeaturesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( shaderTerminateInvocation == rhs.shaderTerminateInvocation );
    }

    bool operator!=( PhysicalDeviceShaderTerminateInvocationFeaturesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceShaderTerminateInvocationFeaturesKHR;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderTerminateInvocation = {};
  };
  static_assert( sizeof( PhysicalDeviceShaderTerminateInvocationFeaturesKHR ) ==
                   sizeof( VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceShaderTerminateInvocationFeaturesKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceShaderTerminateInvocationFeaturesKHR>
  {
    using Type = PhysicalDeviceShaderTerminateInvocationFeaturesKHR;
  };

  struct PhysicalDeviceShadingRateImageFeaturesNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceShadingRateImageFeaturesNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceShadingRateImageFeaturesNV(
      VULKAN_HPP_NAMESPACE::Bool32 shadingRateImage_             = {},
      VULKAN_HPP_NAMESPACE::Bool32 shadingRateCoarseSampleOrder_ = {} ) VULKAN_HPP_NOEXCEPT
      : shadingRateImage( shadingRateImage_ )
      , shadingRateCoarseSampleOrder( shadingRateCoarseSampleOrder_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceShadingRateImageFeaturesNV(
      PhysicalDeviceShadingRateImageFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceShadingRateImageFeaturesNV( VkPhysicalDeviceShadingRateImageFeaturesNV const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceShadingRateImageFeaturesNV(
          *reinterpret_cast<PhysicalDeviceShadingRateImageFeaturesNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceShadingRateImageFeaturesNV &
                            operator=( PhysicalDeviceShadingRateImageFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceShadingRateImageFeaturesNV &
      operator=( VkPhysicalDeviceShadingRateImageFeaturesNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceShadingRateImageFeaturesNV const *>( &rhs );
      return *this;
    }

    PhysicalDeviceShadingRateImageFeaturesNV & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceShadingRateImageFeaturesNV &
      setShadingRateImage( VULKAN_HPP_NAMESPACE::Bool32 shadingRateImage_ ) VULKAN_HPP_NOEXCEPT
    {
      shadingRateImage = shadingRateImage_;
      return *this;
    }

    PhysicalDeviceShadingRateImageFeaturesNV &
      setShadingRateCoarseSampleOrder( VULKAN_HPP_NAMESPACE::Bool32 shadingRateCoarseSampleOrder_ ) VULKAN_HPP_NOEXCEPT
    {
      shadingRateCoarseSampleOrder = shadingRateCoarseSampleOrder_;
      return *this;
    }

    operator VkPhysicalDeviceShadingRateImageFeaturesNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceShadingRateImageFeaturesNV *>( this );
    }

    operator VkPhysicalDeviceShadingRateImageFeaturesNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceShadingRateImageFeaturesNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceShadingRateImageFeaturesNV const & ) const = default;
#else
    bool operator==( PhysicalDeviceShadingRateImageFeaturesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( shadingRateImage == rhs.shadingRateImage ) &&
             ( shadingRateCoarseSampleOrder == rhs.shadingRateCoarseSampleOrder );
    }

    bool operator!=( PhysicalDeviceShadingRateImageFeaturesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType            = StructureType::ePhysicalDeviceShadingRateImageFeaturesNV;
    void *                              pNext            = {};
    VULKAN_HPP_NAMESPACE::Bool32        shadingRateImage = {};
    VULKAN_HPP_NAMESPACE::Bool32        shadingRateCoarseSampleOrder = {};
  };
  static_assert( sizeof( PhysicalDeviceShadingRateImageFeaturesNV ) ==
                   sizeof( VkPhysicalDeviceShadingRateImageFeaturesNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceShadingRateImageFeaturesNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceShadingRateImageFeaturesNV>
  {
    using Type = PhysicalDeviceShadingRateImageFeaturesNV;
  };

  struct PhysicalDeviceShadingRateImagePropertiesNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceShadingRateImagePropertiesNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      PhysicalDeviceShadingRateImagePropertiesNV( VULKAN_HPP_NAMESPACE::Extent2D shadingRateTexelSize_   = {},
                                                  uint32_t                       shadingRatePaletteSize_ = {},
                                                  uint32_t shadingRateMaxCoarseSamples_ = {} ) VULKAN_HPP_NOEXCEPT
      : shadingRateTexelSize( shadingRateTexelSize_ )
      , shadingRatePaletteSize( shadingRatePaletteSize_ )
      , shadingRateMaxCoarseSamples( shadingRateMaxCoarseSamples_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceShadingRateImagePropertiesNV(
      PhysicalDeviceShadingRateImagePropertiesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceShadingRateImagePropertiesNV( VkPhysicalDeviceShadingRateImagePropertiesNV const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceShadingRateImagePropertiesNV(
          *reinterpret_cast<PhysicalDeviceShadingRateImagePropertiesNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceShadingRateImagePropertiesNV &
                            operator=( PhysicalDeviceShadingRateImagePropertiesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceShadingRateImagePropertiesNV &
      operator=( VkPhysicalDeviceShadingRateImagePropertiesNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceShadingRateImagePropertiesNV const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceShadingRateImagePropertiesNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceShadingRateImagePropertiesNV *>( this );
    }

    operator VkPhysicalDeviceShadingRateImagePropertiesNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceShadingRateImagePropertiesNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceShadingRateImagePropertiesNV const & ) const = default;
#else
    bool operator==( PhysicalDeviceShadingRateImagePropertiesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( shadingRateTexelSize == rhs.shadingRateTexelSize ) &&
             ( shadingRatePaletteSize == rhs.shadingRatePaletteSize ) &&
             ( shadingRateMaxCoarseSamples == rhs.shadingRateMaxCoarseSamples );
    }

    bool operator!=( PhysicalDeviceShadingRateImagePropertiesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceShadingRateImagePropertiesNV;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Extent2D      shadingRateTexelSize        = {};
    uint32_t                            shadingRatePaletteSize      = {};
    uint32_t                            shadingRateMaxCoarseSamples = {};
  };
  static_assert( sizeof( PhysicalDeviceShadingRateImagePropertiesNV ) ==
                   sizeof( VkPhysicalDeviceShadingRateImagePropertiesNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceShadingRateImagePropertiesNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceShadingRateImagePropertiesNV>
  {
    using Type = PhysicalDeviceShadingRateImagePropertiesNV;
  };

  struct PhysicalDeviceSparseImageFormatInfo2
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceSparseImageFormatInfo2;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceSparseImageFormatInfo2(
      VULKAN_HPP_NAMESPACE::Format              format_  = VULKAN_HPP_NAMESPACE::Format::eUndefined,
      VULKAN_HPP_NAMESPACE::ImageType           type_    = VULKAN_HPP_NAMESPACE::ImageType::e1D,
      VULKAN_HPP_NAMESPACE::SampleCountFlagBits samples_ = VULKAN_HPP_NAMESPACE::SampleCountFlagBits::e1,
      VULKAN_HPP_NAMESPACE::ImageUsageFlags     usage_   = {},
      VULKAN_HPP_NAMESPACE::ImageTiling tiling_ = VULKAN_HPP_NAMESPACE::ImageTiling::eOptimal ) VULKAN_HPP_NOEXCEPT
      : format( format_ )
      , type( type_ )
      , samples( samples_ )
      , usage( usage_ )
      , tiling( tiling_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceSparseImageFormatInfo2( PhysicalDeviceSparseImageFormatInfo2 const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceSparseImageFormatInfo2( VkPhysicalDeviceSparseImageFormatInfo2 const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceSparseImageFormatInfo2( *reinterpret_cast<PhysicalDeviceSparseImageFormatInfo2 const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceSparseImageFormatInfo2 &
                            operator=( PhysicalDeviceSparseImageFormatInfo2 const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceSparseImageFormatInfo2 &
      operator=( VkPhysicalDeviceSparseImageFormatInfo2 const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceSparseImageFormatInfo2 const *>( &rhs );
      return *this;
    }

    PhysicalDeviceSparseImageFormatInfo2 & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceSparseImageFormatInfo2 & setFormat( VULKAN_HPP_NAMESPACE::Format format_ ) VULKAN_HPP_NOEXCEPT
    {
      format = format_;
      return *this;
    }

    PhysicalDeviceSparseImageFormatInfo2 & setType( VULKAN_HPP_NAMESPACE::ImageType type_ ) VULKAN_HPP_NOEXCEPT
    {
      type = type_;
      return *this;
    }

    PhysicalDeviceSparseImageFormatInfo2 &
      setSamples( VULKAN_HPP_NAMESPACE::SampleCountFlagBits samples_ ) VULKAN_HPP_NOEXCEPT
    {
      samples = samples_;
      return *this;
    }

    PhysicalDeviceSparseImageFormatInfo2 & setUsage( VULKAN_HPP_NAMESPACE::ImageUsageFlags usage_ ) VULKAN_HPP_NOEXCEPT
    {
      usage = usage_;
      return *this;
    }

    PhysicalDeviceSparseImageFormatInfo2 & setTiling( VULKAN_HPP_NAMESPACE::ImageTiling tiling_ ) VULKAN_HPP_NOEXCEPT
    {
      tiling = tiling_;
      return *this;
    }

    operator VkPhysicalDeviceSparseImageFormatInfo2 const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceSparseImageFormatInfo2 *>( this );
    }

    operator VkPhysicalDeviceSparseImageFormatInfo2 &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceSparseImageFormatInfo2 *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceSparseImageFormatInfo2 const & ) const = default;
#else
    bool operator==( PhysicalDeviceSparseImageFormatInfo2 const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( format == rhs.format ) && ( type == rhs.type ) &&
             ( samples == rhs.samples ) && ( usage == rhs.usage ) && ( tiling == rhs.tiling );
    }

    bool operator!=( PhysicalDeviceSparseImageFormatInfo2 const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType       sType   = StructureType::ePhysicalDeviceSparseImageFormatInfo2;
    const void *                              pNext   = {};
    VULKAN_HPP_NAMESPACE::Format              format  = VULKAN_HPP_NAMESPACE::Format::eUndefined;
    VULKAN_HPP_NAMESPACE::ImageType           type    = VULKAN_HPP_NAMESPACE::ImageType::e1D;
    VULKAN_HPP_NAMESPACE::SampleCountFlagBits samples = VULKAN_HPP_NAMESPACE::SampleCountFlagBits::e1;
    VULKAN_HPP_NAMESPACE::ImageUsageFlags     usage   = {};
    VULKAN_HPP_NAMESPACE::ImageTiling         tiling  = VULKAN_HPP_NAMESPACE::ImageTiling::eOptimal;
  };
  static_assert( sizeof( PhysicalDeviceSparseImageFormatInfo2 ) == sizeof( VkPhysicalDeviceSparseImageFormatInfo2 ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceSparseImageFormatInfo2>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceSparseImageFormatInfo2>
  {
    using Type = PhysicalDeviceSparseImageFormatInfo2;
  };
  using PhysicalDeviceSparseImageFormatInfo2KHR = PhysicalDeviceSparseImageFormatInfo2;

  struct PhysicalDeviceSubgroupProperties
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::ePhysicalDeviceSubgroupProperties;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceSubgroupProperties(
      uint32_t                                   subgroupSize_              = {},
      VULKAN_HPP_NAMESPACE::ShaderStageFlags     supportedStages_           = {},
      VULKAN_HPP_NAMESPACE::SubgroupFeatureFlags supportedOperations_       = {},
      VULKAN_HPP_NAMESPACE::Bool32               quadOperationsInAllStages_ = {} ) VULKAN_HPP_NOEXCEPT
      : subgroupSize( subgroupSize_ )
      , supportedStages( supportedStages_ )
      , supportedOperations( supportedOperations_ )
      , quadOperationsInAllStages( quadOperationsInAllStages_ )
    {}

    VULKAN_HPP_CONSTEXPR
      PhysicalDeviceSubgroupProperties( PhysicalDeviceSubgroupProperties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceSubgroupProperties( VkPhysicalDeviceSubgroupProperties const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceSubgroupProperties( *reinterpret_cast<PhysicalDeviceSubgroupProperties const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceSubgroupProperties &
                            operator=( PhysicalDeviceSubgroupProperties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceSubgroupProperties & operator=( VkPhysicalDeviceSubgroupProperties const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceSubgroupProperties const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceSubgroupProperties const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceSubgroupProperties *>( this );
    }

    operator VkPhysicalDeviceSubgroupProperties &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceSubgroupProperties *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceSubgroupProperties const & ) const = default;
#else
    bool operator==( PhysicalDeviceSubgroupProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( subgroupSize == rhs.subgroupSize ) &&
             ( supportedStages == rhs.supportedStages ) && ( supportedOperations == rhs.supportedOperations ) &&
             ( quadOperationsInAllStages == rhs.quadOperationsInAllStages );
    }

    bool operator!=( PhysicalDeviceSubgroupProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType        sType               = StructureType::ePhysicalDeviceSubgroupProperties;
    void *                                     pNext               = {};
    uint32_t                                   subgroupSize        = {};
    VULKAN_HPP_NAMESPACE::ShaderStageFlags     supportedStages     = {};
    VULKAN_HPP_NAMESPACE::SubgroupFeatureFlags supportedOperations = {};
    VULKAN_HPP_NAMESPACE::Bool32               quadOperationsInAllStages = {};
  };
  static_assert( sizeof( PhysicalDeviceSubgroupProperties ) == sizeof( VkPhysicalDeviceSubgroupProperties ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceSubgroupProperties>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceSubgroupProperties>
  {
    using Type = PhysicalDeviceSubgroupProperties;
  };

  struct PhysicalDeviceSubgroupSizeControlFeaturesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceSubgroupSizeControlFeaturesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceSubgroupSizeControlFeaturesEXT(
      VULKAN_HPP_NAMESPACE::Bool32 subgroupSizeControl_  = {},
      VULKAN_HPP_NAMESPACE::Bool32 computeFullSubgroups_ = {} ) VULKAN_HPP_NOEXCEPT
      : subgroupSizeControl( subgroupSizeControl_ )
      , computeFullSubgroups( computeFullSubgroups_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceSubgroupSizeControlFeaturesEXT(
      PhysicalDeviceSubgroupSizeControlFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceSubgroupSizeControlFeaturesEXT( VkPhysicalDeviceSubgroupSizeControlFeaturesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceSubgroupSizeControlFeaturesEXT(
          *reinterpret_cast<PhysicalDeviceSubgroupSizeControlFeaturesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceSubgroupSizeControlFeaturesEXT &
                            operator=( PhysicalDeviceSubgroupSizeControlFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceSubgroupSizeControlFeaturesEXT &
      operator=( VkPhysicalDeviceSubgroupSizeControlFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceSubgroupSizeControlFeaturesEXT const *>( &rhs );
      return *this;
    }

    PhysicalDeviceSubgroupSizeControlFeaturesEXT & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceSubgroupSizeControlFeaturesEXT &
      setSubgroupSizeControl( VULKAN_HPP_NAMESPACE::Bool32 subgroupSizeControl_ ) VULKAN_HPP_NOEXCEPT
    {
      subgroupSizeControl = subgroupSizeControl_;
      return *this;
    }

    PhysicalDeviceSubgroupSizeControlFeaturesEXT &
      setComputeFullSubgroups( VULKAN_HPP_NAMESPACE::Bool32 computeFullSubgroups_ ) VULKAN_HPP_NOEXCEPT
    {
      computeFullSubgroups = computeFullSubgroups_;
      return *this;
    }

    operator VkPhysicalDeviceSubgroupSizeControlFeaturesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceSubgroupSizeControlFeaturesEXT *>( this );
    }

    operator VkPhysicalDeviceSubgroupSizeControlFeaturesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceSubgroupSizeControlFeaturesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceSubgroupSizeControlFeaturesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceSubgroupSizeControlFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( subgroupSizeControl == rhs.subgroupSizeControl ) &&
             ( computeFullSubgroups == rhs.computeFullSubgroups );
    }

    bool operator!=( PhysicalDeviceSubgroupSizeControlFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceSubgroupSizeControlFeaturesEXT;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        subgroupSizeControl  = {};
    VULKAN_HPP_NAMESPACE::Bool32        computeFullSubgroups = {};
  };
  static_assert( sizeof( PhysicalDeviceSubgroupSizeControlFeaturesEXT ) ==
                   sizeof( VkPhysicalDeviceSubgroupSizeControlFeaturesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceSubgroupSizeControlFeaturesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceSubgroupSizeControlFeaturesEXT>
  {
    using Type = PhysicalDeviceSubgroupSizeControlFeaturesEXT;
  };

  struct PhysicalDeviceSubgroupSizeControlPropertiesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceSubgroupSizeControlPropertiesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceSubgroupSizeControlPropertiesEXT(
      uint32_t                               minSubgroupSize_              = {},
      uint32_t                               maxSubgroupSize_              = {},
      uint32_t                               maxComputeWorkgroupSubgroups_ = {},
      VULKAN_HPP_NAMESPACE::ShaderStageFlags requiredSubgroupSizeStages_   = {} ) VULKAN_HPP_NOEXCEPT
      : minSubgroupSize( minSubgroupSize_ )
      , maxSubgroupSize( maxSubgroupSize_ )
      , maxComputeWorkgroupSubgroups( maxComputeWorkgroupSubgroups_ )
      , requiredSubgroupSizeStages( requiredSubgroupSizeStages_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceSubgroupSizeControlPropertiesEXT(
      PhysicalDeviceSubgroupSizeControlPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceSubgroupSizeControlPropertiesEXT( VkPhysicalDeviceSubgroupSizeControlPropertiesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceSubgroupSizeControlPropertiesEXT(
          *reinterpret_cast<PhysicalDeviceSubgroupSizeControlPropertiesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceSubgroupSizeControlPropertiesEXT &
                            operator=( PhysicalDeviceSubgroupSizeControlPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceSubgroupSizeControlPropertiesEXT &
      operator=( VkPhysicalDeviceSubgroupSizeControlPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceSubgroupSizeControlPropertiesEXT const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceSubgroupSizeControlPropertiesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceSubgroupSizeControlPropertiesEXT *>( this );
    }

    operator VkPhysicalDeviceSubgroupSizeControlPropertiesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceSubgroupSizeControlPropertiesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceSubgroupSizeControlPropertiesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceSubgroupSizeControlPropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( minSubgroupSize == rhs.minSubgroupSize ) &&
             ( maxSubgroupSize == rhs.maxSubgroupSize ) &&
             ( maxComputeWorkgroupSubgroups == rhs.maxComputeWorkgroupSubgroups ) &&
             ( requiredSubgroupSizeStages == rhs.requiredSubgroupSizeStages );
    }

    bool operator!=( PhysicalDeviceSubgroupSizeControlPropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType    sType = StructureType::ePhysicalDeviceSubgroupSizeControlPropertiesEXT;
    void *                                 pNext = {};
    uint32_t                               minSubgroupSize              = {};
    uint32_t                               maxSubgroupSize              = {};
    uint32_t                               maxComputeWorkgroupSubgroups = {};
    VULKAN_HPP_NAMESPACE::ShaderStageFlags requiredSubgroupSizeStages   = {};
  };
  static_assert( sizeof( PhysicalDeviceSubgroupSizeControlPropertiesEXT ) ==
                   sizeof( VkPhysicalDeviceSubgroupSizeControlPropertiesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceSubgroupSizeControlPropertiesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceSubgroupSizeControlPropertiesEXT>
  {
    using Type = PhysicalDeviceSubgroupSizeControlPropertiesEXT;
  };

  struct PhysicalDeviceSubpassShadingFeaturesHUAWEI
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceSubpassShadingFeaturesHUAWEI;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceSubpassShadingFeaturesHUAWEI( VULKAN_HPP_NAMESPACE::Bool32 subpassShading_ = {} )
      VULKAN_HPP_NOEXCEPT : subpassShading( subpassShading_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceSubpassShadingFeaturesHUAWEI(
      PhysicalDeviceSubpassShadingFeaturesHUAWEI const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceSubpassShadingFeaturesHUAWEI( VkPhysicalDeviceSubpassShadingFeaturesHUAWEI const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceSubpassShadingFeaturesHUAWEI(
          *reinterpret_cast<PhysicalDeviceSubpassShadingFeaturesHUAWEI const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceSubpassShadingFeaturesHUAWEI &
                            operator=( PhysicalDeviceSubpassShadingFeaturesHUAWEI const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceSubpassShadingFeaturesHUAWEI &
      operator=( VkPhysicalDeviceSubpassShadingFeaturesHUAWEI const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceSubpassShadingFeaturesHUAWEI const *>( &rhs );
      return *this;
    }

    PhysicalDeviceSubpassShadingFeaturesHUAWEI & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceSubpassShadingFeaturesHUAWEI &
      setSubpassShading( VULKAN_HPP_NAMESPACE::Bool32 subpassShading_ ) VULKAN_HPP_NOEXCEPT
    {
      subpassShading = subpassShading_;
      return *this;
    }

    operator VkPhysicalDeviceSubpassShadingFeaturesHUAWEI const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceSubpassShadingFeaturesHUAWEI *>( this );
    }

    operator VkPhysicalDeviceSubpassShadingFeaturesHUAWEI &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceSubpassShadingFeaturesHUAWEI *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceSubpassShadingFeaturesHUAWEI const & ) const = default;
#else
    bool operator==( PhysicalDeviceSubpassShadingFeaturesHUAWEI const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( subpassShading == rhs.subpassShading );
    }

    bool operator!=( PhysicalDeviceSubpassShadingFeaturesHUAWEI const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType          = StructureType::ePhysicalDeviceSubpassShadingFeaturesHUAWEI;
    void *                              pNext          = {};
    VULKAN_HPP_NAMESPACE::Bool32        subpassShading = {};
  };
  static_assert( sizeof( PhysicalDeviceSubpassShadingFeaturesHUAWEI ) ==
                   sizeof( VkPhysicalDeviceSubpassShadingFeaturesHUAWEI ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceSubpassShadingFeaturesHUAWEI>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceSubpassShadingFeaturesHUAWEI>
  {
    using Type = PhysicalDeviceSubpassShadingFeaturesHUAWEI;
  };

  struct PhysicalDeviceSubpassShadingPropertiesHUAWEI
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceSubpassShadingPropertiesHUAWEI;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceSubpassShadingPropertiesHUAWEI(
      uint32_t maxSubpassShadingWorkgroupSizeAspectRatio_ = {} ) VULKAN_HPP_NOEXCEPT
      : maxSubpassShadingWorkgroupSizeAspectRatio( maxSubpassShadingWorkgroupSizeAspectRatio_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceSubpassShadingPropertiesHUAWEI(
      PhysicalDeviceSubpassShadingPropertiesHUAWEI const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceSubpassShadingPropertiesHUAWEI( VkPhysicalDeviceSubpassShadingPropertiesHUAWEI const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceSubpassShadingPropertiesHUAWEI(
          *reinterpret_cast<PhysicalDeviceSubpassShadingPropertiesHUAWEI const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceSubpassShadingPropertiesHUAWEI &
                            operator=( PhysicalDeviceSubpassShadingPropertiesHUAWEI const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceSubpassShadingPropertiesHUAWEI &
      operator=( VkPhysicalDeviceSubpassShadingPropertiesHUAWEI const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceSubpassShadingPropertiesHUAWEI const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceSubpassShadingPropertiesHUAWEI const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceSubpassShadingPropertiesHUAWEI *>( this );
    }

    operator VkPhysicalDeviceSubpassShadingPropertiesHUAWEI &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceSubpassShadingPropertiesHUAWEI *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceSubpassShadingPropertiesHUAWEI const & ) const = default;
#else
    bool operator==( PhysicalDeviceSubpassShadingPropertiesHUAWEI const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( maxSubpassShadingWorkgroupSizeAspectRatio == rhs.maxSubpassShadingWorkgroupSizeAspectRatio );
    }

    bool operator!=( PhysicalDeviceSubpassShadingPropertiesHUAWEI const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceSubpassShadingPropertiesHUAWEI;
    void *                              pNext = {};
    uint32_t                            maxSubpassShadingWorkgroupSizeAspectRatio = {};
  };
  static_assert( sizeof( PhysicalDeviceSubpassShadingPropertiesHUAWEI ) ==
                   sizeof( VkPhysicalDeviceSubpassShadingPropertiesHUAWEI ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceSubpassShadingPropertiesHUAWEI>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceSubpassShadingPropertiesHUAWEI>
  {
    using Type = PhysicalDeviceSubpassShadingPropertiesHUAWEI;
  };

  struct PhysicalDeviceSurfaceInfo2KHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::ePhysicalDeviceSurfaceInfo2KHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      PhysicalDeviceSurfaceInfo2KHR( VULKAN_HPP_NAMESPACE::SurfaceKHR surface_ = {} ) VULKAN_HPP_NOEXCEPT
      : surface( surface_ )
    {}

    VULKAN_HPP_CONSTEXPR
      PhysicalDeviceSurfaceInfo2KHR( PhysicalDeviceSurfaceInfo2KHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceSurfaceInfo2KHR( VkPhysicalDeviceSurfaceInfo2KHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceSurfaceInfo2KHR( *reinterpret_cast<PhysicalDeviceSurfaceInfo2KHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceSurfaceInfo2KHR &
                            operator=( PhysicalDeviceSurfaceInfo2KHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceSurfaceInfo2KHR & operator=( VkPhysicalDeviceSurfaceInfo2KHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceSurfaceInfo2KHR const *>( &rhs );
      return *this;
    }

    PhysicalDeviceSurfaceInfo2KHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceSurfaceInfo2KHR & setSurface( VULKAN_HPP_NAMESPACE::SurfaceKHR surface_ ) VULKAN_HPP_NOEXCEPT
    {
      surface = surface_;
      return *this;
    }

    operator VkPhysicalDeviceSurfaceInfo2KHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceSurfaceInfo2KHR *>( this );
    }

    operator VkPhysicalDeviceSurfaceInfo2KHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceSurfaceInfo2KHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceSurfaceInfo2KHR const & ) const = default;
#else
    bool operator==( PhysicalDeviceSurfaceInfo2KHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( surface == rhs.surface );
    }

    bool operator!=( PhysicalDeviceSurfaceInfo2KHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType   = StructureType::ePhysicalDeviceSurfaceInfo2KHR;
    const void *                        pNext   = {};
    VULKAN_HPP_NAMESPACE::SurfaceKHR    surface = {};
  };
  static_assert( sizeof( PhysicalDeviceSurfaceInfo2KHR ) == sizeof( VkPhysicalDeviceSurfaceInfo2KHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceSurfaceInfo2KHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceSurfaceInfo2KHR>
  {
    using Type = PhysicalDeviceSurfaceInfo2KHR;
  };

  struct PhysicalDeviceSynchronization2FeaturesKHR
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceSynchronization2FeaturesKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceSynchronization2FeaturesKHR(
      VULKAN_HPP_NAMESPACE::Bool32 synchronization2_ = {} ) VULKAN_HPP_NOEXCEPT : synchronization2( synchronization2_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceSynchronization2FeaturesKHR(
      PhysicalDeviceSynchronization2FeaturesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceSynchronization2FeaturesKHR( VkPhysicalDeviceSynchronization2FeaturesKHR const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceSynchronization2FeaturesKHR(
          *reinterpret_cast<PhysicalDeviceSynchronization2FeaturesKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceSynchronization2FeaturesKHR &
                            operator=( PhysicalDeviceSynchronization2FeaturesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceSynchronization2FeaturesKHR &
      operator=( VkPhysicalDeviceSynchronization2FeaturesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceSynchronization2FeaturesKHR const *>( &rhs );
      return *this;
    }

    PhysicalDeviceSynchronization2FeaturesKHR & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceSynchronization2FeaturesKHR &
      setSynchronization2( VULKAN_HPP_NAMESPACE::Bool32 synchronization2_ ) VULKAN_HPP_NOEXCEPT
    {
      synchronization2 = synchronization2_;
      return *this;
    }

    operator VkPhysicalDeviceSynchronization2FeaturesKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceSynchronization2FeaturesKHR *>( this );
    }

    operator VkPhysicalDeviceSynchronization2FeaturesKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceSynchronization2FeaturesKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceSynchronization2FeaturesKHR const & ) const = default;
#else
    bool operator==( PhysicalDeviceSynchronization2FeaturesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( synchronization2 == rhs.synchronization2 );
    }

    bool operator!=( PhysicalDeviceSynchronization2FeaturesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType            = StructureType::ePhysicalDeviceSynchronization2FeaturesKHR;
    void *                              pNext            = {};
    VULKAN_HPP_NAMESPACE::Bool32        synchronization2 = {};
  };
  static_assert( sizeof( PhysicalDeviceSynchronization2FeaturesKHR ) ==
                   sizeof( VkPhysicalDeviceSynchronization2FeaturesKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceSynchronization2FeaturesKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceSynchronization2FeaturesKHR>
  {
    using Type = PhysicalDeviceSynchronization2FeaturesKHR;
  };

  struct PhysicalDeviceTexelBufferAlignmentFeaturesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceTexelBufferAlignmentFeaturesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceTexelBufferAlignmentFeaturesEXT(
      VULKAN_HPP_NAMESPACE::Bool32 texelBufferAlignment_ = {} ) VULKAN_HPP_NOEXCEPT
      : texelBufferAlignment( texelBufferAlignment_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceTexelBufferAlignmentFeaturesEXT(
      PhysicalDeviceTexelBufferAlignmentFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceTexelBufferAlignmentFeaturesEXT( VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceTexelBufferAlignmentFeaturesEXT(
          *reinterpret_cast<PhysicalDeviceTexelBufferAlignmentFeaturesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceTexelBufferAlignmentFeaturesEXT &
                            operator=( PhysicalDeviceTexelBufferAlignmentFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceTexelBufferAlignmentFeaturesEXT &
      operator=( VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceTexelBufferAlignmentFeaturesEXT const *>( &rhs );
      return *this;
    }

    PhysicalDeviceTexelBufferAlignmentFeaturesEXT & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceTexelBufferAlignmentFeaturesEXT &
      setTexelBufferAlignment( VULKAN_HPP_NAMESPACE::Bool32 texelBufferAlignment_ ) VULKAN_HPP_NOEXCEPT
    {
      texelBufferAlignment = texelBufferAlignment_;
      return *this;
    }

    operator VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT *>( this );
    }

    operator VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceTexelBufferAlignmentFeaturesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceTexelBufferAlignmentFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( texelBufferAlignment == rhs.texelBufferAlignment );
    }

    bool operator!=( PhysicalDeviceTexelBufferAlignmentFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceTexelBufferAlignmentFeaturesEXT;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        texelBufferAlignment = {};
  };
  static_assert( sizeof( PhysicalDeviceTexelBufferAlignmentFeaturesEXT ) ==
                   sizeof( VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceTexelBufferAlignmentFeaturesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceTexelBufferAlignmentFeaturesEXT>
  {
    using Type = PhysicalDeviceTexelBufferAlignmentFeaturesEXT;
  };

  struct PhysicalDeviceTexelBufferAlignmentPropertiesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceTexelBufferAlignmentPropertiesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceTexelBufferAlignmentPropertiesEXT(
      VULKAN_HPP_NAMESPACE::DeviceSize storageTexelBufferOffsetAlignmentBytes_       = {},
      VULKAN_HPP_NAMESPACE::Bool32     storageTexelBufferOffsetSingleTexelAlignment_ = {},
      VULKAN_HPP_NAMESPACE::DeviceSize uniformTexelBufferOffsetAlignmentBytes_       = {},
      VULKAN_HPP_NAMESPACE::Bool32     uniformTexelBufferOffsetSingleTexelAlignment_ = {} ) VULKAN_HPP_NOEXCEPT
      : storageTexelBufferOffsetAlignmentBytes( storageTexelBufferOffsetAlignmentBytes_ )
      , storageTexelBufferOffsetSingleTexelAlignment( storageTexelBufferOffsetSingleTexelAlignment_ )
      , uniformTexelBufferOffsetAlignmentBytes( uniformTexelBufferOffsetAlignmentBytes_ )
      , uniformTexelBufferOffsetSingleTexelAlignment( uniformTexelBufferOffsetSingleTexelAlignment_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceTexelBufferAlignmentPropertiesEXT(
      PhysicalDeviceTexelBufferAlignmentPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceTexelBufferAlignmentPropertiesEXT( VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceTexelBufferAlignmentPropertiesEXT(
          *reinterpret_cast<PhysicalDeviceTexelBufferAlignmentPropertiesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceTexelBufferAlignmentPropertiesEXT &
                            operator=( PhysicalDeviceTexelBufferAlignmentPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceTexelBufferAlignmentPropertiesEXT &
      operator=( VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceTexelBufferAlignmentPropertiesEXT const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT *>( this );
    }

    operator VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceTexelBufferAlignmentPropertiesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceTexelBufferAlignmentPropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( storageTexelBufferOffsetAlignmentBytes == rhs.storageTexelBufferOffsetAlignmentBytes ) &&
             ( storageTexelBufferOffsetSingleTexelAlignment == rhs.storageTexelBufferOffsetSingleTexelAlignment ) &&
             ( uniformTexelBufferOffsetAlignmentBytes == rhs.uniformTexelBufferOffsetAlignmentBytes ) &&
             ( uniformTexelBufferOffsetSingleTexelAlignment == rhs.uniformTexelBufferOffsetSingleTexelAlignment );
    }

    bool operator!=( PhysicalDeviceTexelBufferAlignmentPropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceTexelBufferAlignmentPropertiesEXT;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::DeviceSize    storageTexelBufferOffsetAlignmentBytes       = {};
    VULKAN_HPP_NAMESPACE::Bool32        storageTexelBufferOffsetSingleTexelAlignment = {};
    VULKAN_HPP_NAMESPACE::DeviceSize    uniformTexelBufferOffsetAlignmentBytes       = {};
    VULKAN_HPP_NAMESPACE::Bool32        uniformTexelBufferOffsetSingleTexelAlignment = {};
  };
  static_assert( sizeof( PhysicalDeviceTexelBufferAlignmentPropertiesEXT ) ==
                   sizeof( VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceTexelBufferAlignmentPropertiesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceTexelBufferAlignmentPropertiesEXT>
  {
    using Type = PhysicalDeviceTexelBufferAlignmentPropertiesEXT;
  };

  struct PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceTextureCompressionAstcHdrFeaturesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT(
      VULKAN_HPP_NAMESPACE::Bool32 textureCompressionASTC_HDR_ = {} ) VULKAN_HPP_NOEXCEPT
      : textureCompressionASTC_HDR( textureCompressionASTC_HDR_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT(
      PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT(
      VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT(
          *reinterpret_cast<PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT &
                            operator=( PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT &
      operator=( VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this =
        *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT const *>( &rhs );
      return *this;
    }

    PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT &
      setTextureCompressionASTC_HDR( VULKAN_HPP_NAMESPACE::Bool32 textureCompressionASTC_HDR_ ) VULKAN_HPP_NOEXCEPT
    {
      textureCompressionASTC_HDR = textureCompressionASTC_HDR_;
      return *this;
    }

    operator VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT *>( this );
    }

    operator VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( textureCompressionASTC_HDR == rhs.textureCompressionASTC_HDR );
    }

    bool operator!=( PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceTextureCompressionAstcHdrFeaturesEXT;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        textureCompressionASTC_HDR = {};
  };
  static_assert( sizeof( PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT ) ==
                   sizeof( VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceTextureCompressionAstcHdrFeaturesEXT>
  {
    using Type = PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT;
  };

  struct PhysicalDeviceTimelineSemaphoreFeatures
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceTimelineSemaphoreFeatures;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceTimelineSemaphoreFeatures( VULKAN_HPP_NAMESPACE::Bool32 timelineSemaphore_ = {} )
      VULKAN_HPP_NOEXCEPT : timelineSemaphore( timelineSemaphore_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceTimelineSemaphoreFeatures( PhysicalDeviceTimelineSemaphoreFeatures const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceTimelineSemaphoreFeatures( VkPhysicalDeviceTimelineSemaphoreFeatures const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceTimelineSemaphoreFeatures(
          *reinterpret_cast<PhysicalDeviceTimelineSemaphoreFeatures const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceTimelineSemaphoreFeatures &
                            operator=( PhysicalDeviceTimelineSemaphoreFeatures const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceTimelineSemaphoreFeatures &
      operator=( VkPhysicalDeviceTimelineSemaphoreFeatures const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceTimelineSemaphoreFeatures const *>( &rhs );
      return *this;
    }

    PhysicalDeviceTimelineSemaphoreFeatures & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceTimelineSemaphoreFeatures &
      setTimelineSemaphore( VULKAN_HPP_NAMESPACE::Bool32 timelineSemaphore_ ) VULKAN_HPP_NOEXCEPT
    {
      timelineSemaphore = timelineSemaphore_;
      return *this;
    }

    operator VkPhysicalDeviceTimelineSemaphoreFeatures const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceTimelineSemaphoreFeatures *>( this );
    }

    operator VkPhysicalDeviceTimelineSemaphoreFeatures &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceTimelineSemaphoreFeatures *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceTimelineSemaphoreFeatures const & ) const = default;
#else
    bool operator==( PhysicalDeviceTimelineSemaphoreFeatures const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( timelineSemaphore == rhs.timelineSemaphore );
    }

    bool operator!=( PhysicalDeviceTimelineSemaphoreFeatures const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType             = StructureType::ePhysicalDeviceTimelineSemaphoreFeatures;
    void *                              pNext             = {};
    VULKAN_HPP_NAMESPACE::Bool32        timelineSemaphore = {};
  };
  static_assert( sizeof( PhysicalDeviceTimelineSemaphoreFeatures ) ==
                   sizeof( VkPhysicalDeviceTimelineSemaphoreFeatures ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceTimelineSemaphoreFeatures>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceTimelineSemaphoreFeatures>
  {
    using Type = PhysicalDeviceTimelineSemaphoreFeatures;
  };
  using PhysicalDeviceTimelineSemaphoreFeaturesKHR = PhysicalDeviceTimelineSemaphoreFeatures;

  struct PhysicalDeviceTimelineSemaphoreProperties
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceTimelineSemaphoreProperties;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceTimelineSemaphoreProperties( uint64_t maxTimelineSemaphoreValueDifference_ = {} )
      VULKAN_HPP_NOEXCEPT : maxTimelineSemaphoreValueDifference( maxTimelineSemaphoreValueDifference_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceTimelineSemaphoreProperties(
      PhysicalDeviceTimelineSemaphoreProperties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceTimelineSemaphoreProperties( VkPhysicalDeviceTimelineSemaphoreProperties const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceTimelineSemaphoreProperties(
          *reinterpret_cast<PhysicalDeviceTimelineSemaphoreProperties const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceTimelineSemaphoreProperties &
                            operator=( PhysicalDeviceTimelineSemaphoreProperties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceTimelineSemaphoreProperties &
      operator=( VkPhysicalDeviceTimelineSemaphoreProperties const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceTimelineSemaphoreProperties const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceTimelineSemaphoreProperties const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceTimelineSemaphoreProperties *>( this );
    }

    operator VkPhysicalDeviceTimelineSemaphoreProperties &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceTimelineSemaphoreProperties *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceTimelineSemaphoreProperties const & ) const = default;
#else
    bool operator==( PhysicalDeviceTimelineSemaphoreProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( maxTimelineSemaphoreValueDifference == rhs.maxTimelineSemaphoreValueDifference );
    }

    bool operator!=( PhysicalDeviceTimelineSemaphoreProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceTimelineSemaphoreProperties;
    void *                              pNext = {};
    uint64_t                            maxTimelineSemaphoreValueDifference = {};
  };
  static_assert( sizeof( PhysicalDeviceTimelineSemaphoreProperties ) ==
                   sizeof( VkPhysicalDeviceTimelineSemaphoreProperties ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceTimelineSemaphoreProperties>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceTimelineSemaphoreProperties>
  {
    using Type = PhysicalDeviceTimelineSemaphoreProperties;
  };
  using PhysicalDeviceTimelineSemaphorePropertiesKHR = PhysicalDeviceTimelineSemaphoreProperties;

  struct PhysicalDeviceToolPropertiesEXT
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::ePhysicalDeviceToolPropertiesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceToolPropertiesEXT(
      std::array<char, VK_MAX_EXTENSION_NAME_SIZE> const & name_        = {},
      std::array<char, VK_MAX_EXTENSION_NAME_SIZE> const & version_     = {},
      VULKAN_HPP_NAMESPACE::ToolPurposeFlagsEXT            purposes_    = {},
      std::array<char, VK_MAX_DESCRIPTION_SIZE> const &    description_ = {},
      std::array<char, VK_MAX_EXTENSION_NAME_SIZE> const & layer_       = {} ) VULKAN_HPP_NOEXCEPT
      : name( name_ )
      , version( version_ )
      , purposes( purposes_ )
      , description( description_ )
      , layer( layer_ )
    {}

    VULKAN_HPP_CONSTEXPR_14
      PhysicalDeviceToolPropertiesEXT( PhysicalDeviceToolPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceToolPropertiesEXT( VkPhysicalDeviceToolPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceToolPropertiesEXT( *reinterpret_cast<PhysicalDeviceToolPropertiesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceToolPropertiesEXT &
                            operator=( PhysicalDeviceToolPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceToolPropertiesEXT & operator=( VkPhysicalDeviceToolPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceToolPropertiesEXT const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceToolPropertiesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceToolPropertiesEXT *>( this );
    }

    operator VkPhysicalDeviceToolPropertiesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceToolPropertiesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceToolPropertiesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceToolPropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( name == rhs.name ) && ( version == rhs.version ) &&
             ( purposes == rhs.purposes ) && ( description == rhs.description ) && ( layer == rhs.layer );
    }

    bool operator!=( PhysicalDeviceToolPropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceToolPropertiesEXT;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<char, VK_MAX_EXTENSION_NAME_SIZE> name        = {};
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<char, VK_MAX_EXTENSION_NAME_SIZE> version     = {};
    VULKAN_HPP_NAMESPACE::ToolPurposeFlagsEXT                              purposes    = {};
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<char, VK_MAX_DESCRIPTION_SIZE>    description = {};
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<char, VK_MAX_EXTENSION_NAME_SIZE> layer       = {};
  };
  static_assert( sizeof( PhysicalDeviceToolPropertiesEXT ) == sizeof( VkPhysicalDeviceToolPropertiesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceToolPropertiesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceToolPropertiesEXT>
  {
    using Type = PhysicalDeviceToolPropertiesEXT;
  };

  struct PhysicalDeviceTransformFeedbackFeaturesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceTransformFeedbackFeaturesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceTransformFeedbackFeaturesEXT(
      VULKAN_HPP_NAMESPACE::Bool32 transformFeedback_ = {},
      VULKAN_HPP_NAMESPACE::Bool32 geometryStreams_   = {} ) VULKAN_HPP_NOEXCEPT
      : transformFeedback( transformFeedback_ )
      , geometryStreams( geometryStreams_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceTransformFeedbackFeaturesEXT(
      PhysicalDeviceTransformFeedbackFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceTransformFeedbackFeaturesEXT( VkPhysicalDeviceTransformFeedbackFeaturesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceTransformFeedbackFeaturesEXT(
          *reinterpret_cast<PhysicalDeviceTransformFeedbackFeaturesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceTransformFeedbackFeaturesEXT &
                            operator=( PhysicalDeviceTransformFeedbackFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceTransformFeedbackFeaturesEXT &
      operator=( VkPhysicalDeviceTransformFeedbackFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceTransformFeedbackFeaturesEXT const *>( &rhs );
      return *this;
    }

    PhysicalDeviceTransformFeedbackFeaturesEXT & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceTransformFeedbackFeaturesEXT &
      setTransformFeedback( VULKAN_HPP_NAMESPACE::Bool32 transformFeedback_ ) VULKAN_HPP_NOEXCEPT
    {
      transformFeedback = transformFeedback_;
      return *this;
    }

    PhysicalDeviceTransformFeedbackFeaturesEXT &
      setGeometryStreams( VULKAN_HPP_NAMESPACE::Bool32 geometryStreams_ ) VULKAN_HPP_NOEXCEPT
    {
      geometryStreams = geometryStreams_;
      return *this;
    }

    operator VkPhysicalDeviceTransformFeedbackFeaturesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceTransformFeedbackFeaturesEXT *>( this );
    }

    operator VkPhysicalDeviceTransformFeedbackFeaturesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceTransformFeedbackFeaturesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceTransformFeedbackFeaturesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceTransformFeedbackFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( transformFeedback == rhs.transformFeedback ) &&
             ( geometryStreams == rhs.geometryStreams );
    }

    bool operator!=( PhysicalDeviceTransformFeedbackFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType             = StructureType::ePhysicalDeviceTransformFeedbackFeaturesEXT;
    void *                              pNext             = {};
    VULKAN_HPP_NAMESPACE::Bool32        transformFeedback = {};
    VULKAN_HPP_NAMESPACE::Bool32        geometryStreams   = {};
  };
  static_assert( sizeof( PhysicalDeviceTransformFeedbackFeaturesEXT ) ==
                   sizeof( VkPhysicalDeviceTransformFeedbackFeaturesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceTransformFeedbackFeaturesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceTransformFeedbackFeaturesEXT>
  {
    using Type = PhysicalDeviceTransformFeedbackFeaturesEXT;
  };

  struct PhysicalDeviceTransformFeedbackPropertiesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceTransformFeedbackPropertiesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceTransformFeedbackPropertiesEXT(
      uint32_t                         maxTransformFeedbackStreams_                = {},
      uint32_t                         maxTransformFeedbackBuffers_                = {},
      VULKAN_HPP_NAMESPACE::DeviceSize maxTransformFeedbackBufferSize_             = {},
      uint32_t                         maxTransformFeedbackStreamDataSize_         = {},
      uint32_t                         maxTransformFeedbackBufferDataSize_         = {},
      uint32_t                         maxTransformFeedbackBufferDataStride_       = {},
      VULKAN_HPP_NAMESPACE::Bool32     transformFeedbackQueries_                   = {},
      VULKAN_HPP_NAMESPACE::Bool32     transformFeedbackStreamsLinesTriangles_     = {},
      VULKAN_HPP_NAMESPACE::Bool32     transformFeedbackRasterizationStreamSelect_ = {},
      VULKAN_HPP_NAMESPACE::Bool32     transformFeedbackDraw_                      = {} ) VULKAN_HPP_NOEXCEPT
      : maxTransformFeedbackStreams( maxTransformFeedbackStreams_ )
      , maxTransformFeedbackBuffers( maxTransformFeedbackBuffers_ )
      , maxTransformFeedbackBufferSize( maxTransformFeedbackBufferSize_ )
      , maxTransformFeedbackStreamDataSize( maxTransformFeedbackStreamDataSize_ )
      , maxTransformFeedbackBufferDataSize( maxTransformFeedbackBufferDataSize_ )
      , maxTransformFeedbackBufferDataStride( maxTransformFeedbackBufferDataStride_ )
      , transformFeedbackQueries( transformFeedbackQueries_ )
      , transformFeedbackStreamsLinesTriangles( transformFeedbackStreamsLinesTriangles_ )
      , transformFeedbackRasterizationStreamSelect( transformFeedbackRasterizationStreamSelect_ )
      , transformFeedbackDraw( transformFeedbackDraw_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceTransformFeedbackPropertiesEXT(
      PhysicalDeviceTransformFeedbackPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceTransformFeedbackPropertiesEXT( VkPhysicalDeviceTransformFeedbackPropertiesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceTransformFeedbackPropertiesEXT(
          *reinterpret_cast<PhysicalDeviceTransformFeedbackPropertiesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceTransformFeedbackPropertiesEXT &
                            operator=( PhysicalDeviceTransformFeedbackPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceTransformFeedbackPropertiesEXT &
      operator=( VkPhysicalDeviceTransformFeedbackPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceTransformFeedbackPropertiesEXT const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceTransformFeedbackPropertiesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceTransformFeedbackPropertiesEXT *>( this );
    }

    operator VkPhysicalDeviceTransformFeedbackPropertiesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceTransformFeedbackPropertiesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceTransformFeedbackPropertiesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceTransformFeedbackPropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( maxTransformFeedbackStreams == rhs.maxTransformFeedbackStreams ) &&
             ( maxTransformFeedbackBuffers == rhs.maxTransformFeedbackBuffers ) &&
             ( maxTransformFeedbackBufferSize == rhs.maxTransformFeedbackBufferSize ) &&
             ( maxTransformFeedbackStreamDataSize == rhs.maxTransformFeedbackStreamDataSize ) &&
             ( maxTransformFeedbackBufferDataSize == rhs.maxTransformFeedbackBufferDataSize ) &&
             ( maxTransformFeedbackBufferDataStride == rhs.maxTransformFeedbackBufferDataStride ) &&
             ( transformFeedbackQueries == rhs.transformFeedbackQueries ) &&
             ( transformFeedbackStreamsLinesTriangles == rhs.transformFeedbackStreamsLinesTriangles ) &&
             ( transformFeedbackRasterizationStreamSelect == rhs.transformFeedbackRasterizationStreamSelect ) &&
             ( transformFeedbackDraw == rhs.transformFeedbackDraw );
    }

    bool operator!=( PhysicalDeviceTransformFeedbackPropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceTransformFeedbackPropertiesEXT;
    void *                              pNext = {};
    uint32_t                            maxTransformFeedbackStreams                = {};
    uint32_t                            maxTransformFeedbackBuffers                = {};
    VULKAN_HPP_NAMESPACE::DeviceSize    maxTransformFeedbackBufferSize             = {};
    uint32_t                            maxTransformFeedbackStreamDataSize         = {};
    uint32_t                            maxTransformFeedbackBufferDataSize         = {};
    uint32_t                            maxTransformFeedbackBufferDataStride       = {};
    VULKAN_HPP_NAMESPACE::Bool32        transformFeedbackQueries                   = {};
    VULKAN_HPP_NAMESPACE::Bool32        transformFeedbackStreamsLinesTriangles     = {};
    VULKAN_HPP_NAMESPACE::Bool32        transformFeedbackRasterizationStreamSelect = {};
    VULKAN_HPP_NAMESPACE::Bool32        transformFeedbackDraw                      = {};
  };
  static_assert( sizeof( PhysicalDeviceTransformFeedbackPropertiesEXT ) ==
                   sizeof( VkPhysicalDeviceTransformFeedbackPropertiesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceTransformFeedbackPropertiesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceTransformFeedbackPropertiesEXT>
  {
    using Type = PhysicalDeviceTransformFeedbackPropertiesEXT;
  };

  struct PhysicalDeviceUniformBufferStandardLayoutFeatures
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceUniformBufferStandardLayoutFeatures;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceUniformBufferStandardLayoutFeatures(
      VULKAN_HPP_NAMESPACE::Bool32 uniformBufferStandardLayout_ = {} ) VULKAN_HPP_NOEXCEPT
      : uniformBufferStandardLayout( uniformBufferStandardLayout_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceUniformBufferStandardLayoutFeatures(
      PhysicalDeviceUniformBufferStandardLayoutFeatures const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceUniformBufferStandardLayoutFeatures( VkPhysicalDeviceUniformBufferStandardLayoutFeatures const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceUniformBufferStandardLayoutFeatures(
          *reinterpret_cast<PhysicalDeviceUniformBufferStandardLayoutFeatures const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceUniformBufferStandardLayoutFeatures &
                            operator=( PhysicalDeviceUniformBufferStandardLayoutFeatures const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceUniformBufferStandardLayoutFeatures &
      operator=( VkPhysicalDeviceUniformBufferStandardLayoutFeatures const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this =
        *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceUniformBufferStandardLayoutFeatures const *>( &rhs );
      return *this;
    }

    PhysicalDeviceUniformBufferStandardLayoutFeatures & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceUniformBufferStandardLayoutFeatures &
      setUniformBufferStandardLayout( VULKAN_HPP_NAMESPACE::Bool32 uniformBufferStandardLayout_ ) VULKAN_HPP_NOEXCEPT
    {
      uniformBufferStandardLayout = uniformBufferStandardLayout_;
      return *this;
    }

    operator VkPhysicalDeviceUniformBufferStandardLayoutFeatures const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceUniformBufferStandardLayoutFeatures *>( this );
    }

    operator VkPhysicalDeviceUniformBufferStandardLayoutFeatures &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceUniformBufferStandardLayoutFeatures *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceUniformBufferStandardLayoutFeatures const & ) const = default;
#else
    bool operator==( PhysicalDeviceUniformBufferStandardLayoutFeatures const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( uniformBufferStandardLayout == rhs.uniformBufferStandardLayout );
    }

    bool operator!=( PhysicalDeviceUniformBufferStandardLayoutFeatures const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceUniformBufferStandardLayoutFeatures;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        uniformBufferStandardLayout = {};
  };
  static_assert( sizeof( PhysicalDeviceUniformBufferStandardLayoutFeatures ) ==
                   sizeof( VkPhysicalDeviceUniformBufferStandardLayoutFeatures ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceUniformBufferStandardLayoutFeatures>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceUniformBufferStandardLayoutFeatures>
  {
    using Type = PhysicalDeviceUniformBufferStandardLayoutFeatures;
  };
  using PhysicalDeviceUniformBufferStandardLayoutFeaturesKHR = PhysicalDeviceUniformBufferStandardLayoutFeatures;

  struct PhysicalDeviceVariablePointersFeatures
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceVariablePointersFeatures;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      PhysicalDeviceVariablePointersFeatures( VULKAN_HPP_NAMESPACE::Bool32 variablePointersStorageBuffer_ = {},
                                              VULKAN_HPP_NAMESPACE::Bool32 variablePointers_ = {} ) VULKAN_HPP_NOEXCEPT
      : variablePointersStorageBuffer( variablePointersStorageBuffer_ )
      , variablePointers( variablePointers_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceVariablePointersFeatures( PhysicalDeviceVariablePointersFeatures const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceVariablePointersFeatures( VkPhysicalDeviceVariablePointersFeatures const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceVariablePointersFeatures(
          *reinterpret_cast<PhysicalDeviceVariablePointersFeatures const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceVariablePointersFeatures &
                            operator=( PhysicalDeviceVariablePointersFeatures const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceVariablePointersFeatures &
      operator=( VkPhysicalDeviceVariablePointersFeatures const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceVariablePointersFeatures const *>( &rhs );
      return *this;
    }

    PhysicalDeviceVariablePointersFeatures & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceVariablePointersFeatures & setVariablePointersStorageBuffer(
      VULKAN_HPP_NAMESPACE::Bool32 variablePointersStorageBuffer_ ) VULKAN_HPP_NOEXCEPT
    {
      variablePointersStorageBuffer = variablePointersStorageBuffer_;
      return *this;
    }

    PhysicalDeviceVariablePointersFeatures &
      setVariablePointers( VULKAN_HPP_NAMESPACE::Bool32 variablePointers_ ) VULKAN_HPP_NOEXCEPT
    {
      variablePointers = variablePointers_;
      return *this;
    }

    operator VkPhysicalDeviceVariablePointersFeatures const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceVariablePointersFeatures *>( this );
    }

    operator VkPhysicalDeviceVariablePointersFeatures &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceVariablePointersFeatures *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceVariablePointersFeatures const & ) const = default;
#else
    bool operator==( PhysicalDeviceVariablePointersFeatures const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( variablePointersStorageBuffer == rhs.variablePointersStorageBuffer ) &&
             ( variablePointers == rhs.variablePointers );
    }

    bool operator!=( PhysicalDeviceVariablePointersFeatures const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceVariablePointersFeatures;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        variablePointersStorageBuffer = {};
    VULKAN_HPP_NAMESPACE::Bool32        variablePointers              = {};
  };
  static_assert( sizeof( PhysicalDeviceVariablePointersFeatures ) == sizeof( VkPhysicalDeviceVariablePointersFeatures ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceVariablePointersFeatures>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceVariablePointersFeatures>
  {
    using Type = PhysicalDeviceVariablePointersFeatures;
  };
  using PhysicalDeviceVariablePointerFeatures     = PhysicalDeviceVariablePointersFeatures;
  using PhysicalDeviceVariablePointerFeaturesKHR  = PhysicalDeviceVariablePointersFeatures;
  using PhysicalDeviceVariablePointersFeaturesKHR = PhysicalDeviceVariablePointersFeatures;

  struct PhysicalDeviceVertexAttributeDivisorFeaturesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceVertexAttributeDivisorFeaturesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceVertexAttributeDivisorFeaturesEXT(
      VULKAN_HPP_NAMESPACE::Bool32 vertexAttributeInstanceRateDivisor_     = {},
      VULKAN_HPP_NAMESPACE::Bool32 vertexAttributeInstanceRateZeroDivisor_ = {} ) VULKAN_HPP_NOEXCEPT
      : vertexAttributeInstanceRateDivisor( vertexAttributeInstanceRateDivisor_ )
      , vertexAttributeInstanceRateZeroDivisor( vertexAttributeInstanceRateZeroDivisor_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceVertexAttributeDivisorFeaturesEXT(
      PhysicalDeviceVertexAttributeDivisorFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceVertexAttributeDivisorFeaturesEXT( VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceVertexAttributeDivisorFeaturesEXT(
          *reinterpret_cast<PhysicalDeviceVertexAttributeDivisorFeaturesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceVertexAttributeDivisorFeaturesEXT &
                            operator=( PhysicalDeviceVertexAttributeDivisorFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceVertexAttributeDivisorFeaturesEXT &
      operator=( VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceVertexAttributeDivisorFeaturesEXT const *>( &rhs );
      return *this;
    }

    PhysicalDeviceVertexAttributeDivisorFeaturesEXT & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceVertexAttributeDivisorFeaturesEXT & setVertexAttributeInstanceRateDivisor(
      VULKAN_HPP_NAMESPACE::Bool32 vertexAttributeInstanceRateDivisor_ ) VULKAN_HPP_NOEXCEPT
    {
      vertexAttributeInstanceRateDivisor = vertexAttributeInstanceRateDivisor_;
      return *this;
    }

    PhysicalDeviceVertexAttributeDivisorFeaturesEXT & setVertexAttributeInstanceRateZeroDivisor(
      VULKAN_HPP_NAMESPACE::Bool32 vertexAttributeInstanceRateZeroDivisor_ ) VULKAN_HPP_NOEXCEPT
    {
      vertexAttributeInstanceRateZeroDivisor = vertexAttributeInstanceRateZeroDivisor_;
      return *this;
    }

    operator VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT *>( this );
    }

    operator VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceVertexAttributeDivisorFeaturesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceVertexAttributeDivisorFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( vertexAttributeInstanceRateDivisor == rhs.vertexAttributeInstanceRateDivisor ) &&
             ( vertexAttributeInstanceRateZeroDivisor == rhs.vertexAttributeInstanceRateZeroDivisor );
    }

    bool operator!=( PhysicalDeviceVertexAttributeDivisorFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceVertexAttributeDivisorFeaturesEXT;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        vertexAttributeInstanceRateDivisor     = {};
    VULKAN_HPP_NAMESPACE::Bool32        vertexAttributeInstanceRateZeroDivisor = {};
  };
  static_assert( sizeof( PhysicalDeviceVertexAttributeDivisorFeaturesEXT ) ==
                   sizeof( VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceVertexAttributeDivisorFeaturesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceVertexAttributeDivisorFeaturesEXT>
  {
    using Type = PhysicalDeviceVertexAttributeDivisorFeaturesEXT;
  };

  struct PhysicalDeviceVertexAttributeDivisorPropertiesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceVertexAttributeDivisorPropertiesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      PhysicalDeviceVertexAttributeDivisorPropertiesEXT( uint32_t maxVertexAttribDivisor_ = {} ) VULKAN_HPP_NOEXCEPT
      : maxVertexAttribDivisor( maxVertexAttribDivisor_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceVertexAttributeDivisorPropertiesEXT(
      PhysicalDeviceVertexAttributeDivisorPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceVertexAttributeDivisorPropertiesEXT( VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceVertexAttributeDivisorPropertiesEXT(
          *reinterpret_cast<PhysicalDeviceVertexAttributeDivisorPropertiesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceVertexAttributeDivisorPropertiesEXT &
                            operator=( PhysicalDeviceVertexAttributeDivisorPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceVertexAttributeDivisorPropertiesEXT &
      operator=( VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this =
        *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceVertexAttributeDivisorPropertiesEXT const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT *>( this );
    }

    operator VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceVertexAttributeDivisorPropertiesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceVertexAttributeDivisorPropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( maxVertexAttribDivisor == rhs.maxVertexAttribDivisor );
    }

    bool operator!=( PhysicalDeviceVertexAttributeDivisorPropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceVertexAttributeDivisorPropertiesEXT;
    void *                              pNext = {};
    uint32_t                            maxVertexAttribDivisor = {};
  };
  static_assert( sizeof( PhysicalDeviceVertexAttributeDivisorPropertiesEXT ) ==
                   sizeof( VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceVertexAttributeDivisorPropertiesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceVertexAttributeDivisorPropertiesEXT>
  {
    using Type = PhysicalDeviceVertexAttributeDivisorPropertiesEXT;
  };

  struct PhysicalDeviceVertexInputDynamicStateFeaturesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceVertexInputDynamicStateFeaturesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceVertexInputDynamicStateFeaturesEXT(
      VULKAN_HPP_NAMESPACE::Bool32 vertexInputDynamicState_ = {} ) VULKAN_HPP_NOEXCEPT
      : vertexInputDynamicState( vertexInputDynamicState_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceVertexInputDynamicStateFeaturesEXT(
      PhysicalDeviceVertexInputDynamicStateFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceVertexInputDynamicStateFeaturesEXT( VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceVertexInputDynamicStateFeaturesEXT(
          *reinterpret_cast<PhysicalDeviceVertexInputDynamicStateFeaturesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceVertexInputDynamicStateFeaturesEXT &
                            operator=( PhysicalDeviceVertexInputDynamicStateFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceVertexInputDynamicStateFeaturesEXT &
      operator=( VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceVertexInputDynamicStateFeaturesEXT const *>( &rhs );
      return *this;
    }

    PhysicalDeviceVertexInputDynamicStateFeaturesEXT & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceVertexInputDynamicStateFeaturesEXT &
      setVertexInputDynamicState( VULKAN_HPP_NAMESPACE::Bool32 vertexInputDynamicState_ ) VULKAN_HPP_NOEXCEPT
    {
      vertexInputDynamicState = vertexInputDynamicState_;
      return *this;
    }

    operator VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT *>( this );
    }

    operator VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceVertexInputDynamicStateFeaturesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceVertexInputDynamicStateFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( vertexInputDynamicState == rhs.vertexInputDynamicState );
    }

    bool operator!=( PhysicalDeviceVertexInputDynamicStateFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceVertexInputDynamicStateFeaturesEXT;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        vertexInputDynamicState = {};
  };
  static_assert( sizeof( PhysicalDeviceVertexInputDynamicStateFeaturesEXT ) ==
                   sizeof( VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceVertexInputDynamicStateFeaturesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceVertexInputDynamicStateFeaturesEXT>
  {
    using Type = PhysicalDeviceVertexInputDynamicStateFeaturesEXT;
  };

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  struct VideoProfileKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eVideoProfileKHR;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      VideoProfileKHR( VULKAN_HPP_NAMESPACE::VideoCodecOperationFlagBitsKHR videoCodecOperation_ =
                         VULKAN_HPP_NAMESPACE::VideoCodecOperationFlagBitsKHR::eInvalid,
                       VULKAN_HPP_NAMESPACE::VideoChromaSubsamplingFlagsKHR chromaSubsampling_ = {},
                       VULKAN_HPP_NAMESPACE::VideoComponentBitDepthFlagsKHR lumaBitDepth_      = {},
                       VULKAN_HPP_NAMESPACE::VideoComponentBitDepthFlagsKHR chromaBitDepth_ = {} ) VULKAN_HPP_NOEXCEPT
      : videoCodecOperation( videoCodecOperation_ )
      , chromaSubsampling( chromaSubsampling_ )
      , lumaBitDepth( lumaBitDepth_ )
      , chromaBitDepth( chromaBitDepth_ )
    {}

    VULKAN_HPP_CONSTEXPR VideoProfileKHR( VideoProfileKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoProfileKHR( VkVideoProfileKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : VideoProfileKHR( *reinterpret_cast<VideoProfileKHR const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 VideoProfileKHR & operator=( VideoProfileKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoProfileKHR & operator=( VkVideoProfileKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::VideoProfileKHR const *>( &rhs );
      return *this;
    }

    VideoProfileKHR & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    VideoProfileKHR & setVideoCodecOperation(
      VULKAN_HPP_NAMESPACE::VideoCodecOperationFlagBitsKHR videoCodecOperation_ ) VULKAN_HPP_NOEXCEPT
    {
      videoCodecOperation = videoCodecOperation_;
      return *this;
    }

    VideoProfileKHR & setChromaSubsampling( VULKAN_HPP_NAMESPACE::VideoChromaSubsamplingFlagsKHR chromaSubsampling_ )
      VULKAN_HPP_NOEXCEPT
    {
      chromaSubsampling = chromaSubsampling_;
      return *this;
    }

    VideoProfileKHR &
      setLumaBitDepth( VULKAN_HPP_NAMESPACE::VideoComponentBitDepthFlagsKHR lumaBitDepth_ ) VULKAN_HPP_NOEXCEPT
    {
      lumaBitDepth = lumaBitDepth_;
      return *this;
    }

    VideoProfileKHR &
      setChromaBitDepth( VULKAN_HPP_NAMESPACE::VideoComponentBitDepthFlagsKHR chromaBitDepth_ ) VULKAN_HPP_NOEXCEPT
    {
      chromaBitDepth = chromaBitDepth_;
      return *this;
    }

    operator VkVideoProfileKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkVideoProfileKHR *>( this );
    }

    operator VkVideoProfileKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkVideoProfileKHR *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( VideoProfileKHR const & ) const = default;
#  else
    bool operator==( VideoProfileKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( videoCodecOperation == rhs.videoCodecOperation ) &&
             ( chromaSubsampling == rhs.chromaSubsampling ) && ( lumaBitDepth == rhs.lumaBitDepth ) &&
             ( chromaBitDepth == rhs.chromaBitDepth );
    }

    bool operator!=( VideoProfileKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                  sType = StructureType::eVideoProfileKHR;
    void *                                               pNext = {};
    VULKAN_HPP_NAMESPACE::VideoCodecOperationFlagBitsKHR videoCodecOperation =
      VULKAN_HPP_NAMESPACE::VideoCodecOperationFlagBitsKHR::eInvalid;
    VULKAN_HPP_NAMESPACE::VideoChromaSubsamplingFlagsKHR chromaSubsampling = {};
    VULKAN_HPP_NAMESPACE::VideoComponentBitDepthFlagsKHR lumaBitDepth      = {};
    VULKAN_HPP_NAMESPACE::VideoComponentBitDepthFlagsKHR chromaBitDepth    = {};
  };
  static_assert( sizeof( VideoProfileKHR ) == sizeof( VkVideoProfileKHR ), "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<VideoProfileKHR>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eVideoProfileKHR>
  {
    using Type = VideoProfileKHR;
  };
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  struct VideoProfilesKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eVideoProfilesKHR;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      VideoProfilesKHR( uint32_t                                      profileCount_ = {},
                        const VULKAN_HPP_NAMESPACE::VideoProfileKHR * pProfiles_    = {} ) VULKAN_HPP_NOEXCEPT
      : profileCount( profileCount_ )
      , pProfiles( pProfiles_ )
    {}

    VULKAN_HPP_CONSTEXPR VideoProfilesKHR( VideoProfilesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoProfilesKHR( VkVideoProfilesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : VideoProfilesKHR( *reinterpret_cast<VideoProfilesKHR const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 VideoProfilesKHR & operator=( VideoProfilesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoProfilesKHR & operator=( VkVideoProfilesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::VideoProfilesKHR const *>( &rhs );
      return *this;
    }

    VideoProfilesKHR & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    VideoProfilesKHR & setProfileCount( uint32_t profileCount_ ) VULKAN_HPP_NOEXCEPT
    {
      profileCount = profileCount_;
      return *this;
    }

    VideoProfilesKHR & setPProfiles( const VULKAN_HPP_NAMESPACE::VideoProfileKHR * pProfiles_ ) VULKAN_HPP_NOEXCEPT
    {
      pProfiles = pProfiles_;
      return *this;
    }

    operator VkVideoProfilesKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkVideoProfilesKHR *>( this );
    }

    operator VkVideoProfilesKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkVideoProfilesKHR *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( VideoProfilesKHR const & ) const = default;
#  else
    bool operator==( VideoProfilesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( profileCount == rhs.profileCount ) &&
             ( pProfiles == rhs.pProfiles );
    }

    bool operator!=( VideoProfilesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType           sType        = StructureType::eVideoProfilesKHR;
    void *                                        pNext        = {};
    uint32_t                                      profileCount = {};
    const VULKAN_HPP_NAMESPACE::VideoProfileKHR * pProfiles    = {};
  };
  static_assert( sizeof( VideoProfilesKHR ) == sizeof( VkVideoProfilesKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<VideoProfilesKHR>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eVideoProfilesKHR>
  {
    using Type = VideoProfilesKHR;
  };
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  struct PhysicalDeviceVideoFormatInfoKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::ePhysicalDeviceVideoFormatInfoKHR;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceVideoFormatInfoKHR(
      VULKAN_HPP_NAMESPACE::ImageUsageFlags          imageUsage_     = {},
      const VULKAN_HPP_NAMESPACE::VideoProfilesKHR * pVideoProfiles_ = {} ) VULKAN_HPP_NOEXCEPT
      : imageUsage( imageUsage_ )
      , pVideoProfiles( pVideoProfiles_ )
    {}

    VULKAN_HPP_CONSTEXPR
      PhysicalDeviceVideoFormatInfoKHR( PhysicalDeviceVideoFormatInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceVideoFormatInfoKHR( VkPhysicalDeviceVideoFormatInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceVideoFormatInfoKHR( *reinterpret_cast<PhysicalDeviceVideoFormatInfoKHR const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceVideoFormatInfoKHR &
                            operator=( PhysicalDeviceVideoFormatInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceVideoFormatInfoKHR & operator=( VkPhysicalDeviceVideoFormatInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceVideoFormatInfoKHR const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceVideoFormatInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceVideoFormatInfoKHR *>( this );
    }

    operator VkPhysicalDeviceVideoFormatInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceVideoFormatInfoKHR *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceVideoFormatInfoKHR const & ) const = default;
#  else
    bool operator==( PhysicalDeviceVideoFormatInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( imageUsage == rhs.imageUsage ) &&
             ( pVideoProfiles == rhs.pVideoProfiles );
    }

    bool operator!=( PhysicalDeviceVideoFormatInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType            sType          = StructureType::ePhysicalDeviceVideoFormatInfoKHR;
    const void *                                   pNext          = {};
    VULKAN_HPP_NAMESPACE::ImageUsageFlags          imageUsage     = {};
    const VULKAN_HPP_NAMESPACE::VideoProfilesKHR * pVideoProfiles = {};
  };
  static_assert( sizeof( PhysicalDeviceVideoFormatInfoKHR ) == sizeof( VkPhysicalDeviceVideoFormatInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceVideoFormatInfoKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceVideoFormatInfoKHR>
  {
    using Type = PhysicalDeviceVideoFormatInfoKHR;
  };
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

  struct PhysicalDeviceVulkan11Features
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::ePhysicalDeviceVulkan11Features;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      PhysicalDeviceVulkan11Features( VULKAN_HPP_NAMESPACE::Bool32 storageBuffer16BitAccess_           = {},
                                      VULKAN_HPP_NAMESPACE::Bool32 uniformAndStorageBuffer16BitAccess_ = {},
                                      VULKAN_HPP_NAMESPACE::Bool32 storagePushConstant16_              = {},
                                      VULKAN_HPP_NAMESPACE::Bool32 storageInputOutput16_               = {},
                                      VULKAN_HPP_NAMESPACE::Bool32 multiview_                          = {},
                                      VULKAN_HPP_NAMESPACE::Bool32 multiviewGeometryShader_            = {},
                                      VULKAN_HPP_NAMESPACE::Bool32 multiviewTessellationShader_        = {},
                                      VULKAN_HPP_NAMESPACE::Bool32 variablePointersStorageBuffer_      = {},
                                      VULKAN_HPP_NAMESPACE::Bool32 variablePointers_                   = {},
                                      VULKAN_HPP_NAMESPACE::Bool32 protectedMemory_                    = {},
                                      VULKAN_HPP_NAMESPACE::Bool32 samplerYcbcrConversion_             = {},
                                      VULKAN_HPP_NAMESPACE::Bool32 shaderDrawParameters_ = {} ) VULKAN_HPP_NOEXCEPT
      : storageBuffer16BitAccess( storageBuffer16BitAccess_ )
      , uniformAndStorageBuffer16BitAccess( uniformAndStorageBuffer16BitAccess_ )
      , storagePushConstant16( storagePushConstant16_ )
      , storageInputOutput16( storageInputOutput16_ )
      , multiview( multiview_ )
      , multiviewGeometryShader( multiviewGeometryShader_ )
      , multiviewTessellationShader( multiviewTessellationShader_ )
      , variablePointersStorageBuffer( variablePointersStorageBuffer_ )
      , variablePointers( variablePointers_ )
      , protectedMemory( protectedMemory_ )
      , samplerYcbcrConversion( samplerYcbcrConversion_ )
      , shaderDrawParameters( shaderDrawParameters_ )
    {}

    VULKAN_HPP_CONSTEXPR
      PhysicalDeviceVulkan11Features( PhysicalDeviceVulkan11Features const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceVulkan11Features( VkPhysicalDeviceVulkan11Features const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceVulkan11Features( *reinterpret_cast<PhysicalDeviceVulkan11Features const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceVulkan11Features &
                            operator=( PhysicalDeviceVulkan11Features const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceVulkan11Features & operator=( VkPhysicalDeviceVulkan11Features const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceVulkan11Features const *>( &rhs );
      return *this;
    }

    PhysicalDeviceVulkan11Features & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceVulkan11Features &
      setStorageBuffer16BitAccess( VULKAN_HPP_NAMESPACE::Bool32 storageBuffer16BitAccess_ ) VULKAN_HPP_NOEXCEPT
    {
      storageBuffer16BitAccess = storageBuffer16BitAccess_;
      return *this;
    }

    PhysicalDeviceVulkan11Features & setUniformAndStorageBuffer16BitAccess(
      VULKAN_HPP_NAMESPACE::Bool32 uniformAndStorageBuffer16BitAccess_ ) VULKAN_HPP_NOEXCEPT
    {
      uniformAndStorageBuffer16BitAccess = uniformAndStorageBuffer16BitAccess_;
      return *this;
    }

    PhysicalDeviceVulkan11Features &
      setStoragePushConstant16( VULKAN_HPP_NAMESPACE::Bool32 storagePushConstant16_ ) VULKAN_HPP_NOEXCEPT
    {
      storagePushConstant16 = storagePushConstant16_;
      return *this;
    }

    PhysicalDeviceVulkan11Features &
      setStorageInputOutput16( VULKAN_HPP_NAMESPACE::Bool32 storageInputOutput16_ ) VULKAN_HPP_NOEXCEPT
    {
      storageInputOutput16 = storageInputOutput16_;
      return *this;
    }

    PhysicalDeviceVulkan11Features & setMultiview( VULKAN_HPP_NAMESPACE::Bool32 multiview_ ) VULKAN_HPP_NOEXCEPT
    {
      multiview = multiview_;
      return *this;
    }

    PhysicalDeviceVulkan11Features &
      setMultiviewGeometryShader( VULKAN_HPP_NAMESPACE::Bool32 multiviewGeometryShader_ ) VULKAN_HPP_NOEXCEPT
    {
      multiviewGeometryShader = multiviewGeometryShader_;
      return *this;
    }

    PhysicalDeviceVulkan11Features &
      setMultiviewTessellationShader( VULKAN_HPP_NAMESPACE::Bool32 multiviewTessellationShader_ ) VULKAN_HPP_NOEXCEPT
    {
      multiviewTessellationShader = multiviewTessellationShader_;
      return *this;
    }

    PhysicalDeviceVulkan11Features & setVariablePointersStorageBuffer(
      VULKAN_HPP_NAMESPACE::Bool32 variablePointersStorageBuffer_ ) VULKAN_HPP_NOEXCEPT
    {
      variablePointersStorageBuffer = variablePointersStorageBuffer_;
      return *this;
    }

    PhysicalDeviceVulkan11Features &
      setVariablePointers( VULKAN_HPP_NAMESPACE::Bool32 variablePointers_ ) VULKAN_HPP_NOEXCEPT
    {
      variablePointers = variablePointers_;
      return *this;
    }

    PhysicalDeviceVulkan11Features &
      setProtectedMemory( VULKAN_HPP_NAMESPACE::Bool32 protectedMemory_ ) VULKAN_HPP_NOEXCEPT
    {
      protectedMemory = protectedMemory_;
      return *this;
    }

    PhysicalDeviceVulkan11Features &
      setSamplerYcbcrConversion( VULKAN_HPP_NAMESPACE::Bool32 samplerYcbcrConversion_ ) VULKAN_HPP_NOEXCEPT
    {
      samplerYcbcrConversion = samplerYcbcrConversion_;
      return *this;
    }

    PhysicalDeviceVulkan11Features &
      setShaderDrawParameters( VULKAN_HPP_NAMESPACE::Bool32 shaderDrawParameters_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderDrawParameters = shaderDrawParameters_;
      return *this;
    }

    operator VkPhysicalDeviceVulkan11Features const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceVulkan11Features *>( this );
    }

    operator VkPhysicalDeviceVulkan11Features &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceVulkan11Features *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceVulkan11Features const & ) const = default;
#else
    bool operator==( PhysicalDeviceVulkan11Features const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( storageBuffer16BitAccess == rhs.storageBuffer16BitAccess ) &&
             ( uniformAndStorageBuffer16BitAccess == rhs.uniformAndStorageBuffer16BitAccess ) &&
             ( storagePushConstant16 == rhs.storagePushConstant16 ) &&
             ( storageInputOutput16 == rhs.storageInputOutput16 ) && ( multiview == rhs.multiview ) &&
             ( multiviewGeometryShader == rhs.multiviewGeometryShader ) &&
             ( multiviewTessellationShader == rhs.multiviewTessellationShader ) &&
             ( variablePointersStorageBuffer == rhs.variablePointersStorageBuffer ) &&
             ( variablePointers == rhs.variablePointers ) && ( protectedMemory == rhs.protectedMemory ) &&
             ( samplerYcbcrConversion == rhs.samplerYcbcrConversion ) &&
             ( shaderDrawParameters == rhs.shaderDrawParameters );
    }

    bool operator!=( PhysicalDeviceVulkan11Features const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType                    = StructureType::ePhysicalDeviceVulkan11Features;
    void *                              pNext                    = {};
    VULKAN_HPP_NAMESPACE::Bool32        storageBuffer16BitAccess = {};
    VULKAN_HPP_NAMESPACE::Bool32        uniformAndStorageBuffer16BitAccess = {};
    VULKAN_HPP_NAMESPACE::Bool32        storagePushConstant16              = {};
    VULKAN_HPP_NAMESPACE::Bool32        storageInputOutput16               = {};
    VULKAN_HPP_NAMESPACE::Bool32        multiview                          = {};
    VULKAN_HPP_NAMESPACE::Bool32        multiviewGeometryShader            = {};
    VULKAN_HPP_NAMESPACE::Bool32        multiviewTessellationShader        = {};
    VULKAN_HPP_NAMESPACE::Bool32        variablePointersStorageBuffer      = {};
    VULKAN_HPP_NAMESPACE::Bool32        variablePointers                   = {};
    VULKAN_HPP_NAMESPACE::Bool32        protectedMemory                    = {};
    VULKAN_HPP_NAMESPACE::Bool32        samplerYcbcrConversion             = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderDrawParameters               = {};
  };
  static_assert( sizeof( PhysicalDeviceVulkan11Features ) == sizeof( VkPhysicalDeviceVulkan11Features ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceVulkan11Features>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceVulkan11Features>
  {
    using Type = PhysicalDeviceVulkan11Features;
  };

  struct PhysicalDeviceVulkan11Properties
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::ePhysicalDeviceVulkan11Properties;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceVulkan11Properties(
      std::array<uint8_t, VK_UUID_SIZE> const &   deviceUUID_                        = {},
      std::array<uint8_t, VK_UUID_SIZE> const &   driverUUID_                        = {},
      std::array<uint8_t, VK_LUID_SIZE> const &   deviceLUID_                        = {},
      uint32_t                                    deviceNodeMask_                    = {},
      VULKAN_HPP_NAMESPACE::Bool32                deviceLUIDValid_                   = {},
      uint32_t                                    subgroupSize_                      = {},
      VULKAN_HPP_NAMESPACE::ShaderStageFlags      subgroupSupportedStages_           = {},
      VULKAN_HPP_NAMESPACE::SubgroupFeatureFlags  subgroupSupportedOperations_       = {},
      VULKAN_HPP_NAMESPACE::Bool32                subgroupQuadOperationsInAllStages_ = {},
      VULKAN_HPP_NAMESPACE::PointClippingBehavior pointClippingBehavior_ =
        VULKAN_HPP_NAMESPACE::PointClippingBehavior::eAllClipPlanes,
      uint32_t                         maxMultiviewViewCount_     = {},
      uint32_t                         maxMultiviewInstanceIndex_ = {},
      VULKAN_HPP_NAMESPACE::Bool32     protectedNoFault_          = {},
      uint32_t                         maxPerSetDescriptors_      = {},
      VULKAN_HPP_NAMESPACE::DeviceSize maxMemoryAllocationSize_   = {} ) VULKAN_HPP_NOEXCEPT
      : deviceUUID( deviceUUID_ )
      , driverUUID( driverUUID_ )
      , deviceLUID( deviceLUID_ )
      , deviceNodeMask( deviceNodeMask_ )
      , deviceLUIDValid( deviceLUIDValid_ )
      , subgroupSize( subgroupSize_ )
      , subgroupSupportedStages( subgroupSupportedStages_ )
      , subgroupSupportedOperations( subgroupSupportedOperations_ )
      , subgroupQuadOperationsInAllStages( subgroupQuadOperationsInAllStages_ )
      , pointClippingBehavior( pointClippingBehavior_ )
      , maxMultiviewViewCount( maxMultiviewViewCount_ )
      , maxMultiviewInstanceIndex( maxMultiviewInstanceIndex_ )
      , protectedNoFault( protectedNoFault_ )
      , maxPerSetDescriptors( maxPerSetDescriptors_ )
      , maxMemoryAllocationSize( maxMemoryAllocationSize_ )
    {}

    VULKAN_HPP_CONSTEXPR_14
      PhysicalDeviceVulkan11Properties( PhysicalDeviceVulkan11Properties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceVulkan11Properties( VkPhysicalDeviceVulkan11Properties const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceVulkan11Properties( *reinterpret_cast<PhysicalDeviceVulkan11Properties const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceVulkan11Properties &
                            operator=( PhysicalDeviceVulkan11Properties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceVulkan11Properties & operator=( VkPhysicalDeviceVulkan11Properties const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceVulkan11Properties const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceVulkan11Properties const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceVulkan11Properties *>( this );
    }

    operator VkPhysicalDeviceVulkan11Properties &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceVulkan11Properties *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceVulkan11Properties const & ) const = default;
#else
    bool operator==( PhysicalDeviceVulkan11Properties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( deviceUUID == rhs.deviceUUID ) &&
             ( driverUUID == rhs.driverUUID ) && ( deviceLUID == rhs.deviceLUID ) &&
             ( deviceNodeMask == rhs.deviceNodeMask ) && ( deviceLUIDValid == rhs.deviceLUIDValid ) &&
             ( subgroupSize == rhs.subgroupSize ) && ( subgroupSupportedStages == rhs.subgroupSupportedStages ) &&
             ( subgroupSupportedOperations == rhs.subgroupSupportedOperations ) &&
             ( subgroupQuadOperationsInAllStages == rhs.subgroupQuadOperationsInAllStages ) &&
             ( pointClippingBehavior == rhs.pointClippingBehavior ) &&
             ( maxMultiviewViewCount == rhs.maxMultiviewViewCount ) &&
             ( maxMultiviewInstanceIndex == rhs.maxMultiviewInstanceIndex ) &&
             ( protectedNoFault == rhs.protectedNoFault ) && ( maxPerSetDescriptors == rhs.maxPerSetDescriptors ) &&
             ( maxMemoryAllocationSize == rhs.maxMemoryAllocationSize );
    }

    bool operator!=( PhysicalDeviceVulkan11Properties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceVulkan11Properties;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<uint8_t, VK_UUID_SIZE> deviceUUID                        = {};
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<uint8_t, VK_UUID_SIZE> driverUUID                        = {};
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<uint8_t, VK_LUID_SIZE> deviceLUID                        = {};
    uint32_t                                                    deviceNodeMask                    = {};
    VULKAN_HPP_NAMESPACE::Bool32                                deviceLUIDValid                   = {};
    uint32_t                                                    subgroupSize                      = {};
    VULKAN_HPP_NAMESPACE::ShaderStageFlags                      subgroupSupportedStages           = {};
    VULKAN_HPP_NAMESPACE::SubgroupFeatureFlags                  subgroupSupportedOperations       = {};
    VULKAN_HPP_NAMESPACE::Bool32                                subgroupQuadOperationsInAllStages = {};
    VULKAN_HPP_NAMESPACE::PointClippingBehavior                 pointClippingBehavior =
      VULKAN_HPP_NAMESPACE::PointClippingBehavior::eAllClipPlanes;
    uint32_t                         maxMultiviewViewCount     = {};
    uint32_t                         maxMultiviewInstanceIndex = {};
    VULKAN_HPP_NAMESPACE::Bool32     protectedNoFault          = {};
    uint32_t                         maxPerSetDescriptors      = {};
    VULKAN_HPP_NAMESPACE::DeviceSize maxMemoryAllocationSize   = {};
  };
  static_assert( sizeof( PhysicalDeviceVulkan11Properties ) == sizeof( VkPhysicalDeviceVulkan11Properties ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceVulkan11Properties>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceVulkan11Properties>
  {
    using Type = PhysicalDeviceVulkan11Properties;
  };

  struct PhysicalDeviceVulkan12Features
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::ePhysicalDeviceVulkan12Features;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceVulkan12Features(
      VULKAN_HPP_NAMESPACE::Bool32 samplerMirrorClampToEdge_                           = {},
      VULKAN_HPP_NAMESPACE::Bool32 drawIndirectCount_                                  = {},
      VULKAN_HPP_NAMESPACE::Bool32 storageBuffer8BitAccess_                            = {},
      VULKAN_HPP_NAMESPACE::Bool32 uniformAndStorageBuffer8BitAccess_                  = {},
      VULKAN_HPP_NAMESPACE::Bool32 storagePushConstant8_                               = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderBufferInt64Atomics_                           = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderSharedInt64Atomics_                           = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderFloat16_                                      = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderInt8_                                         = {},
      VULKAN_HPP_NAMESPACE::Bool32 descriptorIndexing_                                 = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderInputAttachmentArrayDynamicIndexing_          = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderUniformTexelBufferArrayDynamicIndexing_       = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderStorageTexelBufferArrayDynamicIndexing_       = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderUniformBufferArrayNonUniformIndexing_         = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderSampledImageArrayNonUniformIndexing_          = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderStorageBufferArrayNonUniformIndexing_         = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderStorageImageArrayNonUniformIndexing_          = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderInputAttachmentArrayNonUniformIndexing_       = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderUniformTexelBufferArrayNonUniformIndexing_    = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderStorageTexelBufferArrayNonUniformIndexing_    = {},
      VULKAN_HPP_NAMESPACE::Bool32 descriptorBindingUniformBufferUpdateAfterBind_      = {},
      VULKAN_HPP_NAMESPACE::Bool32 descriptorBindingSampledImageUpdateAfterBind_       = {},
      VULKAN_HPP_NAMESPACE::Bool32 descriptorBindingStorageImageUpdateAfterBind_       = {},
      VULKAN_HPP_NAMESPACE::Bool32 descriptorBindingStorageBufferUpdateAfterBind_      = {},
      VULKAN_HPP_NAMESPACE::Bool32 descriptorBindingUniformTexelBufferUpdateAfterBind_ = {},
      VULKAN_HPP_NAMESPACE::Bool32 descriptorBindingStorageTexelBufferUpdateAfterBind_ = {},
      VULKAN_HPP_NAMESPACE::Bool32 descriptorBindingUpdateUnusedWhilePending_          = {},
      VULKAN_HPP_NAMESPACE::Bool32 descriptorBindingPartiallyBound_                    = {},
      VULKAN_HPP_NAMESPACE::Bool32 descriptorBindingVariableDescriptorCount_           = {},
      VULKAN_HPP_NAMESPACE::Bool32 runtimeDescriptorArray_                             = {},
      VULKAN_HPP_NAMESPACE::Bool32 samplerFilterMinmax_                                = {},
      VULKAN_HPP_NAMESPACE::Bool32 scalarBlockLayout_                                  = {},
      VULKAN_HPP_NAMESPACE::Bool32 imagelessFramebuffer_                               = {},
      VULKAN_HPP_NAMESPACE::Bool32 uniformBufferStandardLayout_                        = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderSubgroupExtendedTypes_                        = {},
      VULKAN_HPP_NAMESPACE::Bool32 separateDepthStencilLayouts_                        = {},
      VULKAN_HPP_NAMESPACE::Bool32 hostQueryReset_                                     = {},
      VULKAN_HPP_NAMESPACE::Bool32 timelineSemaphore_                                  = {},
      VULKAN_HPP_NAMESPACE::Bool32 bufferDeviceAddress_                                = {},
      VULKAN_HPP_NAMESPACE::Bool32 bufferDeviceAddressCaptureReplay_                   = {},
      VULKAN_HPP_NAMESPACE::Bool32 bufferDeviceAddressMultiDevice_                     = {},
      VULKAN_HPP_NAMESPACE::Bool32 vulkanMemoryModel_                                  = {},
      VULKAN_HPP_NAMESPACE::Bool32 vulkanMemoryModelDeviceScope_                       = {},
      VULKAN_HPP_NAMESPACE::Bool32 vulkanMemoryModelAvailabilityVisibilityChains_      = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderOutputViewportIndex_                          = {},
      VULKAN_HPP_NAMESPACE::Bool32 shaderOutputLayer_                                  = {},
      VULKAN_HPP_NAMESPACE::Bool32 subgroupBroadcastDynamicId_                         = {} ) VULKAN_HPP_NOEXCEPT
      : samplerMirrorClampToEdge( samplerMirrorClampToEdge_ )
      , drawIndirectCount( drawIndirectCount_ )
      , storageBuffer8BitAccess( storageBuffer8BitAccess_ )
      , uniformAndStorageBuffer8BitAccess( uniformAndStorageBuffer8BitAccess_ )
      , storagePushConstant8( storagePushConstant8_ )
      , shaderBufferInt64Atomics( shaderBufferInt64Atomics_ )
      , shaderSharedInt64Atomics( shaderSharedInt64Atomics_ )
      , shaderFloat16( shaderFloat16_ )
      , shaderInt8( shaderInt8_ )
      , descriptorIndexing( descriptorIndexing_ )
      , shaderInputAttachmentArrayDynamicIndexing( shaderInputAttachmentArrayDynamicIndexing_ )
      , shaderUniformTexelBufferArrayDynamicIndexing( shaderUniformTexelBufferArrayDynamicIndexing_ )
      , shaderStorageTexelBufferArrayDynamicIndexing( shaderStorageTexelBufferArrayDynamicIndexing_ )
      , shaderUniformBufferArrayNonUniformIndexing( shaderUniformBufferArrayNonUniformIndexing_ )
      , shaderSampledImageArrayNonUniformIndexing( shaderSampledImageArrayNonUniformIndexing_ )
      , shaderStorageBufferArrayNonUniformIndexing( shaderStorageBufferArrayNonUniformIndexing_ )
      , shaderStorageImageArrayNonUniformIndexing( shaderStorageImageArrayNonUniformIndexing_ )
      , shaderInputAttachmentArrayNonUniformIndexing( shaderInputAttachmentArrayNonUniformIndexing_ )
      , shaderUniformTexelBufferArrayNonUniformIndexing( shaderUniformTexelBufferArrayNonUniformIndexing_ )
      , shaderStorageTexelBufferArrayNonUniformIndexing( shaderStorageTexelBufferArrayNonUniformIndexing_ )
      , descriptorBindingUniformBufferUpdateAfterBind( descriptorBindingUniformBufferUpdateAfterBind_ )
      , descriptorBindingSampledImageUpdateAfterBind( descriptorBindingSampledImageUpdateAfterBind_ )
      , descriptorBindingStorageImageUpdateAfterBind( descriptorBindingStorageImageUpdateAfterBind_ )
      , descriptorBindingStorageBufferUpdateAfterBind( descriptorBindingStorageBufferUpdateAfterBind_ )
      , descriptorBindingUniformTexelBufferUpdateAfterBind( descriptorBindingUniformTexelBufferUpdateAfterBind_ )
      , descriptorBindingStorageTexelBufferUpdateAfterBind( descriptorBindingStorageTexelBufferUpdateAfterBind_ )
      , descriptorBindingUpdateUnusedWhilePending( descriptorBindingUpdateUnusedWhilePending_ )
      , descriptorBindingPartiallyBound( descriptorBindingPartiallyBound_ )
      , descriptorBindingVariableDescriptorCount( descriptorBindingVariableDescriptorCount_ )
      , runtimeDescriptorArray( runtimeDescriptorArray_ )
      , samplerFilterMinmax( samplerFilterMinmax_ )
      , scalarBlockLayout( scalarBlockLayout_ )
      , imagelessFramebuffer( imagelessFramebuffer_ )
      , uniformBufferStandardLayout( uniformBufferStandardLayout_ )
      , shaderSubgroupExtendedTypes( shaderSubgroupExtendedTypes_ )
      , separateDepthStencilLayouts( separateDepthStencilLayouts_ )
      , hostQueryReset( hostQueryReset_ )
      , timelineSemaphore( timelineSemaphore_ )
      , bufferDeviceAddress( bufferDeviceAddress_ )
      , bufferDeviceAddressCaptureReplay( bufferDeviceAddressCaptureReplay_ )
      , bufferDeviceAddressMultiDevice( bufferDeviceAddressMultiDevice_ )
      , vulkanMemoryModel( vulkanMemoryModel_ )
      , vulkanMemoryModelDeviceScope( vulkanMemoryModelDeviceScope_ )
      , vulkanMemoryModelAvailabilityVisibilityChains( vulkanMemoryModelAvailabilityVisibilityChains_ )
      , shaderOutputViewportIndex( shaderOutputViewportIndex_ )
      , shaderOutputLayer( shaderOutputLayer_ )
      , subgroupBroadcastDynamicId( subgroupBroadcastDynamicId_ )
    {}

    VULKAN_HPP_CONSTEXPR
      PhysicalDeviceVulkan12Features( PhysicalDeviceVulkan12Features const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceVulkan12Features( VkPhysicalDeviceVulkan12Features const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceVulkan12Features( *reinterpret_cast<PhysicalDeviceVulkan12Features const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceVulkan12Features &
                            operator=( PhysicalDeviceVulkan12Features const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceVulkan12Features & operator=( VkPhysicalDeviceVulkan12Features const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceVulkan12Features const *>( &rhs );
      return *this;
    }

    PhysicalDeviceVulkan12Features & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceVulkan12Features &
      setSamplerMirrorClampToEdge( VULKAN_HPP_NAMESPACE::Bool32 samplerMirrorClampToEdge_ ) VULKAN_HPP_NOEXCEPT
    {
      samplerMirrorClampToEdge = samplerMirrorClampToEdge_;
      return *this;
    }

    PhysicalDeviceVulkan12Features &
      setDrawIndirectCount( VULKAN_HPP_NAMESPACE::Bool32 drawIndirectCount_ ) VULKAN_HPP_NOEXCEPT
    {
      drawIndirectCount = drawIndirectCount_;
      return *this;
    }

    PhysicalDeviceVulkan12Features &
      setStorageBuffer8BitAccess( VULKAN_HPP_NAMESPACE::Bool32 storageBuffer8BitAccess_ ) VULKAN_HPP_NOEXCEPT
    {
      storageBuffer8BitAccess = storageBuffer8BitAccess_;
      return *this;
    }

    PhysicalDeviceVulkan12Features & setUniformAndStorageBuffer8BitAccess(
      VULKAN_HPP_NAMESPACE::Bool32 uniformAndStorageBuffer8BitAccess_ ) VULKAN_HPP_NOEXCEPT
    {
      uniformAndStorageBuffer8BitAccess = uniformAndStorageBuffer8BitAccess_;
      return *this;
    }

    PhysicalDeviceVulkan12Features &
      setStoragePushConstant8( VULKAN_HPP_NAMESPACE::Bool32 storagePushConstant8_ ) VULKAN_HPP_NOEXCEPT
    {
      storagePushConstant8 = storagePushConstant8_;
      return *this;
    }

    PhysicalDeviceVulkan12Features &
      setShaderBufferInt64Atomics( VULKAN_HPP_NAMESPACE::Bool32 shaderBufferInt64Atomics_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderBufferInt64Atomics = shaderBufferInt64Atomics_;
      return *this;
    }

    PhysicalDeviceVulkan12Features &
      setShaderSharedInt64Atomics( VULKAN_HPP_NAMESPACE::Bool32 shaderSharedInt64Atomics_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderSharedInt64Atomics = shaderSharedInt64Atomics_;
      return *this;
    }

    PhysicalDeviceVulkan12Features & setShaderFloat16( VULKAN_HPP_NAMESPACE::Bool32 shaderFloat16_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderFloat16 = shaderFloat16_;
      return *this;
    }

    PhysicalDeviceVulkan12Features & setShaderInt8( VULKAN_HPP_NAMESPACE::Bool32 shaderInt8_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderInt8 = shaderInt8_;
      return *this;
    }

    PhysicalDeviceVulkan12Features &
      setDescriptorIndexing( VULKAN_HPP_NAMESPACE::Bool32 descriptorIndexing_ ) VULKAN_HPP_NOEXCEPT
    {
      descriptorIndexing = descriptorIndexing_;
      return *this;
    }

    PhysicalDeviceVulkan12Features & setShaderInputAttachmentArrayDynamicIndexing(
      VULKAN_HPP_NAMESPACE::Bool32 shaderInputAttachmentArrayDynamicIndexing_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderInputAttachmentArrayDynamicIndexing = shaderInputAttachmentArrayDynamicIndexing_;
      return *this;
    }

    PhysicalDeviceVulkan12Features & setShaderUniformTexelBufferArrayDynamicIndexing(
      VULKAN_HPP_NAMESPACE::Bool32 shaderUniformTexelBufferArrayDynamicIndexing_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderUniformTexelBufferArrayDynamicIndexing = shaderUniformTexelBufferArrayDynamicIndexing_;
      return *this;
    }

    PhysicalDeviceVulkan12Features & setShaderStorageTexelBufferArrayDynamicIndexing(
      VULKAN_HPP_NAMESPACE::Bool32 shaderStorageTexelBufferArrayDynamicIndexing_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderStorageTexelBufferArrayDynamicIndexing = shaderStorageTexelBufferArrayDynamicIndexing_;
      return *this;
    }

    PhysicalDeviceVulkan12Features & setShaderUniformBufferArrayNonUniformIndexing(
      VULKAN_HPP_NAMESPACE::Bool32 shaderUniformBufferArrayNonUniformIndexing_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderUniformBufferArrayNonUniformIndexing = shaderUniformBufferArrayNonUniformIndexing_;
      return *this;
    }

    PhysicalDeviceVulkan12Features & setShaderSampledImageArrayNonUniformIndexing(
      VULKAN_HPP_NAMESPACE::Bool32 shaderSampledImageArrayNonUniformIndexing_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderSampledImageArrayNonUniformIndexing = shaderSampledImageArrayNonUniformIndexing_;
      return *this;
    }

    PhysicalDeviceVulkan12Features & setShaderStorageBufferArrayNonUniformIndexing(
      VULKAN_HPP_NAMESPACE::Bool32 shaderStorageBufferArrayNonUniformIndexing_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderStorageBufferArrayNonUniformIndexing = shaderStorageBufferArrayNonUniformIndexing_;
      return *this;
    }

    PhysicalDeviceVulkan12Features & setShaderStorageImageArrayNonUniformIndexing(
      VULKAN_HPP_NAMESPACE::Bool32 shaderStorageImageArrayNonUniformIndexing_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderStorageImageArrayNonUniformIndexing = shaderStorageImageArrayNonUniformIndexing_;
      return *this;
    }

    PhysicalDeviceVulkan12Features & setShaderInputAttachmentArrayNonUniformIndexing(
      VULKAN_HPP_NAMESPACE::Bool32 shaderInputAttachmentArrayNonUniformIndexing_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderInputAttachmentArrayNonUniformIndexing = shaderInputAttachmentArrayNonUniformIndexing_;
      return *this;
    }

    PhysicalDeviceVulkan12Features & setShaderUniformTexelBufferArrayNonUniformIndexing(
      VULKAN_HPP_NAMESPACE::Bool32 shaderUniformTexelBufferArrayNonUniformIndexing_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderUniformTexelBufferArrayNonUniformIndexing = shaderUniformTexelBufferArrayNonUniformIndexing_;
      return *this;
    }

    PhysicalDeviceVulkan12Features & setShaderStorageTexelBufferArrayNonUniformIndexing(
      VULKAN_HPP_NAMESPACE::Bool32 shaderStorageTexelBufferArrayNonUniformIndexing_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderStorageTexelBufferArrayNonUniformIndexing = shaderStorageTexelBufferArrayNonUniformIndexing_;
      return *this;
    }

    PhysicalDeviceVulkan12Features & setDescriptorBindingUniformBufferUpdateAfterBind(
      VULKAN_HPP_NAMESPACE::Bool32 descriptorBindingUniformBufferUpdateAfterBind_ ) VULKAN_HPP_NOEXCEPT
    {
      descriptorBindingUniformBufferUpdateAfterBind = descriptorBindingUniformBufferUpdateAfterBind_;
      return *this;
    }

    PhysicalDeviceVulkan12Features & setDescriptorBindingSampledImageUpdateAfterBind(
      VULKAN_HPP_NAMESPACE::Bool32 descriptorBindingSampledImageUpdateAfterBind_ ) VULKAN_HPP_NOEXCEPT
    {
      descriptorBindingSampledImageUpdateAfterBind = descriptorBindingSampledImageUpdateAfterBind_;
      return *this;
    }

    PhysicalDeviceVulkan12Features & setDescriptorBindingStorageImageUpdateAfterBind(
      VULKAN_HPP_NAMESPACE::Bool32 descriptorBindingStorageImageUpdateAfterBind_ ) VULKAN_HPP_NOEXCEPT
    {
      descriptorBindingStorageImageUpdateAfterBind = descriptorBindingStorageImageUpdateAfterBind_;
      return *this;
    }

    PhysicalDeviceVulkan12Features & setDescriptorBindingStorageBufferUpdateAfterBind(
      VULKAN_HPP_NAMESPACE::Bool32 descriptorBindingStorageBufferUpdateAfterBind_ ) VULKAN_HPP_NOEXCEPT
    {
      descriptorBindingStorageBufferUpdateAfterBind = descriptorBindingStorageBufferUpdateAfterBind_;
      return *this;
    }

    PhysicalDeviceVulkan12Features & setDescriptorBindingUniformTexelBufferUpdateAfterBind(
      VULKAN_HPP_NAMESPACE::Bool32 descriptorBindingUniformTexelBufferUpdateAfterBind_ ) VULKAN_HPP_NOEXCEPT
    {
      descriptorBindingUniformTexelBufferUpdateAfterBind = descriptorBindingUniformTexelBufferUpdateAfterBind_;
      return *this;
    }

    PhysicalDeviceVulkan12Features & setDescriptorBindingStorageTexelBufferUpdateAfterBind(
      VULKAN_HPP_NAMESPACE::Bool32 descriptorBindingStorageTexelBufferUpdateAfterBind_ ) VULKAN_HPP_NOEXCEPT
    {
      descriptorBindingStorageTexelBufferUpdateAfterBind = descriptorBindingStorageTexelBufferUpdateAfterBind_;
      return *this;
    }

    PhysicalDeviceVulkan12Features & setDescriptorBindingUpdateUnusedWhilePending(
      VULKAN_HPP_NAMESPACE::Bool32 descriptorBindingUpdateUnusedWhilePending_ ) VULKAN_HPP_NOEXCEPT
    {
      descriptorBindingUpdateUnusedWhilePending = descriptorBindingUpdateUnusedWhilePending_;
      return *this;
    }

    PhysicalDeviceVulkan12Features & setDescriptorBindingPartiallyBound(
      VULKAN_HPP_NAMESPACE::Bool32 descriptorBindingPartiallyBound_ ) VULKAN_HPP_NOEXCEPT
    {
      descriptorBindingPartiallyBound = descriptorBindingPartiallyBound_;
      return *this;
    }

    PhysicalDeviceVulkan12Features & setDescriptorBindingVariableDescriptorCount(
      VULKAN_HPP_NAMESPACE::Bool32 descriptorBindingVariableDescriptorCount_ ) VULKAN_HPP_NOEXCEPT
    {
      descriptorBindingVariableDescriptorCount = descriptorBindingVariableDescriptorCount_;
      return *this;
    }

    PhysicalDeviceVulkan12Features &
      setRuntimeDescriptorArray( VULKAN_HPP_NAMESPACE::Bool32 runtimeDescriptorArray_ ) VULKAN_HPP_NOEXCEPT
    {
      runtimeDescriptorArray = runtimeDescriptorArray_;
      return *this;
    }

    PhysicalDeviceVulkan12Features &
      setSamplerFilterMinmax( VULKAN_HPP_NAMESPACE::Bool32 samplerFilterMinmax_ ) VULKAN_HPP_NOEXCEPT
    {
      samplerFilterMinmax = samplerFilterMinmax_;
      return *this;
    }

    PhysicalDeviceVulkan12Features &
      setScalarBlockLayout( VULKAN_HPP_NAMESPACE::Bool32 scalarBlockLayout_ ) VULKAN_HPP_NOEXCEPT
    {
      scalarBlockLayout = scalarBlockLayout_;
      return *this;
    }

    PhysicalDeviceVulkan12Features &
      setImagelessFramebuffer( VULKAN_HPP_NAMESPACE::Bool32 imagelessFramebuffer_ ) VULKAN_HPP_NOEXCEPT
    {
      imagelessFramebuffer = imagelessFramebuffer_;
      return *this;
    }

    PhysicalDeviceVulkan12Features &
      setUniformBufferStandardLayout( VULKAN_HPP_NAMESPACE::Bool32 uniformBufferStandardLayout_ ) VULKAN_HPP_NOEXCEPT
    {
      uniformBufferStandardLayout = uniformBufferStandardLayout_;
      return *this;
    }

    PhysicalDeviceVulkan12Features &
      setShaderSubgroupExtendedTypes( VULKAN_HPP_NAMESPACE::Bool32 shaderSubgroupExtendedTypes_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderSubgroupExtendedTypes = shaderSubgroupExtendedTypes_;
      return *this;
    }

    PhysicalDeviceVulkan12Features &
      setSeparateDepthStencilLayouts( VULKAN_HPP_NAMESPACE::Bool32 separateDepthStencilLayouts_ ) VULKAN_HPP_NOEXCEPT
    {
      separateDepthStencilLayouts = separateDepthStencilLayouts_;
      return *this;
    }

    PhysicalDeviceVulkan12Features &
      setHostQueryReset( VULKAN_HPP_NAMESPACE::Bool32 hostQueryReset_ ) VULKAN_HPP_NOEXCEPT
    {
      hostQueryReset = hostQueryReset_;
      return *this;
    }

    PhysicalDeviceVulkan12Features &
      setTimelineSemaphore( VULKAN_HPP_NAMESPACE::Bool32 timelineSemaphore_ ) VULKAN_HPP_NOEXCEPT
    {
      timelineSemaphore = timelineSemaphore_;
      return *this;
    }

    PhysicalDeviceVulkan12Features &
      setBufferDeviceAddress( VULKAN_HPP_NAMESPACE::Bool32 bufferDeviceAddress_ ) VULKAN_HPP_NOEXCEPT
    {
      bufferDeviceAddress = bufferDeviceAddress_;
      return *this;
    }

    PhysicalDeviceVulkan12Features & setBufferDeviceAddressCaptureReplay(
      VULKAN_HPP_NAMESPACE::Bool32 bufferDeviceAddressCaptureReplay_ ) VULKAN_HPP_NOEXCEPT
    {
      bufferDeviceAddressCaptureReplay = bufferDeviceAddressCaptureReplay_;
      return *this;
    }

    PhysicalDeviceVulkan12Features & setBufferDeviceAddressMultiDevice(
      VULKAN_HPP_NAMESPACE::Bool32 bufferDeviceAddressMultiDevice_ ) VULKAN_HPP_NOEXCEPT
    {
      bufferDeviceAddressMultiDevice = bufferDeviceAddressMultiDevice_;
      return *this;
    }

    PhysicalDeviceVulkan12Features &
      setVulkanMemoryModel( VULKAN_HPP_NAMESPACE::Bool32 vulkanMemoryModel_ ) VULKAN_HPP_NOEXCEPT
    {
      vulkanMemoryModel = vulkanMemoryModel_;
      return *this;
    }

    PhysicalDeviceVulkan12Features &
      setVulkanMemoryModelDeviceScope( VULKAN_HPP_NAMESPACE::Bool32 vulkanMemoryModelDeviceScope_ ) VULKAN_HPP_NOEXCEPT
    {
      vulkanMemoryModelDeviceScope = vulkanMemoryModelDeviceScope_;
      return *this;
    }

    PhysicalDeviceVulkan12Features & setVulkanMemoryModelAvailabilityVisibilityChains(
      VULKAN_HPP_NAMESPACE::Bool32 vulkanMemoryModelAvailabilityVisibilityChains_ ) VULKAN_HPP_NOEXCEPT
    {
      vulkanMemoryModelAvailabilityVisibilityChains = vulkanMemoryModelAvailabilityVisibilityChains_;
      return *this;
    }

    PhysicalDeviceVulkan12Features &
      setShaderOutputViewportIndex( VULKAN_HPP_NAMESPACE::Bool32 shaderOutputViewportIndex_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderOutputViewportIndex = shaderOutputViewportIndex_;
      return *this;
    }

    PhysicalDeviceVulkan12Features &
      setShaderOutputLayer( VULKAN_HPP_NAMESPACE::Bool32 shaderOutputLayer_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderOutputLayer = shaderOutputLayer_;
      return *this;
    }

    PhysicalDeviceVulkan12Features &
      setSubgroupBroadcastDynamicId( VULKAN_HPP_NAMESPACE::Bool32 subgroupBroadcastDynamicId_ ) VULKAN_HPP_NOEXCEPT
    {
      subgroupBroadcastDynamicId = subgroupBroadcastDynamicId_;
      return *this;
    }

    operator VkPhysicalDeviceVulkan12Features const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceVulkan12Features *>( this );
    }

    operator VkPhysicalDeviceVulkan12Features &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceVulkan12Features *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceVulkan12Features const & ) const = default;
#else
    bool operator==( PhysicalDeviceVulkan12Features const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( samplerMirrorClampToEdge == rhs.samplerMirrorClampToEdge ) &&
             ( drawIndirectCount == rhs.drawIndirectCount ) &&
             ( storageBuffer8BitAccess == rhs.storageBuffer8BitAccess ) &&
             ( uniformAndStorageBuffer8BitAccess == rhs.uniformAndStorageBuffer8BitAccess ) &&
             ( storagePushConstant8 == rhs.storagePushConstant8 ) &&
             ( shaderBufferInt64Atomics == rhs.shaderBufferInt64Atomics ) &&
             ( shaderSharedInt64Atomics == rhs.shaderSharedInt64Atomics ) && ( shaderFloat16 == rhs.shaderFloat16 ) &&
             ( shaderInt8 == rhs.shaderInt8 ) && ( descriptorIndexing == rhs.descriptorIndexing ) &&
             ( shaderInputAttachmentArrayDynamicIndexing == rhs.shaderInputAttachmentArrayDynamicIndexing ) &&
             ( shaderUniformTexelBufferArrayDynamicIndexing == rhs.shaderUniformTexelBufferArrayDynamicIndexing ) &&
             ( shaderStorageTexelBufferArrayDynamicIndexing == rhs.shaderStorageTexelBufferArrayDynamicIndexing ) &&
             ( shaderUniformBufferArrayNonUniformIndexing == rhs.shaderUniformBufferArrayNonUniformIndexing ) &&
             ( shaderSampledImageArrayNonUniformIndexing == rhs.shaderSampledImageArrayNonUniformIndexing ) &&
             ( shaderStorageBufferArrayNonUniformIndexing == rhs.shaderStorageBufferArrayNonUniformIndexing ) &&
             ( shaderStorageImageArrayNonUniformIndexing == rhs.shaderStorageImageArrayNonUniformIndexing ) &&
             ( shaderInputAttachmentArrayNonUniformIndexing == rhs.shaderInputAttachmentArrayNonUniformIndexing ) &&
             ( shaderUniformTexelBufferArrayNonUniformIndexing ==
               rhs.shaderUniformTexelBufferArrayNonUniformIndexing ) &&
             ( shaderStorageTexelBufferArrayNonUniformIndexing ==
               rhs.shaderStorageTexelBufferArrayNonUniformIndexing ) &&
             ( descriptorBindingUniformBufferUpdateAfterBind == rhs.descriptorBindingUniformBufferUpdateAfterBind ) &&
             ( descriptorBindingSampledImageUpdateAfterBind == rhs.descriptorBindingSampledImageUpdateAfterBind ) &&
             ( descriptorBindingStorageImageUpdateAfterBind == rhs.descriptorBindingStorageImageUpdateAfterBind ) &&
             ( descriptorBindingStorageBufferUpdateAfterBind == rhs.descriptorBindingStorageBufferUpdateAfterBind ) &&
             ( descriptorBindingUniformTexelBufferUpdateAfterBind ==
               rhs.descriptorBindingUniformTexelBufferUpdateAfterBind ) &&
             ( descriptorBindingStorageTexelBufferUpdateAfterBind ==
               rhs.descriptorBindingStorageTexelBufferUpdateAfterBind ) &&
             ( descriptorBindingUpdateUnusedWhilePending == rhs.descriptorBindingUpdateUnusedWhilePending ) &&
             ( descriptorBindingPartiallyBound == rhs.descriptorBindingPartiallyBound ) &&
             ( descriptorBindingVariableDescriptorCount == rhs.descriptorBindingVariableDescriptorCount ) &&
             ( runtimeDescriptorArray == rhs.runtimeDescriptorArray ) &&
             ( samplerFilterMinmax == rhs.samplerFilterMinmax ) && ( scalarBlockLayout == rhs.scalarBlockLayout ) &&
             ( imagelessFramebuffer == rhs.imagelessFramebuffer ) &&
             ( uniformBufferStandardLayout == rhs.uniformBufferStandardLayout ) &&
             ( shaderSubgroupExtendedTypes == rhs.shaderSubgroupExtendedTypes ) &&
             ( separateDepthStencilLayouts == rhs.separateDepthStencilLayouts ) &&
             ( hostQueryReset == rhs.hostQueryReset ) && ( timelineSemaphore == rhs.timelineSemaphore ) &&
             ( bufferDeviceAddress == rhs.bufferDeviceAddress ) &&
             ( bufferDeviceAddressCaptureReplay == rhs.bufferDeviceAddressCaptureReplay ) &&
             ( bufferDeviceAddressMultiDevice == rhs.bufferDeviceAddressMultiDevice ) &&
             ( vulkanMemoryModel == rhs.vulkanMemoryModel ) &&
             ( vulkanMemoryModelDeviceScope == rhs.vulkanMemoryModelDeviceScope ) &&
             ( vulkanMemoryModelAvailabilityVisibilityChains == rhs.vulkanMemoryModelAvailabilityVisibilityChains ) &&
             ( shaderOutputViewportIndex == rhs.shaderOutputViewportIndex ) &&
             ( shaderOutputLayer == rhs.shaderOutputLayer ) &&
             ( subgroupBroadcastDynamicId == rhs.subgroupBroadcastDynamicId );
    }

    bool operator!=( PhysicalDeviceVulkan12Features const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType                    = StructureType::ePhysicalDeviceVulkan12Features;
    void *                              pNext                    = {};
    VULKAN_HPP_NAMESPACE::Bool32        samplerMirrorClampToEdge = {};
    VULKAN_HPP_NAMESPACE::Bool32        drawIndirectCount        = {};
    VULKAN_HPP_NAMESPACE::Bool32        storageBuffer8BitAccess  = {};
    VULKAN_HPP_NAMESPACE::Bool32        uniformAndStorageBuffer8BitAccess                  = {};
    VULKAN_HPP_NAMESPACE::Bool32        storagePushConstant8                               = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderBufferInt64Atomics                           = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderSharedInt64Atomics                           = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderFloat16                                      = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderInt8                                         = {};
    VULKAN_HPP_NAMESPACE::Bool32        descriptorIndexing                                 = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderInputAttachmentArrayDynamicIndexing          = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderUniformTexelBufferArrayDynamicIndexing       = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderStorageTexelBufferArrayDynamicIndexing       = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderUniformBufferArrayNonUniformIndexing         = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderSampledImageArrayNonUniformIndexing          = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderStorageBufferArrayNonUniformIndexing         = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderStorageImageArrayNonUniformIndexing          = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderInputAttachmentArrayNonUniformIndexing       = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderUniformTexelBufferArrayNonUniformIndexing    = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderStorageTexelBufferArrayNonUniformIndexing    = {};
    VULKAN_HPP_NAMESPACE::Bool32        descriptorBindingUniformBufferUpdateAfterBind      = {};
    VULKAN_HPP_NAMESPACE::Bool32        descriptorBindingSampledImageUpdateAfterBind       = {};
    VULKAN_HPP_NAMESPACE::Bool32        descriptorBindingStorageImageUpdateAfterBind       = {};
    VULKAN_HPP_NAMESPACE::Bool32        descriptorBindingStorageBufferUpdateAfterBind      = {};
    VULKAN_HPP_NAMESPACE::Bool32        descriptorBindingUniformTexelBufferUpdateAfterBind = {};
    VULKAN_HPP_NAMESPACE::Bool32        descriptorBindingStorageTexelBufferUpdateAfterBind = {};
    VULKAN_HPP_NAMESPACE::Bool32        descriptorBindingUpdateUnusedWhilePending          = {};
    VULKAN_HPP_NAMESPACE::Bool32        descriptorBindingPartiallyBound                    = {};
    VULKAN_HPP_NAMESPACE::Bool32        descriptorBindingVariableDescriptorCount           = {};
    VULKAN_HPP_NAMESPACE::Bool32        runtimeDescriptorArray                             = {};
    VULKAN_HPP_NAMESPACE::Bool32        samplerFilterMinmax                                = {};
    VULKAN_HPP_NAMESPACE::Bool32        scalarBlockLayout                                  = {};
    VULKAN_HPP_NAMESPACE::Bool32        imagelessFramebuffer                               = {};
    VULKAN_HPP_NAMESPACE::Bool32        uniformBufferStandardLayout                        = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderSubgroupExtendedTypes                        = {};
    VULKAN_HPP_NAMESPACE::Bool32        separateDepthStencilLayouts                        = {};
    VULKAN_HPP_NAMESPACE::Bool32        hostQueryReset                                     = {};
    VULKAN_HPP_NAMESPACE::Bool32        timelineSemaphore                                  = {};
    VULKAN_HPP_NAMESPACE::Bool32        bufferDeviceAddress                                = {};
    VULKAN_HPP_NAMESPACE::Bool32        bufferDeviceAddressCaptureReplay                   = {};
    VULKAN_HPP_NAMESPACE::Bool32        bufferDeviceAddressMultiDevice                     = {};
    VULKAN_HPP_NAMESPACE::Bool32        vulkanMemoryModel                                  = {};
    VULKAN_HPP_NAMESPACE::Bool32        vulkanMemoryModelDeviceScope                       = {};
    VULKAN_HPP_NAMESPACE::Bool32        vulkanMemoryModelAvailabilityVisibilityChains      = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderOutputViewportIndex                          = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderOutputLayer                                  = {};
    VULKAN_HPP_NAMESPACE::Bool32        subgroupBroadcastDynamicId                         = {};
  };
  static_assert( sizeof( PhysicalDeviceVulkan12Features ) == sizeof( VkPhysicalDeviceVulkan12Features ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceVulkan12Features>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceVulkan12Features>
  {
    using Type = PhysicalDeviceVulkan12Features;
  };

  struct PhysicalDeviceVulkan12Properties
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::ePhysicalDeviceVulkan12Properties;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceVulkan12Properties(
      VULKAN_HPP_NAMESPACE::DriverId                        driverID_ = VULKAN_HPP_NAMESPACE::DriverId::eAmdProprietary,
      std::array<char, VK_MAX_DRIVER_NAME_SIZE> const &     driverName_         = {},
      std::array<char, VK_MAX_DRIVER_INFO_SIZE> const &     driverInfo_         = {},
      VULKAN_HPP_NAMESPACE::ConformanceVersion              conformanceVersion_ = {},
      VULKAN_HPP_NAMESPACE::ShaderFloatControlsIndependence denormBehaviorIndependence_ =
        VULKAN_HPP_NAMESPACE::ShaderFloatControlsIndependence::e32BitOnly,
      VULKAN_HPP_NAMESPACE::ShaderFloatControlsIndependence roundingModeIndependence_ =
        VULKAN_HPP_NAMESPACE::ShaderFloatControlsIndependence::e32BitOnly,
      VULKAN_HPP_NAMESPACE::Bool32           shaderSignedZeroInfNanPreserveFloat16_                = {},
      VULKAN_HPP_NAMESPACE::Bool32           shaderSignedZeroInfNanPreserveFloat32_                = {},
      VULKAN_HPP_NAMESPACE::Bool32           shaderSignedZeroInfNanPreserveFloat64_                = {},
      VULKAN_HPP_NAMESPACE::Bool32           shaderDenormPreserveFloat16_                          = {},
      VULKAN_HPP_NAMESPACE::Bool32           shaderDenormPreserveFloat32_                          = {},
      VULKAN_HPP_NAMESPACE::Bool32           shaderDenormPreserveFloat64_                          = {},
      VULKAN_HPP_NAMESPACE::Bool32           shaderDenormFlushToZeroFloat16_                       = {},
      VULKAN_HPP_NAMESPACE::Bool32           shaderDenormFlushToZeroFloat32_                       = {},
      VULKAN_HPP_NAMESPACE::Bool32           shaderDenormFlushToZeroFloat64_                       = {},
      VULKAN_HPP_NAMESPACE::Bool32           shaderRoundingModeRTEFloat16_                         = {},
      VULKAN_HPP_NAMESPACE::Bool32           shaderRoundingModeRTEFloat32_                         = {},
      VULKAN_HPP_NAMESPACE::Bool32           shaderRoundingModeRTEFloat64_                         = {},
      VULKAN_HPP_NAMESPACE::Bool32           shaderRoundingModeRTZFloat16_                         = {},
      VULKAN_HPP_NAMESPACE::Bool32           shaderRoundingModeRTZFloat32_                         = {},
      VULKAN_HPP_NAMESPACE::Bool32           shaderRoundingModeRTZFloat64_                         = {},
      uint32_t                               maxUpdateAfterBindDescriptorsInAllPools_              = {},
      VULKAN_HPP_NAMESPACE::Bool32           shaderUniformBufferArrayNonUniformIndexingNative_     = {},
      VULKAN_HPP_NAMESPACE::Bool32           shaderSampledImageArrayNonUniformIndexingNative_      = {},
      VULKAN_HPP_NAMESPACE::Bool32           shaderStorageBufferArrayNonUniformIndexingNative_     = {},
      VULKAN_HPP_NAMESPACE::Bool32           shaderStorageImageArrayNonUniformIndexingNative_      = {},
      VULKAN_HPP_NAMESPACE::Bool32           shaderInputAttachmentArrayNonUniformIndexingNative_   = {},
      VULKAN_HPP_NAMESPACE::Bool32           robustBufferAccessUpdateAfterBind_                    = {},
      VULKAN_HPP_NAMESPACE::Bool32           quadDivergentImplicitLod_                             = {},
      uint32_t                               maxPerStageDescriptorUpdateAfterBindSamplers_         = {},
      uint32_t                               maxPerStageDescriptorUpdateAfterBindUniformBuffers_   = {},
      uint32_t                               maxPerStageDescriptorUpdateAfterBindStorageBuffers_   = {},
      uint32_t                               maxPerStageDescriptorUpdateAfterBindSampledImages_    = {},
      uint32_t                               maxPerStageDescriptorUpdateAfterBindStorageImages_    = {},
      uint32_t                               maxPerStageDescriptorUpdateAfterBindInputAttachments_ = {},
      uint32_t                               maxPerStageUpdateAfterBindResources_                  = {},
      uint32_t                               maxDescriptorSetUpdateAfterBindSamplers_              = {},
      uint32_t                               maxDescriptorSetUpdateAfterBindUniformBuffers_        = {},
      uint32_t                               maxDescriptorSetUpdateAfterBindUniformBuffersDynamic_ = {},
      uint32_t                               maxDescriptorSetUpdateAfterBindStorageBuffers_        = {},
      uint32_t                               maxDescriptorSetUpdateAfterBindStorageBuffersDynamic_ = {},
      uint32_t                               maxDescriptorSetUpdateAfterBindSampledImages_         = {},
      uint32_t                               maxDescriptorSetUpdateAfterBindStorageImages_         = {},
      uint32_t                               maxDescriptorSetUpdateAfterBindInputAttachments_      = {},
      VULKAN_HPP_NAMESPACE::ResolveModeFlags supportedDepthResolveModes_                           = {},
      VULKAN_HPP_NAMESPACE::ResolveModeFlags supportedStencilResolveModes_                         = {},
      VULKAN_HPP_NAMESPACE::Bool32           independentResolveNone_                               = {},
      VULKAN_HPP_NAMESPACE::Bool32           independentResolve_                                   = {},
      VULKAN_HPP_NAMESPACE::Bool32           filterMinmaxSingleComponentFormats_                   = {},
      VULKAN_HPP_NAMESPACE::Bool32           filterMinmaxImageComponentMapping_                    = {},
      uint64_t                               maxTimelineSemaphoreValueDifference_                  = {},
      VULKAN_HPP_NAMESPACE::SampleCountFlags framebufferIntegerColorSampleCounts_ = {} ) VULKAN_HPP_NOEXCEPT
      : driverID( driverID_ )
      , driverName( driverName_ )
      , driverInfo( driverInfo_ )
      , conformanceVersion( conformanceVersion_ )
      , denormBehaviorIndependence( denormBehaviorIndependence_ )
      , roundingModeIndependence( roundingModeIndependence_ )
      , shaderSignedZeroInfNanPreserveFloat16( shaderSignedZeroInfNanPreserveFloat16_ )
      , shaderSignedZeroInfNanPreserveFloat32( shaderSignedZeroInfNanPreserveFloat32_ )
      , shaderSignedZeroInfNanPreserveFloat64( shaderSignedZeroInfNanPreserveFloat64_ )
      , shaderDenormPreserveFloat16( shaderDenormPreserveFloat16_ )
      , shaderDenormPreserveFloat32( shaderDenormPreserveFloat32_ )
      , shaderDenormPreserveFloat64( shaderDenormPreserveFloat64_ )
      , shaderDenormFlushToZeroFloat16( shaderDenormFlushToZeroFloat16_ )
      , shaderDenormFlushToZeroFloat32( shaderDenormFlushToZeroFloat32_ )
      , shaderDenormFlushToZeroFloat64( shaderDenormFlushToZeroFloat64_ )
      , shaderRoundingModeRTEFloat16( shaderRoundingModeRTEFloat16_ )
      , shaderRoundingModeRTEFloat32( shaderRoundingModeRTEFloat32_ )
      , shaderRoundingModeRTEFloat64( shaderRoundingModeRTEFloat64_ )
      , shaderRoundingModeRTZFloat16( shaderRoundingModeRTZFloat16_ )
      , shaderRoundingModeRTZFloat32( shaderRoundingModeRTZFloat32_ )
      , shaderRoundingModeRTZFloat64( shaderRoundingModeRTZFloat64_ )
      , maxUpdateAfterBindDescriptorsInAllPools( maxUpdateAfterBindDescriptorsInAllPools_ )
      , shaderUniformBufferArrayNonUniformIndexingNative( shaderUniformBufferArrayNonUniformIndexingNative_ )
      , shaderSampledImageArrayNonUniformIndexingNative( shaderSampledImageArrayNonUniformIndexingNative_ )
      , shaderStorageBufferArrayNonUniformIndexingNative( shaderStorageBufferArrayNonUniformIndexingNative_ )
      , shaderStorageImageArrayNonUniformIndexingNative( shaderStorageImageArrayNonUniformIndexingNative_ )
      , shaderInputAttachmentArrayNonUniformIndexingNative( shaderInputAttachmentArrayNonUniformIndexingNative_ )
      , robustBufferAccessUpdateAfterBind( robustBufferAccessUpdateAfterBind_ )
      , quadDivergentImplicitLod( quadDivergentImplicitLod_ )
      , maxPerStageDescriptorUpdateAfterBindSamplers( maxPerStageDescriptorUpdateAfterBindSamplers_ )
      , maxPerStageDescriptorUpdateAfterBindUniformBuffers( maxPerStageDescriptorUpdateAfterBindUniformBuffers_ )
      , maxPerStageDescriptorUpdateAfterBindStorageBuffers( maxPerStageDescriptorUpdateAfterBindStorageBuffers_ )
      , maxPerStageDescriptorUpdateAfterBindSampledImages( maxPerStageDescriptorUpdateAfterBindSampledImages_ )
      , maxPerStageDescriptorUpdateAfterBindStorageImages( maxPerStageDescriptorUpdateAfterBindStorageImages_ )
      , maxPerStageDescriptorUpdateAfterBindInputAttachments( maxPerStageDescriptorUpdateAfterBindInputAttachments_ )
      , maxPerStageUpdateAfterBindResources( maxPerStageUpdateAfterBindResources_ )
      , maxDescriptorSetUpdateAfterBindSamplers( maxDescriptorSetUpdateAfterBindSamplers_ )
      , maxDescriptorSetUpdateAfterBindUniformBuffers( maxDescriptorSetUpdateAfterBindUniformBuffers_ )
      , maxDescriptorSetUpdateAfterBindUniformBuffersDynamic( maxDescriptorSetUpdateAfterBindUniformBuffersDynamic_ )
      , maxDescriptorSetUpdateAfterBindStorageBuffers( maxDescriptorSetUpdateAfterBindStorageBuffers_ )
      , maxDescriptorSetUpdateAfterBindStorageBuffersDynamic( maxDescriptorSetUpdateAfterBindStorageBuffersDynamic_ )
      , maxDescriptorSetUpdateAfterBindSampledImages( maxDescriptorSetUpdateAfterBindSampledImages_ )
      , maxDescriptorSetUpdateAfterBindStorageImages( maxDescriptorSetUpdateAfterBindStorageImages_ )
      , maxDescriptorSetUpdateAfterBindInputAttachments( maxDescriptorSetUpdateAfterBindInputAttachments_ )
      , supportedDepthResolveModes( supportedDepthResolveModes_ )
      , supportedStencilResolveModes( supportedStencilResolveModes_ )
      , independentResolveNone( independentResolveNone_ )
      , independentResolve( independentResolve_ )
      , filterMinmaxSingleComponentFormats( filterMinmaxSingleComponentFormats_ )
      , filterMinmaxImageComponentMapping( filterMinmaxImageComponentMapping_ )
      , maxTimelineSemaphoreValueDifference( maxTimelineSemaphoreValueDifference_ )
      , framebufferIntegerColorSampleCounts( framebufferIntegerColorSampleCounts_ )
    {}

    VULKAN_HPP_CONSTEXPR_14
      PhysicalDeviceVulkan12Properties( PhysicalDeviceVulkan12Properties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceVulkan12Properties( VkPhysicalDeviceVulkan12Properties const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceVulkan12Properties( *reinterpret_cast<PhysicalDeviceVulkan12Properties const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceVulkan12Properties &
                            operator=( PhysicalDeviceVulkan12Properties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceVulkan12Properties & operator=( VkPhysicalDeviceVulkan12Properties const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceVulkan12Properties const *>( &rhs );
      return *this;
    }

    operator VkPhysicalDeviceVulkan12Properties const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceVulkan12Properties *>( this );
    }

    operator VkPhysicalDeviceVulkan12Properties &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceVulkan12Properties *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceVulkan12Properties const & ) const = default;
#else
    bool operator==( PhysicalDeviceVulkan12Properties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( driverID == rhs.driverID ) &&
             ( driverName == rhs.driverName ) && ( driverInfo == rhs.driverInfo ) &&
             ( conformanceVersion == rhs.conformanceVersion ) &&
             ( denormBehaviorIndependence == rhs.denormBehaviorIndependence ) &&
             ( roundingModeIndependence == rhs.roundingModeIndependence ) &&
             ( shaderSignedZeroInfNanPreserveFloat16 == rhs.shaderSignedZeroInfNanPreserveFloat16 ) &&
             ( shaderSignedZeroInfNanPreserveFloat32 == rhs.shaderSignedZeroInfNanPreserveFloat32 ) &&
             ( shaderSignedZeroInfNanPreserveFloat64 == rhs.shaderSignedZeroInfNanPreserveFloat64 ) &&
             ( shaderDenormPreserveFloat16 == rhs.shaderDenormPreserveFloat16 ) &&
             ( shaderDenormPreserveFloat32 == rhs.shaderDenormPreserveFloat32 ) &&
             ( shaderDenormPreserveFloat64 == rhs.shaderDenormPreserveFloat64 ) &&
             ( shaderDenormFlushToZeroFloat16 == rhs.shaderDenormFlushToZeroFloat16 ) &&
             ( shaderDenormFlushToZeroFloat32 == rhs.shaderDenormFlushToZeroFloat32 ) &&
             ( shaderDenormFlushToZeroFloat64 == rhs.shaderDenormFlushToZeroFloat64 ) &&
             ( shaderRoundingModeRTEFloat16 == rhs.shaderRoundingModeRTEFloat16 ) &&
             ( shaderRoundingModeRTEFloat32 == rhs.shaderRoundingModeRTEFloat32 ) &&
             ( shaderRoundingModeRTEFloat64 == rhs.shaderRoundingModeRTEFloat64 ) &&
             ( shaderRoundingModeRTZFloat16 == rhs.shaderRoundingModeRTZFloat16 ) &&
             ( shaderRoundingModeRTZFloat32 == rhs.shaderRoundingModeRTZFloat32 ) &&
             ( shaderRoundingModeRTZFloat64 == rhs.shaderRoundingModeRTZFloat64 ) &&
             ( maxUpdateAfterBindDescriptorsInAllPools == rhs.maxUpdateAfterBindDescriptorsInAllPools ) &&
             ( shaderUniformBufferArrayNonUniformIndexingNative ==
               rhs.shaderUniformBufferArrayNonUniformIndexingNative ) &&
             ( shaderSampledImageArrayNonUniformIndexingNative ==
               rhs.shaderSampledImageArrayNonUniformIndexingNative ) &&
             ( shaderStorageBufferArrayNonUniformIndexingNative ==
               rhs.shaderStorageBufferArrayNonUniformIndexingNative ) &&
             ( shaderStorageImageArrayNonUniformIndexingNative ==
               rhs.shaderStorageImageArrayNonUniformIndexingNative ) &&
             ( shaderInputAttachmentArrayNonUniformIndexingNative ==
               rhs.shaderInputAttachmentArrayNonUniformIndexingNative ) &&
             ( robustBufferAccessUpdateAfterBind == rhs.robustBufferAccessUpdateAfterBind ) &&
             ( quadDivergentImplicitLod == rhs.quadDivergentImplicitLod ) &&
             ( maxPerStageDescriptorUpdateAfterBindSamplers == rhs.maxPerStageDescriptorUpdateAfterBindSamplers ) &&
             ( maxPerStageDescriptorUpdateAfterBindUniformBuffers ==
               rhs.maxPerStageDescriptorUpdateAfterBindUniformBuffers ) &&
             ( maxPerStageDescriptorUpdateAfterBindStorageBuffers ==
               rhs.maxPerStageDescriptorUpdateAfterBindStorageBuffers ) &&
             ( maxPerStageDescriptorUpdateAfterBindSampledImages ==
               rhs.maxPerStageDescriptorUpdateAfterBindSampledImages ) &&
             ( maxPerStageDescriptorUpdateAfterBindStorageImages ==
               rhs.maxPerStageDescriptorUpdateAfterBindStorageImages ) &&
             ( maxPerStageDescriptorUpdateAfterBindInputAttachments ==
               rhs.maxPerStageDescriptorUpdateAfterBindInputAttachments ) &&
             ( maxPerStageUpdateAfterBindResources == rhs.maxPerStageUpdateAfterBindResources ) &&
             ( maxDescriptorSetUpdateAfterBindSamplers == rhs.maxDescriptorSetUpdateAfterBindSamplers ) &&
             ( maxDescriptorSetUpdateAfterBindUniformBuffers == rhs.maxDescriptorSetUpdateAfterBindUniformBuffers ) &&
             ( maxDescriptorSetUpdateAfterBindUniformBuffersDynamic ==
               rhs.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic ) &&
             ( maxDescriptorSetUpdateAfterBindStorageBuffers == rhs.maxDescriptorSetUpdateAfterBindStorageBuffers ) &&
             ( maxDescriptorSetUpdateAfterBindStorageBuffersDynamic ==
               rhs.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic ) &&
             ( maxDescriptorSetUpdateAfterBindSampledImages == rhs.maxDescriptorSetUpdateAfterBindSampledImages ) &&
             ( maxDescriptorSetUpdateAfterBindStorageImages == rhs.maxDescriptorSetUpdateAfterBindStorageImages ) &&
             ( maxDescriptorSetUpdateAfterBindInputAttachments ==
               rhs.maxDescriptorSetUpdateAfterBindInputAttachments ) &&
             ( supportedDepthResolveModes == rhs.supportedDepthResolveModes ) &&
             ( supportedStencilResolveModes == rhs.supportedStencilResolveModes ) &&
             ( independentResolveNone == rhs.independentResolveNone ) &&
             ( independentResolve == rhs.independentResolve ) &&
             ( filterMinmaxSingleComponentFormats == rhs.filterMinmaxSingleComponentFormats ) &&
             ( filterMinmaxImageComponentMapping == rhs.filterMinmaxImageComponentMapping ) &&
             ( maxTimelineSemaphoreValueDifference == rhs.maxTimelineSemaphoreValueDifference ) &&
             ( framebufferIntegerColorSampleCounts == rhs.framebufferIntegerColorSampleCounts );
    }

    bool operator!=( PhysicalDeviceVulkan12Properties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType    = StructureType::ePhysicalDeviceVulkan12Properties;
    void *                              pNext    = {};
    VULKAN_HPP_NAMESPACE::DriverId      driverID = VULKAN_HPP_NAMESPACE::DriverId::eAmdProprietary;
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<char, VK_MAX_DRIVER_NAME_SIZE> driverName         = {};
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<char, VK_MAX_DRIVER_INFO_SIZE> driverInfo         = {};
    VULKAN_HPP_NAMESPACE::ConformanceVersion                            conformanceVersion = {};
    VULKAN_HPP_NAMESPACE::ShaderFloatControlsIndependence               denormBehaviorIndependence =
      VULKAN_HPP_NAMESPACE::ShaderFloatControlsIndependence::e32BitOnly;
    VULKAN_HPP_NAMESPACE::ShaderFloatControlsIndependence roundingModeIndependence =
      VULKAN_HPP_NAMESPACE::ShaderFloatControlsIndependence::e32BitOnly;
    VULKAN_HPP_NAMESPACE::Bool32           shaderSignedZeroInfNanPreserveFloat16                = {};
    VULKAN_HPP_NAMESPACE::Bool32           shaderSignedZeroInfNanPreserveFloat32                = {};
    VULKAN_HPP_NAMESPACE::Bool32           shaderSignedZeroInfNanPreserveFloat64                = {};
    VULKAN_HPP_NAMESPACE::Bool32           shaderDenormPreserveFloat16                          = {};
    VULKAN_HPP_NAMESPACE::Bool32           shaderDenormPreserveFloat32                          = {};
    VULKAN_HPP_NAMESPACE::Bool32           shaderDenormPreserveFloat64                          = {};
    VULKAN_HPP_NAMESPACE::Bool32           shaderDenormFlushToZeroFloat16                       = {};
    VULKAN_HPP_NAMESPACE::Bool32           shaderDenormFlushToZeroFloat32                       = {};
    VULKAN_HPP_NAMESPACE::Bool32           shaderDenormFlushToZeroFloat64                       = {};
    VULKAN_HPP_NAMESPACE::Bool32           shaderRoundingModeRTEFloat16                         = {};
    VULKAN_HPP_NAMESPACE::Bool32           shaderRoundingModeRTEFloat32                         = {};
    VULKAN_HPP_NAMESPACE::Bool32           shaderRoundingModeRTEFloat64                         = {};
    VULKAN_HPP_NAMESPACE::Bool32           shaderRoundingModeRTZFloat16                         = {};
    VULKAN_HPP_NAMESPACE::Bool32           shaderRoundingModeRTZFloat32                         = {};
    VULKAN_HPP_NAMESPACE::Bool32           shaderRoundingModeRTZFloat64                         = {};
    uint32_t                               maxUpdateAfterBindDescriptorsInAllPools              = {};
    VULKAN_HPP_NAMESPACE::Bool32           shaderUniformBufferArrayNonUniformIndexingNative     = {};
    VULKAN_HPP_NAMESPACE::Bool32           shaderSampledImageArrayNonUniformIndexingNative      = {};
    VULKAN_HPP_NAMESPACE::Bool32           shaderStorageBufferArrayNonUniformIndexingNative     = {};
    VULKAN_HPP_NAMESPACE::Bool32           shaderStorageImageArrayNonUniformIndexingNative      = {};
    VULKAN_HPP_NAMESPACE::Bool32           shaderInputAttachmentArrayNonUniformIndexingNative   = {};
    VULKAN_HPP_NAMESPACE::Bool32           robustBufferAccessUpdateAfterBind                    = {};
    VULKAN_HPP_NAMESPACE::Bool32           quadDivergentImplicitLod                             = {};
    uint32_t                               maxPerStageDescriptorUpdateAfterBindSamplers         = {};
    uint32_t                               maxPerStageDescriptorUpdateAfterBindUniformBuffers   = {};
    uint32_t                               maxPerStageDescriptorUpdateAfterBindStorageBuffers   = {};
    uint32_t                               maxPerStageDescriptorUpdateAfterBindSampledImages    = {};
    uint32_t                               maxPerStageDescriptorUpdateAfterBindStorageImages    = {};
    uint32_t                               maxPerStageDescriptorUpdateAfterBindInputAttachments = {};
    uint32_t                               maxPerStageUpdateAfterBindResources                  = {};
    uint32_t                               maxDescriptorSetUpdateAfterBindSamplers              = {};
    uint32_t                               maxDescriptorSetUpdateAfterBindUniformBuffers        = {};
    uint32_t                               maxDescriptorSetUpdateAfterBindUniformBuffersDynamic = {};
    uint32_t                               maxDescriptorSetUpdateAfterBindStorageBuffers        = {};
    uint32_t                               maxDescriptorSetUpdateAfterBindStorageBuffersDynamic = {};
    uint32_t                               maxDescriptorSetUpdateAfterBindSampledImages         = {};
    uint32_t                               maxDescriptorSetUpdateAfterBindStorageImages         = {};
    uint32_t                               maxDescriptorSetUpdateAfterBindInputAttachments      = {};
    VULKAN_HPP_NAMESPACE::ResolveModeFlags supportedDepthResolveModes                           = {};
    VULKAN_HPP_NAMESPACE::ResolveModeFlags supportedStencilResolveModes                         = {};
    VULKAN_HPP_NAMESPACE::Bool32           independentResolveNone                               = {};
    VULKAN_HPP_NAMESPACE::Bool32           independentResolve                                   = {};
    VULKAN_HPP_NAMESPACE::Bool32           filterMinmaxSingleComponentFormats                   = {};
    VULKAN_HPP_NAMESPACE::Bool32           filterMinmaxImageComponentMapping                    = {};
    uint64_t                               maxTimelineSemaphoreValueDifference                  = {};
    VULKAN_HPP_NAMESPACE::SampleCountFlags framebufferIntegerColorSampleCounts                  = {};
  };
  static_assert( sizeof( PhysicalDeviceVulkan12Properties ) == sizeof( VkPhysicalDeviceVulkan12Properties ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceVulkan12Properties>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceVulkan12Properties>
  {
    using Type = PhysicalDeviceVulkan12Properties;
  };

  struct PhysicalDeviceVulkanMemoryModelFeatures
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceVulkanMemoryModelFeatures;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceVulkanMemoryModelFeatures(
      VULKAN_HPP_NAMESPACE::Bool32 vulkanMemoryModel_                             = {},
      VULKAN_HPP_NAMESPACE::Bool32 vulkanMemoryModelDeviceScope_                  = {},
      VULKAN_HPP_NAMESPACE::Bool32 vulkanMemoryModelAvailabilityVisibilityChains_ = {} ) VULKAN_HPP_NOEXCEPT
      : vulkanMemoryModel( vulkanMemoryModel_ )
      , vulkanMemoryModelDeviceScope( vulkanMemoryModelDeviceScope_ )
      , vulkanMemoryModelAvailabilityVisibilityChains( vulkanMemoryModelAvailabilityVisibilityChains_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceVulkanMemoryModelFeatures( PhysicalDeviceVulkanMemoryModelFeatures const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceVulkanMemoryModelFeatures( VkPhysicalDeviceVulkanMemoryModelFeatures const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceVulkanMemoryModelFeatures(
          *reinterpret_cast<PhysicalDeviceVulkanMemoryModelFeatures const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceVulkanMemoryModelFeatures &
                            operator=( PhysicalDeviceVulkanMemoryModelFeatures const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceVulkanMemoryModelFeatures &
      operator=( VkPhysicalDeviceVulkanMemoryModelFeatures const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceVulkanMemoryModelFeatures const *>( &rhs );
      return *this;
    }

    PhysicalDeviceVulkanMemoryModelFeatures & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceVulkanMemoryModelFeatures &
      setVulkanMemoryModel( VULKAN_HPP_NAMESPACE::Bool32 vulkanMemoryModel_ ) VULKAN_HPP_NOEXCEPT
    {
      vulkanMemoryModel = vulkanMemoryModel_;
      return *this;
    }

    PhysicalDeviceVulkanMemoryModelFeatures &
      setVulkanMemoryModelDeviceScope( VULKAN_HPP_NAMESPACE::Bool32 vulkanMemoryModelDeviceScope_ ) VULKAN_HPP_NOEXCEPT
    {
      vulkanMemoryModelDeviceScope = vulkanMemoryModelDeviceScope_;
      return *this;
    }

    PhysicalDeviceVulkanMemoryModelFeatures & setVulkanMemoryModelAvailabilityVisibilityChains(
      VULKAN_HPP_NAMESPACE::Bool32 vulkanMemoryModelAvailabilityVisibilityChains_ ) VULKAN_HPP_NOEXCEPT
    {
      vulkanMemoryModelAvailabilityVisibilityChains = vulkanMemoryModelAvailabilityVisibilityChains_;
      return *this;
    }

    operator VkPhysicalDeviceVulkanMemoryModelFeatures const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceVulkanMemoryModelFeatures *>( this );
    }

    operator VkPhysicalDeviceVulkanMemoryModelFeatures &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceVulkanMemoryModelFeatures *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceVulkanMemoryModelFeatures const & ) const = default;
#else
    bool operator==( PhysicalDeviceVulkanMemoryModelFeatures const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( vulkanMemoryModel == rhs.vulkanMemoryModel ) &&
             ( vulkanMemoryModelDeviceScope == rhs.vulkanMemoryModelDeviceScope ) &&
             ( vulkanMemoryModelAvailabilityVisibilityChains == rhs.vulkanMemoryModelAvailabilityVisibilityChains );
    }

    bool operator!=( PhysicalDeviceVulkanMemoryModelFeatures const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType             = StructureType::ePhysicalDeviceVulkanMemoryModelFeatures;
    void *                              pNext             = {};
    VULKAN_HPP_NAMESPACE::Bool32        vulkanMemoryModel = {};
    VULKAN_HPP_NAMESPACE::Bool32        vulkanMemoryModelDeviceScope                  = {};
    VULKAN_HPP_NAMESPACE::Bool32        vulkanMemoryModelAvailabilityVisibilityChains = {};
  };
  static_assert( sizeof( PhysicalDeviceVulkanMemoryModelFeatures ) ==
                   sizeof( VkPhysicalDeviceVulkanMemoryModelFeatures ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceVulkanMemoryModelFeatures>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceVulkanMemoryModelFeatures>
  {
    using Type = PhysicalDeviceVulkanMemoryModelFeatures;
  };
  using PhysicalDeviceVulkanMemoryModelFeaturesKHR = PhysicalDeviceVulkanMemoryModelFeatures;

  struct PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR(
      VULKAN_HPP_NAMESPACE::Bool32 workgroupMemoryExplicitLayout_                  = {},
      VULKAN_HPP_NAMESPACE::Bool32 workgroupMemoryExplicitLayoutScalarBlockLayout_ = {},
      VULKAN_HPP_NAMESPACE::Bool32 workgroupMemoryExplicitLayout8BitAccess_        = {},
      VULKAN_HPP_NAMESPACE::Bool32 workgroupMemoryExplicitLayout16BitAccess_       = {} ) VULKAN_HPP_NOEXCEPT
      : workgroupMemoryExplicitLayout( workgroupMemoryExplicitLayout_ )
      , workgroupMemoryExplicitLayoutScalarBlockLayout( workgroupMemoryExplicitLayoutScalarBlockLayout_ )
      , workgroupMemoryExplicitLayout8BitAccess( workgroupMemoryExplicitLayout8BitAccess_ )
      , workgroupMemoryExplicitLayout16BitAccess( workgroupMemoryExplicitLayout16BitAccess_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR(
      PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR(
      VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR(
          *reinterpret_cast<PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR &
                            operator=( PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR &
      operator=( VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this =
        *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR const *>( &rhs );
      return *this;
    }

    PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR & setWorkgroupMemoryExplicitLayout(
      VULKAN_HPP_NAMESPACE::Bool32 workgroupMemoryExplicitLayout_ ) VULKAN_HPP_NOEXCEPT
    {
      workgroupMemoryExplicitLayout = workgroupMemoryExplicitLayout_;
      return *this;
    }

    PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR & setWorkgroupMemoryExplicitLayoutScalarBlockLayout(
      VULKAN_HPP_NAMESPACE::Bool32 workgroupMemoryExplicitLayoutScalarBlockLayout_ ) VULKAN_HPP_NOEXCEPT
    {
      workgroupMemoryExplicitLayoutScalarBlockLayout = workgroupMemoryExplicitLayoutScalarBlockLayout_;
      return *this;
    }

    PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR & setWorkgroupMemoryExplicitLayout8BitAccess(
      VULKAN_HPP_NAMESPACE::Bool32 workgroupMemoryExplicitLayout8BitAccess_ ) VULKAN_HPP_NOEXCEPT
    {
      workgroupMemoryExplicitLayout8BitAccess = workgroupMemoryExplicitLayout8BitAccess_;
      return *this;
    }

    PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR & setWorkgroupMemoryExplicitLayout16BitAccess(
      VULKAN_HPP_NAMESPACE::Bool32 workgroupMemoryExplicitLayout16BitAccess_ ) VULKAN_HPP_NOEXCEPT
    {
      workgroupMemoryExplicitLayout16BitAccess = workgroupMemoryExplicitLayout16BitAccess_;
      return *this;
    }

    operator VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR *>( this );
    }

    operator VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR const & ) const = default;
#else
    bool operator==( PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( workgroupMemoryExplicitLayout == rhs.workgroupMemoryExplicitLayout ) &&
             ( workgroupMemoryExplicitLayoutScalarBlockLayout == rhs.workgroupMemoryExplicitLayoutScalarBlockLayout ) &&
             ( workgroupMemoryExplicitLayout8BitAccess == rhs.workgroupMemoryExplicitLayout8BitAccess ) &&
             ( workgroupMemoryExplicitLayout16BitAccess == rhs.workgroupMemoryExplicitLayout16BitAccess );
    }

    bool operator!=( PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        workgroupMemoryExplicitLayout                  = {};
    VULKAN_HPP_NAMESPACE::Bool32        workgroupMemoryExplicitLayoutScalarBlockLayout = {};
    VULKAN_HPP_NAMESPACE::Bool32        workgroupMemoryExplicitLayout8BitAccess        = {};
    VULKAN_HPP_NAMESPACE::Bool32        workgroupMemoryExplicitLayout16BitAccess       = {};
  };
  static_assert( sizeof( PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR ) ==
                   sizeof( VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR>
  {
    using Type = PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR;
  };

  struct PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT(
      VULKAN_HPP_NAMESPACE::Bool32 ycbcr2plane444Formats_ = {} ) VULKAN_HPP_NOEXCEPT
      : ycbcr2plane444Formats( ycbcr2plane444Formats_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT(
      PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT( VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT(
          *reinterpret_cast<PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT &
                            operator=( PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT &
      operator=( VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT const *>( &rhs );
      return *this;
    }

    PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT &
      setYcbcr2plane444Formats( VULKAN_HPP_NAMESPACE::Bool32 ycbcr2plane444Formats_ ) VULKAN_HPP_NOEXCEPT
    {
      ycbcr2plane444Formats = ycbcr2plane444Formats_;
      return *this;
    }

    operator VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT *>( this );
    }

    operator VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( ycbcr2plane444Formats == rhs.ycbcr2plane444Formats );
    }

    bool operator!=( PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        ycbcr2plane444Formats = {};
  };
  static_assert( sizeof( PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT ) ==
                   sizeof( VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT>
  {
    using Type = PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT;
  };

  struct PhysicalDeviceYcbcrImageArraysFeaturesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceYcbcrImageArraysFeaturesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceYcbcrImageArraysFeaturesEXT(
      VULKAN_HPP_NAMESPACE::Bool32 ycbcrImageArrays_ = {} ) VULKAN_HPP_NOEXCEPT : ycbcrImageArrays( ycbcrImageArrays_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceYcbcrImageArraysFeaturesEXT(
      PhysicalDeviceYcbcrImageArraysFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceYcbcrImageArraysFeaturesEXT( VkPhysicalDeviceYcbcrImageArraysFeaturesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceYcbcrImageArraysFeaturesEXT(
          *reinterpret_cast<PhysicalDeviceYcbcrImageArraysFeaturesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceYcbcrImageArraysFeaturesEXT &
                            operator=( PhysicalDeviceYcbcrImageArraysFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceYcbcrImageArraysFeaturesEXT &
      operator=( VkPhysicalDeviceYcbcrImageArraysFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceYcbcrImageArraysFeaturesEXT const *>( &rhs );
      return *this;
    }

    PhysicalDeviceYcbcrImageArraysFeaturesEXT & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceYcbcrImageArraysFeaturesEXT &
      setYcbcrImageArrays( VULKAN_HPP_NAMESPACE::Bool32 ycbcrImageArrays_ ) VULKAN_HPP_NOEXCEPT
    {
      ycbcrImageArrays = ycbcrImageArrays_;
      return *this;
    }

    operator VkPhysicalDeviceYcbcrImageArraysFeaturesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT *>( this );
    }

    operator VkPhysicalDeviceYcbcrImageArraysFeaturesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceYcbcrImageArraysFeaturesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceYcbcrImageArraysFeaturesEXT const & ) const = default;
#else
    bool operator==( PhysicalDeviceYcbcrImageArraysFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( ycbcrImageArrays == rhs.ycbcrImageArrays );
    }

    bool operator!=( PhysicalDeviceYcbcrImageArraysFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType            = StructureType::ePhysicalDeviceYcbcrImageArraysFeaturesEXT;
    void *                              pNext            = {};
    VULKAN_HPP_NAMESPACE::Bool32        ycbcrImageArrays = {};
  };
  static_assert( sizeof( PhysicalDeviceYcbcrImageArraysFeaturesEXT ) ==
                   sizeof( VkPhysicalDeviceYcbcrImageArraysFeaturesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceYcbcrImageArraysFeaturesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceYcbcrImageArraysFeaturesEXT>
  {
    using Type = PhysicalDeviceYcbcrImageArraysFeaturesEXT;
  };

  struct PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR(
      VULKAN_HPP_NAMESPACE::Bool32 shaderZeroInitializeWorkgroupMemory_ = {} ) VULKAN_HPP_NOEXCEPT
      : shaderZeroInitializeWorkgroupMemory( shaderZeroInitializeWorkgroupMemory_ )
    {}

    VULKAN_HPP_CONSTEXPR PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR(
      PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR(
      VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR(
          *reinterpret_cast<PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR &
                            operator=( PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR &
      operator=( VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this =
        *reinterpret_cast<VULKAN_HPP_NAMESPACE::PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR const *>( &rhs );
      return *this;
    }

    PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR & setShaderZeroInitializeWorkgroupMemory(
      VULKAN_HPP_NAMESPACE::Bool32 shaderZeroInitializeWorkgroupMemory_ ) VULKAN_HPP_NOEXCEPT
    {
      shaderZeroInitializeWorkgroupMemory = shaderZeroInitializeWorkgroupMemory_;
      return *this;
    }

    operator VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR *>( this );
    }

    operator VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR const & ) const = default;
#else
    bool operator==( PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( shaderZeroInitializeWorkgroupMemory == rhs.shaderZeroInitializeWorkgroupMemory );
    }

    bool operator!=( PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        shaderZeroInitializeWorkgroupMemory = {};
  };
  static_assert( sizeof( PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR ) ==
                   sizeof( VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR>
  {
    using Type = PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR;
  };

  struct PipelineCacheCreateInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::ePipelineCacheCreateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PipelineCacheCreateInfo( VULKAN_HPP_NAMESPACE::PipelineCacheCreateFlags flags_           = {},
                                                  size_t                                         initialDataSize_ = {},
                                                  const void * pInitialData_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , initialDataSize( initialDataSize_ )
      , pInitialData( pInitialData_ )
    {}

    VULKAN_HPP_CONSTEXPR PipelineCacheCreateInfo( PipelineCacheCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineCacheCreateInfo( VkPipelineCacheCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : PipelineCacheCreateInfo( *reinterpret_cast<PipelineCacheCreateInfo const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    template <typename T>
    PipelineCacheCreateInfo( VULKAN_HPP_NAMESPACE::PipelineCacheCreateFlags                 flags_,
                             VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const T> const & initialData_ )
      : flags( flags_ ), initialDataSize( initialData_.size() * sizeof( T ) ), pInitialData( initialData_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PipelineCacheCreateInfo &
                            operator=( PipelineCacheCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineCacheCreateInfo & operator=( VkPipelineCacheCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PipelineCacheCreateInfo const *>( &rhs );
      return *this;
    }

    PipelineCacheCreateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PipelineCacheCreateInfo & setFlags( VULKAN_HPP_NAMESPACE::PipelineCacheCreateFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    PipelineCacheCreateInfo & setInitialDataSize( size_t initialDataSize_ ) VULKAN_HPP_NOEXCEPT
    {
      initialDataSize = initialDataSize_;
      return *this;
    }

    PipelineCacheCreateInfo & setPInitialData( const void * pInitialData_ ) VULKAN_HPP_NOEXCEPT
    {
      pInitialData = pInitialData_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    template <typename T>
    PipelineCacheCreateInfo &
      setInitialData( VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const T> const & initialData_ ) VULKAN_HPP_NOEXCEPT
    {
      initialDataSize = initialData_.size() * sizeof( T );
      pInitialData    = initialData_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkPipelineCacheCreateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPipelineCacheCreateInfo *>( this );
    }

    operator VkPipelineCacheCreateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPipelineCacheCreateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PipelineCacheCreateInfo const & ) const = default;
#else
    bool operator==( PipelineCacheCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( initialDataSize == rhs.initialDataSize ) && ( pInitialData == rhs.pInitialData );
    }

    bool operator!=( PipelineCacheCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType            sType           = StructureType::ePipelineCacheCreateInfo;
    const void *                                   pNext           = {};
    VULKAN_HPP_NAMESPACE::PipelineCacheCreateFlags flags           = {};
    size_t                                         initialDataSize = {};
    const void *                                   pInitialData    = {};
  };
  static_assert( sizeof( PipelineCacheCreateInfo ) == sizeof( VkPipelineCacheCreateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PipelineCacheCreateInfo>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePipelineCacheCreateInfo>
  {
    using Type = PipelineCacheCreateInfo;
  };

  struct PipelineColorBlendAdvancedStateCreateInfoEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePipelineColorBlendAdvancedStateCreateInfoEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PipelineColorBlendAdvancedStateCreateInfoEXT(
      VULKAN_HPP_NAMESPACE::Bool32          srcPremultiplied_ = {},
      VULKAN_HPP_NAMESPACE::Bool32          dstPremultiplied_ = {},
      VULKAN_HPP_NAMESPACE::BlendOverlapEXT blendOverlap_     = VULKAN_HPP_NAMESPACE::BlendOverlapEXT::eUncorrelated )
      VULKAN_HPP_NOEXCEPT
      : srcPremultiplied( srcPremultiplied_ )
      , dstPremultiplied( dstPremultiplied_ )
      , blendOverlap( blendOverlap_ )
    {}

    VULKAN_HPP_CONSTEXPR PipelineColorBlendAdvancedStateCreateInfoEXT(
      PipelineColorBlendAdvancedStateCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineColorBlendAdvancedStateCreateInfoEXT( VkPipelineColorBlendAdvancedStateCreateInfoEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PipelineColorBlendAdvancedStateCreateInfoEXT(
          *reinterpret_cast<PipelineColorBlendAdvancedStateCreateInfoEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PipelineColorBlendAdvancedStateCreateInfoEXT &
                            operator=( PipelineColorBlendAdvancedStateCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineColorBlendAdvancedStateCreateInfoEXT &
      operator=( VkPipelineColorBlendAdvancedStateCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PipelineColorBlendAdvancedStateCreateInfoEXT const *>( &rhs );
      return *this;
    }

    PipelineColorBlendAdvancedStateCreateInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PipelineColorBlendAdvancedStateCreateInfoEXT &
      setSrcPremultiplied( VULKAN_HPP_NAMESPACE::Bool32 srcPremultiplied_ ) VULKAN_HPP_NOEXCEPT
    {
      srcPremultiplied = srcPremultiplied_;
      return *this;
    }

    PipelineColorBlendAdvancedStateCreateInfoEXT &
      setDstPremultiplied( VULKAN_HPP_NAMESPACE::Bool32 dstPremultiplied_ ) VULKAN_HPP_NOEXCEPT
    {
      dstPremultiplied = dstPremultiplied_;
      return *this;
    }

    PipelineColorBlendAdvancedStateCreateInfoEXT &
      setBlendOverlap( VULKAN_HPP_NAMESPACE::BlendOverlapEXT blendOverlap_ ) VULKAN_HPP_NOEXCEPT
    {
      blendOverlap = blendOverlap_;
      return *this;
    }

    operator VkPipelineColorBlendAdvancedStateCreateInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPipelineColorBlendAdvancedStateCreateInfoEXT *>( this );
    }

    operator VkPipelineColorBlendAdvancedStateCreateInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPipelineColorBlendAdvancedStateCreateInfoEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PipelineColorBlendAdvancedStateCreateInfoEXT const & ) const = default;
#else
    bool operator==( PipelineColorBlendAdvancedStateCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( srcPremultiplied == rhs.srcPremultiplied ) &&
             ( dstPremultiplied == rhs.dstPremultiplied ) && ( blendOverlap == rhs.blendOverlap );
    }

    bool operator!=( PipelineColorBlendAdvancedStateCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType   sType = StructureType::ePipelineColorBlendAdvancedStateCreateInfoEXT;
    const void *                          pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32          srcPremultiplied = {};
    VULKAN_HPP_NAMESPACE::Bool32          dstPremultiplied = {};
    VULKAN_HPP_NAMESPACE::BlendOverlapEXT blendOverlap     = VULKAN_HPP_NAMESPACE::BlendOverlapEXT::eUncorrelated;
  };
  static_assert( sizeof( PipelineColorBlendAdvancedStateCreateInfoEXT ) ==
                   sizeof( VkPipelineColorBlendAdvancedStateCreateInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PipelineColorBlendAdvancedStateCreateInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePipelineColorBlendAdvancedStateCreateInfoEXT>
  {
    using Type = PipelineColorBlendAdvancedStateCreateInfoEXT;
  };

  struct PipelineColorWriteCreateInfoEXT
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::ePipelineColorWriteCreateInfoEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PipelineColorWriteCreateInfoEXT(
      uint32_t                             attachmentCount_    = {},
      const VULKAN_HPP_NAMESPACE::Bool32 * pColorWriteEnables_ = {} ) VULKAN_HPP_NOEXCEPT
      : attachmentCount( attachmentCount_ )
      , pColorWriteEnables( pColorWriteEnables_ )
    {}

    VULKAN_HPP_CONSTEXPR
      PipelineColorWriteCreateInfoEXT( PipelineColorWriteCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineColorWriteCreateInfoEXT( VkPipelineColorWriteCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : PipelineColorWriteCreateInfoEXT( *reinterpret_cast<PipelineColorWriteCreateInfoEXT const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    PipelineColorWriteCreateInfoEXT(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::Bool32> const & colorWriteEnables_ )
      : attachmentCount( static_cast<uint32_t>( colorWriteEnables_.size() ) )
      , pColorWriteEnables( colorWriteEnables_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PipelineColorWriteCreateInfoEXT &
                            operator=( PipelineColorWriteCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineColorWriteCreateInfoEXT & operator=( VkPipelineColorWriteCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PipelineColorWriteCreateInfoEXT const *>( &rhs );
      return *this;
    }

    PipelineColorWriteCreateInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PipelineColorWriteCreateInfoEXT & setAttachmentCount( uint32_t attachmentCount_ ) VULKAN_HPP_NOEXCEPT
    {
      attachmentCount = attachmentCount_;
      return *this;
    }

    PipelineColorWriteCreateInfoEXT &
      setPColorWriteEnables( const VULKAN_HPP_NAMESPACE::Bool32 * pColorWriteEnables_ ) VULKAN_HPP_NOEXCEPT
    {
      pColorWriteEnables = pColorWriteEnables_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    PipelineColorWriteCreateInfoEXT & setColorWriteEnables(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::Bool32> const & colorWriteEnables_ )
      VULKAN_HPP_NOEXCEPT
    {
      attachmentCount    = static_cast<uint32_t>( colorWriteEnables_.size() );
      pColorWriteEnables = colorWriteEnables_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkPipelineColorWriteCreateInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPipelineColorWriteCreateInfoEXT *>( this );
    }

    operator VkPipelineColorWriteCreateInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPipelineColorWriteCreateInfoEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PipelineColorWriteCreateInfoEXT const & ) const = default;
#else
    bool operator==( PipelineColorWriteCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( attachmentCount == rhs.attachmentCount ) &&
             ( pColorWriteEnables == rhs.pColorWriteEnables );
    }

    bool operator!=( PipelineColorWriteCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType  sType              = StructureType::ePipelineColorWriteCreateInfoEXT;
    const void *                         pNext              = {};
    uint32_t                             attachmentCount    = {};
    const VULKAN_HPP_NAMESPACE::Bool32 * pColorWriteEnables = {};
  };
  static_assert( sizeof( PipelineColorWriteCreateInfoEXT ) == sizeof( VkPipelineColorWriteCreateInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PipelineColorWriteCreateInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePipelineColorWriteCreateInfoEXT>
  {
    using Type = PipelineColorWriteCreateInfoEXT;
  };

  struct PipelineCompilerControlCreateInfoAMD
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePipelineCompilerControlCreateInfoAMD;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PipelineCompilerControlCreateInfoAMD(
      VULKAN_HPP_NAMESPACE::PipelineCompilerControlFlagsAMD compilerControlFlags_ = {} ) VULKAN_HPP_NOEXCEPT
      : compilerControlFlags( compilerControlFlags_ )
    {}

    VULKAN_HPP_CONSTEXPR PipelineCompilerControlCreateInfoAMD( PipelineCompilerControlCreateInfoAMD const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    PipelineCompilerControlCreateInfoAMD( VkPipelineCompilerControlCreateInfoAMD const & rhs ) VULKAN_HPP_NOEXCEPT
      : PipelineCompilerControlCreateInfoAMD( *reinterpret_cast<PipelineCompilerControlCreateInfoAMD const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PipelineCompilerControlCreateInfoAMD &
                            operator=( PipelineCompilerControlCreateInfoAMD const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineCompilerControlCreateInfoAMD &
      operator=( VkPipelineCompilerControlCreateInfoAMD const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PipelineCompilerControlCreateInfoAMD const *>( &rhs );
      return *this;
    }

    PipelineCompilerControlCreateInfoAMD & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PipelineCompilerControlCreateInfoAMD & setCompilerControlFlags(
      VULKAN_HPP_NAMESPACE::PipelineCompilerControlFlagsAMD compilerControlFlags_ ) VULKAN_HPP_NOEXCEPT
    {
      compilerControlFlags = compilerControlFlags_;
      return *this;
    }

    operator VkPipelineCompilerControlCreateInfoAMD const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPipelineCompilerControlCreateInfoAMD *>( this );
    }

    operator VkPipelineCompilerControlCreateInfoAMD &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPipelineCompilerControlCreateInfoAMD *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PipelineCompilerControlCreateInfoAMD const & ) const = default;
#else
    bool operator==( PipelineCompilerControlCreateInfoAMD const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( compilerControlFlags == rhs.compilerControlFlags );
    }

    bool operator!=( PipelineCompilerControlCreateInfoAMD const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                   sType = StructureType::ePipelineCompilerControlCreateInfoAMD;
    const void *                                          pNext = {};
    VULKAN_HPP_NAMESPACE::PipelineCompilerControlFlagsAMD compilerControlFlags = {};
  };
  static_assert( sizeof( PipelineCompilerControlCreateInfoAMD ) == sizeof( VkPipelineCompilerControlCreateInfoAMD ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PipelineCompilerControlCreateInfoAMD>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePipelineCompilerControlCreateInfoAMD>
  {
    using Type = PipelineCompilerControlCreateInfoAMD;
  };

  struct PipelineCoverageModulationStateCreateInfoNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePipelineCoverageModulationStateCreateInfoNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PipelineCoverageModulationStateCreateInfoNV(
      VULKAN_HPP_NAMESPACE::PipelineCoverageModulationStateCreateFlagsNV flags_ = {},
      VULKAN_HPP_NAMESPACE::CoverageModulationModeNV                     coverageModulationMode_ =
        VULKAN_HPP_NAMESPACE::CoverageModulationModeNV::eNone,
      VULKAN_HPP_NAMESPACE::Bool32 coverageModulationTableEnable_ = {},
      uint32_t                     coverageModulationTableCount_  = {},
      const float *                pCoverageModulationTable_      = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , coverageModulationMode( coverageModulationMode_ )
      , coverageModulationTableEnable( coverageModulationTableEnable_ )
      , coverageModulationTableCount( coverageModulationTableCount_ )
      , pCoverageModulationTable( pCoverageModulationTable_ )
    {}

    VULKAN_HPP_CONSTEXPR PipelineCoverageModulationStateCreateInfoNV(
      PipelineCoverageModulationStateCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineCoverageModulationStateCreateInfoNV( VkPipelineCoverageModulationStateCreateInfoNV const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PipelineCoverageModulationStateCreateInfoNV(
          *reinterpret_cast<PipelineCoverageModulationStateCreateInfoNV const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    PipelineCoverageModulationStateCreateInfoNV(
      VULKAN_HPP_NAMESPACE::PipelineCoverageModulationStateCreateFlagsNV flags_,
      VULKAN_HPP_NAMESPACE::CoverageModulationModeNV                     coverageModulationMode_,
      VULKAN_HPP_NAMESPACE::Bool32                                       coverageModulationTableEnable_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const float> const & coverageModulationTable_ )
      : flags( flags_ )
      , coverageModulationMode( coverageModulationMode_ )
      , coverageModulationTableEnable( coverageModulationTableEnable_ )
      , coverageModulationTableCount( static_cast<uint32_t>( coverageModulationTable_.size() ) )
      , pCoverageModulationTable( coverageModulationTable_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PipelineCoverageModulationStateCreateInfoNV &
                            operator=( PipelineCoverageModulationStateCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineCoverageModulationStateCreateInfoNV &
      operator=( VkPipelineCoverageModulationStateCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PipelineCoverageModulationStateCreateInfoNV const *>( &rhs );
      return *this;
    }

    PipelineCoverageModulationStateCreateInfoNV & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PipelineCoverageModulationStateCreateInfoNV &
      setFlags( VULKAN_HPP_NAMESPACE::PipelineCoverageModulationStateCreateFlagsNV flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    PipelineCoverageModulationStateCreateInfoNV & setCoverageModulationMode(
      VULKAN_HPP_NAMESPACE::CoverageModulationModeNV coverageModulationMode_ ) VULKAN_HPP_NOEXCEPT
    {
      coverageModulationMode = coverageModulationMode_;
      return *this;
    }

    PipelineCoverageModulationStateCreateInfoNV & setCoverageModulationTableEnable(
      VULKAN_HPP_NAMESPACE::Bool32 coverageModulationTableEnable_ ) VULKAN_HPP_NOEXCEPT
    {
      coverageModulationTableEnable = coverageModulationTableEnable_;
      return *this;
    }

    PipelineCoverageModulationStateCreateInfoNV &
      setCoverageModulationTableCount( uint32_t coverageModulationTableCount_ ) VULKAN_HPP_NOEXCEPT
    {
      coverageModulationTableCount = coverageModulationTableCount_;
      return *this;
    }

    PipelineCoverageModulationStateCreateInfoNV &
      setPCoverageModulationTable( const float * pCoverageModulationTable_ ) VULKAN_HPP_NOEXCEPT
    {
      pCoverageModulationTable = pCoverageModulationTable_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    PipelineCoverageModulationStateCreateInfoNV & setCoverageModulationTable(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const float> const & coverageModulationTable_ ) VULKAN_HPP_NOEXCEPT
    {
      coverageModulationTableCount = static_cast<uint32_t>( coverageModulationTable_.size() );
      pCoverageModulationTable     = coverageModulationTable_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkPipelineCoverageModulationStateCreateInfoNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPipelineCoverageModulationStateCreateInfoNV *>( this );
    }

    operator VkPipelineCoverageModulationStateCreateInfoNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPipelineCoverageModulationStateCreateInfoNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PipelineCoverageModulationStateCreateInfoNV const & ) const = default;
#else
    bool operator==( PipelineCoverageModulationStateCreateInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( coverageModulationMode == rhs.coverageModulationMode ) &&
             ( coverageModulationTableEnable == rhs.coverageModulationTableEnable ) &&
             ( coverageModulationTableCount == rhs.coverageModulationTableCount ) &&
             ( pCoverageModulationTable == rhs.pCoverageModulationTable );
    }

    bool operator!=( PipelineCoverageModulationStateCreateInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePipelineCoverageModulationStateCreateInfoNV;
    const void *                        pNext = {};
    VULKAN_HPP_NAMESPACE::PipelineCoverageModulationStateCreateFlagsNV flags = {};
    VULKAN_HPP_NAMESPACE::CoverageModulationModeNV                     coverageModulationMode =
      VULKAN_HPP_NAMESPACE::CoverageModulationModeNV::eNone;
    VULKAN_HPP_NAMESPACE::Bool32 coverageModulationTableEnable = {};
    uint32_t                     coverageModulationTableCount  = {};
    const float *                pCoverageModulationTable      = {};
  };
  static_assert( sizeof( PipelineCoverageModulationStateCreateInfoNV ) ==
                   sizeof( VkPipelineCoverageModulationStateCreateInfoNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PipelineCoverageModulationStateCreateInfoNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePipelineCoverageModulationStateCreateInfoNV>
  {
    using Type = PipelineCoverageModulationStateCreateInfoNV;
  };

  struct PipelineCoverageReductionStateCreateInfoNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePipelineCoverageReductionStateCreateInfoNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PipelineCoverageReductionStateCreateInfoNV(
      VULKAN_HPP_NAMESPACE::PipelineCoverageReductionStateCreateFlagsNV flags_ = {},
      VULKAN_HPP_NAMESPACE::CoverageReductionModeNV                     coverageReductionMode_ =
        VULKAN_HPP_NAMESPACE::CoverageReductionModeNV::eMerge ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , coverageReductionMode( coverageReductionMode_ )
    {}

    VULKAN_HPP_CONSTEXPR PipelineCoverageReductionStateCreateInfoNV(
      PipelineCoverageReductionStateCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineCoverageReductionStateCreateInfoNV( VkPipelineCoverageReductionStateCreateInfoNV const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PipelineCoverageReductionStateCreateInfoNV(
          *reinterpret_cast<PipelineCoverageReductionStateCreateInfoNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PipelineCoverageReductionStateCreateInfoNV &
                            operator=( PipelineCoverageReductionStateCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineCoverageReductionStateCreateInfoNV &
      operator=( VkPipelineCoverageReductionStateCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PipelineCoverageReductionStateCreateInfoNV const *>( &rhs );
      return *this;
    }

    PipelineCoverageReductionStateCreateInfoNV & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PipelineCoverageReductionStateCreateInfoNV &
      setFlags( VULKAN_HPP_NAMESPACE::PipelineCoverageReductionStateCreateFlagsNV flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    PipelineCoverageReductionStateCreateInfoNV & setCoverageReductionMode(
      VULKAN_HPP_NAMESPACE::CoverageReductionModeNV coverageReductionMode_ ) VULKAN_HPP_NOEXCEPT
    {
      coverageReductionMode = coverageReductionMode_;
      return *this;
    }

    operator VkPipelineCoverageReductionStateCreateInfoNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPipelineCoverageReductionStateCreateInfoNV *>( this );
    }

    operator VkPipelineCoverageReductionStateCreateInfoNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPipelineCoverageReductionStateCreateInfoNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PipelineCoverageReductionStateCreateInfoNV const & ) const = default;
#else
    bool operator==( PipelineCoverageReductionStateCreateInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( coverageReductionMode == rhs.coverageReductionMode );
    }

    bool operator!=( PipelineCoverageReductionStateCreateInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePipelineCoverageReductionStateCreateInfoNV;
    const void *                        pNext = {};
    VULKAN_HPP_NAMESPACE::PipelineCoverageReductionStateCreateFlagsNV flags = {};
    VULKAN_HPP_NAMESPACE::CoverageReductionModeNV                     coverageReductionMode =
      VULKAN_HPP_NAMESPACE::CoverageReductionModeNV::eMerge;
  };
  static_assert( sizeof( PipelineCoverageReductionStateCreateInfoNV ) ==
                   sizeof( VkPipelineCoverageReductionStateCreateInfoNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PipelineCoverageReductionStateCreateInfoNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePipelineCoverageReductionStateCreateInfoNV>
  {
    using Type = PipelineCoverageReductionStateCreateInfoNV;
  };

  struct PipelineCoverageToColorStateCreateInfoNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePipelineCoverageToColorStateCreateInfoNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PipelineCoverageToColorStateCreateInfoNV(
      VULKAN_HPP_NAMESPACE::PipelineCoverageToColorStateCreateFlagsNV flags_                 = {},
      VULKAN_HPP_NAMESPACE::Bool32                                    coverageToColorEnable_ = {},
      uint32_t coverageToColorLocation_                                                      = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , coverageToColorEnable( coverageToColorEnable_ )
      , coverageToColorLocation( coverageToColorLocation_ )
    {}

    VULKAN_HPP_CONSTEXPR PipelineCoverageToColorStateCreateInfoNV(
      PipelineCoverageToColorStateCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineCoverageToColorStateCreateInfoNV( VkPipelineCoverageToColorStateCreateInfoNV const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PipelineCoverageToColorStateCreateInfoNV(
          *reinterpret_cast<PipelineCoverageToColorStateCreateInfoNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PipelineCoverageToColorStateCreateInfoNV &
                            operator=( PipelineCoverageToColorStateCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineCoverageToColorStateCreateInfoNV &
      operator=( VkPipelineCoverageToColorStateCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PipelineCoverageToColorStateCreateInfoNV const *>( &rhs );
      return *this;
    }

    PipelineCoverageToColorStateCreateInfoNV & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PipelineCoverageToColorStateCreateInfoNV &
      setFlags( VULKAN_HPP_NAMESPACE::PipelineCoverageToColorStateCreateFlagsNV flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    PipelineCoverageToColorStateCreateInfoNV &
      setCoverageToColorEnable( VULKAN_HPP_NAMESPACE::Bool32 coverageToColorEnable_ ) VULKAN_HPP_NOEXCEPT
    {
      coverageToColorEnable = coverageToColorEnable_;
      return *this;
    }

    PipelineCoverageToColorStateCreateInfoNV &
      setCoverageToColorLocation( uint32_t coverageToColorLocation_ ) VULKAN_HPP_NOEXCEPT
    {
      coverageToColorLocation = coverageToColorLocation_;
      return *this;
    }

    operator VkPipelineCoverageToColorStateCreateInfoNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPipelineCoverageToColorStateCreateInfoNV *>( this );
    }

    operator VkPipelineCoverageToColorStateCreateInfoNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPipelineCoverageToColorStateCreateInfoNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PipelineCoverageToColorStateCreateInfoNV const & ) const = default;
#else
    bool operator==( PipelineCoverageToColorStateCreateInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( coverageToColorEnable == rhs.coverageToColorEnable ) &&
             ( coverageToColorLocation == rhs.coverageToColorLocation );
    }

    bool operator!=( PipelineCoverageToColorStateCreateInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePipelineCoverageToColorStateCreateInfoNV;
    const void *                        pNext = {};
    VULKAN_HPP_NAMESPACE::PipelineCoverageToColorStateCreateFlagsNV flags                   = {};
    VULKAN_HPP_NAMESPACE::Bool32                                    coverageToColorEnable   = {};
    uint32_t                                                        coverageToColorLocation = {};
  };
  static_assert( sizeof( PipelineCoverageToColorStateCreateInfoNV ) ==
                   sizeof( VkPipelineCoverageToColorStateCreateInfoNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PipelineCoverageToColorStateCreateInfoNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePipelineCoverageToColorStateCreateInfoNV>
  {
    using Type = PipelineCoverageToColorStateCreateInfoNV;
  };

  struct PipelineCreationFeedbackEXT
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      PipelineCreationFeedbackEXT( VULKAN_HPP_NAMESPACE::PipelineCreationFeedbackFlagsEXT flags_ = {},
                                   uint64_t duration_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , duration( duration_ )
    {}

    VULKAN_HPP_CONSTEXPR
      PipelineCreationFeedbackEXT( PipelineCreationFeedbackEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineCreationFeedbackEXT( VkPipelineCreationFeedbackEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : PipelineCreationFeedbackEXT( *reinterpret_cast<PipelineCreationFeedbackEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PipelineCreationFeedbackEXT &
                            operator=( PipelineCreationFeedbackEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineCreationFeedbackEXT & operator=( VkPipelineCreationFeedbackEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PipelineCreationFeedbackEXT const *>( &rhs );
      return *this;
    }

    operator VkPipelineCreationFeedbackEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPipelineCreationFeedbackEXT *>( this );
    }

    operator VkPipelineCreationFeedbackEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPipelineCreationFeedbackEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PipelineCreationFeedbackEXT const & ) const = default;
#else
    bool operator==( PipelineCreationFeedbackEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( flags == rhs.flags ) && ( duration == rhs.duration );
    }

    bool operator!=( PipelineCreationFeedbackEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::PipelineCreationFeedbackFlagsEXT flags    = {};
    uint64_t                                               duration = {};
  };
  static_assert( sizeof( PipelineCreationFeedbackEXT ) == sizeof( VkPipelineCreationFeedbackEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PipelineCreationFeedbackEXT>::value,
                 "struct wrapper is not a standard layout!" );

  struct PipelineCreationFeedbackCreateInfoEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePipelineCreationFeedbackCreateInfoEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PipelineCreationFeedbackCreateInfoEXT(
      VULKAN_HPP_NAMESPACE::PipelineCreationFeedbackEXT * pPipelineCreationFeedback_          = {},
      uint32_t                                            pipelineStageCreationFeedbackCount_ = {},
      VULKAN_HPP_NAMESPACE::PipelineCreationFeedbackEXT * pPipelineStageCreationFeedbacks_    = {} ) VULKAN_HPP_NOEXCEPT
      : pPipelineCreationFeedback( pPipelineCreationFeedback_ )
      , pipelineStageCreationFeedbackCount( pipelineStageCreationFeedbackCount_ )
      , pPipelineStageCreationFeedbacks( pPipelineStageCreationFeedbacks_ )
    {}

    VULKAN_HPP_CONSTEXPR PipelineCreationFeedbackCreateInfoEXT( PipelineCreationFeedbackCreateInfoEXT const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    PipelineCreationFeedbackCreateInfoEXT( VkPipelineCreationFeedbackCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : PipelineCreationFeedbackCreateInfoEXT(
          *reinterpret_cast<PipelineCreationFeedbackCreateInfoEXT const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    PipelineCreationFeedbackCreateInfoEXT(
      VULKAN_HPP_NAMESPACE::PipelineCreationFeedbackEXT * pPipelineCreationFeedback_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<VULKAN_HPP_NAMESPACE::PipelineCreationFeedbackEXT> const &
        pipelineStageCreationFeedbacks_ )
      : pPipelineCreationFeedback( pPipelineCreationFeedback_ )
      , pipelineStageCreationFeedbackCount( static_cast<uint32_t>( pipelineStageCreationFeedbacks_.size() ) )
      , pPipelineStageCreationFeedbacks( pipelineStageCreationFeedbacks_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PipelineCreationFeedbackCreateInfoEXT &
                            operator=( PipelineCreationFeedbackCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineCreationFeedbackCreateInfoEXT &
      operator=( VkPipelineCreationFeedbackCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PipelineCreationFeedbackCreateInfoEXT const *>( &rhs );
      return *this;
    }

    PipelineCreationFeedbackCreateInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PipelineCreationFeedbackCreateInfoEXT & setPPipelineCreationFeedback(
      VULKAN_HPP_NAMESPACE::PipelineCreationFeedbackEXT * pPipelineCreationFeedback_ ) VULKAN_HPP_NOEXCEPT
    {
      pPipelineCreationFeedback = pPipelineCreationFeedback_;
      return *this;
    }

    PipelineCreationFeedbackCreateInfoEXT &
      setPipelineStageCreationFeedbackCount( uint32_t pipelineStageCreationFeedbackCount_ ) VULKAN_HPP_NOEXCEPT
    {
      pipelineStageCreationFeedbackCount = pipelineStageCreationFeedbackCount_;
      return *this;
    }

    PipelineCreationFeedbackCreateInfoEXT & setPPipelineStageCreationFeedbacks(
      VULKAN_HPP_NAMESPACE::PipelineCreationFeedbackEXT * pPipelineStageCreationFeedbacks_ ) VULKAN_HPP_NOEXCEPT
    {
      pPipelineStageCreationFeedbacks = pPipelineStageCreationFeedbacks_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    PipelineCreationFeedbackCreateInfoEXT & setPipelineStageCreationFeedbacks(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<VULKAN_HPP_NAMESPACE::PipelineCreationFeedbackEXT> const &
        pipelineStageCreationFeedbacks_ ) VULKAN_HPP_NOEXCEPT
    {
      pipelineStageCreationFeedbackCount = static_cast<uint32_t>( pipelineStageCreationFeedbacks_.size() );
      pPipelineStageCreationFeedbacks    = pipelineStageCreationFeedbacks_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkPipelineCreationFeedbackCreateInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPipelineCreationFeedbackCreateInfoEXT *>( this );
    }

    operator VkPipelineCreationFeedbackCreateInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPipelineCreationFeedbackCreateInfoEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PipelineCreationFeedbackCreateInfoEXT const & ) const = default;
#else
    bool operator==( PipelineCreationFeedbackCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( pPipelineCreationFeedback == rhs.pPipelineCreationFeedback ) &&
             ( pipelineStageCreationFeedbackCount == rhs.pipelineStageCreationFeedbackCount ) &&
             ( pPipelineStageCreationFeedbacks == rhs.pPipelineStageCreationFeedbacks );
    }

    bool operator!=( PipelineCreationFeedbackCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                 sType = StructureType::ePipelineCreationFeedbackCreateInfoEXT;
    const void *                                        pNext = {};
    VULKAN_HPP_NAMESPACE::PipelineCreationFeedbackEXT * pPipelineCreationFeedback          = {};
    uint32_t                                            pipelineStageCreationFeedbackCount = {};
    VULKAN_HPP_NAMESPACE::PipelineCreationFeedbackEXT * pPipelineStageCreationFeedbacks    = {};
  };
  static_assert( sizeof( PipelineCreationFeedbackCreateInfoEXT ) == sizeof( VkPipelineCreationFeedbackCreateInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PipelineCreationFeedbackCreateInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePipelineCreationFeedbackCreateInfoEXT>
  {
    using Type = PipelineCreationFeedbackCreateInfoEXT;
  };

  struct PipelineDiscardRectangleStateCreateInfoEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePipelineDiscardRectangleStateCreateInfoEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PipelineDiscardRectangleStateCreateInfoEXT(
      VULKAN_HPP_NAMESPACE::PipelineDiscardRectangleStateCreateFlagsEXT flags_ = {},
      VULKAN_HPP_NAMESPACE::DiscardRectangleModeEXT                     discardRectangleMode_ =
        VULKAN_HPP_NAMESPACE::DiscardRectangleModeEXT::eInclusive,
      uint32_t                             discardRectangleCount_ = {},
      const VULKAN_HPP_NAMESPACE::Rect2D * pDiscardRectangles_    = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , discardRectangleMode( discardRectangleMode_ )
      , discardRectangleCount( discardRectangleCount_ )
      , pDiscardRectangles( pDiscardRectangles_ )
    {}

    VULKAN_HPP_CONSTEXPR PipelineDiscardRectangleStateCreateInfoEXT(
      PipelineDiscardRectangleStateCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineDiscardRectangleStateCreateInfoEXT( VkPipelineDiscardRectangleStateCreateInfoEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PipelineDiscardRectangleStateCreateInfoEXT(
          *reinterpret_cast<PipelineDiscardRectangleStateCreateInfoEXT const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    PipelineDiscardRectangleStateCreateInfoEXT(
      VULKAN_HPP_NAMESPACE::PipelineDiscardRectangleStateCreateFlagsEXT                         flags_,
      VULKAN_HPP_NAMESPACE::DiscardRectangleModeEXT                                             discardRectangleMode_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::Rect2D> const & discardRectangles_ )
      : flags( flags_ )
      , discardRectangleMode( discardRectangleMode_ )
      , discardRectangleCount( static_cast<uint32_t>( discardRectangles_.size() ) )
      , pDiscardRectangles( discardRectangles_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PipelineDiscardRectangleStateCreateInfoEXT &
                            operator=( PipelineDiscardRectangleStateCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineDiscardRectangleStateCreateInfoEXT &
      operator=( VkPipelineDiscardRectangleStateCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PipelineDiscardRectangleStateCreateInfoEXT const *>( &rhs );
      return *this;
    }

    PipelineDiscardRectangleStateCreateInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PipelineDiscardRectangleStateCreateInfoEXT &
      setFlags( VULKAN_HPP_NAMESPACE::PipelineDiscardRectangleStateCreateFlagsEXT flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    PipelineDiscardRectangleStateCreateInfoEXT &
      setDiscardRectangleMode( VULKAN_HPP_NAMESPACE::DiscardRectangleModeEXT discardRectangleMode_ ) VULKAN_HPP_NOEXCEPT
    {
      discardRectangleMode = discardRectangleMode_;
      return *this;
    }

    PipelineDiscardRectangleStateCreateInfoEXT &
      setDiscardRectangleCount( uint32_t discardRectangleCount_ ) VULKAN_HPP_NOEXCEPT
    {
      discardRectangleCount = discardRectangleCount_;
      return *this;
    }

    PipelineDiscardRectangleStateCreateInfoEXT &
      setPDiscardRectangles( const VULKAN_HPP_NAMESPACE::Rect2D * pDiscardRectangles_ ) VULKAN_HPP_NOEXCEPT
    {
      pDiscardRectangles = pDiscardRectangles_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    PipelineDiscardRectangleStateCreateInfoEXT & setDiscardRectangles(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::Rect2D> const & discardRectangles_ )
      VULKAN_HPP_NOEXCEPT
    {
      discardRectangleCount = static_cast<uint32_t>( discardRectangles_.size() );
      pDiscardRectangles    = discardRectangles_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkPipelineDiscardRectangleStateCreateInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPipelineDiscardRectangleStateCreateInfoEXT *>( this );
    }

    operator VkPipelineDiscardRectangleStateCreateInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPipelineDiscardRectangleStateCreateInfoEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PipelineDiscardRectangleStateCreateInfoEXT const & ) const = default;
#else
    bool operator==( PipelineDiscardRectangleStateCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( discardRectangleMode == rhs.discardRectangleMode ) &&
             ( discardRectangleCount == rhs.discardRectangleCount ) && ( pDiscardRectangles == rhs.pDiscardRectangles );
    }

    bool operator!=( PipelineDiscardRectangleStateCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePipelineDiscardRectangleStateCreateInfoEXT;
    const void *                        pNext = {};
    VULKAN_HPP_NAMESPACE::PipelineDiscardRectangleStateCreateFlagsEXT flags = {};
    VULKAN_HPP_NAMESPACE::DiscardRectangleModeEXT                     discardRectangleMode =
      VULKAN_HPP_NAMESPACE::DiscardRectangleModeEXT::eInclusive;
    uint32_t                             discardRectangleCount = {};
    const VULKAN_HPP_NAMESPACE::Rect2D * pDiscardRectangles    = {};
  };
  static_assert( sizeof( PipelineDiscardRectangleStateCreateInfoEXT ) ==
                   sizeof( VkPipelineDiscardRectangleStateCreateInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PipelineDiscardRectangleStateCreateInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePipelineDiscardRectangleStateCreateInfoEXT>
  {
    using Type = PipelineDiscardRectangleStateCreateInfoEXT;
  };

  struct PipelineExecutableInfoKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::ePipelineExecutableInfoKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PipelineExecutableInfoKHR( VULKAN_HPP_NAMESPACE::Pipeline pipeline_ = {},
                                                    uint32_t executableIndex_                = {} ) VULKAN_HPP_NOEXCEPT
      : pipeline( pipeline_ )
      , executableIndex( executableIndex_ )
    {}

    VULKAN_HPP_CONSTEXPR
      PipelineExecutableInfoKHR( PipelineExecutableInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineExecutableInfoKHR( VkPipelineExecutableInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : PipelineExecutableInfoKHR( *reinterpret_cast<PipelineExecutableInfoKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PipelineExecutableInfoKHR &
                            operator=( PipelineExecutableInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineExecutableInfoKHR & operator=( VkPipelineExecutableInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PipelineExecutableInfoKHR const *>( &rhs );
      return *this;
    }

    PipelineExecutableInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PipelineExecutableInfoKHR & setPipeline( VULKAN_HPP_NAMESPACE::Pipeline pipeline_ ) VULKAN_HPP_NOEXCEPT
    {
      pipeline = pipeline_;
      return *this;
    }

    PipelineExecutableInfoKHR & setExecutableIndex( uint32_t executableIndex_ ) VULKAN_HPP_NOEXCEPT
    {
      executableIndex = executableIndex_;
      return *this;
    }

    operator VkPipelineExecutableInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPipelineExecutableInfoKHR *>( this );
    }

    operator VkPipelineExecutableInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPipelineExecutableInfoKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PipelineExecutableInfoKHR const & ) const = default;
#else
    bool operator==( PipelineExecutableInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( pipeline == rhs.pipeline ) &&
             ( executableIndex == rhs.executableIndex );
    }

    bool operator!=( PipelineExecutableInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType           = StructureType::ePipelineExecutableInfoKHR;
    const void *                        pNext           = {};
    VULKAN_HPP_NAMESPACE::Pipeline      pipeline        = {};
    uint32_t                            executableIndex = {};
  };
  static_assert( sizeof( PipelineExecutableInfoKHR ) == sizeof( VkPipelineExecutableInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PipelineExecutableInfoKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePipelineExecutableInfoKHR>
  {
    using Type = PipelineExecutableInfoKHR;
  };

  struct PipelineExecutableInternalRepresentationKHR
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePipelineExecutableInternalRepresentationKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR_14
      PipelineExecutableInternalRepresentationKHR( std::array<char, VK_MAX_DESCRIPTION_SIZE> const & name_        = {},
                                                   std::array<char, VK_MAX_DESCRIPTION_SIZE> const & description_ = {},
                                                   VULKAN_HPP_NAMESPACE::Bool32                      isText_      = {},
                                                   size_t                                            dataSize_    = {},
                                                   void * pData_ = {} ) VULKAN_HPP_NOEXCEPT
      : name( name_ )
      , description( description_ )
      , isText( isText_ )
      , dataSize( dataSize_ )
      , pData( pData_ )
    {}

    VULKAN_HPP_CONSTEXPR_14 PipelineExecutableInternalRepresentationKHR(
      PipelineExecutableInternalRepresentationKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineExecutableInternalRepresentationKHR( VkPipelineExecutableInternalRepresentationKHR const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PipelineExecutableInternalRepresentationKHR(
          *reinterpret_cast<PipelineExecutableInternalRepresentationKHR const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    template <typename T>
    PipelineExecutableInternalRepresentationKHR( std::array<char, VK_MAX_DESCRIPTION_SIZE> const &        name_,
                                                 std::array<char, VK_MAX_DESCRIPTION_SIZE> const &        description_,
                                                 VULKAN_HPP_NAMESPACE::Bool32                             isText_,
                                                 VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<T> const & data_ )
      : name( name_ )
      , description( description_ )
      , isText( isText_ )
      , dataSize( data_.size() * sizeof( T ) )
      , pData( data_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PipelineExecutableInternalRepresentationKHR &
                            operator=( PipelineExecutableInternalRepresentationKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineExecutableInternalRepresentationKHR &
      operator=( VkPipelineExecutableInternalRepresentationKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PipelineExecutableInternalRepresentationKHR const *>( &rhs );
      return *this;
    }

    operator VkPipelineExecutableInternalRepresentationKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPipelineExecutableInternalRepresentationKHR *>( this );
    }

    operator VkPipelineExecutableInternalRepresentationKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPipelineExecutableInternalRepresentationKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PipelineExecutableInternalRepresentationKHR const & ) const = default;
#else
    bool operator==( PipelineExecutableInternalRepresentationKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( name == rhs.name ) &&
             ( description == rhs.description ) && ( isText == rhs.isText ) && ( dataSize == rhs.dataSize ) &&
             ( pData == rhs.pData );
    }

    bool operator!=( PipelineExecutableInternalRepresentationKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePipelineExecutableInternalRepresentationKHR;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<char, VK_MAX_DESCRIPTION_SIZE> name        = {};
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<char, VK_MAX_DESCRIPTION_SIZE> description = {};
    VULKAN_HPP_NAMESPACE::Bool32                                        isText      = {};
    size_t                                                              dataSize    = {};
    void *                                                              pData       = {};
  };
  static_assert( sizeof( PipelineExecutableInternalRepresentationKHR ) ==
                   sizeof( VkPipelineExecutableInternalRepresentationKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PipelineExecutableInternalRepresentationKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePipelineExecutableInternalRepresentationKHR>
  {
    using Type = PipelineExecutableInternalRepresentationKHR;
  };

  struct PipelineExecutablePropertiesKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::ePipelineExecutablePropertiesKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR_14
      PipelineExecutablePropertiesKHR( VULKAN_HPP_NAMESPACE::ShaderStageFlags            stages_      = {},
                                       std::array<char, VK_MAX_DESCRIPTION_SIZE> const & name_        = {},
                                       std::array<char, VK_MAX_DESCRIPTION_SIZE> const & description_ = {},
                                       uint32_t subgroupSize_ = {} ) VULKAN_HPP_NOEXCEPT
      : stages( stages_ )
      , name( name_ )
      , description( description_ )
      , subgroupSize( subgroupSize_ )
    {}

    VULKAN_HPP_CONSTEXPR_14
      PipelineExecutablePropertiesKHR( PipelineExecutablePropertiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineExecutablePropertiesKHR( VkPipelineExecutablePropertiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : PipelineExecutablePropertiesKHR( *reinterpret_cast<PipelineExecutablePropertiesKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PipelineExecutablePropertiesKHR &
                            operator=( PipelineExecutablePropertiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineExecutablePropertiesKHR & operator=( VkPipelineExecutablePropertiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PipelineExecutablePropertiesKHR const *>( &rhs );
      return *this;
    }

    operator VkPipelineExecutablePropertiesKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPipelineExecutablePropertiesKHR *>( this );
    }

    operator VkPipelineExecutablePropertiesKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPipelineExecutablePropertiesKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PipelineExecutablePropertiesKHR const & ) const = default;
#else
    bool operator==( PipelineExecutablePropertiesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( stages == rhs.stages ) && ( name == rhs.name ) &&
             ( description == rhs.description ) && ( subgroupSize == rhs.subgroupSize );
    }

    bool operator!=( PipelineExecutablePropertiesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType    sType  = StructureType::ePipelineExecutablePropertiesKHR;
    void *                                 pNext  = {};
    VULKAN_HPP_NAMESPACE::ShaderStageFlags stages = {};
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<char, VK_MAX_DESCRIPTION_SIZE> name         = {};
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<char, VK_MAX_DESCRIPTION_SIZE> description  = {};
    uint32_t                                                            subgroupSize = {};
  };
  static_assert( sizeof( PipelineExecutablePropertiesKHR ) == sizeof( VkPipelineExecutablePropertiesKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PipelineExecutablePropertiesKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePipelineExecutablePropertiesKHR>
  {
    using Type = PipelineExecutablePropertiesKHR;
  };

  union PipelineExecutableStatisticValueKHR
  {
    PipelineExecutableStatisticValueKHR( VULKAN_HPP_NAMESPACE::PipelineExecutableStatisticValueKHR const & rhs )
      VULKAN_HPP_NOEXCEPT
    {
      memcpy( static_cast<void *>( this ), &rhs, sizeof( VULKAN_HPP_NAMESPACE::PipelineExecutableStatisticValueKHR ) );
    }

    PipelineExecutableStatisticValueKHR( VULKAN_HPP_NAMESPACE::Bool32 b32_ = {} ) : b32( b32_ ) {}

    PipelineExecutableStatisticValueKHR( int64_t i64_ ) : i64( i64_ ) {}

    PipelineExecutableStatisticValueKHR( uint64_t u64_ ) : u64( u64_ ) {}

    PipelineExecutableStatisticValueKHR( double f64_ ) : f64( f64_ ) {}

    PipelineExecutableStatisticValueKHR & setB32( VULKAN_HPP_NAMESPACE::Bool32 b32_ ) VULKAN_HPP_NOEXCEPT
    {
      b32 = b32_;
      return *this;
    }

    PipelineExecutableStatisticValueKHR & setI64( int64_t i64_ ) VULKAN_HPP_NOEXCEPT
    {
      i64 = i64_;
      return *this;
    }

    PipelineExecutableStatisticValueKHR & setU64( uint64_t u64_ ) VULKAN_HPP_NOEXCEPT
    {
      u64 = u64_;
      return *this;
    }

    PipelineExecutableStatisticValueKHR & setF64( double f64_ ) VULKAN_HPP_NOEXCEPT
    {
      f64 = f64_;
      return *this;
    }

    VULKAN_HPP_NAMESPACE::PipelineExecutableStatisticValueKHR &
      operator=( VULKAN_HPP_NAMESPACE::PipelineExecutableStatisticValueKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      memcpy( static_cast<void *>( this ), &rhs, sizeof( VULKAN_HPP_NAMESPACE::PipelineExecutableStatisticValueKHR ) );
      return *this;
    }

    operator VkPipelineExecutableStatisticValueKHR const &() const
    {
      return *reinterpret_cast<const VkPipelineExecutableStatisticValueKHR *>( this );
    }

    operator VkPipelineExecutableStatisticValueKHR &()
    {
      return *reinterpret_cast<VkPipelineExecutableStatisticValueKHR *>( this );
    }

#ifdef VULKAN_HPP_HAS_UNRESTRICTED_UNIONS
    VULKAN_HPP_NAMESPACE::Bool32 b32;
    int64_t                      i64;
    uint64_t                     u64;
    double                       f64;
#else
    VkBool32 b32;
    int64_t  i64;
    uint64_t u64;
    double   f64;
#endif /*VULKAN_HPP_HAS_UNRESTRICTED_UNIONS*/
  };

  struct PipelineExecutableStatisticKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::ePipelineExecutableStatisticKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    PipelineExecutableStatisticKHR( std::array<char, VK_MAX_DESCRIPTION_SIZE> const &          name_        = {},
                                    std::array<char, VK_MAX_DESCRIPTION_SIZE> const &          description_ = {},
                                    VULKAN_HPP_NAMESPACE::PipelineExecutableStatisticFormatKHR format_ =
                                      VULKAN_HPP_NAMESPACE::PipelineExecutableStatisticFormatKHR::eBool32,
                                    VULKAN_HPP_NAMESPACE::PipelineExecutableStatisticValueKHR value_ = {} )
      VULKAN_HPP_NOEXCEPT
      : name( name_ )
      , description( description_ )
      , format( format_ )
      , value( value_ )
    {}

    PipelineExecutableStatisticKHR( PipelineExecutableStatisticKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineExecutableStatisticKHR( VkPipelineExecutableStatisticKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : PipelineExecutableStatisticKHR( *reinterpret_cast<PipelineExecutableStatisticKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    PipelineExecutableStatisticKHR &
      operator=( PipelineExecutableStatisticKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineExecutableStatisticKHR & operator=( VkPipelineExecutableStatisticKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PipelineExecutableStatisticKHR const *>( &rhs );
      return *this;
    }

    operator VkPipelineExecutableStatisticKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPipelineExecutableStatisticKHR *>( this );
    }

    operator VkPipelineExecutableStatisticKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPipelineExecutableStatisticKHR *>( this );
    }

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePipelineExecutableStatisticKHR;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<char, VK_MAX_DESCRIPTION_SIZE> name        = {};
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<char, VK_MAX_DESCRIPTION_SIZE> description = {};
    VULKAN_HPP_NAMESPACE::PipelineExecutableStatisticFormatKHR          format =
      VULKAN_HPP_NAMESPACE::PipelineExecutableStatisticFormatKHR::eBool32;
    VULKAN_HPP_NAMESPACE::PipelineExecutableStatisticValueKHR value = {};
  };
  static_assert( sizeof( PipelineExecutableStatisticKHR ) == sizeof( VkPipelineExecutableStatisticKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PipelineExecutableStatisticKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePipelineExecutableStatisticKHR>
  {
    using Type = PipelineExecutableStatisticKHR;
  };

  struct PipelineFragmentShadingRateEnumStateCreateInfoNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePipelineFragmentShadingRateEnumStateCreateInfoNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR_14 PipelineFragmentShadingRateEnumStateCreateInfoNV(
      VULKAN_HPP_NAMESPACE::FragmentShadingRateTypeNV shadingRateType_ =
        VULKAN_HPP_NAMESPACE::FragmentShadingRateTypeNV::eFragmentSize,
      VULKAN_HPP_NAMESPACE::FragmentShadingRateNV shadingRate_ =
        VULKAN_HPP_NAMESPACE::FragmentShadingRateNV::e1InvocationPerPixel,
      std::array<VULKAN_HPP_NAMESPACE::FragmentShadingRateCombinerOpKHR, 2> const &
        combinerOps_ = { { VULKAN_HPP_NAMESPACE::FragmentShadingRateCombinerOpKHR::eKeep,
                           VULKAN_HPP_NAMESPACE::FragmentShadingRateCombinerOpKHR::eKeep } } ) VULKAN_HPP_NOEXCEPT
      : shadingRateType( shadingRateType_ )
      , shadingRate( shadingRate_ )
      , combinerOps( combinerOps_ )
    {}

    VULKAN_HPP_CONSTEXPR_14 PipelineFragmentShadingRateEnumStateCreateInfoNV(
      PipelineFragmentShadingRateEnumStateCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineFragmentShadingRateEnumStateCreateInfoNV( VkPipelineFragmentShadingRateEnumStateCreateInfoNV const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PipelineFragmentShadingRateEnumStateCreateInfoNV(
          *reinterpret_cast<PipelineFragmentShadingRateEnumStateCreateInfoNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PipelineFragmentShadingRateEnumStateCreateInfoNV &
                            operator=( PipelineFragmentShadingRateEnumStateCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineFragmentShadingRateEnumStateCreateInfoNV &
      operator=( VkPipelineFragmentShadingRateEnumStateCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PipelineFragmentShadingRateEnumStateCreateInfoNV const *>( &rhs );
      return *this;
    }

    PipelineFragmentShadingRateEnumStateCreateInfoNV & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PipelineFragmentShadingRateEnumStateCreateInfoNV &
      setShadingRateType( VULKAN_HPP_NAMESPACE::FragmentShadingRateTypeNV shadingRateType_ ) VULKAN_HPP_NOEXCEPT
    {
      shadingRateType = shadingRateType_;
      return *this;
    }

    PipelineFragmentShadingRateEnumStateCreateInfoNV &
      setShadingRate( VULKAN_HPP_NAMESPACE::FragmentShadingRateNV shadingRate_ ) VULKAN_HPP_NOEXCEPT
    {
      shadingRate = shadingRate_;
      return *this;
    }

    PipelineFragmentShadingRateEnumStateCreateInfoNV & setCombinerOps(
      std::array<VULKAN_HPP_NAMESPACE::FragmentShadingRateCombinerOpKHR, 2> combinerOps_ ) VULKAN_HPP_NOEXCEPT
    {
      combinerOps = combinerOps_;
      return *this;
    }

    operator VkPipelineFragmentShadingRateEnumStateCreateInfoNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPipelineFragmentShadingRateEnumStateCreateInfoNV *>( this );
    }

    operator VkPipelineFragmentShadingRateEnumStateCreateInfoNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPipelineFragmentShadingRateEnumStateCreateInfoNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PipelineFragmentShadingRateEnumStateCreateInfoNV const & ) const = default;
#else
    bool     operator==( PipelineFragmentShadingRateEnumStateCreateInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( shadingRateType == rhs.shadingRateType ) &&
             ( shadingRate == rhs.shadingRate ) && ( combinerOps == rhs.combinerOps );
    }

    bool operator!=( PipelineFragmentShadingRateEnumStateCreateInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePipelineFragmentShadingRateEnumStateCreateInfoNV;
    const void *                        pNext = {};
    VULKAN_HPP_NAMESPACE::FragmentShadingRateTypeNV shadingRateType =
      VULKAN_HPP_NAMESPACE::FragmentShadingRateTypeNV::eFragmentSize;
    VULKAN_HPP_NAMESPACE::FragmentShadingRateNV shadingRate =
      VULKAN_HPP_NAMESPACE::FragmentShadingRateNV::e1InvocationPerPixel;
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<VULKAN_HPP_NAMESPACE::FragmentShadingRateCombinerOpKHR, 2> combinerOps = {};
  };
  static_assert( sizeof( PipelineFragmentShadingRateEnumStateCreateInfoNV ) ==
                   sizeof( VkPipelineFragmentShadingRateEnumStateCreateInfoNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PipelineFragmentShadingRateEnumStateCreateInfoNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePipelineFragmentShadingRateEnumStateCreateInfoNV>
  {
    using Type = PipelineFragmentShadingRateEnumStateCreateInfoNV;
  };

  struct PipelineFragmentShadingRateStateCreateInfoKHR
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePipelineFragmentShadingRateStateCreateInfoKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR_14 PipelineFragmentShadingRateStateCreateInfoKHR(
      VULKAN_HPP_NAMESPACE::Extent2D fragmentSize_ = {},
      std::array<VULKAN_HPP_NAMESPACE::FragmentShadingRateCombinerOpKHR, 2> const &
        combinerOps_ = { { VULKAN_HPP_NAMESPACE::FragmentShadingRateCombinerOpKHR::eKeep,
                           VULKAN_HPP_NAMESPACE::FragmentShadingRateCombinerOpKHR::eKeep } } ) VULKAN_HPP_NOEXCEPT
      : fragmentSize( fragmentSize_ )
      , combinerOps( combinerOps_ )
    {}

    VULKAN_HPP_CONSTEXPR_14 PipelineFragmentShadingRateStateCreateInfoKHR(
      PipelineFragmentShadingRateStateCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineFragmentShadingRateStateCreateInfoKHR( VkPipelineFragmentShadingRateStateCreateInfoKHR const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PipelineFragmentShadingRateStateCreateInfoKHR(
          *reinterpret_cast<PipelineFragmentShadingRateStateCreateInfoKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PipelineFragmentShadingRateStateCreateInfoKHR &
                            operator=( PipelineFragmentShadingRateStateCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineFragmentShadingRateStateCreateInfoKHR &
      operator=( VkPipelineFragmentShadingRateStateCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PipelineFragmentShadingRateStateCreateInfoKHR const *>( &rhs );
      return *this;
    }

    PipelineFragmentShadingRateStateCreateInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PipelineFragmentShadingRateStateCreateInfoKHR &
      setFragmentSize( VULKAN_HPP_NAMESPACE::Extent2D const & fragmentSize_ ) VULKAN_HPP_NOEXCEPT
    {
      fragmentSize = fragmentSize_;
      return *this;
    }

    PipelineFragmentShadingRateStateCreateInfoKHR & setCombinerOps(
      std::array<VULKAN_HPP_NAMESPACE::FragmentShadingRateCombinerOpKHR, 2> combinerOps_ ) VULKAN_HPP_NOEXCEPT
    {
      combinerOps = combinerOps_;
      return *this;
    }

    operator VkPipelineFragmentShadingRateStateCreateInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPipelineFragmentShadingRateStateCreateInfoKHR *>( this );
    }

    operator VkPipelineFragmentShadingRateStateCreateInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPipelineFragmentShadingRateStateCreateInfoKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PipelineFragmentShadingRateStateCreateInfoKHR const & ) const = default;
#else
    bool operator==( PipelineFragmentShadingRateStateCreateInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( fragmentSize == rhs.fragmentSize ) &&
             ( combinerOps == rhs.combinerOps );
    }

    bool operator!=( PipelineFragmentShadingRateStateCreateInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType        = StructureType::ePipelineFragmentShadingRateStateCreateInfoKHR;
    const void *                        pNext        = {};
    VULKAN_HPP_NAMESPACE::Extent2D      fragmentSize = {};
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<VULKAN_HPP_NAMESPACE::FragmentShadingRateCombinerOpKHR, 2> combinerOps = {};
  };
  static_assert( sizeof( PipelineFragmentShadingRateStateCreateInfoKHR ) ==
                   sizeof( VkPipelineFragmentShadingRateStateCreateInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PipelineFragmentShadingRateStateCreateInfoKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePipelineFragmentShadingRateStateCreateInfoKHR>
  {
    using Type = PipelineFragmentShadingRateStateCreateInfoKHR;
  };

  struct PipelineInfoKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::ePipelineInfoKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PipelineInfoKHR( VULKAN_HPP_NAMESPACE::Pipeline pipeline_ = {} ) VULKAN_HPP_NOEXCEPT
      : pipeline( pipeline_ )
    {}

    VULKAN_HPP_CONSTEXPR PipelineInfoKHR( PipelineInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineInfoKHR( VkPipelineInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : PipelineInfoKHR( *reinterpret_cast<PipelineInfoKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PipelineInfoKHR & operator=( PipelineInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineInfoKHR & operator=( VkPipelineInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PipelineInfoKHR const *>( &rhs );
      return *this;
    }

    PipelineInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PipelineInfoKHR & setPipeline( VULKAN_HPP_NAMESPACE::Pipeline pipeline_ ) VULKAN_HPP_NOEXCEPT
    {
      pipeline = pipeline_;
      return *this;
    }

    operator VkPipelineInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPipelineInfoKHR *>( this );
    }

    operator VkPipelineInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPipelineInfoKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PipelineInfoKHR const & ) const = default;
#else
    bool operator==( PipelineInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( pipeline == rhs.pipeline );
    }

    bool operator!=( PipelineInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType    = StructureType::ePipelineInfoKHR;
    const void *                        pNext    = {};
    VULKAN_HPP_NAMESPACE::Pipeline      pipeline = {};
  };
  static_assert( sizeof( PipelineInfoKHR ) == sizeof( VkPipelineInfoKHR ), "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PipelineInfoKHR>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePipelineInfoKHR>
  {
    using Type = PipelineInfoKHR;
  };

  struct PushConstantRange
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PushConstantRange( VULKAN_HPP_NAMESPACE::ShaderStageFlags stageFlags_ = {},
                                            uint32_t                               offset_     = {},
                                            uint32_t                               size_ = {} ) VULKAN_HPP_NOEXCEPT
      : stageFlags( stageFlags_ )
      , offset( offset_ )
      , size( size_ )
    {}

    VULKAN_HPP_CONSTEXPR PushConstantRange( PushConstantRange const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PushConstantRange( VkPushConstantRange const & rhs ) VULKAN_HPP_NOEXCEPT
      : PushConstantRange( *reinterpret_cast<PushConstantRange const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PushConstantRange &
                            operator=( PushConstantRange const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PushConstantRange & operator=( VkPushConstantRange const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PushConstantRange const *>( &rhs );
      return *this;
    }

    PushConstantRange & setStageFlags( VULKAN_HPP_NAMESPACE::ShaderStageFlags stageFlags_ ) VULKAN_HPP_NOEXCEPT
    {
      stageFlags = stageFlags_;
      return *this;
    }

    PushConstantRange & setOffset( uint32_t offset_ ) VULKAN_HPP_NOEXCEPT
    {
      offset = offset_;
      return *this;
    }

    PushConstantRange & setSize( uint32_t size_ ) VULKAN_HPP_NOEXCEPT
    {
      size = size_;
      return *this;
    }

    operator VkPushConstantRange const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPushConstantRange *>( this );
    }

    operator VkPushConstantRange &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPushConstantRange *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PushConstantRange const & ) const = default;
#else
    bool operator==( PushConstantRange const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( stageFlags == rhs.stageFlags ) && ( offset == rhs.offset ) && ( size == rhs.size );
    }

    bool operator!=( PushConstantRange const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::ShaderStageFlags stageFlags = {};
    uint32_t                               offset     = {};
    uint32_t                               size       = {};
  };
  static_assert( sizeof( PushConstantRange ) == sizeof( VkPushConstantRange ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PushConstantRange>::value, "struct wrapper is not a standard layout!" );

  struct PipelineLayoutCreateInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::ePipelineLayoutCreateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PipelineLayoutCreateInfo(
      VULKAN_HPP_NAMESPACE::PipelineLayoutCreateFlags   flags_                  = {},
      uint32_t                                          setLayoutCount_         = {},
      const VULKAN_HPP_NAMESPACE::DescriptorSetLayout * pSetLayouts_            = {},
      uint32_t                                          pushConstantRangeCount_ = {},
      const VULKAN_HPP_NAMESPACE::PushConstantRange *   pPushConstantRanges_    = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , setLayoutCount( setLayoutCount_ )
      , pSetLayouts( pSetLayouts_ )
      , pushConstantRangeCount( pushConstantRangeCount_ )
      , pPushConstantRanges( pPushConstantRanges_ )
    {}

    VULKAN_HPP_CONSTEXPR PipelineLayoutCreateInfo( PipelineLayoutCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineLayoutCreateInfo( VkPipelineLayoutCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : PipelineLayoutCreateInfo( *reinterpret_cast<PipelineLayoutCreateInfo const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    PipelineLayoutCreateInfo(
      VULKAN_HPP_NAMESPACE::PipelineLayoutCreateFlags flags_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::DescriptorSetLayout> const &
        setLayouts_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::PushConstantRange> const &
        pushConstantRanges_ = {} )
      : flags( flags_ )
      , setLayoutCount( static_cast<uint32_t>( setLayouts_.size() ) )
      , pSetLayouts( setLayouts_.data() )
      , pushConstantRangeCount( static_cast<uint32_t>( pushConstantRanges_.size() ) )
      , pPushConstantRanges( pushConstantRanges_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PipelineLayoutCreateInfo &
                            operator=( PipelineLayoutCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineLayoutCreateInfo & operator=( VkPipelineLayoutCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PipelineLayoutCreateInfo const *>( &rhs );
      return *this;
    }

    PipelineLayoutCreateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PipelineLayoutCreateInfo & setFlags( VULKAN_HPP_NAMESPACE::PipelineLayoutCreateFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    PipelineLayoutCreateInfo & setSetLayoutCount( uint32_t setLayoutCount_ ) VULKAN_HPP_NOEXCEPT
    {
      setLayoutCount = setLayoutCount_;
      return *this;
    }

    PipelineLayoutCreateInfo &
      setPSetLayouts( const VULKAN_HPP_NAMESPACE::DescriptorSetLayout * pSetLayouts_ ) VULKAN_HPP_NOEXCEPT
    {
      pSetLayouts = pSetLayouts_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    PipelineLayoutCreateInfo & setSetLayouts(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::DescriptorSetLayout> const &
        setLayouts_ ) VULKAN_HPP_NOEXCEPT
    {
      setLayoutCount = static_cast<uint32_t>( setLayouts_.size() );
      pSetLayouts    = setLayouts_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    PipelineLayoutCreateInfo & setPushConstantRangeCount( uint32_t pushConstantRangeCount_ ) VULKAN_HPP_NOEXCEPT
    {
      pushConstantRangeCount = pushConstantRangeCount_;
      return *this;
    }

    PipelineLayoutCreateInfo &
      setPPushConstantRanges( const VULKAN_HPP_NAMESPACE::PushConstantRange * pPushConstantRanges_ ) VULKAN_HPP_NOEXCEPT
    {
      pPushConstantRanges = pPushConstantRanges_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    PipelineLayoutCreateInfo & setPushConstantRanges(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::PushConstantRange> const &
        pushConstantRanges_ ) VULKAN_HPP_NOEXCEPT
    {
      pushConstantRangeCount = static_cast<uint32_t>( pushConstantRanges_.size() );
      pPushConstantRanges    = pushConstantRanges_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkPipelineLayoutCreateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPipelineLayoutCreateInfo *>( this );
    }

    operator VkPipelineLayoutCreateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPipelineLayoutCreateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PipelineLayoutCreateInfo const & ) const = default;
#else
    bool operator==( PipelineLayoutCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( setLayoutCount == rhs.setLayoutCount ) && ( pSetLayouts == rhs.pSetLayouts ) &&
             ( pushConstantRangeCount == rhs.pushConstantRangeCount ) &&
             ( pPushConstantRanges == rhs.pPushConstantRanges );
    }

    bool operator!=( PipelineLayoutCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType               sType                  = StructureType::ePipelineLayoutCreateInfo;
    const void *                                      pNext                  = {};
    VULKAN_HPP_NAMESPACE::PipelineLayoutCreateFlags   flags                  = {};
    uint32_t                                          setLayoutCount         = {};
    const VULKAN_HPP_NAMESPACE::DescriptorSetLayout * pSetLayouts            = {};
    uint32_t                                          pushConstantRangeCount = {};
    const VULKAN_HPP_NAMESPACE::PushConstantRange *   pPushConstantRanges    = {};
  };
  static_assert( sizeof( PipelineLayoutCreateInfo ) == sizeof( VkPipelineLayoutCreateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PipelineLayoutCreateInfo>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePipelineLayoutCreateInfo>
  {
    using Type = PipelineLayoutCreateInfo;
  };

  struct PipelineLibraryCreateInfoKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::ePipelineLibraryCreateInfoKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      PipelineLibraryCreateInfoKHR( uint32_t                               libraryCount_ = {},
                                    const VULKAN_HPP_NAMESPACE::Pipeline * pLibraries_   = {} ) VULKAN_HPP_NOEXCEPT
      : libraryCount( libraryCount_ )
      , pLibraries( pLibraries_ )
    {}

    VULKAN_HPP_CONSTEXPR
      PipelineLibraryCreateInfoKHR( PipelineLibraryCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineLibraryCreateInfoKHR( VkPipelineLibraryCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : PipelineLibraryCreateInfoKHR( *reinterpret_cast<PipelineLibraryCreateInfoKHR const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    PipelineLibraryCreateInfoKHR(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::Pipeline> const & libraries_ )
      : libraryCount( static_cast<uint32_t>( libraries_.size() ) ), pLibraries( libraries_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PipelineLibraryCreateInfoKHR &
                            operator=( PipelineLibraryCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineLibraryCreateInfoKHR & operator=( VkPipelineLibraryCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PipelineLibraryCreateInfoKHR const *>( &rhs );
      return *this;
    }

    PipelineLibraryCreateInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PipelineLibraryCreateInfoKHR & setLibraryCount( uint32_t libraryCount_ ) VULKAN_HPP_NOEXCEPT
    {
      libraryCount = libraryCount_;
      return *this;
    }

    PipelineLibraryCreateInfoKHR &
      setPLibraries( const VULKAN_HPP_NAMESPACE::Pipeline * pLibraries_ ) VULKAN_HPP_NOEXCEPT
    {
      pLibraries = pLibraries_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    PipelineLibraryCreateInfoKHR & setLibraries(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::Pipeline> const & libraries_ )
      VULKAN_HPP_NOEXCEPT
    {
      libraryCount = static_cast<uint32_t>( libraries_.size() );
      pLibraries   = libraries_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkPipelineLibraryCreateInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPipelineLibraryCreateInfoKHR *>( this );
    }

    operator VkPipelineLibraryCreateInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPipelineLibraryCreateInfoKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PipelineLibraryCreateInfoKHR const & ) const = default;
#else
    bool operator==( PipelineLibraryCreateInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( libraryCount == rhs.libraryCount ) &&
             ( pLibraries == rhs.pLibraries );
    }

    bool operator!=( PipelineLibraryCreateInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType    sType        = StructureType::ePipelineLibraryCreateInfoKHR;
    const void *                           pNext        = {};
    uint32_t                               libraryCount = {};
    const VULKAN_HPP_NAMESPACE::Pipeline * pLibraries   = {};
  };
  static_assert( sizeof( PipelineLibraryCreateInfoKHR ) == sizeof( VkPipelineLibraryCreateInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PipelineLibraryCreateInfoKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePipelineLibraryCreateInfoKHR>
  {
    using Type = PipelineLibraryCreateInfoKHR;
  };

  struct PipelineRasterizationConservativeStateCreateInfoEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePipelineRasterizationConservativeStateCreateInfoEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PipelineRasterizationConservativeStateCreateInfoEXT(
      VULKAN_HPP_NAMESPACE::PipelineRasterizationConservativeStateCreateFlagsEXT flags_ = {},
      VULKAN_HPP_NAMESPACE::ConservativeRasterizationModeEXT                     conservativeRasterizationMode_ =
        VULKAN_HPP_NAMESPACE::ConservativeRasterizationModeEXT::eDisabled,
      float extraPrimitiveOverestimationSize_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , conservativeRasterizationMode( conservativeRasterizationMode_ )
      , extraPrimitiveOverestimationSize( extraPrimitiveOverestimationSize_ )
    {}

    VULKAN_HPP_CONSTEXPR PipelineRasterizationConservativeStateCreateInfoEXT(
      PipelineRasterizationConservativeStateCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineRasterizationConservativeStateCreateInfoEXT(
      VkPipelineRasterizationConservativeStateCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : PipelineRasterizationConservativeStateCreateInfoEXT(
          *reinterpret_cast<PipelineRasterizationConservativeStateCreateInfoEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PipelineRasterizationConservativeStateCreateInfoEXT &
                            operator=( PipelineRasterizationConservativeStateCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineRasterizationConservativeStateCreateInfoEXT &
      operator=( VkPipelineRasterizationConservativeStateCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this =
        *reinterpret_cast<VULKAN_HPP_NAMESPACE::PipelineRasterizationConservativeStateCreateInfoEXT const *>( &rhs );
      return *this;
    }

    PipelineRasterizationConservativeStateCreateInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PipelineRasterizationConservativeStateCreateInfoEXT &
      setFlags( VULKAN_HPP_NAMESPACE::PipelineRasterizationConservativeStateCreateFlagsEXT flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    PipelineRasterizationConservativeStateCreateInfoEXT & setConservativeRasterizationMode(
      VULKAN_HPP_NAMESPACE::ConservativeRasterizationModeEXT conservativeRasterizationMode_ ) VULKAN_HPP_NOEXCEPT
    {
      conservativeRasterizationMode = conservativeRasterizationMode_;
      return *this;
    }

    PipelineRasterizationConservativeStateCreateInfoEXT &
      setExtraPrimitiveOverestimationSize( float extraPrimitiveOverestimationSize_ ) VULKAN_HPP_NOEXCEPT
    {
      extraPrimitiveOverestimationSize = extraPrimitiveOverestimationSize_;
      return *this;
    }

    operator VkPipelineRasterizationConservativeStateCreateInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPipelineRasterizationConservativeStateCreateInfoEXT *>( this );
    }

    operator VkPipelineRasterizationConservativeStateCreateInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPipelineRasterizationConservativeStateCreateInfoEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PipelineRasterizationConservativeStateCreateInfoEXT const & ) const = default;
#else
    bool operator==( PipelineRasterizationConservativeStateCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( conservativeRasterizationMode == rhs.conservativeRasterizationMode ) &&
             ( extraPrimitiveOverestimationSize == rhs.extraPrimitiveOverestimationSize );
    }

    bool operator!=( PipelineRasterizationConservativeStateCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePipelineRasterizationConservativeStateCreateInfoEXT;
    const void *                        pNext = {};
    VULKAN_HPP_NAMESPACE::PipelineRasterizationConservativeStateCreateFlagsEXT flags = {};
    VULKAN_HPP_NAMESPACE::ConservativeRasterizationModeEXT                     conservativeRasterizationMode =
      VULKAN_HPP_NAMESPACE::ConservativeRasterizationModeEXT::eDisabled;
    float extraPrimitiveOverestimationSize = {};
  };
  static_assert( sizeof( PipelineRasterizationConservativeStateCreateInfoEXT ) ==
                   sizeof( VkPipelineRasterizationConservativeStateCreateInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PipelineRasterizationConservativeStateCreateInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePipelineRasterizationConservativeStateCreateInfoEXT>
  {
    using Type = PipelineRasterizationConservativeStateCreateInfoEXT;
  };

  struct PipelineRasterizationDepthClipStateCreateInfoEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePipelineRasterizationDepthClipStateCreateInfoEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PipelineRasterizationDepthClipStateCreateInfoEXT(
      VULKAN_HPP_NAMESPACE::PipelineRasterizationDepthClipStateCreateFlagsEXT flags_ = {},
      VULKAN_HPP_NAMESPACE::Bool32 depthClipEnable_                                  = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , depthClipEnable( depthClipEnable_ )
    {}

    VULKAN_HPP_CONSTEXPR PipelineRasterizationDepthClipStateCreateInfoEXT(
      PipelineRasterizationDepthClipStateCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineRasterizationDepthClipStateCreateInfoEXT( VkPipelineRasterizationDepthClipStateCreateInfoEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PipelineRasterizationDepthClipStateCreateInfoEXT(
          *reinterpret_cast<PipelineRasterizationDepthClipStateCreateInfoEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PipelineRasterizationDepthClipStateCreateInfoEXT &
                            operator=( PipelineRasterizationDepthClipStateCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineRasterizationDepthClipStateCreateInfoEXT &
      operator=( VkPipelineRasterizationDepthClipStateCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PipelineRasterizationDepthClipStateCreateInfoEXT const *>( &rhs );
      return *this;
    }

    PipelineRasterizationDepthClipStateCreateInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PipelineRasterizationDepthClipStateCreateInfoEXT &
      setFlags( VULKAN_HPP_NAMESPACE::PipelineRasterizationDepthClipStateCreateFlagsEXT flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    PipelineRasterizationDepthClipStateCreateInfoEXT &
      setDepthClipEnable( VULKAN_HPP_NAMESPACE::Bool32 depthClipEnable_ ) VULKAN_HPP_NOEXCEPT
    {
      depthClipEnable = depthClipEnable_;
      return *this;
    }

    operator VkPipelineRasterizationDepthClipStateCreateInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPipelineRasterizationDepthClipStateCreateInfoEXT *>( this );
    }

    operator VkPipelineRasterizationDepthClipStateCreateInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPipelineRasterizationDepthClipStateCreateInfoEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PipelineRasterizationDepthClipStateCreateInfoEXT const & ) const = default;
#else
    bool operator==( PipelineRasterizationDepthClipStateCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( depthClipEnable == rhs.depthClipEnable );
    }

    bool operator!=( PipelineRasterizationDepthClipStateCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePipelineRasterizationDepthClipStateCreateInfoEXT;
    const void *                        pNext = {};
    VULKAN_HPP_NAMESPACE::PipelineRasterizationDepthClipStateCreateFlagsEXT flags           = {};
    VULKAN_HPP_NAMESPACE::Bool32                                            depthClipEnable = {};
  };
  static_assert( sizeof( PipelineRasterizationDepthClipStateCreateInfoEXT ) ==
                   sizeof( VkPipelineRasterizationDepthClipStateCreateInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PipelineRasterizationDepthClipStateCreateInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePipelineRasterizationDepthClipStateCreateInfoEXT>
  {
    using Type = PipelineRasterizationDepthClipStateCreateInfoEXT;
  };

  struct PipelineRasterizationLineStateCreateInfoEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePipelineRasterizationLineStateCreateInfoEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PipelineRasterizationLineStateCreateInfoEXT(
      VULKAN_HPP_NAMESPACE::LineRasterizationModeEXT lineRasterizationMode_ =
        VULKAN_HPP_NAMESPACE::LineRasterizationModeEXT::eDefault,
      VULKAN_HPP_NAMESPACE::Bool32 stippledLineEnable_ = {},
      uint32_t                     lineStippleFactor_  = {},
      uint16_t                     lineStipplePattern_ = {} ) VULKAN_HPP_NOEXCEPT
      : lineRasterizationMode( lineRasterizationMode_ )
      , stippledLineEnable( stippledLineEnable_ )
      , lineStippleFactor( lineStippleFactor_ )
      , lineStipplePattern( lineStipplePattern_ )
    {}

    VULKAN_HPP_CONSTEXPR PipelineRasterizationLineStateCreateInfoEXT(
      PipelineRasterizationLineStateCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineRasterizationLineStateCreateInfoEXT( VkPipelineRasterizationLineStateCreateInfoEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PipelineRasterizationLineStateCreateInfoEXT(
          *reinterpret_cast<PipelineRasterizationLineStateCreateInfoEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PipelineRasterizationLineStateCreateInfoEXT &
                            operator=( PipelineRasterizationLineStateCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineRasterizationLineStateCreateInfoEXT &
      operator=( VkPipelineRasterizationLineStateCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PipelineRasterizationLineStateCreateInfoEXT const *>( &rhs );
      return *this;
    }

    PipelineRasterizationLineStateCreateInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PipelineRasterizationLineStateCreateInfoEXT & setLineRasterizationMode(
      VULKAN_HPP_NAMESPACE::LineRasterizationModeEXT lineRasterizationMode_ ) VULKAN_HPP_NOEXCEPT
    {
      lineRasterizationMode = lineRasterizationMode_;
      return *this;
    }

    PipelineRasterizationLineStateCreateInfoEXT &
      setStippledLineEnable( VULKAN_HPP_NAMESPACE::Bool32 stippledLineEnable_ ) VULKAN_HPP_NOEXCEPT
    {
      stippledLineEnable = stippledLineEnable_;
      return *this;
    }

    PipelineRasterizationLineStateCreateInfoEXT &
      setLineStippleFactor( uint32_t lineStippleFactor_ ) VULKAN_HPP_NOEXCEPT
    {
      lineStippleFactor = lineStippleFactor_;
      return *this;
    }

    PipelineRasterizationLineStateCreateInfoEXT &
      setLineStipplePattern( uint16_t lineStipplePattern_ ) VULKAN_HPP_NOEXCEPT
    {
      lineStipplePattern = lineStipplePattern_;
      return *this;
    }

    operator VkPipelineRasterizationLineStateCreateInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPipelineRasterizationLineStateCreateInfoEXT *>( this );
    }

    operator VkPipelineRasterizationLineStateCreateInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPipelineRasterizationLineStateCreateInfoEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PipelineRasterizationLineStateCreateInfoEXT const & ) const = default;
#else
    bool operator==( PipelineRasterizationLineStateCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( lineRasterizationMode == rhs.lineRasterizationMode ) &&
             ( stippledLineEnable == rhs.stippledLineEnable ) && ( lineStippleFactor == rhs.lineStippleFactor ) &&
             ( lineStipplePattern == rhs.lineStipplePattern );
    }

    bool operator!=( PipelineRasterizationLineStateCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType            sType = StructureType::ePipelineRasterizationLineStateCreateInfoEXT;
    const void *                                   pNext = {};
    VULKAN_HPP_NAMESPACE::LineRasterizationModeEXT lineRasterizationMode =
      VULKAN_HPP_NAMESPACE::LineRasterizationModeEXT::eDefault;
    VULKAN_HPP_NAMESPACE::Bool32 stippledLineEnable = {};
    uint32_t                     lineStippleFactor  = {};
    uint16_t                     lineStipplePattern = {};
  };
  static_assert( sizeof( PipelineRasterizationLineStateCreateInfoEXT ) ==
                   sizeof( VkPipelineRasterizationLineStateCreateInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PipelineRasterizationLineStateCreateInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePipelineRasterizationLineStateCreateInfoEXT>
  {
    using Type = PipelineRasterizationLineStateCreateInfoEXT;
  };

  struct PipelineRasterizationProvokingVertexStateCreateInfoEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePipelineRasterizationProvokingVertexStateCreateInfoEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PipelineRasterizationProvokingVertexStateCreateInfoEXT(
      VULKAN_HPP_NAMESPACE::ProvokingVertexModeEXT provokingVertexMode_ =
        VULKAN_HPP_NAMESPACE::ProvokingVertexModeEXT::eFirstVertex ) VULKAN_HPP_NOEXCEPT
      : provokingVertexMode( provokingVertexMode_ )
    {}

    VULKAN_HPP_CONSTEXPR PipelineRasterizationProvokingVertexStateCreateInfoEXT(
      PipelineRasterizationProvokingVertexStateCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineRasterizationProvokingVertexStateCreateInfoEXT(
      VkPipelineRasterizationProvokingVertexStateCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : PipelineRasterizationProvokingVertexStateCreateInfoEXT(
          *reinterpret_cast<PipelineRasterizationProvokingVertexStateCreateInfoEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PipelineRasterizationProvokingVertexStateCreateInfoEXT &
                            operator=( PipelineRasterizationProvokingVertexStateCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineRasterizationProvokingVertexStateCreateInfoEXT &
      operator=( VkPipelineRasterizationProvokingVertexStateCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this =
        *reinterpret_cast<VULKAN_HPP_NAMESPACE::PipelineRasterizationProvokingVertexStateCreateInfoEXT const *>( &rhs );
      return *this;
    }

    PipelineRasterizationProvokingVertexStateCreateInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PipelineRasterizationProvokingVertexStateCreateInfoEXT &
      setProvokingVertexMode( VULKAN_HPP_NAMESPACE::ProvokingVertexModeEXT provokingVertexMode_ ) VULKAN_HPP_NOEXCEPT
    {
      provokingVertexMode = provokingVertexMode_;
      return *this;
    }

    operator VkPipelineRasterizationProvokingVertexStateCreateInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPipelineRasterizationProvokingVertexStateCreateInfoEXT *>( this );
    }

    operator VkPipelineRasterizationProvokingVertexStateCreateInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPipelineRasterizationProvokingVertexStateCreateInfoEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PipelineRasterizationProvokingVertexStateCreateInfoEXT const & ) const = default;
#else
    bool operator==( PipelineRasterizationProvokingVertexStateCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( provokingVertexMode == rhs.provokingVertexMode );
    }

    bool operator!=( PipelineRasterizationProvokingVertexStateCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePipelineRasterizationProvokingVertexStateCreateInfoEXT;
    const void *                        pNext = {};
    VULKAN_HPP_NAMESPACE::ProvokingVertexModeEXT provokingVertexMode =
      VULKAN_HPP_NAMESPACE::ProvokingVertexModeEXT::eFirstVertex;
  };
  static_assert( sizeof( PipelineRasterizationProvokingVertexStateCreateInfoEXT ) ==
                   sizeof( VkPipelineRasterizationProvokingVertexStateCreateInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PipelineRasterizationProvokingVertexStateCreateInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePipelineRasterizationProvokingVertexStateCreateInfoEXT>
  {
    using Type = PipelineRasterizationProvokingVertexStateCreateInfoEXT;
  };

  struct PipelineRasterizationStateRasterizationOrderAMD
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePipelineRasterizationStateRasterizationOrderAMD;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PipelineRasterizationStateRasterizationOrderAMD(
      VULKAN_HPP_NAMESPACE::RasterizationOrderAMD rasterizationOrder_ =
        VULKAN_HPP_NAMESPACE::RasterizationOrderAMD::eStrict ) VULKAN_HPP_NOEXCEPT
      : rasterizationOrder( rasterizationOrder_ )
    {}

    VULKAN_HPP_CONSTEXPR PipelineRasterizationStateRasterizationOrderAMD(
      PipelineRasterizationStateRasterizationOrderAMD const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineRasterizationStateRasterizationOrderAMD( VkPipelineRasterizationStateRasterizationOrderAMD const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PipelineRasterizationStateRasterizationOrderAMD(
          *reinterpret_cast<PipelineRasterizationStateRasterizationOrderAMD const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PipelineRasterizationStateRasterizationOrderAMD &
                            operator=( PipelineRasterizationStateRasterizationOrderAMD const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineRasterizationStateRasterizationOrderAMD &
      operator=( VkPipelineRasterizationStateRasterizationOrderAMD const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PipelineRasterizationStateRasterizationOrderAMD const *>( &rhs );
      return *this;
    }

    PipelineRasterizationStateRasterizationOrderAMD & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PipelineRasterizationStateRasterizationOrderAMD &
      setRasterizationOrder( VULKAN_HPP_NAMESPACE::RasterizationOrderAMD rasterizationOrder_ ) VULKAN_HPP_NOEXCEPT
    {
      rasterizationOrder = rasterizationOrder_;
      return *this;
    }

    operator VkPipelineRasterizationStateRasterizationOrderAMD const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPipelineRasterizationStateRasterizationOrderAMD *>( this );
    }

    operator VkPipelineRasterizationStateRasterizationOrderAMD &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPipelineRasterizationStateRasterizationOrderAMD *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PipelineRasterizationStateRasterizationOrderAMD const & ) const = default;
#else
    bool operator==( PipelineRasterizationStateRasterizationOrderAMD const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( rasterizationOrder == rhs.rasterizationOrder );
    }

    bool operator!=( PipelineRasterizationStateRasterizationOrderAMD const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType         sType = StructureType::ePipelineRasterizationStateRasterizationOrderAMD;
    const void *                                pNext = {};
    VULKAN_HPP_NAMESPACE::RasterizationOrderAMD rasterizationOrder =
      VULKAN_HPP_NAMESPACE::RasterizationOrderAMD::eStrict;
  };
  static_assert( sizeof( PipelineRasterizationStateRasterizationOrderAMD ) ==
                   sizeof( VkPipelineRasterizationStateRasterizationOrderAMD ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PipelineRasterizationStateRasterizationOrderAMD>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePipelineRasterizationStateRasterizationOrderAMD>
  {
    using Type = PipelineRasterizationStateRasterizationOrderAMD;
  };

  struct PipelineRasterizationStateStreamCreateInfoEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePipelineRasterizationStateStreamCreateInfoEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PipelineRasterizationStateStreamCreateInfoEXT(
      VULKAN_HPP_NAMESPACE::PipelineRasterizationStateStreamCreateFlagsEXT flags_ = {},
      uint32_t rasterizationStream_                                               = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , rasterizationStream( rasterizationStream_ )
    {}

    VULKAN_HPP_CONSTEXPR PipelineRasterizationStateStreamCreateInfoEXT(
      PipelineRasterizationStateStreamCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineRasterizationStateStreamCreateInfoEXT( VkPipelineRasterizationStateStreamCreateInfoEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PipelineRasterizationStateStreamCreateInfoEXT(
          *reinterpret_cast<PipelineRasterizationStateStreamCreateInfoEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PipelineRasterizationStateStreamCreateInfoEXT &
                            operator=( PipelineRasterizationStateStreamCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineRasterizationStateStreamCreateInfoEXT &
      operator=( VkPipelineRasterizationStateStreamCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PipelineRasterizationStateStreamCreateInfoEXT const *>( &rhs );
      return *this;
    }

    PipelineRasterizationStateStreamCreateInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PipelineRasterizationStateStreamCreateInfoEXT &
      setFlags( VULKAN_HPP_NAMESPACE::PipelineRasterizationStateStreamCreateFlagsEXT flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    PipelineRasterizationStateStreamCreateInfoEXT &
      setRasterizationStream( uint32_t rasterizationStream_ ) VULKAN_HPP_NOEXCEPT
    {
      rasterizationStream = rasterizationStream_;
      return *this;
    }

    operator VkPipelineRasterizationStateStreamCreateInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPipelineRasterizationStateStreamCreateInfoEXT *>( this );
    }

    operator VkPipelineRasterizationStateStreamCreateInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPipelineRasterizationStateStreamCreateInfoEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PipelineRasterizationStateStreamCreateInfoEXT const & ) const = default;
#else
    bool operator==( PipelineRasterizationStateStreamCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( rasterizationStream == rhs.rasterizationStream );
    }

    bool operator!=( PipelineRasterizationStateStreamCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePipelineRasterizationStateStreamCreateInfoEXT;
    const void *                        pNext = {};
    VULKAN_HPP_NAMESPACE::PipelineRasterizationStateStreamCreateFlagsEXT flags               = {};
    uint32_t                                                             rasterizationStream = {};
  };
  static_assert( sizeof( PipelineRasterizationStateStreamCreateInfoEXT ) ==
                   sizeof( VkPipelineRasterizationStateStreamCreateInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PipelineRasterizationStateStreamCreateInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePipelineRasterizationStateStreamCreateInfoEXT>
  {
    using Type = PipelineRasterizationStateStreamCreateInfoEXT;
  };

  struct PipelineRepresentativeFragmentTestStateCreateInfoNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePipelineRepresentativeFragmentTestStateCreateInfoNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PipelineRepresentativeFragmentTestStateCreateInfoNV(
      VULKAN_HPP_NAMESPACE::Bool32 representativeFragmentTestEnable_ = {} ) VULKAN_HPP_NOEXCEPT
      : representativeFragmentTestEnable( representativeFragmentTestEnable_ )
    {}

    VULKAN_HPP_CONSTEXPR PipelineRepresentativeFragmentTestStateCreateInfoNV(
      PipelineRepresentativeFragmentTestStateCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineRepresentativeFragmentTestStateCreateInfoNV(
      VkPipelineRepresentativeFragmentTestStateCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
      : PipelineRepresentativeFragmentTestStateCreateInfoNV(
          *reinterpret_cast<PipelineRepresentativeFragmentTestStateCreateInfoNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PipelineRepresentativeFragmentTestStateCreateInfoNV &
                            operator=( PipelineRepresentativeFragmentTestStateCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineRepresentativeFragmentTestStateCreateInfoNV &
      operator=( VkPipelineRepresentativeFragmentTestStateCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this =
        *reinterpret_cast<VULKAN_HPP_NAMESPACE::PipelineRepresentativeFragmentTestStateCreateInfoNV const *>( &rhs );
      return *this;
    }

    PipelineRepresentativeFragmentTestStateCreateInfoNV & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PipelineRepresentativeFragmentTestStateCreateInfoNV & setRepresentativeFragmentTestEnable(
      VULKAN_HPP_NAMESPACE::Bool32 representativeFragmentTestEnable_ ) VULKAN_HPP_NOEXCEPT
    {
      representativeFragmentTestEnable = representativeFragmentTestEnable_;
      return *this;
    }

    operator VkPipelineRepresentativeFragmentTestStateCreateInfoNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPipelineRepresentativeFragmentTestStateCreateInfoNV *>( this );
    }

    operator VkPipelineRepresentativeFragmentTestStateCreateInfoNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPipelineRepresentativeFragmentTestStateCreateInfoNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PipelineRepresentativeFragmentTestStateCreateInfoNV const & ) const = default;
#else
    bool operator==( PipelineRepresentativeFragmentTestStateCreateInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( representativeFragmentTestEnable == rhs.representativeFragmentTestEnable );
    }

    bool operator!=( PipelineRepresentativeFragmentTestStateCreateInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePipelineRepresentativeFragmentTestStateCreateInfoNV;
    const void *                        pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        representativeFragmentTestEnable = {};
  };
  static_assert( sizeof( PipelineRepresentativeFragmentTestStateCreateInfoNV ) ==
                   sizeof( VkPipelineRepresentativeFragmentTestStateCreateInfoNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PipelineRepresentativeFragmentTestStateCreateInfoNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePipelineRepresentativeFragmentTestStateCreateInfoNV>
  {
    using Type = PipelineRepresentativeFragmentTestStateCreateInfoNV;
  };

  struct PipelineSampleLocationsStateCreateInfoEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePipelineSampleLocationsStateCreateInfoEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PipelineSampleLocationsStateCreateInfoEXT(
      VULKAN_HPP_NAMESPACE::Bool32                 sampleLocationsEnable_ = {},
      VULKAN_HPP_NAMESPACE::SampleLocationsInfoEXT sampleLocationsInfo_   = {} ) VULKAN_HPP_NOEXCEPT
      : sampleLocationsEnable( sampleLocationsEnable_ )
      , sampleLocationsInfo( sampleLocationsInfo_ )
    {}

    VULKAN_HPP_CONSTEXPR PipelineSampleLocationsStateCreateInfoEXT(
      PipelineSampleLocationsStateCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineSampleLocationsStateCreateInfoEXT( VkPipelineSampleLocationsStateCreateInfoEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PipelineSampleLocationsStateCreateInfoEXT(
          *reinterpret_cast<PipelineSampleLocationsStateCreateInfoEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PipelineSampleLocationsStateCreateInfoEXT &
                            operator=( PipelineSampleLocationsStateCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineSampleLocationsStateCreateInfoEXT &
      operator=( VkPipelineSampleLocationsStateCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PipelineSampleLocationsStateCreateInfoEXT const *>( &rhs );
      return *this;
    }

    PipelineSampleLocationsStateCreateInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PipelineSampleLocationsStateCreateInfoEXT &
      setSampleLocationsEnable( VULKAN_HPP_NAMESPACE::Bool32 sampleLocationsEnable_ ) VULKAN_HPP_NOEXCEPT
    {
      sampleLocationsEnable = sampleLocationsEnable_;
      return *this;
    }

    PipelineSampleLocationsStateCreateInfoEXT & setSampleLocationsInfo(
      VULKAN_HPP_NAMESPACE::SampleLocationsInfoEXT const & sampleLocationsInfo_ ) VULKAN_HPP_NOEXCEPT
    {
      sampleLocationsInfo = sampleLocationsInfo_;
      return *this;
    }

    operator VkPipelineSampleLocationsStateCreateInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPipelineSampleLocationsStateCreateInfoEXT *>( this );
    }

    operator VkPipelineSampleLocationsStateCreateInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPipelineSampleLocationsStateCreateInfoEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PipelineSampleLocationsStateCreateInfoEXT const & ) const = default;
#else
    bool operator==( PipelineSampleLocationsStateCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( sampleLocationsEnable == rhs.sampleLocationsEnable ) &&
             ( sampleLocationsInfo == rhs.sampleLocationsInfo );
    }

    bool operator!=( PipelineSampleLocationsStateCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType          sType = StructureType::ePipelineSampleLocationsStateCreateInfoEXT;
    const void *                                 pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32                 sampleLocationsEnable = {};
    VULKAN_HPP_NAMESPACE::SampleLocationsInfoEXT sampleLocationsInfo   = {};
  };
  static_assert( sizeof( PipelineSampleLocationsStateCreateInfoEXT ) ==
                   sizeof( VkPipelineSampleLocationsStateCreateInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PipelineSampleLocationsStateCreateInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePipelineSampleLocationsStateCreateInfoEXT>
  {
    using Type = PipelineSampleLocationsStateCreateInfoEXT;
  };

  struct PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePipelineShaderStageRequiredSubgroupSizeCreateInfoEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT( uint32_t requiredSubgroupSize_ = {} ) VULKAN_HPP_NOEXCEPT
      : requiredSubgroupSize( requiredSubgroupSize_ )
    {}

    VULKAN_HPP_CONSTEXPR PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT(
      PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT(
      VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT(
          *reinterpret_cast<PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT &
                            operator=( PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT &
      operator=( VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this =
        *reinterpret_cast<VULKAN_HPP_NAMESPACE::PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT const *>( &rhs );
      return *this;
    }

    operator VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT *>( this );
    }

    operator VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT const & ) const = default;
#else
    bool operator==( PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( requiredSubgroupSize == rhs.requiredSubgroupSize );
    }

    bool operator!=( PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePipelineShaderStageRequiredSubgroupSizeCreateInfoEXT;
    void *                              pNext = {};
    uint32_t                            requiredSubgroupSize = {};
  };
  static_assert( sizeof( PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT ) ==
                   sizeof( VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePipelineShaderStageRequiredSubgroupSizeCreateInfoEXT>
  {
    using Type = PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT;
  };

  struct PipelineTessellationDomainOriginStateCreateInfo
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePipelineTessellationDomainOriginStateCreateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PipelineTessellationDomainOriginStateCreateInfo(
      VULKAN_HPP_NAMESPACE::TessellationDomainOrigin domainOrigin_ =
        VULKAN_HPP_NAMESPACE::TessellationDomainOrigin::eUpperLeft ) VULKAN_HPP_NOEXCEPT : domainOrigin( domainOrigin_ )
    {}

    VULKAN_HPP_CONSTEXPR PipelineTessellationDomainOriginStateCreateInfo(
      PipelineTessellationDomainOriginStateCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineTessellationDomainOriginStateCreateInfo( VkPipelineTessellationDomainOriginStateCreateInfo const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PipelineTessellationDomainOriginStateCreateInfo(
          *reinterpret_cast<PipelineTessellationDomainOriginStateCreateInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PipelineTessellationDomainOriginStateCreateInfo &
                            operator=( PipelineTessellationDomainOriginStateCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineTessellationDomainOriginStateCreateInfo &
      operator=( VkPipelineTessellationDomainOriginStateCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PipelineTessellationDomainOriginStateCreateInfo const *>( &rhs );
      return *this;
    }

    PipelineTessellationDomainOriginStateCreateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PipelineTessellationDomainOriginStateCreateInfo &
      setDomainOrigin( VULKAN_HPP_NAMESPACE::TessellationDomainOrigin domainOrigin_ ) VULKAN_HPP_NOEXCEPT
    {
      domainOrigin = domainOrigin_;
      return *this;
    }

    operator VkPipelineTessellationDomainOriginStateCreateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPipelineTessellationDomainOriginStateCreateInfo *>( this );
    }

    operator VkPipelineTessellationDomainOriginStateCreateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPipelineTessellationDomainOriginStateCreateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PipelineTessellationDomainOriginStateCreateInfo const & ) const = default;
#else
    bool operator==( PipelineTessellationDomainOriginStateCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( domainOrigin == rhs.domainOrigin );
    }

    bool operator!=( PipelineTessellationDomainOriginStateCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePipelineTessellationDomainOriginStateCreateInfo;
    const void *                        pNext = {};
    VULKAN_HPP_NAMESPACE::TessellationDomainOrigin domainOrigin =
      VULKAN_HPP_NAMESPACE::TessellationDomainOrigin::eUpperLeft;
  };
  static_assert( sizeof( PipelineTessellationDomainOriginStateCreateInfo ) ==
                   sizeof( VkPipelineTessellationDomainOriginStateCreateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PipelineTessellationDomainOriginStateCreateInfo>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePipelineTessellationDomainOriginStateCreateInfo>
  {
    using Type = PipelineTessellationDomainOriginStateCreateInfo;
  };
  using PipelineTessellationDomainOriginStateCreateInfoKHR = PipelineTessellationDomainOriginStateCreateInfo;

  struct VertexInputBindingDivisorDescriptionEXT
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR VertexInputBindingDivisorDescriptionEXT( uint32_t binding_ = {},
                                                                  uint32_t divisor_ = {} ) VULKAN_HPP_NOEXCEPT
      : binding( binding_ )
      , divisor( divisor_ )
    {}

    VULKAN_HPP_CONSTEXPR VertexInputBindingDivisorDescriptionEXT( VertexInputBindingDivisorDescriptionEXT const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    VertexInputBindingDivisorDescriptionEXT( VkVertexInputBindingDivisorDescriptionEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : VertexInputBindingDivisorDescriptionEXT(
          *reinterpret_cast<VertexInputBindingDivisorDescriptionEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 VertexInputBindingDivisorDescriptionEXT &
                            operator=( VertexInputBindingDivisorDescriptionEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VertexInputBindingDivisorDescriptionEXT &
      operator=( VkVertexInputBindingDivisorDescriptionEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::VertexInputBindingDivisorDescriptionEXT const *>( &rhs );
      return *this;
    }

    VertexInputBindingDivisorDescriptionEXT & setBinding( uint32_t binding_ ) VULKAN_HPP_NOEXCEPT
    {
      binding = binding_;
      return *this;
    }

    VertexInputBindingDivisorDescriptionEXT & setDivisor( uint32_t divisor_ ) VULKAN_HPP_NOEXCEPT
    {
      divisor = divisor_;
      return *this;
    }

    operator VkVertexInputBindingDivisorDescriptionEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkVertexInputBindingDivisorDescriptionEXT *>( this );
    }

    operator VkVertexInputBindingDivisorDescriptionEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkVertexInputBindingDivisorDescriptionEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( VertexInputBindingDivisorDescriptionEXT const & ) const = default;
#else
    bool operator==( VertexInputBindingDivisorDescriptionEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( binding == rhs.binding ) && ( divisor == rhs.divisor );
    }

    bool operator!=( VertexInputBindingDivisorDescriptionEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    uint32_t binding = {};
    uint32_t divisor = {};
  };
  static_assert( sizeof( VertexInputBindingDivisorDescriptionEXT ) ==
                   sizeof( VkVertexInputBindingDivisorDescriptionEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<VertexInputBindingDivisorDescriptionEXT>::value,
                 "struct wrapper is not a standard layout!" );

  struct PipelineVertexInputDivisorStateCreateInfoEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePipelineVertexInputDivisorStateCreateInfoEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PipelineVertexInputDivisorStateCreateInfoEXT(
      uint32_t                                                              vertexBindingDivisorCount_ = {},
      const VULKAN_HPP_NAMESPACE::VertexInputBindingDivisorDescriptionEXT * pVertexBindingDivisors_    = {} )
      VULKAN_HPP_NOEXCEPT
      : vertexBindingDivisorCount( vertexBindingDivisorCount_ )
      , pVertexBindingDivisors( pVertexBindingDivisors_ )
    {}

    VULKAN_HPP_CONSTEXPR PipelineVertexInputDivisorStateCreateInfoEXT(
      PipelineVertexInputDivisorStateCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineVertexInputDivisorStateCreateInfoEXT( VkPipelineVertexInputDivisorStateCreateInfoEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PipelineVertexInputDivisorStateCreateInfoEXT(
          *reinterpret_cast<PipelineVertexInputDivisorStateCreateInfoEXT const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    PipelineVertexInputDivisorStateCreateInfoEXT(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<
        const VULKAN_HPP_NAMESPACE::VertexInputBindingDivisorDescriptionEXT> const & vertexBindingDivisors_ )
      : vertexBindingDivisorCount( static_cast<uint32_t>( vertexBindingDivisors_.size() ) )
      , pVertexBindingDivisors( vertexBindingDivisors_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PipelineVertexInputDivisorStateCreateInfoEXT &
                            operator=( PipelineVertexInputDivisorStateCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineVertexInputDivisorStateCreateInfoEXT &
      operator=( VkPipelineVertexInputDivisorStateCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PipelineVertexInputDivisorStateCreateInfoEXT const *>( &rhs );
      return *this;
    }

    PipelineVertexInputDivisorStateCreateInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PipelineVertexInputDivisorStateCreateInfoEXT &
      setVertexBindingDivisorCount( uint32_t vertexBindingDivisorCount_ ) VULKAN_HPP_NOEXCEPT
    {
      vertexBindingDivisorCount = vertexBindingDivisorCount_;
      return *this;
    }

    PipelineVertexInputDivisorStateCreateInfoEXT & setPVertexBindingDivisors(
      const VULKAN_HPP_NAMESPACE::VertexInputBindingDivisorDescriptionEXT * pVertexBindingDivisors_ )
      VULKAN_HPP_NOEXCEPT
    {
      pVertexBindingDivisors = pVertexBindingDivisors_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    PipelineVertexInputDivisorStateCreateInfoEXT & setVertexBindingDivisors(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<
        const VULKAN_HPP_NAMESPACE::VertexInputBindingDivisorDescriptionEXT> const & vertexBindingDivisors_ )
      VULKAN_HPP_NOEXCEPT
    {
      vertexBindingDivisorCount = static_cast<uint32_t>( vertexBindingDivisors_.size() );
      pVertexBindingDivisors    = vertexBindingDivisors_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkPipelineVertexInputDivisorStateCreateInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPipelineVertexInputDivisorStateCreateInfoEXT *>( this );
    }

    operator VkPipelineVertexInputDivisorStateCreateInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPipelineVertexInputDivisorStateCreateInfoEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PipelineVertexInputDivisorStateCreateInfoEXT const & ) const = default;
#else
    bool operator==( PipelineVertexInputDivisorStateCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( vertexBindingDivisorCount == rhs.vertexBindingDivisorCount ) &&
             ( pVertexBindingDivisors == rhs.pVertexBindingDivisors );
    }

    bool operator!=( PipelineVertexInputDivisorStateCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePipelineVertexInputDivisorStateCreateInfoEXT;
    const void *                        pNext = {};
    uint32_t                            vertexBindingDivisorCount                                = {};
    const VULKAN_HPP_NAMESPACE::VertexInputBindingDivisorDescriptionEXT * pVertexBindingDivisors = {};
  };
  static_assert( sizeof( PipelineVertexInputDivisorStateCreateInfoEXT ) ==
                   sizeof( VkPipelineVertexInputDivisorStateCreateInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PipelineVertexInputDivisorStateCreateInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePipelineVertexInputDivisorStateCreateInfoEXT>
  {
    using Type = PipelineVertexInputDivisorStateCreateInfoEXT;
  };

  struct PipelineViewportCoarseSampleOrderStateCreateInfoNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePipelineViewportCoarseSampleOrderStateCreateInfoNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PipelineViewportCoarseSampleOrderStateCreateInfoNV(
      VULKAN_HPP_NAMESPACE::CoarseSampleOrderTypeNV sampleOrderType_ =
        VULKAN_HPP_NAMESPACE::CoarseSampleOrderTypeNV::eDefault,
      uint32_t                                                customSampleOrderCount_ = {},
      const VULKAN_HPP_NAMESPACE::CoarseSampleOrderCustomNV * pCustomSampleOrders_    = {} ) VULKAN_HPP_NOEXCEPT
      : sampleOrderType( sampleOrderType_ )
      , customSampleOrderCount( customSampleOrderCount_ )
      , pCustomSampleOrders( pCustomSampleOrders_ )
    {}

    VULKAN_HPP_CONSTEXPR PipelineViewportCoarseSampleOrderStateCreateInfoNV(
      PipelineViewportCoarseSampleOrderStateCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineViewportCoarseSampleOrderStateCreateInfoNV(
      VkPipelineViewportCoarseSampleOrderStateCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
      : PipelineViewportCoarseSampleOrderStateCreateInfoNV(
          *reinterpret_cast<PipelineViewportCoarseSampleOrderStateCreateInfoNV const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    PipelineViewportCoarseSampleOrderStateCreateInfoNV(
      VULKAN_HPP_NAMESPACE::CoarseSampleOrderTypeNV sampleOrderType_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::CoarseSampleOrderCustomNV> const &
        customSampleOrders_ )
      : sampleOrderType( sampleOrderType_ )
      , customSampleOrderCount( static_cast<uint32_t>( customSampleOrders_.size() ) )
      , pCustomSampleOrders( customSampleOrders_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PipelineViewportCoarseSampleOrderStateCreateInfoNV &
                            operator=( PipelineViewportCoarseSampleOrderStateCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineViewportCoarseSampleOrderStateCreateInfoNV &
      operator=( VkPipelineViewportCoarseSampleOrderStateCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this =
        *reinterpret_cast<VULKAN_HPP_NAMESPACE::PipelineViewportCoarseSampleOrderStateCreateInfoNV const *>( &rhs );
      return *this;
    }

    PipelineViewportCoarseSampleOrderStateCreateInfoNV & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PipelineViewportCoarseSampleOrderStateCreateInfoNV &
      setSampleOrderType( VULKAN_HPP_NAMESPACE::CoarseSampleOrderTypeNV sampleOrderType_ ) VULKAN_HPP_NOEXCEPT
    {
      sampleOrderType = sampleOrderType_;
      return *this;
    }

    PipelineViewportCoarseSampleOrderStateCreateInfoNV &
      setCustomSampleOrderCount( uint32_t customSampleOrderCount_ ) VULKAN_HPP_NOEXCEPT
    {
      customSampleOrderCount = customSampleOrderCount_;
      return *this;
    }

    PipelineViewportCoarseSampleOrderStateCreateInfoNV & setPCustomSampleOrders(
      const VULKAN_HPP_NAMESPACE::CoarseSampleOrderCustomNV * pCustomSampleOrders_ ) VULKAN_HPP_NOEXCEPT
    {
      pCustomSampleOrders = pCustomSampleOrders_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    PipelineViewportCoarseSampleOrderStateCreateInfoNV & setCustomSampleOrders(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::CoarseSampleOrderCustomNV> const &
        customSampleOrders_ ) VULKAN_HPP_NOEXCEPT
    {
      customSampleOrderCount = static_cast<uint32_t>( customSampleOrders_.size() );
      pCustomSampleOrders    = customSampleOrders_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkPipelineViewportCoarseSampleOrderStateCreateInfoNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPipelineViewportCoarseSampleOrderStateCreateInfoNV *>( this );
    }

    operator VkPipelineViewportCoarseSampleOrderStateCreateInfoNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPipelineViewportCoarseSampleOrderStateCreateInfoNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PipelineViewportCoarseSampleOrderStateCreateInfoNV const & ) const = default;
#else
    bool operator==( PipelineViewportCoarseSampleOrderStateCreateInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( sampleOrderType == rhs.sampleOrderType ) &&
             ( customSampleOrderCount == rhs.customSampleOrderCount ) &&
             ( pCustomSampleOrders == rhs.pCustomSampleOrders );
    }

    bool operator!=( PipelineViewportCoarseSampleOrderStateCreateInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePipelineViewportCoarseSampleOrderStateCreateInfoNV;
    const void *                        pNext = {};
    VULKAN_HPP_NAMESPACE::CoarseSampleOrderTypeNV sampleOrderType =
      VULKAN_HPP_NAMESPACE::CoarseSampleOrderTypeNV::eDefault;
    uint32_t                                                customSampleOrderCount = {};
    const VULKAN_HPP_NAMESPACE::CoarseSampleOrderCustomNV * pCustomSampleOrders    = {};
  };
  static_assert( sizeof( PipelineViewportCoarseSampleOrderStateCreateInfoNV ) ==
                   sizeof( VkPipelineViewportCoarseSampleOrderStateCreateInfoNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PipelineViewportCoarseSampleOrderStateCreateInfoNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePipelineViewportCoarseSampleOrderStateCreateInfoNV>
  {
    using Type = PipelineViewportCoarseSampleOrderStateCreateInfoNV;
  };

  struct PipelineViewportExclusiveScissorStateCreateInfoNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePipelineViewportExclusiveScissorStateCreateInfoNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PipelineViewportExclusiveScissorStateCreateInfoNV(
      uint32_t                             exclusiveScissorCount_ = {},
      const VULKAN_HPP_NAMESPACE::Rect2D * pExclusiveScissors_    = {} ) VULKAN_HPP_NOEXCEPT
      : exclusiveScissorCount( exclusiveScissorCount_ )
      , pExclusiveScissors( pExclusiveScissors_ )
    {}

    VULKAN_HPP_CONSTEXPR PipelineViewportExclusiveScissorStateCreateInfoNV(
      PipelineViewportExclusiveScissorStateCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineViewportExclusiveScissorStateCreateInfoNV( VkPipelineViewportExclusiveScissorStateCreateInfoNV const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PipelineViewportExclusiveScissorStateCreateInfoNV(
          *reinterpret_cast<PipelineViewportExclusiveScissorStateCreateInfoNV const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    PipelineViewportExclusiveScissorStateCreateInfoNV(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::Rect2D> const & exclusiveScissors_ )
      : exclusiveScissorCount( static_cast<uint32_t>( exclusiveScissors_.size() ) )
      , pExclusiveScissors( exclusiveScissors_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PipelineViewportExclusiveScissorStateCreateInfoNV &
                            operator=( PipelineViewportExclusiveScissorStateCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineViewportExclusiveScissorStateCreateInfoNV &
      operator=( VkPipelineViewportExclusiveScissorStateCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this =
        *reinterpret_cast<VULKAN_HPP_NAMESPACE::PipelineViewportExclusiveScissorStateCreateInfoNV const *>( &rhs );
      return *this;
    }

    PipelineViewportExclusiveScissorStateCreateInfoNV & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PipelineViewportExclusiveScissorStateCreateInfoNV &
      setExclusiveScissorCount( uint32_t exclusiveScissorCount_ ) VULKAN_HPP_NOEXCEPT
    {
      exclusiveScissorCount = exclusiveScissorCount_;
      return *this;
    }

    PipelineViewportExclusiveScissorStateCreateInfoNV &
      setPExclusiveScissors( const VULKAN_HPP_NAMESPACE::Rect2D * pExclusiveScissors_ ) VULKAN_HPP_NOEXCEPT
    {
      pExclusiveScissors = pExclusiveScissors_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    PipelineViewportExclusiveScissorStateCreateInfoNV & setExclusiveScissors(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::Rect2D> const & exclusiveScissors_ )
      VULKAN_HPP_NOEXCEPT
    {
      exclusiveScissorCount = static_cast<uint32_t>( exclusiveScissors_.size() );
      pExclusiveScissors    = exclusiveScissors_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkPipelineViewportExclusiveScissorStateCreateInfoNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPipelineViewportExclusiveScissorStateCreateInfoNV *>( this );
    }

    operator VkPipelineViewportExclusiveScissorStateCreateInfoNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPipelineViewportExclusiveScissorStateCreateInfoNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PipelineViewportExclusiveScissorStateCreateInfoNV const & ) const = default;
#else
    bool operator==( PipelineViewportExclusiveScissorStateCreateInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( exclusiveScissorCount == rhs.exclusiveScissorCount ) && ( pExclusiveScissors == rhs.pExclusiveScissors );
    }

    bool operator!=( PipelineViewportExclusiveScissorStateCreateInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType  sType = StructureType::ePipelineViewportExclusiveScissorStateCreateInfoNV;
    const void *                         pNext = {};
    uint32_t                             exclusiveScissorCount = {};
    const VULKAN_HPP_NAMESPACE::Rect2D * pExclusiveScissors    = {};
  };
  static_assert( sizeof( PipelineViewportExclusiveScissorStateCreateInfoNV ) ==
                   sizeof( VkPipelineViewportExclusiveScissorStateCreateInfoNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PipelineViewportExclusiveScissorStateCreateInfoNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePipelineViewportExclusiveScissorStateCreateInfoNV>
  {
    using Type = PipelineViewportExclusiveScissorStateCreateInfoNV;
  };

  struct ShadingRatePaletteNV
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ShadingRatePaletteNV(
      uint32_t                                                shadingRatePaletteEntryCount_ = {},
      const VULKAN_HPP_NAMESPACE::ShadingRatePaletteEntryNV * pShadingRatePaletteEntries_   = {} ) VULKAN_HPP_NOEXCEPT
      : shadingRatePaletteEntryCount( shadingRatePaletteEntryCount_ )
      , pShadingRatePaletteEntries( pShadingRatePaletteEntries_ )
    {}

    VULKAN_HPP_CONSTEXPR ShadingRatePaletteNV( ShadingRatePaletteNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ShadingRatePaletteNV( VkShadingRatePaletteNV const & rhs ) VULKAN_HPP_NOEXCEPT
      : ShadingRatePaletteNV( *reinterpret_cast<ShadingRatePaletteNV const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    ShadingRatePaletteNV(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::ShadingRatePaletteEntryNV> const &
        shadingRatePaletteEntries_ )
      : shadingRatePaletteEntryCount( static_cast<uint32_t>( shadingRatePaletteEntries_.size() ) )
      , pShadingRatePaletteEntries( shadingRatePaletteEntries_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ShadingRatePaletteNV &
                            operator=( ShadingRatePaletteNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ShadingRatePaletteNV & operator=( VkShadingRatePaletteNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ShadingRatePaletteNV const *>( &rhs );
      return *this;
    }

    ShadingRatePaletteNV & setShadingRatePaletteEntryCount( uint32_t shadingRatePaletteEntryCount_ ) VULKAN_HPP_NOEXCEPT
    {
      shadingRatePaletteEntryCount = shadingRatePaletteEntryCount_;
      return *this;
    }

    ShadingRatePaletteNV & setPShadingRatePaletteEntries(
      const VULKAN_HPP_NAMESPACE::ShadingRatePaletteEntryNV * pShadingRatePaletteEntries_ ) VULKAN_HPP_NOEXCEPT
    {
      pShadingRatePaletteEntries = pShadingRatePaletteEntries_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    ShadingRatePaletteNV & setShadingRatePaletteEntries(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::ShadingRatePaletteEntryNV> const &
        shadingRatePaletteEntries_ ) VULKAN_HPP_NOEXCEPT
    {
      shadingRatePaletteEntryCount = static_cast<uint32_t>( shadingRatePaletteEntries_.size() );
      pShadingRatePaletteEntries   = shadingRatePaletteEntries_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkShadingRatePaletteNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkShadingRatePaletteNV *>( this );
    }

    operator VkShadingRatePaletteNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkShadingRatePaletteNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ShadingRatePaletteNV const & ) const = default;
#else
    bool operator==( ShadingRatePaletteNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( shadingRatePaletteEntryCount == rhs.shadingRatePaletteEntryCount ) &&
             ( pShadingRatePaletteEntries == rhs.pShadingRatePaletteEntries );
    }

    bool operator!=( ShadingRatePaletteNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    uint32_t                                                shadingRatePaletteEntryCount = {};
    const VULKAN_HPP_NAMESPACE::ShadingRatePaletteEntryNV * pShadingRatePaletteEntries   = {};
  };
  static_assert( sizeof( ShadingRatePaletteNV ) == sizeof( VkShadingRatePaletteNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ShadingRatePaletteNV>::value, "struct wrapper is not a standard layout!" );

  struct PipelineViewportShadingRateImageStateCreateInfoNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePipelineViewportShadingRateImageStateCreateInfoNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PipelineViewportShadingRateImageStateCreateInfoNV(
      VULKAN_HPP_NAMESPACE::Bool32                       shadingRateImageEnable_ = {},
      uint32_t                                           viewportCount_          = {},
      const VULKAN_HPP_NAMESPACE::ShadingRatePaletteNV * pShadingRatePalettes_   = {} ) VULKAN_HPP_NOEXCEPT
      : shadingRateImageEnable( shadingRateImageEnable_ )
      , viewportCount( viewportCount_ )
      , pShadingRatePalettes( pShadingRatePalettes_ )
    {}

    VULKAN_HPP_CONSTEXPR PipelineViewportShadingRateImageStateCreateInfoNV(
      PipelineViewportShadingRateImageStateCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineViewportShadingRateImageStateCreateInfoNV( VkPipelineViewportShadingRateImageStateCreateInfoNV const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PipelineViewportShadingRateImageStateCreateInfoNV(
          *reinterpret_cast<PipelineViewportShadingRateImageStateCreateInfoNV const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    PipelineViewportShadingRateImageStateCreateInfoNV(
      VULKAN_HPP_NAMESPACE::Bool32 shadingRateImageEnable_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::ShadingRatePaletteNV> const &
        shadingRatePalettes_ )
      : shadingRateImageEnable( shadingRateImageEnable_ )
      , viewportCount( static_cast<uint32_t>( shadingRatePalettes_.size() ) )
      , pShadingRatePalettes( shadingRatePalettes_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PipelineViewportShadingRateImageStateCreateInfoNV &
                            operator=( PipelineViewportShadingRateImageStateCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineViewportShadingRateImageStateCreateInfoNV &
      operator=( VkPipelineViewportShadingRateImageStateCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this =
        *reinterpret_cast<VULKAN_HPP_NAMESPACE::PipelineViewportShadingRateImageStateCreateInfoNV const *>( &rhs );
      return *this;
    }

    PipelineViewportShadingRateImageStateCreateInfoNV & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PipelineViewportShadingRateImageStateCreateInfoNV &
      setShadingRateImageEnable( VULKAN_HPP_NAMESPACE::Bool32 shadingRateImageEnable_ ) VULKAN_HPP_NOEXCEPT
    {
      shadingRateImageEnable = shadingRateImageEnable_;
      return *this;
    }

    PipelineViewportShadingRateImageStateCreateInfoNV & setViewportCount( uint32_t viewportCount_ ) VULKAN_HPP_NOEXCEPT
    {
      viewportCount = viewportCount_;
      return *this;
    }

    PipelineViewportShadingRateImageStateCreateInfoNV & setPShadingRatePalettes(
      const VULKAN_HPP_NAMESPACE::ShadingRatePaletteNV * pShadingRatePalettes_ ) VULKAN_HPP_NOEXCEPT
    {
      pShadingRatePalettes = pShadingRatePalettes_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    PipelineViewportShadingRateImageStateCreateInfoNV & setShadingRatePalettes(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::ShadingRatePaletteNV> const &
        shadingRatePalettes_ ) VULKAN_HPP_NOEXCEPT
    {
      viewportCount        = static_cast<uint32_t>( shadingRatePalettes_.size() );
      pShadingRatePalettes = shadingRatePalettes_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkPipelineViewportShadingRateImageStateCreateInfoNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPipelineViewportShadingRateImageStateCreateInfoNV *>( this );
    }

    operator VkPipelineViewportShadingRateImageStateCreateInfoNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPipelineViewportShadingRateImageStateCreateInfoNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PipelineViewportShadingRateImageStateCreateInfoNV const & ) const = default;
#else
    bool operator==( PipelineViewportShadingRateImageStateCreateInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( shadingRateImageEnable == rhs.shadingRateImageEnable ) && ( viewportCount == rhs.viewportCount ) &&
             ( pShadingRatePalettes == rhs.pShadingRatePalettes );
    }

    bool operator!=( PipelineViewportShadingRateImageStateCreateInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePipelineViewportShadingRateImageStateCreateInfoNV;
    const void *                        pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        shadingRateImageEnable              = {};
    uint32_t                            viewportCount                       = {};
    const VULKAN_HPP_NAMESPACE::ShadingRatePaletteNV * pShadingRatePalettes = {};
  };
  static_assert( sizeof( PipelineViewportShadingRateImageStateCreateInfoNV ) ==
                   sizeof( VkPipelineViewportShadingRateImageStateCreateInfoNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PipelineViewportShadingRateImageStateCreateInfoNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePipelineViewportShadingRateImageStateCreateInfoNV>
  {
    using Type = PipelineViewportShadingRateImageStateCreateInfoNV;
  };

  struct ViewportSwizzleNV
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      ViewportSwizzleNV( VULKAN_HPP_NAMESPACE::ViewportCoordinateSwizzleNV x_ =
                           VULKAN_HPP_NAMESPACE::ViewportCoordinateSwizzleNV::ePositiveX,
                         VULKAN_HPP_NAMESPACE::ViewportCoordinateSwizzleNV y_ =
                           VULKAN_HPP_NAMESPACE::ViewportCoordinateSwizzleNV::ePositiveX,
                         VULKAN_HPP_NAMESPACE::ViewportCoordinateSwizzleNV z_ =
                           VULKAN_HPP_NAMESPACE::ViewportCoordinateSwizzleNV::ePositiveX,
                         VULKAN_HPP_NAMESPACE::ViewportCoordinateSwizzleNV w_ =
                           VULKAN_HPP_NAMESPACE::ViewportCoordinateSwizzleNV::ePositiveX ) VULKAN_HPP_NOEXCEPT
      : x( x_ )
      , y( y_ )
      , z( z_ )
      , w( w_ )
    {}

    VULKAN_HPP_CONSTEXPR ViewportSwizzleNV( ViewportSwizzleNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ViewportSwizzleNV( VkViewportSwizzleNV const & rhs ) VULKAN_HPP_NOEXCEPT
      : ViewportSwizzleNV( *reinterpret_cast<ViewportSwizzleNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ViewportSwizzleNV &
                            operator=( ViewportSwizzleNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ViewportSwizzleNV & operator=( VkViewportSwizzleNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ViewportSwizzleNV const *>( &rhs );
      return *this;
    }

    ViewportSwizzleNV & setX( VULKAN_HPP_NAMESPACE::ViewportCoordinateSwizzleNV x_ ) VULKAN_HPP_NOEXCEPT
    {
      x = x_;
      return *this;
    }

    ViewportSwizzleNV & setY( VULKAN_HPP_NAMESPACE::ViewportCoordinateSwizzleNV y_ ) VULKAN_HPP_NOEXCEPT
    {
      y = y_;
      return *this;
    }

    ViewportSwizzleNV & setZ( VULKAN_HPP_NAMESPACE::ViewportCoordinateSwizzleNV z_ ) VULKAN_HPP_NOEXCEPT
    {
      z = z_;
      return *this;
    }

    ViewportSwizzleNV & setW( VULKAN_HPP_NAMESPACE::ViewportCoordinateSwizzleNV w_ ) VULKAN_HPP_NOEXCEPT
    {
      w = w_;
      return *this;
    }

    operator VkViewportSwizzleNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkViewportSwizzleNV *>( this );
    }

    operator VkViewportSwizzleNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkViewportSwizzleNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ViewportSwizzleNV const & ) const = default;
#else
    bool operator==( ViewportSwizzleNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( x == rhs.x ) && ( y == rhs.y ) && ( z == rhs.z ) && ( w == rhs.w );
    }

    bool operator!=( ViewportSwizzleNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::ViewportCoordinateSwizzleNV x = VULKAN_HPP_NAMESPACE::ViewportCoordinateSwizzleNV::ePositiveX;
    VULKAN_HPP_NAMESPACE::ViewportCoordinateSwizzleNV y = VULKAN_HPP_NAMESPACE::ViewportCoordinateSwizzleNV::ePositiveX;
    VULKAN_HPP_NAMESPACE::ViewportCoordinateSwizzleNV z = VULKAN_HPP_NAMESPACE::ViewportCoordinateSwizzleNV::ePositiveX;
    VULKAN_HPP_NAMESPACE::ViewportCoordinateSwizzleNV w = VULKAN_HPP_NAMESPACE::ViewportCoordinateSwizzleNV::ePositiveX;
  };
  static_assert( sizeof( ViewportSwizzleNV ) == sizeof( VkViewportSwizzleNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ViewportSwizzleNV>::value, "struct wrapper is not a standard layout!" );

  struct PipelineViewportSwizzleStateCreateInfoNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePipelineViewportSwizzleStateCreateInfoNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PipelineViewportSwizzleStateCreateInfoNV(
      VULKAN_HPP_NAMESPACE::PipelineViewportSwizzleStateCreateFlagsNV flags_             = {},
      uint32_t                                                        viewportCount_     = {},
      const VULKAN_HPP_NAMESPACE::ViewportSwizzleNV *                 pViewportSwizzles_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , viewportCount( viewportCount_ )
      , pViewportSwizzles( pViewportSwizzles_ )
    {}

    VULKAN_HPP_CONSTEXPR PipelineViewportSwizzleStateCreateInfoNV(
      PipelineViewportSwizzleStateCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineViewportSwizzleStateCreateInfoNV( VkPipelineViewportSwizzleStateCreateInfoNV const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PipelineViewportSwizzleStateCreateInfoNV(
          *reinterpret_cast<PipelineViewportSwizzleStateCreateInfoNV const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    PipelineViewportSwizzleStateCreateInfoNV(
      VULKAN_HPP_NAMESPACE::PipelineViewportSwizzleStateCreateFlagsNV flags_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::ViewportSwizzleNV> const &
        viewportSwizzles_ )
      : flags( flags_ )
      , viewportCount( static_cast<uint32_t>( viewportSwizzles_.size() ) )
      , pViewportSwizzles( viewportSwizzles_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PipelineViewportSwizzleStateCreateInfoNV &
                            operator=( PipelineViewportSwizzleStateCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineViewportSwizzleStateCreateInfoNV &
      operator=( VkPipelineViewportSwizzleStateCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PipelineViewportSwizzleStateCreateInfoNV const *>( &rhs );
      return *this;
    }

    PipelineViewportSwizzleStateCreateInfoNV & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PipelineViewportSwizzleStateCreateInfoNV &
      setFlags( VULKAN_HPP_NAMESPACE::PipelineViewportSwizzleStateCreateFlagsNV flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    PipelineViewportSwizzleStateCreateInfoNV & setViewportCount( uint32_t viewportCount_ ) VULKAN_HPP_NOEXCEPT
    {
      viewportCount = viewportCount_;
      return *this;
    }

    PipelineViewportSwizzleStateCreateInfoNV &
      setPViewportSwizzles( const VULKAN_HPP_NAMESPACE::ViewportSwizzleNV * pViewportSwizzles_ ) VULKAN_HPP_NOEXCEPT
    {
      pViewportSwizzles = pViewportSwizzles_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    PipelineViewportSwizzleStateCreateInfoNV & setViewportSwizzles(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::ViewportSwizzleNV> const &
        viewportSwizzles_ ) VULKAN_HPP_NOEXCEPT
    {
      viewportCount     = static_cast<uint32_t>( viewportSwizzles_.size() );
      pViewportSwizzles = viewportSwizzles_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkPipelineViewportSwizzleStateCreateInfoNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPipelineViewportSwizzleStateCreateInfoNV *>( this );
    }

    operator VkPipelineViewportSwizzleStateCreateInfoNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPipelineViewportSwizzleStateCreateInfoNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PipelineViewportSwizzleStateCreateInfoNV const & ) const = default;
#else
    bool operator==( PipelineViewportSwizzleStateCreateInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( viewportCount == rhs.viewportCount ) && ( pViewportSwizzles == rhs.pViewportSwizzles );
    }

    bool operator!=( PipelineViewportSwizzleStateCreateInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::ePipelineViewportSwizzleStateCreateInfoNV;
    const void *                        pNext = {};
    VULKAN_HPP_NAMESPACE::PipelineViewportSwizzleStateCreateFlagsNV flags             = {};
    uint32_t                                                        viewportCount     = {};
    const VULKAN_HPP_NAMESPACE::ViewportSwizzleNV *                 pViewportSwizzles = {};
  };
  static_assert( sizeof( PipelineViewportSwizzleStateCreateInfoNV ) ==
                   sizeof( VkPipelineViewportSwizzleStateCreateInfoNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PipelineViewportSwizzleStateCreateInfoNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePipelineViewportSwizzleStateCreateInfoNV>
  {
    using Type = PipelineViewportSwizzleStateCreateInfoNV;
  };

  struct ViewportWScalingNV
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ViewportWScalingNV( float xcoeff_ = {}, float ycoeff_ = {} ) VULKAN_HPP_NOEXCEPT
      : xcoeff( xcoeff_ )
      , ycoeff( ycoeff_ )
    {}

    VULKAN_HPP_CONSTEXPR ViewportWScalingNV( ViewportWScalingNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ViewportWScalingNV( VkViewportWScalingNV const & rhs ) VULKAN_HPP_NOEXCEPT
      : ViewportWScalingNV( *reinterpret_cast<ViewportWScalingNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ViewportWScalingNV &
                            operator=( ViewportWScalingNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ViewportWScalingNV & operator=( VkViewportWScalingNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ViewportWScalingNV const *>( &rhs );
      return *this;
    }

    ViewportWScalingNV & setXcoeff( float xcoeff_ ) VULKAN_HPP_NOEXCEPT
    {
      xcoeff = xcoeff_;
      return *this;
    }

    ViewportWScalingNV & setYcoeff( float ycoeff_ ) VULKAN_HPP_NOEXCEPT
    {
      ycoeff = ycoeff_;
      return *this;
    }

    operator VkViewportWScalingNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkViewportWScalingNV *>( this );
    }

    operator VkViewportWScalingNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkViewportWScalingNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ViewportWScalingNV const & ) const = default;
#else
    bool operator==( ViewportWScalingNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( xcoeff == rhs.xcoeff ) && ( ycoeff == rhs.ycoeff );
    }

    bool operator!=( ViewportWScalingNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    float xcoeff = {};
    float ycoeff = {};
  };
  static_assert( sizeof( ViewportWScalingNV ) == sizeof( VkViewportWScalingNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ViewportWScalingNV>::value, "struct wrapper is not a standard layout!" );

  struct PipelineViewportWScalingStateCreateInfoNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::ePipelineViewportWScalingStateCreateInfoNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PipelineViewportWScalingStateCreateInfoNV(
      VULKAN_HPP_NAMESPACE::Bool32                     viewportWScalingEnable_ = {},
      uint32_t                                         viewportCount_          = {},
      const VULKAN_HPP_NAMESPACE::ViewportWScalingNV * pViewportWScalings_     = {} ) VULKAN_HPP_NOEXCEPT
      : viewportWScalingEnable( viewportWScalingEnable_ )
      , viewportCount( viewportCount_ )
      , pViewportWScalings( pViewportWScalings_ )
    {}

    VULKAN_HPP_CONSTEXPR PipelineViewportWScalingStateCreateInfoNV(
      PipelineViewportWScalingStateCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineViewportWScalingStateCreateInfoNV( VkPipelineViewportWScalingStateCreateInfoNV const & rhs )
      VULKAN_HPP_NOEXCEPT
      : PipelineViewportWScalingStateCreateInfoNV(
          *reinterpret_cast<PipelineViewportWScalingStateCreateInfoNV const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    PipelineViewportWScalingStateCreateInfoNV(
      VULKAN_HPP_NAMESPACE::Bool32 viewportWScalingEnable_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::ViewportWScalingNV> const &
        viewportWScalings_ )
      : viewportWScalingEnable( viewportWScalingEnable_ )
      , viewportCount( static_cast<uint32_t>( viewportWScalings_.size() ) )
      , pViewportWScalings( viewportWScalings_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PipelineViewportWScalingStateCreateInfoNV &
                            operator=( PipelineViewportWScalingStateCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PipelineViewportWScalingStateCreateInfoNV &
      operator=( VkPipelineViewportWScalingStateCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PipelineViewportWScalingStateCreateInfoNV const *>( &rhs );
      return *this;
    }

    PipelineViewportWScalingStateCreateInfoNV & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PipelineViewportWScalingStateCreateInfoNV &
      setViewportWScalingEnable( VULKAN_HPP_NAMESPACE::Bool32 viewportWScalingEnable_ ) VULKAN_HPP_NOEXCEPT
    {
      viewportWScalingEnable = viewportWScalingEnable_;
      return *this;
    }

    PipelineViewportWScalingStateCreateInfoNV & setViewportCount( uint32_t viewportCount_ ) VULKAN_HPP_NOEXCEPT
    {
      viewportCount = viewportCount_;
      return *this;
    }

    PipelineViewportWScalingStateCreateInfoNV &
      setPViewportWScalings( const VULKAN_HPP_NAMESPACE::ViewportWScalingNV * pViewportWScalings_ ) VULKAN_HPP_NOEXCEPT
    {
      pViewportWScalings = pViewportWScalings_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    PipelineViewportWScalingStateCreateInfoNV & setViewportWScalings(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::ViewportWScalingNV> const &
        viewportWScalings_ ) VULKAN_HPP_NOEXCEPT
    {
      viewportCount      = static_cast<uint32_t>( viewportWScalings_.size() );
      pViewportWScalings = viewportWScalings_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkPipelineViewportWScalingStateCreateInfoNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPipelineViewportWScalingStateCreateInfoNV *>( this );
    }

    operator VkPipelineViewportWScalingStateCreateInfoNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPipelineViewportWScalingStateCreateInfoNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PipelineViewportWScalingStateCreateInfoNV const & ) const = default;
#else
    bool operator==( PipelineViewportWScalingStateCreateInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( viewportWScalingEnable == rhs.viewportWScalingEnable ) && ( viewportCount == rhs.viewportCount ) &&
             ( pViewportWScalings == rhs.pViewportWScalings );
    }

    bool operator!=( PipelineViewportWScalingStateCreateInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType              sType = StructureType::ePipelineViewportWScalingStateCreateInfoNV;
    const void *                                     pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32                     viewportWScalingEnable = {};
    uint32_t                                         viewportCount          = {};
    const VULKAN_HPP_NAMESPACE::ViewportWScalingNV * pViewportWScalings     = {};
  };
  static_assert( sizeof( PipelineViewportWScalingStateCreateInfoNV ) ==
                   sizeof( VkPipelineViewportWScalingStateCreateInfoNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PipelineViewportWScalingStateCreateInfoNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePipelineViewportWScalingStateCreateInfoNV>
  {
    using Type = PipelineViewportWScalingStateCreateInfoNV;
  };

#if defined( VK_USE_PLATFORM_GGP )
  struct PresentFrameTokenGGP
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::ePresentFrameTokenGGP;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PresentFrameTokenGGP( GgpFrameToken frameToken_ = {} ) VULKAN_HPP_NOEXCEPT
      : frameToken( frameToken_ )
    {}

    VULKAN_HPP_CONSTEXPR PresentFrameTokenGGP( PresentFrameTokenGGP const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PresentFrameTokenGGP( VkPresentFrameTokenGGP const & rhs ) VULKAN_HPP_NOEXCEPT
      : PresentFrameTokenGGP( *reinterpret_cast<PresentFrameTokenGGP const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PresentFrameTokenGGP &
                            operator=( PresentFrameTokenGGP const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PresentFrameTokenGGP & operator=( VkPresentFrameTokenGGP const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PresentFrameTokenGGP const *>( &rhs );
      return *this;
    }

    PresentFrameTokenGGP & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PresentFrameTokenGGP & setFrameToken( GgpFrameToken frameToken_ ) VULKAN_HPP_NOEXCEPT
    {
      frameToken = frameToken_;
      return *this;
    }

    operator VkPresentFrameTokenGGP const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPresentFrameTokenGGP *>( this );
    }

    operator VkPresentFrameTokenGGP &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPresentFrameTokenGGP *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PresentFrameTokenGGP const & ) const = default;
#  else
    bool operator==( PresentFrameTokenGGP const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( memcmp( &frameToken, &rhs.frameToken, sizeof( GgpFrameToken ) ) == 0 );
    }

    bool operator!=( PresentFrameTokenGGP const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType      = StructureType::ePresentFrameTokenGGP;
    const void *                        pNext      = {};
    GgpFrameToken                       frameToken = {};
  };
  static_assert( sizeof( PresentFrameTokenGGP ) == sizeof( VkPresentFrameTokenGGP ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PresentFrameTokenGGP>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePresentFrameTokenGGP>
  {
    using Type = PresentFrameTokenGGP;
  };
#endif /*VK_USE_PLATFORM_GGP*/

  struct PresentInfoKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::ePresentInfoKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PresentInfoKHR( uint32_t                                   waitSemaphoreCount_ = {},
                                         const VULKAN_HPP_NAMESPACE::Semaphore *    pWaitSemaphores_    = {},
                                         uint32_t                                   swapchainCount_     = {},
                                         const VULKAN_HPP_NAMESPACE::SwapchainKHR * pSwapchains_        = {},
                                         const uint32_t *                           pImageIndices_      = {},
                                         VULKAN_HPP_NAMESPACE::Result *             pResults_ = {} ) VULKAN_HPP_NOEXCEPT
      : waitSemaphoreCount( waitSemaphoreCount_ )
      , pWaitSemaphores( pWaitSemaphores_ )
      , swapchainCount( swapchainCount_ )
      , pSwapchains( pSwapchains_ )
      , pImageIndices( pImageIndices_ )
      , pResults( pResults_ )
    {}

    VULKAN_HPP_CONSTEXPR PresentInfoKHR( PresentInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PresentInfoKHR( VkPresentInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : PresentInfoKHR( *reinterpret_cast<PresentInfoKHR const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    PresentInfoKHR(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::Semaphore> const &    waitSemaphores_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::SwapchainKHR> const & swapchains_ = {},
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const &               imageIndices_           = {},
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<VULKAN_HPP_NAMESPACE::Result> const & results_                = {} )
      : waitSemaphoreCount( static_cast<uint32_t>( waitSemaphores_.size() ) )
      , pWaitSemaphores( waitSemaphores_.data() )
      , swapchainCount( static_cast<uint32_t>( swapchains_.size() ) )
      , pSwapchains( swapchains_.data() )
      , pImageIndices( imageIndices_.data() )
      , pResults( results_.data() )
    {
#    ifdef VULKAN_HPP_NO_EXCEPTIONS
      VULKAN_HPP_ASSERT( swapchains_.size() == imageIndices_.size() );
      VULKAN_HPP_ASSERT( results_.empty() || ( swapchains_.size() == results_.size() ) );
      VULKAN_HPP_ASSERT( results_.empty() || ( imageIndices_.size() == results_.size() ) );
#    else
      if ( swapchains_.size() != imageIndices_.size() )
      {
        throw LogicError( VULKAN_HPP_NAMESPACE_STRING
                          "::PresentInfoKHR::PresentInfoKHR: swapchains_.size() != imageIndices_.size()" );
      }
      if ( !results_.empty() && ( swapchains_.size() != results_.size() ) )
      {
        throw LogicError(
          VULKAN_HPP_NAMESPACE_STRING
          "::PresentInfoKHR::PresentInfoKHR: !results_.empty() && ( swapchains_.size() != results_.size() )" );
      }
      if ( !results_.empty() && ( imageIndices_.size() != results_.size() ) )
      {
        throw LogicError(
          VULKAN_HPP_NAMESPACE_STRING
          "::PresentInfoKHR::PresentInfoKHR: !results_.empty() && ( imageIndices_.size() != results_.size() )" );
      }
#    endif /*VULKAN_HPP_NO_EXCEPTIONS*/
    }
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PresentInfoKHR & operator=( PresentInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PresentInfoKHR & operator=( VkPresentInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PresentInfoKHR const *>( &rhs );
      return *this;
    }

    PresentInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PresentInfoKHR & setWaitSemaphoreCount( uint32_t waitSemaphoreCount_ ) VULKAN_HPP_NOEXCEPT
    {
      waitSemaphoreCount = waitSemaphoreCount_;
      return *this;
    }

    PresentInfoKHR & setPWaitSemaphores( const VULKAN_HPP_NAMESPACE::Semaphore * pWaitSemaphores_ ) VULKAN_HPP_NOEXCEPT
    {
      pWaitSemaphores = pWaitSemaphores_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    PresentInfoKHR & setWaitSemaphores(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::Semaphore> const & waitSemaphores_ )
      VULKAN_HPP_NOEXCEPT
    {
      waitSemaphoreCount = static_cast<uint32_t>( waitSemaphores_.size() );
      pWaitSemaphores    = waitSemaphores_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    PresentInfoKHR & setSwapchainCount( uint32_t swapchainCount_ ) VULKAN_HPP_NOEXCEPT
    {
      swapchainCount = swapchainCount_;
      return *this;
    }

    PresentInfoKHR & setPSwapchains( const VULKAN_HPP_NAMESPACE::SwapchainKHR * pSwapchains_ ) VULKAN_HPP_NOEXCEPT
    {
      pSwapchains = pSwapchains_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    PresentInfoKHR & setSwapchains(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::SwapchainKHR> const & swapchains_ )
      VULKAN_HPP_NOEXCEPT
    {
      swapchainCount = static_cast<uint32_t>( swapchains_.size() );
      pSwapchains    = swapchains_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    PresentInfoKHR & setPImageIndices( const uint32_t * pImageIndices_ ) VULKAN_HPP_NOEXCEPT
    {
      pImageIndices = pImageIndices_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    PresentInfoKHR & setImageIndices(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const & imageIndices_ ) VULKAN_HPP_NOEXCEPT
    {
      swapchainCount = static_cast<uint32_t>( imageIndices_.size() );
      pImageIndices  = imageIndices_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    PresentInfoKHR & setPResults( VULKAN_HPP_NAMESPACE::Result * pResults_ ) VULKAN_HPP_NOEXCEPT
    {
      pResults = pResults_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    PresentInfoKHR & setResults(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<VULKAN_HPP_NAMESPACE::Result> const & results_ ) VULKAN_HPP_NOEXCEPT
    {
      swapchainCount = static_cast<uint32_t>( results_.size() );
      pResults       = results_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkPresentInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPresentInfoKHR *>( this );
    }

    operator VkPresentInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPresentInfoKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PresentInfoKHR const & ) const = default;
#else
    bool operator==( PresentInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( waitSemaphoreCount == rhs.waitSemaphoreCount ) &&
             ( pWaitSemaphores == rhs.pWaitSemaphores ) && ( swapchainCount == rhs.swapchainCount ) &&
             ( pSwapchains == rhs.pSwapchains ) && ( pImageIndices == rhs.pImageIndices ) &&
             ( pResults == rhs.pResults );
    }

    bool operator!=( PresentInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType        sType              = StructureType::ePresentInfoKHR;
    const void *                               pNext              = {};
    uint32_t                                   waitSemaphoreCount = {};
    const VULKAN_HPP_NAMESPACE::Semaphore *    pWaitSemaphores    = {};
    uint32_t                                   swapchainCount     = {};
    const VULKAN_HPP_NAMESPACE::SwapchainKHR * pSwapchains        = {};
    const uint32_t *                           pImageIndices      = {};
    VULKAN_HPP_NAMESPACE::Result *             pResults           = {};
  };
  static_assert( sizeof( PresentInfoKHR ) == sizeof( VkPresentInfoKHR ), "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PresentInfoKHR>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePresentInfoKHR>
  {
    using Type = PresentInfoKHR;
  };

  struct RectLayerKHR
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR RectLayerKHR( VULKAN_HPP_NAMESPACE::Offset2D offset_ = {},
                                       VULKAN_HPP_NAMESPACE::Extent2D extent_ = {},
                                       uint32_t                       layer_  = {} ) VULKAN_HPP_NOEXCEPT
      : offset( offset_ )
      , extent( extent_ )
      , layer( layer_ )
    {}

    VULKAN_HPP_CONSTEXPR RectLayerKHR( RectLayerKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    RectLayerKHR( VkRectLayerKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : RectLayerKHR( *reinterpret_cast<RectLayerKHR const *>( &rhs ) )
    {}

    explicit RectLayerKHR( Rect2D const & rect2D, uint32_t layer_ = {} )
      : offset( rect2D.offset ), extent( rect2D.extent ), layer( layer_ )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 RectLayerKHR & operator=( RectLayerKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    RectLayerKHR & operator=( VkRectLayerKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::RectLayerKHR const *>( &rhs );
      return *this;
    }

    RectLayerKHR & setOffset( VULKAN_HPP_NAMESPACE::Offset2D const & offset_ ) VULKAN_HPP_NOEXCEPT
    {
      offset = offset_;
      return *this;
    }

    RectLayerKHR & setExtent( VULKAN_HPP_NAMESPACE::Extent2D const & extent_ ) VULKAN_HPP_NOEXCEPT
    {
      extent = extent_;
      return *this;
    }

    RectLayerKHR & setLayer( uint32_t layer_ ) VULKAN_HPP_NOEXCEPT
    {
      layer = layer_;
      return *this;
    }

    operator VkRectLayerKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkRectLayerKHR *>( this );
    }

    operator VkRectLayerKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkRectLayerKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( RectLayerKHR const & ) const = default;
#else
    bool operator==( RectLayerKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( offset == rhs.offset ) && ( extent == rhs.extent ) && ( layer == rhs.layer );
    }

    bool operator!=( RectLayerKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::Offset2D offset = {};
    VULKAN_HPP_NAMESPACE::Extent2D extent = {};
    uint32_t                       layer  = {};
  };
  static_assert( sizeof( RectLayerKHR ) == sizeof( VkRectLayerKHR ), "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<RectLayerKHR>::value, "struct wrapper is not a standard layout!" );

  struct PresentRegionKHR
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      PresentRegionKHR( uint32_t                                   rectangleCount_ = {},
                        const VULKAN_HPP_NAMESPACE::RectLayerKHR * pRectangles_    = {} ) VULKAN_HPP_NOEXCEPT
      : rectangleCount( rectangleCount_ )
      , pRectangles( pRectangles_ )
    {}

    VULKAN_HPP_CONSTEXPR PresentRegionKHR( PresentRegionKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PresentRegionKHR( VkPresentRegionKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : PresentRegionKHR( *reinterpret_cast<PresentRegionKHR const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    PresentRegionKHR(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::RectLayerKHR> const & rectangles_ )
      : rectangleCount( static_cast<uint32_t>( rectangles_.size() ) ), pRectangles( rectangles_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PresentRegionKHR & operator=( PresentRegionKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PresentRegionKHR & operator=( VkPresentRegionKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PresentRegionKHR const *>( &rhs );
      return *this;
    }

    PresentRegionKHR & setRectangleCount( uint32_t rectangleCount_ ) VULKAN_HPP_NOEXCEPT
    {
      rectangleCount = rectangleCount_;
      return *this;
    }

    PresentRegionKHR & setPRectangles( const VULKAN_HPP_NAMESPACE::RectLayerKHR * pRectangles_ ) VULKAN_HPP_NOEXCEPT
    {
      pRectangles = pRectangles_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    PresentRegionKHR & setRectangles(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::RectLayerKHR> const & rectangles_ )
      VULKAN_HPP_NOEXCEPT
    {
      rectangleCount = static_cast<uint32_t>( rectangles_.size() );
      pRectangles    = rectangles_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkPresentRegionKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPresentRegionKHR *>( this );
    }

    operator VkPresentRegionKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPresentRegionKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PresentRegionKHR const & ) const = default;
#else
    bool operator==( PresentRegionKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( rectangleCount == rhs.rectangleCount ) && ( pRectangles == rhs.pRectangles );
    }

    bool operator!=( PresentRegionKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    uint32_t                                   rectangleCount = {};
    const VULKAN_HPP_NAMESPACE::RectLayerKHR * pRectangles    = {};
  };
  static_assert( sizeof( PresentRegionKHR ) == sizeof( VkPresentRegionKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PresentRegionKHR>::value, "struct wrapper is not a standard layout!" );

  struct PresentRegionsKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::ePresentRegionsKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      PresentRegionsKHR( uint32_t                                       swapchainCount_ = {},
                         const VULKAN_HPP_NAMESPACE::PresentRegionKHR * pRegions_       = {} ) VULKAN_HPP_NOEXCEPT
      : swapchainCount( swapchainCount_ )
      , pRegions( pRegions_ )
    {}

    VULKAN_HPP_CONSTEXPR PresentRegionsKHR( PresentRegionsKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PresentRegionsKHR( VkPresentRegionsKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : PresentRegionsKHR( *reinterpret_cast<PresentRegionsKHR const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    PresentRegionsKHR(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::PresentRegionKHR> const & regions_ )
      : swapchainCount( static_cast<uint32_t>( regions_.size() ) ), pRegions( regions_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PresentRegionsKHR &
                            operator=( PresentRegionsKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PresentRegionsKHR & operator=( VkPresentRegionsKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PresentRegionsKHR const *>( &rhs );
      return *this;
    }

    PresentRegionsKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PresentRegionsKHR & setSwapchainCount( uint32_t swapchainCount_ ) VULKAN_HPP_NOEXCEPT
    {
      swapchainCount = swapchainCount_;
      return *this;
    }

    PresentRegionsKHR & setPRegions( const VULKAN_HPP_NAMESPACE::PresentRegionKHR * pRegions_ ) VULKAN_HPP_NOEXCEPT
    {
      pRegions = pRegions_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    PresentRegionsKHR & setRegions(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::PresentRegionKHR> const & regions_ )
      VULKAN_HPP_NOEXCEPT
    {
      swapchainCount = static_cast<uint32_t>( regions_.size() );
      pRegions       = regions_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkPresentRegionsKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPresentRegionsKHR *>( this );
    }

    operator VkPresentRegionsKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPresentRegionsKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PresentRegionsKHR const & ) const = default;
#else
    bool operator==( PresentRegionsKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( swapchainCount == rhs.swapchainCount ) &&
             ( pRegions == rhs.pRegions );
    }

    bool operator!=( PresentRegionsKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType            sType          = StructureType::ePresentRegionsKHR;
    const void *                                   pNext          = {};
    uint32_t                                       swapchainCount = {};
    const VULKAN_HPP_NAMESPACE::PresentRegionKHR * pRegions       = {};
  };
  static_assert( sizeof( PresentRegionsKHR ) == sizeof( VkPresentRegionsKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PresentRegionsKHR>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePresentRegionsKHR>
  {
    using Type = PresentRegionsKHR;
  };

  struct PresentTimeGOOGLE
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PresentTimeGOOGLE( uint32_t presentID_          = {},
                                            uint64_t desiredPresentTime_ = {} ) VULKAN_HPP_NOEXCEPT
      : presentID( presentID_ )
      , desiredPresentTime( desiredPresentTime_ )
    {}

    VULKAN_HPP_CONSTEXPR PresentTimeGOOGLE( PresentTimeGOOGLE const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PresentTimeGOOGLE( VkPresentTimeGOOGLE const & rhs ) VULKAN_HPP_NOEXCEPT
      : PresentTimeGOOGLE( *reinterpret_cast<PresentTimeGOOGLE const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PresentTimeGOOGLE &
                            operator=( PresentTimeGOOGLE const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PresentTimeGOOGLE & operator=( VkPresentTimeGOOGLE const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PresentTimeGOOGLE const *>( &rhs );
      return *this;
    }

    PresentTimeGOOGLE & setPresentID( uint32_t presentID_ ) VULKAN_HPP_NOEXCEPT
    {
      presentID = presentID_;
      return *this;
    }

    PresentTimeGOOGLE & setDesiredPresentTime( uint64_t desiredPresentTime_ ) VULKAN_HPP_NOEXCEPT
    {
      desiredPresentTime = desiredPresentTime_;
      return *this;
    }

    operator VkPresentTimeGOOGLE const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPresentTimeGOOGLE *>( this );
    }

    operator VkPresentTimeGOOGLE &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPresentTimeGOOGLE *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PresentTimeGOOGLE const & ) const = default;
#else
    bool operator==( PresentTimeGOOGLE const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( presentID == rhs.presentID ) && ( desiredPresentTime == rhs.desiredPresentTime );
    }

    bool operator!=( PresentTimeGOOGLE const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    uint32_t presentID          = {};
    uint64_t desiredPresentTime = {};
  };
  static_assert( sizeof( PresentTimeGOOGLE ) == sizeof( VkPresentTimeGOOGLE ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PresentTimeGOOGLE>::value, "struct wrapper is not a standard layout!" );

  struct PresentTimesInfoGOOGLE
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::ePresentTimesInfoGOOGLE;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      PresentTimesInfoGOOGLE( uint32_t                                        swapchainCount_ = {},
                              const VULKAN_HPP_NAMESPACE::PresentTimeGOOGLE * pTimes_         = {} ) VULKAN_HPP_NOEXCEPT
      : swapchainCount( swapchainCount_ )
      , pTimes( pTimes_ )
    {}

    VULKAN_HPP_CONSTEXPR PresentTimesInfoGOOGLE( PresentTimesInfoGOOGLE const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PresentTimesInfoGOOGLE( VkPresentTimesInfoGOOGLE const & rhs ) VULKAN_HPP_NOEXCEPT
      : PresentTimesInfoGOOGLE( *reinterpret_cast<PresentTimesInfoGOOGLE const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    PresentTimesInfoGOOGLE(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::PresentTimeGOOGLE> const & times_ )
      : swapchainCount( static_cast<uint32_t>( times_.size() ) ), pTimes( times_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PresentTimesInfoGOOGLE &
                            operator=( PresentTimesInfoGOOGLE const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PresentTimesInfoGOOGLE & operator=( VkPresentTimesInfoGOOGLE const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PresentTimesInfoGOOGLE const *>( &rhs );
      return *this;
    }

    PresentTimesInfoGOOGLE & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PresentTimesInfoGOOGLE & setSwapchainCount( uint32_t swapchainCount_ ) VULKAN_HPP_NOEXCEPT
    {
      swapchainCount = swapchainCount_;
      return *this;
    }

    PresentTimesInfoGOOGLE & setPTimes( const VULKAN_HPP_NAMESPACE::PresentTimeGOOGLE * pTimes_ ) VULKAN_HPP_NOEXCEPT
    {
      pTimes = pTimes_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    PresentTimesInfoGOOGLE & setTimes(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::PresentTimeGOOGLE> const & times_ )
      VULKAN_HPP_NOEXCEPT
    {
      swapchainCount = static_cast<uint32_t>( times_.size() );
      pTimes         = times_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkPresentTimesInfoGOOGLE const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPresentTimesInfoGOOGLE *>( this );
    }

    operator VkPresentTimesInfoGOOGLE &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPresentTimesInfoGOOGLE *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PresentTimesInfoGOOGLE const & ) const = default;
#else
    bool operator==( PresentTimesInfoGOOGLE const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( swapchainCount == rhs.swapchainCount ) &&
             ( pTimes == rhs.pTimes );
    }

    bool operator!=( PresentTimesInfoGOOGLE const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType             sType          = StructureType::ePresentTimesInfoGOOGLE;
    const void *                                    pNext          = {};
    uint32_t                                        swapchainCount = {};
    const VULKAN_HPP_NAMESPACE::PresentTimeGOOGLE * pTimes         = {};
  };
  static_assert( sizeof( PresentTimesInfoGOOGLE ) == sizeof( VkPresentTimesInfoGOOGLE ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PresentTimesInfoGOOGLE>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePresentTimesInfoGOOGLE>
  {
    using Type = PresentTimesInfoGOOGLE;
  };

  struct PrivateDataSlotCreateInfoEXT
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::ePrivateDataSlotCreateInfoEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR PrivateDataSlotCreateInfoEXT( VULKAN_HPP_NAMESPACE::PrivateDataSlotCreateFlagsEXT flags_ = {} )
      VULKAN_HPP_NOEXCEPT : flags( flags_ )
    {}

    VULKAN_HPP_CONSTEXPR
      PrivateDataSlotCreateInfoEXT( PrivateDataSlotCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PrivateDataSlotCreateInfoEXT( VkPrivateDataSlotCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : PrivateDataSlotCreateInfoEXT( *reinterpret_cast<PrivateDataSlotCreateInfoEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 PrivateDataSlotCreateInfoEXT &
                            operator=( PrivateDataSlotCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    PrivateDataSlotCreateInfoEXT & operator=( VkPrivateDataSlotCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::PrivateDataSlotCreateInfoEXT const *>( &rhs );
      return *this;
    }

    PrivateDataSlotCreateInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    PrivateDataSlotCreateInfoEXT &
      setFlags( VULKAN_HPP_NAMESPACE::PrivateDataSlotCreateFlagsEXT flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    operator VkPrivateDataSlotCreateInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkPrivateDataSlotCreateInfoEXT *>( this );
    }

    operator VkPrivateDataSlotCreateInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkPrivateDataSlotCreateInfoEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( PrivateDataSlotCreateInfoEXT const & ) const = default;
#else
    bool operator==( PrivateDataSlotCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags );
    }

    bool operator!=( PrivateDataSlotCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                 sType = StructureType::ePrivateDataSlotCreateInfoEXT;
    const void *                                        pNext = {};
    VULKAN_HPP_NAMESPACE::PrivateDataSlotCreateFlagsEXT flags = {};
  };
  static_assert( sizeof( PrivateDataSlotCreateInfoEXT ) == sizeof( VkPrivateDataSlotCreateInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<PrivateDataSlotCreateInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::ePrivateDataSlotCreateInfoEXT>
  {
    using Type = PrivateDataSlotCreateInfoEXT;
  };

  struct ProtectedSubmitInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eProtectedSubmitInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ProtectedSubmitInfo( VULKAN_HPP_NAMESPACE::Bool32 protectedSubmit_ = {} ) VULKAN_HPP_NOEXCEPT
      : protectedSubmit( protectedSubmit_ )
    {}

    VULKAN_HPP_CONSTEXPR ProtectedSubmitInfo( ProtectedSubmitInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ProtectedSubmitInfo( VkProtectedSubmitInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : ProtectedSubmitInfo( *reinterpret_cast<ProtectedSubmitInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ProtectedSubmitInfo &
                            operator=( ProtectedSubmitInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ProtectedSubmitInfo & operator=( VkProtectedSubmitInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ProtectedSubmitInfo const *>( &rhs );
      return *this;
    }

    ProtectedSubmitInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ProtectedSubmitInfo & setProtectedSubmit( VULKAN_HPP_NAMESPACE::Bool32 protectedSubmit_ ) VULKAN_HPP_NOEXCEPT
    {
      protectedSubmit = protectedSubmit_;
      return *this;
    }

    operator VkProtectedSubmitInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkProtectedSubmitInfo *>( this );
    }

    operator VkProtectedSubmitInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkProtectedSubmitInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ProtectedSubmitInfo const & ) const = default;
#else
    bool operator==( ProtectedSubmitInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( protectedSubmit == rhs.protectedSubmit );
    }

    bool operator!=( ProtectedSubmitInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType           = StructureType::eProtectedSubmitInfo;
    const void *                        pNext           = {};
    VULKAN_HPP_NAMESPACE::Bool32        protectedSubmit = {};
  };
  static_assert( sizeof( ProtectedSubmitInfo ) == sizeof( VkProtectedSubmitInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ProtectedSubmitInfo>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eProtectedSubmitInfo>
  {
    using Type = ProtectedSubmitInfo;
  };

  struct QueryPoolCreateInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eQueryPoolCreateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR QueryPoolCreateInfo(
      VULKAN_HPP_NAMESPACE::QueryPoolCreateFlags        flags_      = {},
      VULKAN_HPP_NAMESPACE::QueryType                   queryType_  = VULKAN_HPP_NAMESPACE::QueryType::eOcclusion,
      uint32_t                                          queryCount_ = {},
      VULKAN_HPP_NAMESPACE::QueryPipelineStatisticFlags pipelineStatistics_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , queryType( queryType_ )
      , queryCount( queryCount_ )
      , pipelineStatistics( pipelineStatistics_ )
    {}

    VULKAN_HPP_CONSTEXPR QueryPoolCreateInfo( QueryPoolCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    QueryPoolCreateInfo( VkQueryPoolCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : QueryPoolCreateInfo( *reinterpret_cast<QueryPoolCreateInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 QueryPoolCreateInfo &
                            operator=( QueryPoolCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    QueryPoolCreateInfo & operator=( VkQueryPoolCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::QueryPoolCreateInfo const *>( &rhs );
      return *this;
    }

    QueryPoolCreateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    QueryPoolCreateInfo & setFlags( VULKAN_HPP_NAMESPACE::QueryPoolCreateFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    QueryPoolCreateInfo & setQueryType( VULKAN_HPP_NAMESPACE::QueryType queryType_ ) VULKAN_HPP_NOEXCEPT
    {
      queryType = queryType_;
      return *this;
    }

    QueryPoolCreateInfo & setQueryCount( uint32_t queryCount_ ) VULKAN_HPP_NOEXCEPT
    {
      queryCount = queryCount_;
      return *this;
    }

    QueryPoolCreateInfo &
      setPipelineStatistics( VULKAN_HPP_NAMESPACE::QueryPipelineStatisticFlags pipelineStatistics_ ) VULKAN_HPP_NOEXCEPT
    {
      pipelineStatistics = pipelineStatistics_;
      return *this;
    }

    operator VkQueryPoolCreateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkQueryPoolCreateInfo *>( this );
    }

    operator VkQueryPoolCreateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkQueryPoolCreateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( QueryPoolCreateInfo const & ) const = default;
#else
    bool operator==( QueryPoolCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( queryType == rhs.queryType ) && ( queryCount == rhs.queryCount ) &&
             ( pipelineStatistics == rhs.pipelineStatistics );
    }

    bool operator!=( QueryPoolCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType               sType              = StructureType::eQueryPoolCreateInfo;
    const void *                                      pNext              = {};
    VULKAN_HPP_NAMESPACE::QueryPoolCreateFlags        flags              = {};
    VULKAN_HPP_NAMESPACE::QueryType                   queryType          = VULKAN_HPP_NAMESPACE::QueryType::eOcclusion;
    uint32_t                                          queryCount         = {};
    VULKAN_HPP_NAMESPACE::QueryPipelineStatisticFlags pipelineStatistics = {};
  };
  static_assert( sizeof( QueryPoolCreateInfo ) == sizeof( VkQueryPoolCreateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<QueryPoolCreateInfo>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eQueryPoolCreateInfo>
  {
    using Type = QueryPoolCreateInfo;
  };

  struct QueryPoolPerformanceCreateInfoKHR
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eQueryPoolPerformanceCreateInfoKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR QueryPoolPerformanceCreateInfoKHR( uint32_t         queueFamilyIndex_  = {},
                                                            uint32_t         counterIndexCount_ = {},
                                                            const uint32_t * pCounterIndices_ = {} ) VULKAN_HPP_NOEXCEPT
      : queueFamilyIndex( queueFamilyIndex_ )
      , counterIndexCount( counterIndexCount_ )
      , pCounterIndices( pCounterIndices_ )
    {}

    VULKAN_HPP_CONSTEXPR
      QueryPoolPerformanceCreateInfoKHR( QueryPoolPerformanceCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    QueryPoolPerformanceCreateInfoKHR( VkQueryPoolPerformanceCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : QueryPoolPerformanceCreateInfoKHR( *reinterpret_cast<QueryPoolPerformanceCreateInfoKHR const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    QueryPoolPerformanceCreateInfoKHR(
      uint32_t                                                              queueFamilyIndex_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const & counterIndices_ )
      : queueFamilyIndex( queueFamilyIndex_ )
      , counterIndexCount( static_cast<uint32_t>( counterIndices_.size() ) )
      , pCounterIndices( counterIndices_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 QueryPoolPerformanceCreateInfoKHR &
                            operator=( QueryPoolPerformanceCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    QueryPoolPerformanceCreateInfoKHR & operator=( VkQueryPoolPerformanceCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::QueryPoolPerformanceCreateInfoKHR const *>( &rhs );
      return *this;
    }

    QueryPoolPerformanceCreateInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    QueryPoolPerformanceCreateInfoKHR & setQueueFamilyIndex( uint32_t queueFamilyIndex_ ) VULKAN_HPP_NOEXCEPT
    {
      queueFamilyIndex = queueFamilyIndex_;
      return *this;
    }

    QueryPoolPerformanceCreateInfoKHR & setCounterIndexCount( uint32_t counterIndexCount_ ) VULKAN_HPP_NOEXCEPT
    {
      counterIndexCount = counterIndexCount_;
      return *this;
    }

    QueryPoolPerformanceCreateInfoKHR & setPCounterIndices( const uint32_t * pCounterIndices_ ) VULKAN_HPP_NOEXCEPT
    {
      pCounterIndices = pCounterIndices_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    QueryPoolPerformanceCreateInfoKHR & setCounterIndices(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const & counterIndices_ ) VULKAN_HPP_NOEXCEPT
    {
      counterIndexCount = static_cast<uint32_t>( counterIndices_.size() );
      pCounterIndices   = counterIndices_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkQueryPoolPerformanceCreateInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkQueryPoolPerformanceCreateInfoKHR *>( this );
    }

    operator VkQueryPoolPerformanceCreateInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkQueryPoolPerformanceCreateInfoKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( QueryPoolPerformanceCreateInfoKHR const & ) const = default;
#else
    bool operator==( QueryPoolPerformanceCreateInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( queueFamilyIndex == rhs.queueFamilyIndex ) &&
             ( counterIndexCount == rhs.counterIndexCount ) && ( pCounterIndices == rhs.pCounterIndices );
    }

    bool operator!=( QueryPoolPerformanceCreateInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType             = StructureType::eQueryPoolPerformanceCreateInfoKHR;
    const void *                        pNext             = {};
    uint32_t                            queueFamilyIndex  = {};
    uint32_t                            counterIndexCount = {};
    const uint32_t *                    pCounterIndices   = {};
  };
  static_assert( sizeof( QueryPoolPerformanceCreateInfoKHR ) == sizeof( VkQueryPoolPerformanceCreateInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<QueryPoolPerformanceCreateInfoKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eQueryPoolPerformanceCreateInfoKHR>
  {
    using Type = QueryPoolPerformanceCreateInfoKHR;
  };

  struct QueryPoolPerformanceQueryCreateInfoINTEL
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eQueryPoolPerformanceQueryCreateInfoINTEL;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR QueryPoolPerformanceQueryCreateInfoINTEL(
      VULKAN_HPP_NAMESPACE::QueryPoolSamplingModeINTEL performanceCountersSampling_ =
        VULKAN_HPP_NAMESPACE::QueryPoolSamplingModeINTEL::eManual ) VULKAN_HPP_NOEXCEPT
      : performanceCountersSampling( performanceCountersSampling_ )
    {}

    VULKAN_HPP_CONSTEXPR QueryPoolPerformanceQueryCreateInfoINTEL(
      QueryPoolPerformanceQueryCreateInfoINTEL const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    QueryPoolPerformanceQueryCreateInfoINTEL( VkQueryPoolPerformanceQueryCreateInfoINTEL const & rhs )
      VULKAN_HPP_NOEXCEPT
      : QueryPoolPerformanceQueryCreateInfoINTEL(
          *reinterpret_cast<QueryPoolPerformanceQueryCreateInfoINTEL const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 QueryPoolPerformanceQueryCreateInfoINTEL &
                            operator=( QueryPoolPerformanceQueryCreateInfoINTEL const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    QueryPoolPerformanceQueryCreateInfoINTEL &
      operator=( VkQueryPoolPerformanceQueryCreateInfoINTEL const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::QueryPoolPerformanceQueryCreateInfoINTEL const *>( &rhs );
      return *this;
    }

    QueryPoolPerformanceQueryCreateInfoINTEL & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    QueryPoolPerformanceQueryCreateInfoINTEL & setPerformanceCountersSampling(
      VULKAN_HPP_NAMESPACE::QueryPoolSamplingModeINTEL performanceCountersSampling_ ) VULKAN_HPP_NOEXCEPT
    {
      performanceCountersSampling = performanceCountersSampling_;
      return *this;
    }

    operator VkQueryPoolPerformanceQueryCreateInfoINTEL const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkQueryPoolPerformanceQueryCreateInfoINTEL *>( this );
    }

    operator VkQueryPoolPerformanceQueryCreateInfoINTEL &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkQueryPoolPerformanceQueryCreateInfoINTEL *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( QueryPoolPerformanceQueryCreateInfoINTEL const & ) const = default;
#else
    bool operator==( QueryPoolPerformanceQueryCreateInfoINTEL const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( performanceCountersSampling == rhs.performanceCountersSampling );
    }

    bool operator!=( QueryPoolPerformanceQueryCreateInfoINTEL const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType              sType = StructureType::eQueryPoolPerformanceQueryCreateInfoINTEL;
    const void *                                     pNext = {};
    VULKAN_HPP_NAMESPACE::QueryPoolSamplingModeINTEL performanceCountersSampling =
      VULKAN_HPP_NAMESPACE::QueryPoolSamplingModeINTEL::eManual;
  };
  static_assert( sizeof( QueryPoolPerformanceQueryCreateInfoINTEL ) ==
                   sizeof( VkQueryPoolPerformanceQueryCreateInfoINTEL ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<QueryPoolPerformanceQueryCreateInfoINTEL>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eQueryPoolPerformanceQueryCreateInfoINTEL>
  {
    using Type = QueryPoolPerformanceQueryCreateInfoINTEL;
  };
  using QueryPoolCreateInfoINTEL = QueryPoolPerformanceQueryCreateInfoINTEL;

  struct QueueFamilyCheckpointProperties2NV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eQueueFamilyCheckpointProperties2NV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR QueueFamilyCheckpointProperties2NV(
      VULKAN_HPP_NAMESPACE::PipelineStageFlags2KHR checkpointExecutionStageMask_ = {} ) VULKAN_HPP_NOEXCEPT
      : checkpointExecutionStageMask( checkpointExecutionStageMask_ )
    {}

    VULKAN_HPP_CONSTEXPR QueueFamilyCheckpointProperties2NV( QueueFamilyCheckpointProperties2NV const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    QueueFamilyCheckpointProperties2NV( VkQueueFamilyCheckpointProperties2NV const & rhs ) VULKAN_HPP_NOEXCEPT
      : QueueFamilyCheckpointProperties2NV( *reinterpret_cast<QueueFamilyCheckpointProperties2NV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 QueueFamilyCheckpointProperties2NV &
                            operator=( QueueFamilyCheckpointProperties2NV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    QueueFamilyCheckpointProperties2NV &
      operator=( VkQueueFamilyCheckpointProperties2NV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::QueueFamilyCheckpointProperties2NV const *>( &rhs );
      return *this;
    }

    operator VkQueueFamilyCheckpointProperties2NV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkQueueFamilyCheckpointProperties2NV *>( this );
    }

    operator VkQueueFamilyCheckpointProperties2NV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkQueueFamilyCheckpointProperties2NV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( QueueFamilyCheckpointProperties2NV const & ) const = default;
#else
    bool operator==( QueueFamilyCheckpointProperties2NV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( checkpointExecutionStageMask == rhs.checkpointExecutionStageMask );
    }

    bool operator!=( QueueFamilyCheckpointProperties2NV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType          sType = StructureType::eQueueFamilyCheckpointProperties2NV;
    void *                                       pNext = {};
    VULKAN_HPP_NAMESPACE::PipelineStageFlags2KHR checkpointExecutionStageMask = {};
  };
  static_assert( sizeof( QueueFamilyCheckpointProperties2NV ) == sizeof( VkQueueFamilyCheckpointProperties2NV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<QueueFamilyCheckpointProperties2NV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eQueueFamilyCheckpointProperties2NV>
  {
    using Type = QueueFamilyCheckpointProperties2NV;
  };

  struct QueueFamilyCheckpointPropertiesNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eQueueFamilyCheckpointPropertiesNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR QueueFamilyCheckpointPropertiesNV(
      VULKAN_HPP_NAMESPACE::PipelineStageFlags checkpointExecutionStageMask_ = {} ) VULKAN_HPP_NOEXCEPT
      : checkpointExecutionStageMask( checkpointExecutionStageMask_ )
    {}

    VULKAN_HPP_CONSTEXPR
      QueueFamilyCheckpointPropertiesNV( QueueFamilyCheckpointPropertiesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    QueueFamilyCheckpointPropertiesNV( VkQueueFamilyCheckpointPropertiesNV const & rhs ) VULKAN_HPP_NOEXCEPT
      : QueueFamilyCheckpointPropertiesNV( *reinterpret_cast<QueueFamilyCheckpointPropertiesNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 QueueFamilyCheckpointPropertiesNV &
                            operator=( QueueFamilyCheckpointPropertiesNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    QueueFamilyCheckpointPropertiesNV & operator=( VkQueueFamilyCheckpointPropertiesNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::QueueFamilyCheckpointPropertiesNV const *>( &rhs );
      return *this;
    }

    operator VkQueueFamilyCheckpointPropertiesNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkQueueFamilyCheckpointPropertiesNV *>( this );
    }

    operator VkQueueFamilyCheckpointPropertiesNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkQueueFamilyCheckpointPropertiesNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( QueueFamilyCheckpointPropertiesNV const & ) const = default;
#else
    bool operator==( QueueFamilyCheckpointPropertiesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( checkpointExecutionStageMask == rhs.checkpointExecutionStageMask );
    }

    bool operator!=( QueueFamilyCheckpointPropertiesNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType      sType = StructureType::eQueueFamilyCheckpointPropertiesNV;
    void *                                   pNext = {};
    VULKAN_HPP_NAMESPACE::PipelineStageFlags checkpointExecutionStageMask = {};
  };
  static_assert( sizeof( QueueFamilyCheckpointPropertiesNV ) == sizeof( VkQueueFamilyCheckpointPropertiesNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<QueueFamilyCheckpointPropertiesNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eQueueFamilyCheckpointPropertiesNV>
  {
    using Type = QueueFamilyCheckpointPropertiesNV;
  };

  struct QueueFamilyGlobalPriorityPropertiesEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eQueueFamilyGlobalPriorityPropertiesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR_14 QueueFamilyGlobalPriorityPropertiesEXT(
      uint32_t priorityCount_ = {},
      std::array<VULKAN_HPP_NAMESPACE::QueueGlobalPriorityEXT, VK_MAX_GLOBAL_PRIORITY_SIZE_EXT> const &
        priorities_ = { { VULKAN_HPP_NAMESPACE::QueueGlobalPriorityEXT::eLow,
                          VULKAN_HPP_NAMESPACE::QueueGlobalPriorityEXT::eLow,
                          VULKAN_HPP_NAMESPACE::QueueGlobalPriorityEXT::eLow,
                          VULKAN_HPP_NAMESPACE::QueueGlobalPriorityEXT::eLow,
                          VULKAN_HPP_NAMESPACE::QueueGlobalPriorityEXT::eLow,
                          VULKAN_HPP_NAMESPACE::QueueGlobalPriorityEXT::eLow,
                          VULKAN_HPP_NAMESPACE::QueueGlobalPriorityEXT::eLow,
                          VULKAN_HPP_NAMESPACE::QueueGlobalPriorityEXT::eLow,
                          VULKAN_HPP_NAMESPACE::QueueGlobalPriorityEXT::eLow,
                          VULKAN_HPP_NAMESPACE::QueueGlobalPriorityEXT::eLow,
                          VULKAN_HPP_NAMESPACE::QueueGlobalPriorityEXT::eLow,
                          VULKAN_HPP_NAMESPACE::QueueGlobalPriorityEXT::eLow,
                          VULKAN_HPP_NAMESPACE::QueueGlobalPriorityEXT::eLow,
                          VULKAN_HPP_NAMESPACE::QueueGlobalPriorityEXT::eLow,
                          VULKAN_HPP_NAMESPACE::QueueGlobalPriorityEXT::eLow,
                          VULKAN_HPP_NAMESPACE::QueueGlobalPriorityEXT::eLow } } ) VULKAN_HPP_NOEXCEPT
      : priorityCount( priorityCount_ )
      , priorities( priorities_ )
    {}

    VULKAN_HPP_CONSTEXPR_14 QueueFamilyGlobalPriorityPropertiesEXT( QueueFamilyGlobalPriorityPropertiesEXT const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    QueueFamilyGlobalPriorityPropertiesEXT( VkQueueFamilyGlobalPriorityPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : QueueFamilyGlobalPriorityPropertiesEXT(
          *reinterpret_cast<QueueFamilyGlobalPriorityPropertiesEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 QueueFamilyGlobalPriorityPropertiesEXT &
                            operator=( QueueFamilyGlobalPriorityPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    QueueFamilyGlobalPriorityPropertiesEXT &
      operator=( VkQueueFamilyGlobalPriorityPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::QueueFamilyGlobalPriorityPropertiesEXT const *>( &rhs );
      return *this;
    }

    QueueFamilyGlobalPriorityPropertiesEXT & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    QueueFamilyGlobalPriorityPropertiesEXT & setPriorityCount( uint32_t priorityCount_ ) VULKAN_HPP_NOEXCEPT
    {
      priorityCount = priorityCount_;
      return *this;
    }

    QueueFamilyGlobalPriorityPropertiesEXT & setPriorities(
      std::array<VULKAN_HPP_NAMESPACE::QueueGlobalPriorityEXT, VK_MAX_GLOBAL_PRIORITY_SIZE_EXT> priorities_ )
      VULKAN_HPP_NOEXCEPT
    {
      priorities = priorities_;
      return *this;
    }

    operator VkQueueFamilyGlobalPriorityPropertiesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkQueueFamilyGlobalPriorityPropertiesEXT *>( this );
    }

    operator VkQueueFamilyGlobalPriorityPropertiesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkQueueFamilyGlobalPriorityPropertiesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( QueueFamilyGlobalPriorityPropertiesEXT const & ) const = default;
#else
    bool operator==( QueueFamilyGlobalPriorityPropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( priorityCount == rhs.priorityCount ) &&
             ( priorities == rhs.priorities );
    }

    bool operator!=( QueueFamilyGlobalPriorityPropertiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType         = StructureType::eQueueFamilyGlobalPriorityPropertiesEXT;
    void *                              pNext         = {};
    uint32_t                            priorityCount = {};
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<VULKAN_HPP_NAMESPACE::QueueGlobalPriorityEXT, VK_MAX_GLOBAL_PRIORITY_SIZE_EXT>
      priorities = {};
  };
  static_assert( sizeof( QueueFamilyGlobalPriorityPropertiesEXT ) == sizeof( VkQueueFamilyGlobalPriorityPropertiesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<QueueFamilyGlobalPriorityPropertiesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eQueueFamilyGlobalPriorityPropertiesEXT>
  {
    using Type = QueueFamilyGlobalPriorityPropertiesEXT;
  };

  struct QueueFamilyProperties
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      QueueFamilyProperties( VULKAN_HPP_NAMESPACE::QueueFlags queueFlags_                  = {},
                             uint32_t                         queueCount_                  = {},
                             uint32_t                         timestampValidBits_          = {},
                             VULKAN_HPP_NAMESPACE::Extent3D   minImageTransferGranularity_ = {} ) VULKAN_HPP_NOEXCEPT
      : queueFlags( queueFlags_ )
      , queueCount( queueCount_ )
      , timestampValidBits( timestampValidBits_ )
      , minImageTransferGranularity( minImageTransferGranularity_ )
    {}

    VULKAN_HPP_CONSTEXPR QueueFamilyProperties( QueueFamilyProperties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    QueueFamilyProperties( VkQueueFamilyProperties const & rhs ) VULKAN_HPP_NOEXCEPT
      : QueueFamilyProperties( *reinterpret_cast<QueueFamilyProperties const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 QueueFamilyProperties &
                            operator=( QueueFamilyProperties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    QueueFamilyProperties & operator=( VkQueueFamilyProperties const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::QueueFamilyProperties const *>( &rhs );
      return *this;
    }

    operator VkQueueFamilyProperties const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkQueueFamilyProperties *>( this );
    }

    operator VkQueueFamilyProperties &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkQueueFamilyProperties *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( QueueFamilyProperties const & ) const = default;
#else
    bool operator==( QueueFamilyProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( queueFlags == rhs.queueFlags ) && ( queueCount == rhs.queueCount ) &&
             ( timestampValidBits == rhs.timestampValidBits ) &&
             ( minImageTransferGranularity == rhs.minImageTransferGranularity );
    }

    bool operator!=( QueueFamilyProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::QueueFlags queueFlags                  = {};
    uint32_t                         queueCount                  = {};
    uint32_t                         timestampValidBits          = {};
    VULKAN_HPP_NAMESPACE::Extent3D   minImageTransferGranularity = {};
  };
  static_assert( sizeof( QueueFamilyProperties ) == sizeof( VkQueueFamilyProperties ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<QueueFamilyProperties>::value, "struct wrapper is not a standard layout!" );

  struct QueueFamilyProperties2
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eQueueFamilyProperties2;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR QueueFamilyProperties2(
      VULKAN_HPP_NAMESPACE::QueueFamilyProperties queueFamilyProperties_ = {} ) VULKAN_HPP_NOEXCEPT
      : queueFamilyProperties( queueFamilyProperties_ )
    {}

    VULKAN_HPP_CONSTEXPR QueueFamilyProperties2( QueueFamilyProperties2 const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    QueueFamilyProperties2( VkQueueFamilyProperties2 const & rhs ) VULKAN_HPP_NOEXCEPT
      : QueueFamilyProperties2( *reinterpret_cast<QueueFamilyProperties2 const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 QueueFamilyProperties2 &
                            operator=( QueueFamilyProperties2 const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    QueueFamilyProperties2 & operator=( VkQueueFamilyProperties2 const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::QueueFamilyProperties2 const *>( &rhs );
      return *this;
    }

    operator VkQueueFamilyProperties2 const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkQueueFamilyProperties2 *>( this );
    }

    operator VkQueueFamilyProperties2 &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkQueueFamilyProperties2 *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( QueueFamilyProperties2 const & ) const = default;
#else
    bool operator==( QueueFamilyProperties2 const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( queueFamilyProperties == rhs.queueFamilyProperties );
    }

    bool operator!=( QueueFamilyProperties2 const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType         sType                 = StructureType::eQueueFamilyProperties2;
    void *                                      pNext                 = {};
    VULKAN_HPP_NAMESPACE::QueueFamilyProperties queueFamilyProperties = {};
  };
  static_assert( sizeof( QueueFamilyProperties2 ) == sizeof( VkQueueFamilyProperties2 ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<QueueFamilyProperties2>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eQueueFamilyProperties2>
  {
    using Type = QueueFamilyProperties2;
  };
  using QueueFamilyProperties2KHR = QueueFamilyProperties2;

  struct RayTracingShaderGroupCreateInfoKHR
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eRayTracingShaderGroupCreateInfoKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      RayTracingShaderGroupCreateInfoKHR( VULKAN_HPP_NAMESPACE::RayTracingShaderGroupTypeKHR type_ =
                                            VULKAN_HPP_NAMESPACE::RayTracingShaderGroupTypeKHR::eGeneral,
                                          uint32_t     generalShader_                   = {},
                                          uint32_t     closestHitShader_                = {},
                                          uint32_t     anyHitShader_                    = {},
                                          uint32_t     intersectionShader_              = {},
                                          const void * pShaderGroupCaptureReplayHandle_ = {} ) VULKAN_HPP_NOEXCEPT
      : type( type_ )
      , generalShader( generalShader_ )
      , closestHitShader( closestHitShader_ )
      , anyHitShader( anyHitShader_ )
      , intersectionShader( intersectionShader_ )
      , pShaderGroupCaptureReplayHandle( pShaderGroupCaptureReplayHandle_ )
    {}

    VULKAN_HPP_CONSTEXPR RayTracingShaderGroupCreateInfoKHR( RayTracingShaderGroupCreateInfoKHR const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    RayTracingShaderGroupCreateInfoKHR( VkRayTracingShaderGroupCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : RayTracingShaderGroupCreateInfoKHR( *reinterpret_cast<RayTracingShaderGroupCreateInfoKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 RayTracingShaderGroupCreateInfoKHR &
                            operator=( RayTracingShaderGroupCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    RayTracingShaderGroupCreateInfoKHR &
      operator=( VkRayTracingShaderGroupCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::RayTracingShaderGroupCreateInfoKHR const *>( &rhs );
      return *this;
    }

    RayTracingShaderGroupCreateInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    RayTracingShaderGroupCreateInfoKHR &
      setType( VULKAN_HPP_NAMESPACE::RayTracingShaderGroupTypeKHR type_ ) VULKAN_HPP_NOEXCEPT
    {
      type = type_;
      return *this;
    }

    RayTracingShaderGroupCreateInfoKHR & setGeneralShader( uint32_t generalShader_ ) VULKAN_HPP_NOEXCEPT
    {
      generalShader = generalShader_;
      return *this;
    }

    RayTracingShaderGroupCreateInfoKHR & setClosestHitShader( uint32_t closestHitShader_ ) VULKAN_HPP_NOEXCEPT
    {
      closestHitShader = closestHitShader_;
      return *this;
    }

    RayTracingShaderGroupCreateInfoKHR & setAnyHitShader( uint32_t anyHitShader_ ) VULKAN_HPP_NOEXCEPT
    {
      anyHitShader = anyHitShader_;
      return *this;
    }

    RayTracingShaderGroupCreateInfoKHR & setIntersectionShader( uint32_t intersectionShader_ ) VULKAN_HPP_NOEXCEPT
    {
      intersectionShader = intersectionShader_;
      return *this;
    }

    RayTracingShaderGroupCreateInfoKHR &
      setPShaderGroupCaptureReplayHandle( const void * pShaderGroupCaptureReplayHandle_ ) VULKAN_HPP_NOEXCEPT
    {
      pShaderGroupCaptureReplayHandle = pShaderGroupCaptureReplayHandle_;
      return *this;
    }

    operator VkRayTracingShaderGroupCreateInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkRayTracingShaderGroupCreateInfoKHR *>( this );
    }

    operator VkRayTracingShaderGroupCreateInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkRayTracingShaderGroupCreateInfoKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( RayTracingShaderGroupCreateInfoKHR const & ) const = default;
#else
    bool operator==( RayTracingShaderGroupCreateInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( type == rhs.type ) &&
             ( generalShader == rhs.generalShader ) && ( closestHitShader == rhs.closestHitShader ) &&
             ( anyHitShader == rhs.anyHitShader ) && ( intersectionShader == rhs.intersectionShader ) &&
             ( pShaderGroupCaptureReplayHandle == rhs.pShaderGroupCaptureReplayHandle );
    }

    bool operator!=( RayTracingShaderGroupCreateInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                sType = StructureType::eRayTracingShaderGroupCreateInfoKHR;
    const void *                                       pNext = {};
    VULKAN_HPP_NAMESPACE::RayTracingShaderGroupTypeKHR type =
      VULKAN_HPP_NAMESPACE::RayTracingShaderGroupTypeKHR::eGeneral;
    uint32_t     generalShader                   = {};
    uint32_t     closestHitShader                = {};
    uint32_t     anyHitShader                    = {};
    uint32_t     intersectionShader              = {};
    const void * pShaderGroupCaptureReplayHandle = {};
  };
  static_assert( sizeof( RayTracingShaderGroupCreateInfoKHR ) == sizeof( VkRayTracingShaderGroupCreateInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<RayTracingShaderGroupCreateInfoKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eRayTracingShaderGroupCreateInfoKHR>
  {
    using Type = RayTracingShaderGroupCreateInfoKHR;
  };

  struct RayTracingPipelineInterfaceCreateInfoKHR
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eRayTracingPipelineInterfaceCreateInfoKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      RayTracingPipelineInterfaceCreateInfoKHR( uint32_t maxPipelineRayPayloadSize_      = {},
                                                uint32_t maxPipelineRayHitAttributeSize_ = {} ) VULKAN_HPP_NOEXCEPT
      : maxPipelineRayPayloadSize( maxPipelineRayPayloadSize_ )
      , maxPipelineRayHitAttributeSize( maxPipelineRayHitAttributeSize_ )
    {}

    VULKAN_HPP_CONSTEXPR RayTracingPipelineInterfaceCreateInfoKHR(
      RayTracingPipelineInterfaceCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    RayTracingPipelineInterfaceCreateInfoKHR( VkRayTracingPipelineInterfaceCreateInfoKHR const & rhs )
      VULKAN_HPP_NOEXCEPT
      : RayTracingPipelineInterfaceCreateInfoKHR(
          *reinterpret_cast<RayTracingPipelineInterfaceCreateInfoKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 RayTracingPipelineInterfaceCreateInfoKHR &
                            operator=( RayTracingPipelineInterfaceCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    RayTracingPipelineInterfaceCreateInfoKHR &
      operator=( VkRayTracingPipelineInterfaceCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::RayTracingPipelineInterfaceCreateInfoKHR const *>( &rhs );
      return *this;
    }

    RayTracingPipelineInterfaceCreateInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    RayTracingPipelineInterfaceCreateInfoKHR &
      setMaxPipelineRayPayloadSize( uint32_t maxPipelineRayPayloadSize_ ) VULKAN_HPP_NOEXCEPT
    {
      maxPipelineRayPayloadSize = maxPipelineRayPayloadSize_;
      return *this;
    }

    RayTracingPipelineInterfaceCreateInfoKHR &
      setMaxPipelineRayHitAttributeSize( uint32_t maxPipelineRayHitAttributeSize_ ) VULKAN_HPP_NOEXCEPT
    {
      maxPipelineRayHitAttributeSize = maxPipelineRayHitAttributeSize_;
      return *this;
    }

    operator VkRayTracingPipelineInterfaceCreateInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkRayTracingPipelineInterfaceCreateInfoKHR *>( this );
    }

    operator VkRayTracingPipelineInterfaceCreateInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkRayTracingPipelineInterfaceCreateInfoKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( RayTracingPipelineInterfaceCreateInfoKHR const & ) const = default;
#else
    bool operator==( RayTracingPipelineInterfaceCreateInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( maxPipelineRayPayloadSize == rhs.maxPipelineRayPayloadSize ) &&
             ( maxPipelineRayHitAttributeSize == rhs.maxPipelineRayHitAttributeSize );
    }

    bool operator!=( RayTracingPipelineInterfaceCreateInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::eRayTracingPipelineInterfaceCreateInfoKHR;
    const void *                        pNext = {};
    uint32_t                            maxPipelineRayPayloadSize      = {};
    uint32_t                            maxPipelineRayHitAttributeSize = {};
  };
  static_assert( sizeof( RayTracingPipelineInterfaceCreateInfoKHR ) ==
                   sizeof( VkRayTracingPipelineInterfaceCreateInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<RayTracingPipelineInterfaceCreateInfoKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eRayTracingPipelineInterfaceCreateInfoKHR>
  {
    using Type = RayTracingPipelineInterfaceCreateInfoKHR;
  };

  struct RayTracingPipelineCreateInfoKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eRayTracingPipelineCreateInfoKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR RayTracingPipelineCreateInfoKHR(
      VULKAN_HPP_NAMESPACE::PipelineCreateFlags                              flags_                        = {},
      uint32_t                                                               stageCount_                   = {},
      const VULKAN_HPP_NAMESPACE::PipelineShaderStageCreateInfo *            pStages_                      = {},
      uint32_t                                                               groupCount_                   = {},
      const VULKAN_HPP_NAMESPACE::RayTracingShaderGroupCreateInfoKHR *       pGroups_                      = {},
      uint32_t                                                               maxPipelineRayRecursionDepth_ = {},
      const VULKAN_HPP_NAMESPACE::PipelineLibraryCreateInfoKHR *             pLibraryInfo_                 = {},
      const VULKAN_HPP_NAMESPACE::RayTracingPipelineInterfaceCreateInfoKHR * pLibraryInterface_            = {},
      const VULKAN_HPP_NAMESPACE::PipelineDynamicStateCreateInfo *           pDynamicState_                = {},
      VULKAN_HPP_NAMESPACE::PipelineLayout                                   layout_                       = {},
      VULKAN_HPP_NAMESPACE::Pipeline                                         basePipelineHandle_           = {},
      int32_t basePipelineIndex_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , stageCount( stageCount_ )
      , pStages( pStages_ )
      , groupCount( groupCount_ )
      , pGroups( pGroups_ )
      , maxPipelineRayRecursionDepth( maxPipelineRayRecursionDepth_ )
      , pLibraryInfo( pLibraryInfo_ )
      , pLibraryInterface( pLibraryInterface_ )
      , pDynamicState( pDynamicState_ )
      , layout( layout_ )
      , basePipelineHandle( basePipelineHandle_ )
      , basePipelineIndex( basePipelineIndex_ )
    {}

    VULKAN_HPP_CONSTEXPR
      RayTracingPipelineCreateInfoKHR( RayTracingPipelineCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    RayTracingPipelineCreateInfoKHR( VkRayTracingPipelineCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : RayTracingPipelineCreateInfoKHR( *reinterpret_cast<RayTracingPipelineCreateInfoKHR const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    RayTracingPipelineCreateInfoKHR(
      VULKAN_HPP_NAMESPACE::PipelineCreateFlags flags_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::PipelineShaderStageCreateInfo> const &
        stages_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<
        const VULKAN_HPP_NAMESPACE::RayTracingShaderGroupCreateInfoKHR> const & groups_                       = {},
      uint32_t                                                                  maxPipelineRayRecursionDepth_ = {},
      const VULKAN_HPP_NAMESPACE::PipelineLibraryCreateInfoKHR *                pLibraryInfo_                 = {},
      const VULKAN_HPP_NAMESPACE::RayTracingPipelineInterfaceCreateInfoKHR *    pLibraryInterface_            = {},
      const VULKAN_HPP_NAMESPACE::PipelineDynamicStateCreateInfo *              pDynamicState_                = {},
      VULKAN_HPP_NAMESPACE::PipelineLayout                                      layout_                       = {},
      VULKAN_HPP_NAMESPACE::Pipeline                                            basePipelineHandle_           = {},
      int32_t                                                                   basePipelineIndex_            = {} )
      : flags( flags_ )
      , stageCount( static_cast<uint32_t>( stages_.size() ) )
      , pStages( stages_.data() )
      , groupCount( static_cast<uint32_t>( groups_.size() ) )
      , pGroups( groups_.data() )
      , maxPipelineRayRecursionDepth( maxPipelineRayRecursionDepth_ )
      , pLibraryInfo( pLibraryInfo_ )
      , pLibraryInterface( pLibraryInterface_ )
      , pDynamicState( pDynamicState_ )
      , layout( layout_ )
      , basePipelineHandle( basePipelineHandle_ )
      , basePipelineIndex( basePipelineIndex_ )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 RayTracingPipelineCreateInfoKHR &
                            operator=( RayTracingPipelineCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    RayTracingPipelineCreateInfoKHR & operator=( VkRayTracingPipelineCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::RayTracingPipelineCreateInfoKHR const *>( &rhs );
      return *this;
    }

    RayTracingPipelineCreateInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    RayTracingPipelineCreateInfoKHR & setFlags( VULKAN_HPP_NAMESPACE::PipelineCreateFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    RayTracingPipelineCreateInfoKHR & setStageCount( uint32_t stageCount_ ) VULKAN_HPP_NOEXCEPT
    {
      stageCount = stageCount_;
      return *this;
    }

    RayTracingPipelineCreateInfoKHR &
      setPStages( const VULKAN_HPP_NAMESPACE::PipelineShaderStageCreateInfo * pStages_ ) VULKAN_HPP_NOEXCEPT
    {
      pStages = pStages_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    RayTracingPipelineCreateInfoKHR & setStages(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::PipelineShaderStageCreateInfo> const &
        stages_ ) VULKAN_HPP_NOEXCEPT
    {
      stageCount = static_cast<uint32_t>( stages_.size() );
      pStages    = stages_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    RayTracingPipelineCreateInfoKHR & setGroupCount( uint32_t groupCount_ ) VULKAN_HPP_NOEXCEPT
    {
      groupCount = groupCount_;
      return *this;
    }

    RayTracingPipelineCreateInfoKHR &
      setPGroups( const VULKAN_HPP_NAMESPACE::RayTracingShaderGroupCreateInfoKHR * pGroups_ ) VULKAN_HPP_NOEXCEPT
    {
      pGroups = pGroups_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    RayTracingPipelineCreateInfoKHR &
      setGroups( VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<
                 const VULKAN_HPP_NAMESPACE::RayTracingShaderGroupCreateInfoKHR> const & groups_ ) VULKAN_HPP_NOEXCEPT
    {
      groupCount = static_cast<uint32_t>( groups_.size() );
      pGroups    = groups_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    RayTracingPipelineCreateInfoKHR &
      setMaxPipelineRayRecursionDepth( uint32_t maxPipelineRayRecursionDepth_ ) VULKAN_HPP_NOEXCEPT
    {
      maxPipelineRayRecursionDepth = maxPipelineRayRecursionDepth_;
      return *this;
    }

    RayTracingPipelineCreateInfoKHR &
      setPLibraryInfo( const VULKAN_HPP_NAMESPACE::PipelineLibraryCreateInfoKHR * pLibraryInfo_ ) VULKAN_HPP_NOEXCEPT
    {
      pLibraryInfo = pLibraryInfo_;
      return *this;
    }

    RayTracingPipelineCreateInfoKHR & setPLibraryInterface(
      const VULKAN_HPP_NAMESPACE::RayTracingPipelineInterfaceCreateInfoKHR * pLibraryInterface_ ) VULKAN_HPP_NOEXCEPT
    {
      pLibraryInterface = pLibraryInterface_;
      return *this;
    }

    RayTracingPipelineCreateInfoKHR & setPDynamicState(
      const VULKAN_HPP_NAMESPACE::PipelineDynamicStateCreateInfo * pDynamicState_ ) VULKAN_HPP_NOEXCEPT
    {
      pDynamicState = pDynamicState_;
      return *this;
    }

    RayTracingPipelineCreateInfoKHR & setLayout( VULKAN_HPP_NAMESPACE::PipelineLayout layout_ ) VULKAN_HPP_NOEXCEPT
    {
      layout = layout_;
      return *this;
    }

    RayTracingPipelineCreateInfoKHR &
      setBasePipelineHandle( VULKAN_HPP_NAMESPACE::Pipeline basePipelineHandle_ ) VULKAN_HPP_NOEXCEPT
    {
      basePipelineHandle = basePipelineHandle_;
      return *this;
    }

    RayTracingPipelineCreateInfoKHR & setBasePipelineIndex( int32_t basePipelineIndex_ ) VULKAN_HPP_NOEXCEPT
    {
      basePipelineIndex = basePipelineIndex_;
      return *this;
    }

    operator VkRayTracingPipelineCreateInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkRayTracingPipelineCreateInfoKHR *>( this );
    }

    operator VkRayTracingPipelineCreateInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkRayTracingPipelineCreateInfoKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( RayTracingPipelineCreateInfoKHR const & ) const = default;
#else
    bool operator==( RayTracingPipelineCreateInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( stageCount == rhs.stageCount ) && ( pStages == rhs.pStages ) && ( groupCount == rhs.groupCount ) &&
             ( pGroups == rhs.pGroups ) && ( maxPipelineRayRecursionDepth == rhs.maxPipelineRayRecursionDepth ) &&
             ( pLibraryInfo == rhs.pLibraryInfo ) && ( pLibraryInterface == rhs.pLibraryInterface ) &&
             ( pDynamicState == rhs.pDynamicState ) && ( layout == rhs.layout ) &&
             ( basePipelineHandle == rhs.basePipelineHandle ) && ( basePipelineIndex == rhs.basePipelineIndex );
    }

    bool operator!=( RayTracingPipelineCreateInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                         sType = StructureType::eRayTracingPipelineCreateInfoKHR;
    const void *                                                pNext = {};
    VULKAN_HPP_NAMESPACE::PipelineCreateFlags                   flags = {};
    uint32_t                                                    stageCount                              = {};
    const VULKAN_HPP_NAMESPACE::PipelineShaderStageCreateInfo * pStages                                 = {};
    uint32_t                                                    groupCount                              = {};
    const VULKAN_HPP_NAMESPACE::RayTracingShaderGroupCreateInfoKHR *       pGroups                      = {};
    uint32_t                                                               maxPipelineRayRecursionDepth = {};
    const VULKAN_HPP_NAMESPACE::PipelineLibraryCreateInfoKHR *             pLibraryInfo                 = {};
    const VULKAN_HPP_NAMESPACE::RayTracingPipelineInterfaceCreateInfoKHR * pLibraryInterface            = {};
    const VULKAN_HPP_NAMESPACE::PipelineDynamicStateCreateInfo *           pDynamicState                = {};
    VULKAN_HPP_NAMESPACE::PipelineLayout                                   layout                       = {};
    VULKAN_HPP_NAMESPACE::Pipeline                                         basePipelineHandle           = {};
    int32_t                                                                basePipelineIndex            = {};
  };
  static_assert( sizeof( RayTracingPipelineCreateInfoKHR ) == sizeof( VkRayTracingPipelineCreateInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<RayTracingPipelineCreateInfoKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eRayTracingPipelineCreateInfoKHR>
  {
    using Type = RayTracingPipelineCreateInfoKHR;
  };

  struct RayTracingShaderGroupCreateInfoNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eRayTracingShaderGroupCreateInfoNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      RayTracingShaderGroupCreateInfoNV( VULKAN_HPP_NAMESPACE::RayTracingShaderGroupTypeKHR type_ =
                                           VULKAN_HPP_NAMESPACE::RayTracingShaderGroupTypeKHR::eGeneral,
                                         uint32_t generalShader_      = {},
                                         uint32_t closestHitShader_   = {},
                                         uint32_t anyHitShader_       = {},
                                         uint32_t intersectionShader_ = {} ) VULKAN_HPP_NOEXCEPT
      : type( type_ )
      , generalShader( generalShader_ )
      , closestHitShader( closestHitShader_ )
      , anyHitShader( anyHitShader_ )
      , intersectionShader( intersectionShader_ )
    {}

    VULKAN_HPP_CONSTEXPR
      RayTracingShaderGroupCreateInfoNV( RayTracingShaderGroupCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    RayTracingShaderGroupCreateInfoNV( VkRayTracingShaderGroupCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
      : RayTracingShaderGroupCreateInfoNV( *reinterpret_cast<RayTracingShaderGroupCreateInfoNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 RayTracingShaderGroupCreateInfoNV &
                            operator=( RayTracingShaderGroupCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    RayTracingShaderGroupCreateInfoNV & operator=( VkRayTracingShaderGroupCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::RayTracingShaderGroupCreateInfoNV const *>( &rhs );
      return *this;
    }

    RayTracingShaderGroupCreateInfoNV & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    RayTracingShaderGroupCreateInfoNV &
      setType( VULKAN_HPP_NAMESPACE::RayTracingShaderGroupTypeKHR type_ ) VULKAN_HPP_NOEXCEPT
    {
      type = type_;
      return *this;
    }

    RayTracingShaderGroupCreateInfoNV & setGeneralShader( uint32_t generalShader_ ) VULKAN_HPP_NOEXCEPT
    {
      generalShader = generalShader_;
      return *this;
    }

    RayTracingShaderGroupCreateInfoNV & setClosestHitShader( uint32_t closestHitShader_ ) VULKAN_HPP_NOEXCEPT
    {
      closestHitShader = closestHitShader_;
      return *this;
    }

    RayTracingShaderGroupCreateInfoNV & setAnyHitShader( uint32_t anyHitShader_ ) VULKAN_HPP_NOEXCEPT
    {
      anyHitShader = anyHitShader_;
      return *this;
    }

    RayTracingShaderGroupCreateInfoNV & setIntersectionShader( uint32_t intersectionShader_ ) VULKAN_HPP_NOEXCEPT
    {
      intersectionShader = intersectionShader_;
      return *this;
    }

    operator VkRayTracingShaderGroupCreateInfoNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkRayTracingShaderGroupCreateInfoNV *>( this );
    }

    operator VkRayTracingShaderGroupCreateInfoNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkRayTracingShaderGroupCreateInfoNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( RayTracingShaderGroupCreateInfoNV const & ) const = default;
#else
    bool operator==( RayTracingShaderGroupCreateInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( type == rhs.type ) &&
             ( generalShader == rhs.generalShader ) && ( closestHitShader == rhs.closestHitShader ) &&
             ( anyHitShader == rhs.anyHitShader ) && ( intersectionShader == rhs.intersectionShader );
    }

    bool operator!=( RayTracingShaderGroupCreateInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                sType = StructureType::eRayTracingShaderGroupCreateInfoNV;
    const void *                                       pNext = {};
    VULKAN_HPP_NAMESPACE::RayTracingShaderGroupTypeKHR type =
      VULKAN_HPP_NAMESPACE::RayTracingShaderGroupTypeKHR::eGeneral;
    uint32_t generalShader      = {};
    uint32_t closestHitShader   = {};
    uint32_t anyHitShader       = {};
    uint32_t intersectionShader = {};
  };
  static_assert( sizeof( RayTracingShaderGroupCreateInfoNV ) == sizeof( VkRayTracingShaderGroupCreateInfoNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<RayTracingShaderGroupCreateInfoNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eRayTracingShaderGroupCreateInfoNV>
  {
    using Type = RayTracingShaderGroupCreateInfoNV;
  };

  struct RayTracingPipelineCreateInfoNV
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eRayTracingPipelineCreateInfoNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      RayTracingPipelineCreateInfoNV( VULKAN_HPP_NAMESPACE::PipelineCreateFlags                       flags_      = {},
                                      uint32_t                                                        stageCount_ = {},
                                      const VULKAN_HPP_NAMESPACE::PipelineShaderStageCreateInfo *     pStages_    = {},
                                      uint32_t                                                        groupCount_ = {},
                                      const VULKAN_HPP_NAMESPACE::RayTracingShaderGroupCreateInfoNV * pGroups_    = {},
                                      uint32_t                             maxRecursionDepth_                     = {},
                                      VULKAN_HPP_NAMESPACE::PipelineLayout layout_                                = {},
                                      VULKAN_HPP_NAMESPACE::Pipeline       basePipelineHandle_                    = {},
                                      int32_t                              basePipelineIndex_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , stageCount( stageCount_ )
      , pStages( pStages_ )
      , groupCount( groupCount_ )
      , pGroups( pGroups_ )
      , maxRecursionDepth( maxRecursionDepth_ )
      , layout( layout_ )
      , basePipelineHandle( basePipelineHandle_ )
      , basePipelineIndex( basePipelineIndex_ )
    {}

    VULKAN_HPP_CONSTEXPR
      RayTracingPipelineCreateInfoNV( RayTracingPipelineCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    RayTracingPipelineCreateInfoNV( VkRayTracingPipelineCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
      : RayTracingPipelineCreateInfoNV( *reinterpret_cast<RayTracingPipelineCreateInfoNV const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    RayTracingPipelineCreateInfoNV(
      VULKAN_HPP_NAMESPACE::PipelineCreateFlags flags_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::PipelineShaderStageCreateInfo> const &
        stages_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<
        const VULKAN_HPP_NAMESPACE::RayTracingShaderGroupCreateInfoNV> const & groups_             = {},
      uint32_t                                                                 maxRecursionDepth_  = {},
      VULKAN_HPP_NAMESPACE::PipelineLayout                                     layout_             = {},
      VULKAN_HPP_NAMESPACE::Pipeline                                           basePipelineHandle_ = {},
      int32_t                                                                  basePipelineIndex_  = {} )
      : flags( flags_ )
      , stageCount( static_cast<uint32_t>( stages_.size() ) )
      , pStages( stages_.data() )
      , groupCount( static_cast<uint32_t>( groups_.size() ) )
      , pGroups( groups_.data() )
      , maxRecursionDepth( maxRecursionDepth_ )
      , layout( layout_ )
      , basePipelineHandle( basePipelineHandle_ )
      , basePipelineIndex( basePipelineIndex_ )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 RayTracingPipelineCreateInfoNV &
                            operator=( RayTracingPipelineCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    RayTracingPipelineCreateInfoNV & operator=( VkRayTracingPipelineCreateInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::RayTracingPipelineCreateInfoNV const *>( &rhs );
      return *this;
    }

    RayTracingPipelineCreateInfoNV & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    RayTracingPipelineCreateInfoNV & setFlags( VULKAN_HPP_NAMESPACE::PipelineCreateFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    RayTracingPipelineCreateInfoNV & setStageCount( uint32_t stageCount_ ) VULKAN_HPP_NOEXCEPT
    {
      stageCount = stageCount_;
      return *this;
    }

    RayTracingPipelineCreateInfoNV &
      setPStages( const VULKAN_HPP_NAMESPACE::PipelineShaderStageCreateInfo * pStages_ ) VULKAN_HPP_NOEXCEPT
    {
      pStages = pStages_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    RayTracingPipelineCreateInfoNV & setStages(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::PipelineShaderStageCreateInfo> const &
        stages_ ) VULKAN_HPP_NOEXCEPT
    {
      stageCount = static_cast<uint32_t>( stages_.size() );
      pStages    = stages_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    RayTracingPipelineCreateInfoNV & setGroupCount( uint32_t groupCount_ ) VULKAN_HPP_NOEXCEPT
    {
      groupCount = groupCount_;
      return *this;
    }

    RayTracingPipelineCreateInfoNV &
      setPGroups( const VULKAN_HPP_NAMESPACE::RayTracingShaderGroupCreateInfoNV * pGroups_ ) VULKAN_HPP_NOEXCEPT
    {
      pGroups = pGroups_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    RayTracingPipelineCreateInfoNV &
      setGroups( VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<
                 const VULKAN_HPP_NAMESPACE::RayTracingShaderGroupCreateInfoNV> const & groups_ ) VULKAN_HPP_NOEXCEPT
    {
      groupCount = static_cast<uint32_t>( groups_.size() );
      pGroups    = groups_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    RayTracingPipelineCreateInfoNV & setMaxRecursionDepth( uint32_t maxRecursionDepth_ ) VULKAN_HPP_NOEXCEPT
    {
      maxRecursionDepth = maxRecursionDepth_;
      return *this;
    }

    RayTracingPipelineCreateInfoNV & setLayout( VULKAN_HPP_NAMESPACE::PipelineLayout layout_ ) VULKAN_HPP_NOEXCEPT
    {
      layout = layout_;
      return *this;
    }

    RayTracingPipelineCreateInfoNV &
      setBasePipelineHandle( VULKAN_HPP_NAMESPACE::Pipeline basePipelineHandle_ ) VULKAN_HPP_NOEXCEPT
    {
      basePipelineHandle = basePipelineHandle_;
      return *this;
    }

    RayTracingPipelineCreateInfoNV & setBasePipelineIndex( int32_t basePipelineIndex_ ) VULKAN_HPP_NOEXCEPT
    {
      basePipelineIndex = basePipelineIndex_;
      return *this;
    }

    operator VkRayTracingPipelineCreateInfoNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkRayTracingPipelineCreateInfoNV *>( this );
    }

    operator VkRayTracingPipelineCreateInfoNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkRayTracingPipelineCreateInfoNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( RayTracingPipelineCreateInfoNV const & ) const = default;
#else
    bool operator==( RayTracingPipelineCreateInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( stageCount == rhs.stageCount ) && ( pStages == rhs.pStages ) && ( groupCount == rhs.groupCount ) &&
             ( pGroups == rhs.pGroups ) && ( maxRecursionDepth == rhs.maxRecursionDepth ) && ( layout == rhs.layout ) &&
             ( basePipelineHandle == rhs.basePipelineHandle ) && ( basePipelineIndex == rhs.basePipelineIndex );
    }

    bool operator!=( RayTracingPipelineCreateInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                         sType = StructureType::eRayTracingPipelineCreateInfoNV;
    const void *                                                pNext = {};
    VULKAN_HPP_NAMESPACE::PipelineCreateFlags                   flags = {};
    uint32_t                                                    stageCount             = {};
    const VULKAN_HPP_NAMESPACE::PipelineShaderStageCreateInfo * pStages                = {};
    uint32_t                                                    groupCount             = {};
    const VULKAN_HPP_NAMESPACE::RayTracingShaderGroupCreateInfoNV * pGroups            = {};
    uint32_t                                                        maxRecursionDepth  = {};
    VULKAN_HPP_NAMESPACE::PipelineLayout                            layout             = {};
    VULKAN_HPP_NAMESPACE::Pipeline                                  basePipelineHandle = {};
    int32_t                                                         basePipelineIndex  = {};
  };
  static_assert( sizeof( RayTracingPipelineCreateInfoNV ) == sizeof( VkRayTracingPipelineCreateInfoNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<RayTracingPipelineCreateInfoNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eRayTracingPipelineCreateInfoNV>
  {
    using Type = RayTracingPipelineCreateInfoNV;
  };

  struct RefreshCycleDurationGOOGLE
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR RefreshCycleDurationGOOGLE( uint64_t refreshDuration_ = {} ) VULKAN_HPP_NOEXCEPT
      : refreshDuration( refreshDuration_ )
    {}

    VULKAN_HPP_CONSTEXPR
      RefreshCycleDurationGOOGLE( RefreshCycleDurationGOOGLE const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    RefreshCycleDurationGOOGLE( VkRefreshCycleDurationGOOGLE const & rhs ) VULKAN_HPP_NOEXCEPT
      : RefreshCycleDurationGOOGLE( *reinterpret_cast<RefreshCycleDurationGOOGLE const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 RefreshCycleDurationGOOGLE &
                            operator=( RefreshCycleDurationGOOGLE const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    RefreshCycleDurationGOOGLE & operator=( VkRefreshCycleDurationGOOGLE const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::RefreshCycleDurationGOOGLE const *>( &rhs );
      return *this;
    }

    operator VkRefreshCycleDurationGOOGLE const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkRefreshCycleDurationGOOGLE *>( this );
    }

    operator VkRefreshCycleDurationGOOGLE &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkRefreshCycleDurationGOOGLE *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( RefreshCycleDurationGOOGLE const & ) const = default;
#else
    bool operator==( RefreshCycleDurationGOOGLE const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( refreshDuration == rhs.refreshDuration );
    }

    bool operator!=( RefreshCycleDurationGOOGLE const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    uint64_t refreshDuration = {};
  };
  static_assert( sizeof( RefreshCycleDurationGOOGLE ) == sizeof( VkRefreshCycleDurationGOOGLE ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<RefreshCycleDurationGOOGLE>::value,
                 "struct wrapper is not a standard layout!" );

  struct RenderPassAttachmentBeginInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eRenderPassAttachmentBeginInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      RenderPassAttachmentBeginInfo( uint32_t                                attachmentCount_ = {},
                                     const VULKAN_HPP_NAMESPACE::ImageView * pAttachments_    = {} ) VULKAN_HPP_NOEXCEPT
      : attachmentCount( attachmentCount_ )
      , pAttachments( pAttachments_ )
    {}

    VULKAN_HPP_CONSTEXPR
      RenderPassAttachmentBeginInfo( RenderPassAttachmentBeginInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    RenderPassAttachmentBeginInfo( VkRenderPassAttachmentBeginInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : RenderPassAttachmentBeginInfo( *reinterpret_cast<RenderPassAttachmentBeginInfo const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    RenderPassAttachmentBeginInfo(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::ImageView> const & attachments_ )
      : attachmentCount( static_cast<uint32_t>( attachments_.size() ) ), pAttachments( attachments_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 RenderPassAttachmentBeginInfo &
                            operator=( RenderPassAttachmentBeginInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    RenderPassAttachmentBeginInfo & operator=( VkRenderPassAttachmentBeginInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::RenderPassAttachmentBeginInfo const *>( &rhs );
      return *this;
    }

    RenderPassAttachmentBeginInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    RenderPassAttachmentBeginInfo & setAttachmentCount( uint32_t attachmentCount_ ) VULKAN_HPP_NOEXCEPT
    {
      attachmentCount = attachmentCount_;
      return *this;
    }

    RenderPassAttachmentBeginInfo &
      setPAttachments( const VULKAN_HPP_NAMESPACE::ImageView * pAttachments_ ) VULKAN_HPP_NOEXCEPT
    {
      pAttachments = pAttachments_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    RenderPassAttachmentBeginInfo & setAttachments(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::ImageView> const & attachments_ )
      VULKAN_HPP_NOEXCEPT
    {
      attachmentCount = static_cast<uint32_t>( attachments_.size() );
      pAttachments    = attachments_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkRenderPassAttachmentBeginInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkRenderPassAttachmentBeginInfo *>( this );
    }

    operator VkRenderPassAttachmentBeginInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkRenderPassAttachmentBeginInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( RenderPassAttachmentBeginInfo const & ) const = default;
#else
    bool operator==( RenderPassAttachmentBeginInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( attachmentCount == rhs.attachmentCount ) &&
             ( pAttachments == rhs.pAttachments );
    }

    bool operator!=( RenderPassAttachmentBeginInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType     sType           = StructureType::eRenderPassAttachmentBeginInfo;
    const void *                            pNext           = {};
    uint32_t                                attachmentCount = {};
    const VULKAN_HPP_NAMESPACE::ImageView * pAttachments    = {};
  };
  static_assert( sizeof( RenderPassAttachmentBeginInfo ) == sizeof( VkRenderPassAttachmentBeginInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<RenderPassAttachmentBeginInfo>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eRenderPassAttachmentBeginInfo>
  {
    using Type = RenderPassAttachmentBeginInfo;
  };
  using RenderPassAttachmentBeginInfoKHR = RenderPassAttachmentBeginInfo;

  struct RenderPassBeginInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eRenderPassBeginInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR_14
      RenderPassBeginInfo( VULKAN_HPP_NAMESPACE::RenderPass         renderPass_      = {},
                           VULKAN_HPP_NAMESPACE::Framebuffer        framebuffer_     = {},
                           VULKAN_HPP_NAMESPACE::Rect2D             renderArea_      = {},
                           uint32_t                                 clearValueCount_ = {},
                           const VULKAN_HPP_NAMESPACE::ClearValue * pClearValues_    = {} ) VULKAN_HPP_NOEXCEPT
      : renderPass( renderPass_ )
      , framebuffer( framebuffer_ )
      , renderArea( renderArea_ )
      , clearValueCount( clearValueCount_ )
      , pClearValues( pClearValues_ )
    {}

    VULKAN_HPP_CONSTEXPR_14 RenderPassBeginInfo( RenderPassBeginInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    RenderPassBeginInfo( VkRenderPassBeginInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : RenderPassBeginInfo( *reinterpret_cast<RenderPassBeginInfo const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    RenderPassBeginInfo(
      VULKAN_HPP_NAMESPACE::RenderPass                                                              renderPass_,
      VULKAN_HPP_NAMESPACE::Framebuffer                                                             framebuffer_,
      VULKAN_HPP_NAMESPACE::Rect2D                                                                  renderArea_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::ClearValue> const & clearValues_ )
      : renderPass( renderPass_ )
      , framebuffer( framebuffer_ )
      , renderArea( renderArea_ )
      , clearValueCount( static_cast<uint32_t>( clearValues_.size() ) )
      , pClearValues( clearValues_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 RenderPassBeginInfo &
                            operator=( RenderPassBeginInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    RenderPassBeginInfo & operator=( VkRenderPassBeginInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::RenderPassBeginInfo const *>( &rhs );
      return *this;
    }

    RenderPassBeginInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    RenderPassBeginInfo & setRenderPass( VULKAN_HPP_NAMESPACE::RenderPass renderPass_ ) VULKAN_HPP_NOEXCEPT
    {
      renderPass = renderPass_;
      return *this;
    }

    RenderPassBeginInfo & setFramebuffer( VULKAN_HPP_NAMESPACE::Framebuffer framebuffer_ ) VULKAN_HPP_NOEXCEPT
    {
      framebuffer = framebuffer_;
      return *this;
    }

    RenderPassBeginInfo & setRenderArea( VULKAN_HPP_NAMESPACE::Rect2D const & renderArea_ ) VULKAN_HPP_NOEXCEPT
    {
      renderArea = renderArea_;
      return *this;
    }

    RenderPassBeginInfo & setClearValueCount( uint32_t clearValueCount_ ) VULKAN_HPP_NOEXCEPT
    {
      clearValueCount = clearValueCount_;
      return *this;
    }

    RenderPassBeginInfo & setPClearValues( const VULKAN_HPP_NAMESPACE::ClearValue * pClearValues_ ) VULKAN_HPP_NOEXCEPT
    {
      pClearValues = pClearValues_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    RenderPassBeginInfo & setClearValues(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::ClearValue> const & clearValues_ )
      VULKAN_HPP_NOEXCEPT
    {
      clearValueCount = static_cast<uint32_t>( clearValues_.size() );
      pClearValues    = clearValues_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkRenderPassBeginInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkRenderPassBeginInfo *>( this );
    }

    operator VkRenderPassBeginInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkRenderPassBeginInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( RenderPassBeginInfo const & ) const = default;
#else
    bool operator==( RenderPassBeginInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( renderPass == rhs.renderPass ) &&
             ( framebuffer == rhs.framebuffer ) && ( renderArea == rhs.renderArea ) &&
             ( clearValueCount == rhs.clearValueCount ) && ( pClearValues == rhs.pClearValues );
    }

    bool operator!=( RenderPassBeginInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType      sType           = StructureType::eRenderPassBeginInfo;
    const void *                             pNext           = {};
    VULKAN_HPP_NAMESPACE::RenderPass         renderPass      = {};
    VULKAN_HPP_NAMESPACE::Framebuffer        framebuffer     = {};
    VULKAN_HPP_NAMESPACE::Rect2D             renderArea      = {};
    uint32_t                                 clearValueCount = {};
    const VULKAN_HPP_NAMESPACE::ClearValue * pClearValues    = {};
  };
  static_assert( sizeof( RenderPassBeginInfo ) == sizeof( VkRenderPassBeginInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<RenderPassBeginInfo>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eRenderPassBeginInfo>
  {
    using Type = RenderPassBeginInfo;
  };

  struct SubpassDescription
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR SubpassDescription(
      VULKAN_HPP_NAMESPACE::SubpassDescriptionFlags flags_       = {},
      VULKAN_HPP_NAMESPACE::PipelineBindPoint pipelineBindPoint_ = VULKAN_HPP_NAMESPACE::PipelineBindPoint::eGraphics,
      uint32_t                                inputAttachmentCount_              = {},
      const VULKAN_HPP_NAMESPACE::AttachmentReference * pInputAttachments_       = {},
      uint32_t                                          colorAttachmentCount_    = {},
      const VULKAN_HPP_NAMESPACE::AttachmentReference * pColorAttachments_       = {},
      const VULKAN_HPP_NAMESPACE::AttachmentReference * pResolveAttachments_     = {},
      const VULKAN_HPP_NAMESPACE::AttachmentReference * pDepthStencilAttachment_ = {},
      uint32_t                                          preserveAttachmentCount_ = {},
      const uint32_t *                                  pPreserveAttachments_    = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , pipelineBindPoint( pipelineBindPoint_ )
      , inputAttachmentCount( inputAttachmentCount_ )
      , pInputAttachments( pInputAttachments_ )
      , colorAttachmentCount( colorAttachmentCount_ )
      , pColorAttachments( pColorAttachments_ )
      , pResolveAttachments( pResolveAttachments_ )
      , pDepthStencilAttachment( pDepthStencilAttachment_ )
      , preserveAttachmentCount( preserveAttachmentCount_ )
      , pPreserveAttachments( pPreserveAttachments_ )
    {}

    VULKAN_HPP_CONSTEXPR SubpassDescription( SubpassDescription const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SubpassDescription( VkSubpassDescription const & rhs ) VULKAN_HPP_NOEXCEPT
      : SubpassDescription( *reinterpret_cast<SubpassDescription const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    SubpassDescription(
      VULKAN_HPP_NAMESPACE::SubpassDescriptionFlags flags_,
      VULKAN_HPP_NAMESPACE::PipelineBindPoint       pipelineBindPoint_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::AttachmentReference> const &
        inputAttachments_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::AttachmentReference> const &
        colorAttachments_ = {},
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::AttachmentReference> const &
                                                                            resolveAttachments_      = {},
      const VULKAN_HPP_NAMESPACE::AttachmentReference *                     pDepthStencilAttachment_ = {},
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const & preserveAttachments_     = {} )
      : flags( flags_ )
      , pipelineBindPoint( pipelineBindPoint_ )
      , inputAttachmentCount( static_cast<uint32_t>( inputAttachments_.size() ) )
      , pInputAttachments( inputAttachments_.data() )
      , colorAttachmentCount( static_cast<uint32_t>( colorAttachments_.size() ) )
      , pColorAttachments( colorAttachments_.data() )
      , pResolveAttachments( resolveAttachments_.data() )
      , pDepthStencilAttachment( pDepthStencilAttachment_ )
      , preserveAttachmentCount( static_cast<uint32_t>( preserveAttachments_.size() ) )
      , pPreserveAttachments( preserveAttachments_.data() )
    {
#    ifdef VULKAN_HPP_NO_EXCEPTIONS
      VULKAN_HPP_ASSERT( resolveAttachments_.empty() || ( colorAttachments_.size() == resolveAttachments_.size() ) );
#    else
      if ( !resolveAttachments_.empty() && ( colorAttachments_.size() != resolveAttachments_.size() ) )
      {
        throw LogicError(
          VULKAN_HPP_NAMESPACE_STRING
          "::SubpassDescription::SubpassDescription: !resolveAttachments_.empty() && ( colorAttachments_.size() != resolveAttachments_.size() )" );
      }
#    endif /*VULKAN_HPP_NO_EXCEPTIONS*/
    }
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SubpassDescription &
                            operator=( SubpassDescription const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SubpassDescription & operator=( VkSubpassDescription const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SubpassDescription const *>( &rhs );
      return *this;
    }

    SubpassDescription & setFlags( VULKAN_HPP_NAMESPACE::SubpassDescriptionFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    SubpassDescription &
      setPipelineBindPoint( VULKAN_HPP_NAMESPACE::PipelineBindPoint pipelineBindPoint_ ) VULKAN_HPP_NOEXCEPT
    {
      pipelineBindPoint = pipelineBindPoint_;
      return *this;
    }

    SubpassDescription & setInputAttachmentCount( uint32_t inputAttachmentCount_ ) VULKAN_HPP_NOEXCEPT
    {
      inputAttachmentCount = inputAttachmentCount_;
      return *this;
    }

    SubpassDescription &
      setPInputAttachments( const VULKAN_HPP_NAMESPACE::AttachmentReference * pInputAttachments_ ) VULKAN_HPP_NOEXCEPT
    {
      pInputAttachments = pInputAttachments_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    SubpassDescription & setInputAttachments(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::AttachmentReference> const &
        inputAttachments_ ) VULKAN_HPP_NOEXCEPT
    {
      inputAttachmentCount = static_cast<uint32_t>( inputAttachments_.size() );
      pInputAttachments    = inputAttachments_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    SubpassDescription & setColorAttachmentCount( uint32_t colorAttachmentCount_ ) VULKAN_HPP_NOEXCEPT
    {
      colorAttachmentCount = colorAttachmentCount_;
      return *this;
    }

    SubpassDescription &
      setPColorAttachments( const VULKAN_HPP_NAMESPACE::AttachmentReference * pColorAttachments_ ) VULKAN_HPP_NOEXCEPT
    {
      pColorAttachments = pColorAttachments_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    SubpassDescription & setColorAttachments(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::AttachmentReference> const &
        colorAttachments_ ) VULKAN_HPP_NOEXCEPT
    {
      colorAttachmentCount = static_cast<uint32_t>( colorAttachments_.size() );
      pColorAttachments    = colorAttachments_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    SubpassDescription & setPResolveAttachments(
      const VULKAN_HPP_NAMESPACE::AttachmentReference * pResolveAttachments_ ) VULKAN_HPP_NOEXCEPT
    {
      pResolveAttachments = pResolveAttachments_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    SubpassDescription & setResolveAttachments(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::AttachmentReference> const &
        resolveAttachments_ ) VULKAN_HPP_NOEXCEPT
    {
      colorAttachmentCount = static_cast<uint32_t>( resolveAttachments_.size() );
      pResolveAttachments  = resolveAttachments_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    SubpassDescription & setPDepthStencilAttachment(
      const VULKAN_HPP_NAMESPACE::AttachmentReference * pDepthStencilAttachment_ ) VULKAN_HPP_NOEXCEPT
    {
      pDepthStencilAttachment = pDepthStencilAttachment_;
      return *this;
    }

    SubpassDescription & setPreserveAttachmentCount( uint32_t preserveAttachmentCount_ ) VULKAN_HPP_NOEXCEPT
    {
      preserveAttachmentCount = preserveAttachmentCount_;
      return *this;
    }

    SubpassDescription & setPPreserveAttachments( const uint32_t * pPreserveAttachments_ ) VULKAN_HPP_NOEXCEPT
    {
      pPreserveAttachments = pPreserveAttachments_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    SubpassDescription & setPreserveAttachments(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const & preserveAttachments_ ) VULKAN_HPP_NOEXCEPT
    {
      preserveAttachmentCount = static_cast<uint32_t>( preserveAttachments_.size() );
      pPreserveAttachments    = preserveAttachments_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkSubpassDescription const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSubpassDescription *>( this );
    }

    operator VkSubpassDescription &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSubpassDescription *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SubpassDescription const & ) const = default;
#else
    bool operator==( SubpassDescription const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( flags == rhs.flags ) && ( pipelineBindPoint == rhs.pipelineBindPoint ) &&
             ( inputAttachmentCount == rhs.inputAttachmentCount ) && ( pInputAttachments == rhs.pInputAttachments ) &&
             ( colorAttachmentCount == rhs.colorAttachmentCount ) && ( pColorAttachments == rhs.pColorAttachments ) &&
             ( pResolveAttachments == rhs.pResolveAttachments ) &&
             ( pDepthStencilAttachment == rhs.pDepthStencilAttachment ) &&
             ( preserveAttachmentCount == rhs.preserveAttachmentCount ) &&
             ( pPreserveAttachments == rhs.pPreserveAttachments );
    }

    bool operator!=( SubpassDescription const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::SubpassDescriptionFlags flags          = {};
    VULKAN_HPP_NAMESPACE::PipelineBindPoint pipelineBindPoint    = VULKAN_HPP_NAMESPACE::PipelineBindPoint::eGraphics;
    uint32_t                                inputAttachmentCount = {};
    const VULKAN_HPP_NAMESPACE::AttachmentReference * pInputAttachments       = {};
    uint32_t                                          colorAttachmentCount    = {};
    const VULKAN_HPP_NAMESPACE::AttachmentReference * pColorAttachments       = {};
    const VULKAN_HPP_NAMESPACE::AttachmentReference * pResolveAttachments     = {};
    const VULKAN_HPP_NAMESPACE::AttachmentReference * pDepthStencilAttachment = {};
    uint32_t                                          preserveAttachmentCount = {};
    const uint32_t *                                  pPreserveAttachments    = {};
  };
  static_assert( sizeof( SubpassDescription ) == sizeof( VkSubpassDescription ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SubpassDescription>::value, "struct wrapper is not a standard layout!" );

  struct SubpassDependency
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      SubpassDependency( uint32_t                                 srcSubpass_      = {},
                         uint32_t                                 dstSubpass_      = {},
                         VULKAN_HPP_NAMESPACE::PipelineStageFlags srcStageMask_    = {},
                         VULKAN_HPP_NAMESPACE::PipelineStageFlags dstStageMask_    = {},
                         VULKAN_HPP_NAMESPACE::AccessFlags        srcAccessMask_   = {},
                         VULKAN_HPP_NAMESPACE::AccessFlags        dstAccessMask_   = {},
                         VULKAN_HPP_NAMESPACE::DependencyFlags    dependencyFlags_ = {} ) VULKAN_HPP_NOEXCEPT
      : srcSubpass( srcSubpass_ )
      , dstSubpass( dstSubpass_ )
      , srcStageMask( srcStageMask_ )
      , dstStageMask( dstStageMask_ )
      , srcAccessMask( srcAccessMask_ )
      , dstAccessMask( dstAccessMask_ )
      , dependencyFlags( dependencyFlags_ )
    {}

    VULKAN_HPP_CONSTEXPR SubpassDependency( SubpassDependency const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SubpassDependency( VkSubpassDependency const & rhs ) VULKAN_HPP_NOEXCEPT
      : SubpassDependency( *reinterpret_cast<SubpassDependency const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SubpassDependency &
                            operator=( SubpassDependency const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SubpassDependency & operator=( VkSubpassDependency const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SubpassDependency const *>( &rhs );
      return *this;
    }

    SubpassDependency & setSrcSubpass( uint32_t srcSubpass_ ) VULKAN_HPP_NOEXCEPT
    {
      srcSubpass = srcSubpass_;
      return *this;
    }

    SubpassDependency & setDstSubpass( uint32_t dstSubpass_ ) VULKAN_HPP_NOEXCEPT
    {
      dstSubpass = dstSubpass_;
      return *this;
    }

    SubpassDependency & setSrcStageMask( VULKAN_HPP_NAMESPACE::PipelineStageFlags srcStageMask_ ) VULKAN_HPP_NOEXCEPT
    {
      srcStageMask = srcStageMask_;
      return *this;
    }

    SubpassDependency & setDstStageMask( VULKAN_HPP_NAMESPACE::PipelineStageFlags dstStageMask_ ) VULKAN_HPP_NOEXCEPT
    {
      dstStageMask = dstStageMask_;
      return *this;
    }

    SubpassDependency & setSrcAccessMask( VULKAN_HPP_NAMESPACE::AccessFlags srcAccessMask_ ) VULKAN_HPP_NOEXCEPT
    {
      srcAccessMask = srcAccessMask_;
      return *this;
    }

    SubpassDependency & setDstAccessMask( VULKAN_HPP_NAMESPACE::AccessFlags dstAccessMask_ ) VULKAN_HPP_NOEXCEPT
    {
      dstAccessMask = dstAccessMask_;
      return *this;
    }

    SubpassDependency & setDependencyFlags( VULKAN_HPP_NAMESPACE::DependencyFlags dependencyFlags_ ) VULKAN_HPP_NOEXCEPT
    {
      dependencyFlags = dependencyFlags_;
      return *this;
    }

    operator VkSubpassDependency const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSubpassDependency *>( this );
    }

    operator VkSubpassDependency &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSubpassDependency *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SubpassDependency const & ) const = default;
#else
    bool operator==( SubpassDependency const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( srcSubpass == rhs.srcSubpass ) && ( dstSubpass == rhs.dstSubpass ) &&
             ( srcStageMask == rhs.srcStageMask ) && ( dstStageMask == rhs.dstStageMask ) &&
             ( srcAccessMask == rhs.srcAccessMask ) && ( dstAccessMask == rhs.dstAccessMask ) &&
             ( dependencyFlags == rhs.dependencyFlags );
    }

    bool operator!=( SubpassDependency const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    uint32_t                                 srcSubpass      = {};
    uint32_t                                 dstSubpass      = {};
    VULKAN_HPP_NAMESPACE::PipelineStageFlags srcStageMask    = {};
    VULKAN_HPP_NAMESPACE::PipelineStageFlags dstStageMask    = {};
    VULKAN_HPP_NAMESPACE::AccessFlags        srcAccessMask   = {};
    VULKAN_HPP_NAMESPACE::AccessFlags        dstAccessMask   = {};
    VULKAN_HPP_NAMESPACE::DependencyFlags    dependencyFlags = {};
  };
  static_assert( sizeof( SubpassDependency ) == sizeof( VkSubpassDependency ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SubpassDependency>::value, "struct wrapper is not a standard layout!" );

  struct RenderPassCreateInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eRenderPassCreateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      RenderPassCreateInfo( VULKAN_HPP_NAMESPACE::RenderPassCreateFlags         flags_           = {},
                            uint32_t                                            attachmentCount_ = {},
                            const VULKAN_HPP_NAMESPACE::AttachmentDescription * pAttachments_    = {},
                            uint32_t                                            subpassCount_    = {},
                            const VULKAN_HPP_NAMESPACE::SubpassDescription *    pSubpasses_      = {},
                            uint32_t                                            dependencyCount_ = {},
                            const VULKAN_HPP_NAMESPACE::SubpassDependency * pDependencies_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , attachmentCount( attachmentCount_ )
      , pAttachments( pAttachments_ )
      , subpassCount( subpassCount_ )
      , pSubpasses( pSubpasses_ )
      , dependencyCount( dependencyCount_ )
      , pDependencies( pDependencies_ )
    {}

    VULKAN_HPP_CONSTEXPR RenderPassCreateInfo( RenderPassCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    RenderPassCreateInfo( VkRenderPassCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : RenderPassCreateInfo( *reinterpret_cast<RenderPassCreateInfo const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    RenderPassCreateInfo(
      VULKAN_HPP_NAMESPACE::RenderPassCreateFlags flags_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::AttachmentDescription> const &
        attachments_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::SubpassDescription> const &
        subpasses_ = {},
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::SubpassDependency> const &
        dependencies_ = {} )
      : flags( flags_ )
      , attachmentCount( static_cast<uint32_t>( attachments_.size() ) )
      , pAttachments( attachments_.data() )
      , subpassCount( static_cast<uint32_t>( subpasses_.size() ) )
      , pSubpasses( subpasses_.data() )
      , dependencyCount( static_cast<uint32_t>( dependencies_.size() ) )
      , pDependencies( dependencies_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 RenderPassCreateInfo &
                            operator=( RenderPassCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    RenderPassCreateInfo & operator=( VkRenderPassCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::RenderPassCreateInfo const *>( &rhs );
      return *this;
    }

    RenderPassCreateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    RenderPassCreateInfo & setFlags( VULKAN_HPP_NAMESPACE::RenderPassCreateFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    RenderPassCreateInfo & setAttachmentCount( uint32_t attachmentCount_ ) VULKAN_HPP_NOEXCEPT
    {
      attachmentCount = attachmentCount_;
      return *this;
    }

    RenderPassCreateInfo &
      setPAttachments( const VULKAN_HPP_NAMESPACE::AttachmentDescription * pAttachments_ ) VULKAN_HPP_NOEXCEPT
    {
      pAttachments = pAttachments_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    RenderPassCreateInfo & setAttachments(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::AttachmentDescription> const &
        attachments_ ) VULKAN_HPP_NOEXCEPT
    {
      attachmentCount = static_cast<uint32_t>( attachments_.size() );
      pAttachments    = attachments_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    RenderPassCreateInfo & setSubpassCount( uint32_t subpassCount_ ) VULKAN_HPP_NOEXCEPT
    {
      subpassCount = subpassCount_;
      return *this;
    }

    RenderPassCreateInfo &
      setPSubpasses( const VULKAN_HPP_NAMESPACE::SubpassDescription * pSubpasses_ ) VULKAN_HPP_NOEXCEPT
    {
      pSubpasses = pSubpasses_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    RenderPassCreateInfo & setSubpasses(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::SubpassDescription> const & subpasses_ )
      VULKAN_HPP_NOEXCEPT
    {
      subpassCount = static_cast<uint32_t>( subpasses_.size() );
      pSubpasses   = subpasses_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    RenderPassCreateInfo & setDependencyCount( uint32_t dependencyCount_ ) VULKAN_HPP_NOEXCEPT
    {
      dependencyCount = dependencyCount_;
      return *this;
    }

    RenderPassCreateInfo &
      setPDependencies( const VULKAN_HPP_NAMESPACE::SubpassDependency * pDependencies_ ) VULKAN_HPP_NOEXCEPT
    {
      pDependencies = pDependencies_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    RenderPassCreateInfo & setDependencies(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::SubpassDependency> const &
        dependencies_ ) VULKAN_HPP_NOEXCEPT
    {
      dependencyCount = static_cast<uint32_t>( dependencies_.size() );
      pDependencies   = dependencies_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkRenderPassCreateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkRenderPassCreateInfo *>( this );
    }

    operator VkRenderPassCreateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkRenderPassCreateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( RenderPassCreateInfo const & ) const = default;
#else
    bool operator==( RenderPassCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( attachmentCount == rhs.attachmentCount ) && ( pAttachments == rhs.pAttachments ) &&
             ( subpassCount == rhs.subpassCount ) && ( pSubpasses == rhs.pSubpasses ) &&
             ( dependencyCount == rhs.dependencyCount ) && ( pDependencies == rhs.pDependencies );
    }

    bool operator!=( RenderPassCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                 sType           = StructureType::eRenderPassCreateInfo;
    const void *                                        pNext           = {};
    VULKAN_HPP_NAMESPACE::RenderPassCreateFlags         flags           = {};
    uint32_t                                            attachmentCount = {};
    const VULKAN_HPP_NAMESPACE::AttachmentDescription * pAttachments    = {};
    uint32_t                                            subpassCount    = {};
    const VULKAN_HPP_NAMESPACE::SubpassDescription *    pSubpasses      = {};
    uint32_t                                            dependencyCount = {};
    const VULKAN_HPP_NAMESPACE::SubpassDependency *     pDependencies   = {};
  };
  static_assert( sizeof( RenderPassCreateInfo ) == sizeof( VkRenderPassCreateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<RenderPassCreateInfo>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eRenderPassCreateInfo>
  {
    using Type = RenderPassCreateInfo;
  };

  struct SubpassDescription2
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eSubpassDescription2;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR SubpassDescription2(
      VULKAN_HPP_NAMESPACE::SubpassDescriptionFlags flags_       = {},
      VULKAN_HPP_NAMESPACE::PipelineBindPoint pipelineBindPoint_ = VULKAN_HPP_NAMESPACE::PipelineBindPoint::eGraphics,
      uint32_t                                viewMask_          = {},
      uint32_t                                inputAttachmentCount_               = {},
      const VULKAN_HPP_NAMESPACE::AttachmentReference2 * pInputAttachments_       = {},
      uint32_t                                           colorAttachmentCount_    = {},
      const VULKAN_HPP_NAMESPACE::AttachmentReference2 * pColorAttachments_       = {},
      const VULKAN_HPP_NAMESPACE::AttachmentReference2 * pResolveAttachments_     = {},
      const VULKAN_HPP_NAMESPACE::AttachmentReference2 * pDepthStencilAttachment_ = {},
      uint32_t                                           preserveAttachmentCount_ = {},
      const uint32_t *                                   pPreserveAttachments_    = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , pipelineBindPoint( pipelineBindPoint_ )
      , viewMask( viewMask_ )
      , inputAttachmentCount( inputAttachmentCount_ )
      , pInputAttachments( pInputAttachments_ )
      , colorAttachmentCount( colorAttachmentCount_ )
      , pColorAttachments( pColorAttachments_ )
      , pResolveAttachments( pResolveAttachments_ )
      , pDepthStencilAttachment( pDepthStencilAttachment_ )
      , preserveAttachmentCount( preserveAttachmentCount_ )
      , pPreserveAttachments( pPreserveAttachments_ )
    {}

    VULKAN_HPP_CONSTEXPR SubpassDescription2( SubpassDescription2 const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SubpassDescription2( VkSubpassDescription2 const & rhs ) VULKAN_HPP_NOEXCEPT
      : SubpassDescription2( *reinterpret_cast<SubpassDescription2 const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    SubpassDescription2(
      VULKAN_HPP_NAMESPACE::SubpassDescriptionFlags flags_,
      VULKAN_HPP_NAMESPACE::PipelineBindPoint       pipelineBindPoint_,
      uint32_t                                      viewMask_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::AttachmentReference2> const &
        inputAttachments_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::AttachmentReference2> const &
        colorAttachments_ = {},
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::AttachmentReference2> const &
                                                                            resolveAttachments_      = {},
      const VULKAN_HPP_NAMESPACE::AttachmentReference2 *                    pDepthStencilAttachment_ = {},
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const & preserveAttachments_     = {} )
      : flags( flags_ )
      , pipelineBindPoint( pipelineBindPoint_ )
      , viewMask( viewMask_ )
      , inputAttachmentCount( static_cast<uint32_t>( inputAttachments_.size() ) )
      , pInputAttachments( inputAttachments_.data() )
      , colorAttachmentCount( static_cast<uint32_t>( colorAttachments_.size() ) )
      , pColorAttachments( colorAttachments_.data() )
      , pResolveAttachments( resolveAttachments_.data() )
      , pDepthStencilAttachment( pDepthStencilAttachment_ )
      , preserveAttachmentCount( static_cast<uint32_t>( preserveAttachments_.size() ) )
      , pPreserveAttachments( preserveAttachments_.data() )
    {
#    ifdef VULKAN_HPP_NO_EXCEPTIONS
      VULKAN_HPP_ASSERT( resolveAttachments_.empty() || ( colorAttachments_.size() == resolveAttachments_.size() ) );
#    else
      if ( !resolveAttachments_.empty() && ( colorAttachments_.size() != resolveAttachments_.size() ) )
      {
        throw LogicError(
          VULKAN_HPP_NAMESPACE_STRING
          "::SubpassDescription2::SubpassDescription2: !resolveAttachments_.empty() && ( colorAttachments_.size() != resolveAttachments_.size() )" );
      }
#    endif /*VULKAN_HPP_NO_EXCEPTIONS*/
    }
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SubpassDescription2 &
                            operator=( SubpassDescription2 const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SubpassDescription2 & operator=( VkSubpassDescription2 const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SubpassDescription2 const *>( &rhs );
      return *this;
    }

    SubpassDescription2 & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    SubpassDescription2 & setFlags( VULKAN_HPP_NAMESPACE::SubpassDescriptionFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    SubpassDescription2 &
      setPipelineBindPoint( VULKAN_HPP_NAMESPACE::PipelineBindPoint pipelineBindPoint_ ) VULKAN_HPP_NOEXCEPT
    {
      pipelineBindPoint = pipelineBindPoint_;
      return *this;
    }

    SubpassDescription2 & setViewMask( uint32_t viewMask_ ) VULKAN_HPP_NOEXCEPT
    {
      viewMask = viewMask_;
      return *this;
    }

    SubpassDescription2 & setInputAttachmentCount( uint32_t inputAttachmentCount_ ) VULKAN_HPP_NOEXCEPT
    {
      inputAttachmentCount = inputAttachmentCount_;
      return *this;
    }

    SubpassDescription2 &
      setPInputAttachments( const VULKAN_HPP_NAMESPACE::AttachmentReference2 * pInputAttachments_ ) VULKAN_HPP_NOEXCEPT
    {
      pInputAttachments = pInputAttachments_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    SubpassDescription2 & setInputAttachments(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::AttachmentReference2> const &
        inputAttachments_ ) VULKAN_HPP_NOEXCEPT
    {
      inputAttachmentCount = static_cast<uint32_t>( inputAttachments_.size() );
      pInputAttachments    = inputAttachments_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    SubpassDescription2 & setColorAttachmentCount( uint32_t colorAttachmentCount_ ) VULKAN_HPP_NOEXCEPT
    {
      colorAttachmentCount = colorAttachmentCount_;
      return *this;
    }

    SubpassDescription2 &
      setPColorAttachments( const VULKAN_HPP_NAMESPACE::AttachmentReference2 * pColorAttachments_ ) VULKAN_HPP_NOEXCEPT
    {
      pColorAttachments = pColorAttachments_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    SubpassDescription2 & setColorAttachments(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::AttachmentReference2> const &
        colorAttachments_ ) VULKAN_HPP_NOEXCEPT
    {
      colorAttachmentCount = static_cast<uint32_t>( colorAttachments_.size() );
      pColorAttachments    = colorAttachments_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    SubpassDescription2 & setPResolveAttachments(
      const VULKAN_HPP_NAMESPACE::AttachmentReference2 * pResolveAttachments_ ) VULKAN_HPP_NOEXCEPT
    {
      pResolveAttachments = pResolveAttachments_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    SubpassDescription2 & setResolveAttachments(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::AttachmentReference2> const &
        resolveAttachments_ ) VULKAN_HPP_NOEXCEPT
    {
      colorAttachmentCount = static_cast<uint32_t>( resolveAttachments_.size() );
      pResolveAttachments  = resolveAttachments_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    SubpassDescription2 & setPDepthStencilAttachment(
      const VULKAN_HPP_NAMESPACE::AttachmentReference2 * pDepthStencilAttachment_ ) VULKAN_HPP_NOEXCEPT
    {
      pDepthStencilAttachment = pDepthStencilAttachment_;
      return *this;
    }

    SubpassDescription2 & setPreserveAttachmentCount( uint32_t preserveAttachmentCount_ ) VULKAN_HPP_NOEXCEPT
    {
      preserveAttachmentCount = preserveAttachmentCount_;
      return *this;
    }

    SubpassDescription2 & setPPreserveAttachments( const uint32_t * pPreserveAttachments_ ) VULKAN_HPP_NOEXCEPT
    {
      pPreserveAttachments = pPreserveAttachments_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    SubpassDescription2 & setPreserveAttachments(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const & preserveAttachments_ ) VULKAN_HPP_NOEXCEPT
    {
      preserveAttachmentCount = static_cast<uint32_t>( preserveAttachments_.size() );
      pPreserveAttachments    = preserveAttachments_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkSubpassDescription2 const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSubpassDescription2 *>( this );
    }

    operator VkSubpassDescription2 &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSubpassDescription2 *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SubpassDescription2 const & ) const = default;
#else
    bool operator==( SubpassDescription2 const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( pipelineBindPoint == rhs.pipelineBindPoint ) && ( viewMask == rhs.viewMask ) &&
             ( inputAttachmentCount == rhs.inputAttachmentCount ) && ( pInputAttachments == rhs.pInputAttachments ) &&
             ( colorAttachmentCount == rhs.colorAttachmentCount ) && ( pColorAttachments == rhs.pColorAttachments ) &&
             ( pResolveAttachments == rhs.pResolveAttachments ) &&
             ( pDepthStencilAttachment == rhs.pDepthStencilAttachment ) &&
             ( preserveAttachmentCount == rhs.preserveAttachmentCount ) &&
             ( pPreserveAttachments == rhs.pPreserveAttachments );
    }

    bool operator!=( SubpassDescription2 const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType           sType          = StructureType::eSubpassDescription2;
    const void *                                  pNext          = {};
    VULKAN_HPP_NAMESPACE::SubpassDescriptionFlags flags          = {};
    VULKAN_HPP_NAMESPACE::PipelineBindPoint pipelineBindPoint    = VULKAN_HPP_NAMESPACE::PipelineBindPoint::eGraphics;
    uint32_t                                viewMask             = {};
    uint32_t                                inputAttachmentCount = {};
    const VULKAN_HPP_NAMESPACE::AttachmentReference2 * pInputAttachments       = {};
    uint32_t                                           colorAttachmentCount    = {};
    const VULKAN_HPP_NAMESPACE::AttachmentReference2 * pColorAttachments       = {};
    const VULKAN_HPP_NAMESPACE::AttachmentReference2 * pResolveAttachments     = {};
    const VULKAN_HPP_NAMESPACE::AttachmentReference2 * pDepthStencilAttachment = {};
    uint32_t                                           preserveAttachmentCount = {};
    const uint32_t *                                   pPreserveAttachments    = {};
  };
  static_assert( sizeof( SubpassDescription2 ) == sizeof( VkSubpassDescription2 ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SubpassDescription2>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eSubpassDescription2>
  {
    using Type = SubpassDescription2;
  };
  using SubpassDescription2KHR = SubpassDescription2;

  struct SubpassDependency2
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eSubpassDependency2;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR SubpassDependency2( uint32_t                                 srcSubpass_      = {},
                                             uint32_t                                 dstSubpass_      = {},
                                             VULKAN_HPP_NAMESPACE::PipelineStageFlags srcStageMask_    = {},
                                             VULKAN_HPP_NAMESPACE::PipelineStageFlags dstStageMask_    = {},
                                             VULKAN_HPP_NAMESPACE::AccessFlags        srcAccessMask_   = {},
                                             VULKAN_HPP_NAMESPACE::AccessFlags        dstAccessMask_   = {},
                                             VULKAN_HPP_NAMESPACE::DependencyFlags    dependencyFlags_ = {},
                                             int32_t viewOffset_ = {} ) VULKAN_HPP_NOEXCEPT
      : srcSubpass( srcSubpass_ )
      , dstSubpass( dstSubpass_ )
      , srcStageMask( srcStageMask_ )
      , dstStageMask( dstStageMask_ )
      , srcAccessMask( srcAccessMask_ )
      , dstAccessMask( dstAccessMask_ )
      , dependencyFlags( dependencyFlags_ )
      , viewOffset( viewOffset_ )
    {}

    VULKAN_HPP_CONSTEXPR SubpassDependency2( SubpassDependency2 const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SubpassDependency2( VkSubpassDependency2 const & rhs ) VULKAN_HPP_NOEXCEPT
      : SubpassDependency2( *reinterpret_cast<SubpassDependency2 const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SubpassDependency2 &
                            operator=( SubpassDependency2 const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SubpassDependency2 & operator=( VkSubpassDependency2 const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SubpassDependency2 const *>( &rhs );
      return *this;
    }

    SubpassDependency2 & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    SubpassDependency2 & setSrcSubpass( uint32_t srcSubpass_ ) VULKAN_HPP_NOEXCEPT
    {
      srcSubpass = srcSubpass_;
      return *this;
    }

    SubpassDependency2 & setDstSubpass( uint32_t dstSubpass_ ) VULKAN_HPP_NOEXCEPT
    {
      dstSubpass = dstSubpass_;
      return *this;
    }

    SubpassDependency2 & setSrcStageMask( VULKAN_HPP_NAMESPACE::PipelineStageFlags srcStageMask_ ) VULKAN_HPP_NOEXCEPT
    {
      srcStageMask = srcStageMask_;
      return *this;
    }

    SubpassDependency2 & setDstStageMask( VULKAN_HPP_NAMESPACE::PipelineStageFlags dstStageMask_ ) VULKAN_HPP_NOEXCEPT
    {
      dstStageMask = dstStageMask_;
      return *this;
    }

    SubpassDependency2 & setSrcAccessMask( VULKAN_HPP_NAMESPACE::AccessFlags srcAccessMask_ ) VULKAN_HPP_NOEXCEPT
    {
      srcAccessMask = srcAccessMask_;
      return *this;
    }

    SubpassDependency2 & setDstAccessMask( VULKAN_HPP_NAMESPACE::AccessFlags dstAccessMask_ ) VULKAN_HPP_NOEXCEPT
    {
      dstAccessMask = dstAccessMask_;
      return *this;
    }

    SubpassDependency2 &
      setDependencyFlags( VULKAN_HPP_NAMESPACE::DependencyFlags dependencyFlags_ ) VULKAN_HPP_NOEXCEPT
    {
      dependencyFlags = dependencyFlags_;
      return *this;
    }

    SubpassDependency2 & setViewOffset( int32_t viewOffset_ ) VULKAN_HPP_NOEXCEPT
    {
      viewOffset = viewOffset_;
      return *this;
    }

    operator VkSubpassDependency2 const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSubpassDependency2 *>( this );
    }

    operator VkSubpassDependency2 &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSubpassDependency2 *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SubpassDependency2 const & ) const = default;
#else
    bool operator==( SubpassDependency2 const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( srcSubpass == rhs.srcSubpass ) &&
             ( dstSubpass == rhs.dstSubpass ) && ( srcStageMask == rhs.srcStageMask ) &&
             ( dstStageMask == rhs.dstStageMask ) && ( srcAccessMask == rhs.srcAccessMask ) &&
             ( dstAccessMask == rhs.dstAccessMask ) && ( dependencyFlags == rhs.dependencyFlags ) &&
             ( viewOffset == rhs.viewOffset );
    }

    bool operator!=( SubpassDependency2 const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType      sType           = StructureType::eSubpassDependency2;
    const void *                             pNext           = {};
    uint32_t                                 srcSubpass      = {};
    uint32_t                                 dstSubpass      = {};
    VULKAN_HPP_NAMESPACE::PipelineStageFlags srcStageMask    = {};
    VULKAN_HPP_NAMESPACE::PipelineStageFlags dstStageMask    = {};
    VULKAN_HPP_NAMESPACE::AccessFlags        srcAccessMask   = {};
    VULKAN_HPP_NAMESPACE::AccessFlags        dstAccessMask   = {};
    VULKAN_HPP_NAMESPACE::DependencyFlags    dependencyFlags = {};
    int32_t                                  viewOffset      = {};
  };
  static_assert( sizeof( SubpassDependency2 ) == sizeof( VkSubpassDependency2 ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SubpassDependency2>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eSubpassDependency2>
  {
    using Type = SubpassDependency2;
  };
  using SubpassDependency2KHR = SubpassDependency2;

  struct RenderPassCreateInfo2
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eRenderPassCreateInfo2;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR RenderPassCreateInfo2( VULKAN_HPP_NAMESPACE::RenderPassCreateFlags flags_                 = {},
                                                uint32_t                                    attachmentCount_       = {},
                                                const VULKAN_HPP_NAMESPACE::AttachmentDescription2 * pAttachments_ = {},
                                                uint32_t                                             subpassCount_ = {},
                                                const VULKAN_HPP_NAMESPACE::SubpassDescription2 *    pSubpasses_   = {},
                                                uint32_t                                         dependencyCount_  = {},
                                                const VULKAN_HPP_NAMESPACE::SubpassDependency2 * pDependencies_    = {},
                                                uint32_t         correlatedViewMaskCount_                          = {},
                                                const uint32_t * pCorrelatedViewMasks_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , attachmentCount( attachmentCount_ )
      , pAttachments( pAttachments_ )
      , subpassCount( subpassCount_ )
      , pSubpasses( pSubpasses_ )
      , dependencyCount( dependencyCount_ )
      , pDependencies( pDependencies_ )
      , correlatedViewMaskCount( correlatedViewMaskCount_ )
      , pCorrelatedViewMasks( pCorrelatedViewMasks_ )
    {}

    VULKAN_HPP_CONSTEXPR RenderPassCreateInfo2( RenderPassCreateInfo2 const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    RenderPassCreateInfo2( VkRenderPassCreateInfo2 const & rhs ) VULKAN_HPP_NOEXCEPT
      : RenderPassCreateInfo2( *reinterpret_cast<RenderPassCreateInfo2 const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    RenderPassCreateInfo2(
      VULKAN_HPP_NAMESPACE::RenderPassCreateFlags flags_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::AttachmentDescription2> const &
        attachments_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::SubpassDescription2> const &
        subpasses_ = {},
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::SubpassDependency2> const &
                                                                            dependencies_        = {},
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const & correlatedViewMasks_ = {} )
      : flags( flags_ )
      , attachmentCount( static_cast<uint32_t>( attachments_.size() ) )
      , pAttachments( attachments_.data() )
      , subpassCount( static_cast<uint32_t>( subpasses_.size() ) )
      , pSubpasses( subpasses_.data() )
      , dependencyCount( static_cast<uint32_t>( dependencies_.size() ) )
      , pDependencies( dependencies_.data() )
      , correlatedViewMaskCount( static_cast<uint32_t>( correlatedViewMasks_.size() ) )
      , pCorrelatedViewMasks( correlatedViewMasks_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 RenderPassCreateInfo2 &
                            operator=( RenderPassCreateInfo2 const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    RenderPassCreateInfo2 & operator=( VkRenderPassCreateInfo2 const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::RenderPassCreateInfo2 const *>( &rhs );
      return *this;
    }

    RenderPassCreateInfo2 & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    RenderPassCreateInfo2 & setFlags( VULKAN_HPP_NAMESPACE::RenderPassCreateFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    RenderPassCreateInfo2 & setAttachmentCount( uint32_t attachmentCount_ ) VULKAN_HPP_NOEXCEPT
    {
      attachmentCount = attachmentCount_;
      return *this;
    }

    RenderPassCreateInfo2 &
      setPAttachments( const VULKAN_HPP_NAMESPACE::AttachmentDescription2 * pAttachments_ ) VULKAN_HPP_NOEXCEPT
    {
      pAttachments = pAttachments_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    RenderPassCreateInfo2 & setAttachments(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::AttachmentDescription2> const &
        attachments_ ) VULKAN_HPP_NOEXCEPT
    {
      attachmentCount = static_cast<uint32_t>( attachments_.size() );
      pAttachments    = attachments_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    RenderPassCreateInfo2 & setSubpassCount( uint32_t subpassCount_ ) VULKAN_HPP_NOEXCEPT
    {
      subpassCount = subpassCount_;
      return *this;
    }

    RenderPassCreateInfo2 &
      setPSubpasses( const VULKAN_HPP_NAMESPACE::SubpassDescription2 * pSubpasses_ ) VULKAN_HPP_NOEXCEPT
    {
      pSubpasses = pSubpasses_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    RenderPassCreateInfo2 & setSubpasses(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::SubpassDescription2> const &
        subpasses_ ) VULKAN_HPP_NOEXCEPT
    {
      subpassCount = static_cast<uint32_t>( subpasses_.size() );
      pSubpasses   = subpasses_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    RenderPassCreateInfo2 & setDependencyCount( uint32_t dependencyCount_ ) VULKAN_HPP_NOEXCEPT
    {
      dependencyCount = dependencyCount_;
      return *this;
    }

    RenderPassCreateInfo2 &
      setPDependencies( const VULKAN_HPP_NAMESPACE::SubpassDependency2 * pDependencies_ ) VULKAN_HPP_NOEXCEPT
    {
      pDependencies = pDependencies_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    RenderPassCreateInfo2 & setDependencies(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::SubpassDependency2> const &
        dependencies_ ) VULKAN_HPP_NOEXCEPT
    {
      dependencyCount = static_cast<uint32_t>( dependencies_.size() );
      pDependencies   = dependencies_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    RenderPassCreateInfo2 & setCorrelatedViewMaskCount( uint32_t correlatedViewMaskCount_ ) VULKAN_HPP_NOEXCEPT
    {
      correlatedViewMaskCount = correlatedViewMaskCount_;
      return *this;
    }

    RenderPassCreateInfo2 & setPCorrelatedViewMasks( const uint32_t * pCorrelatedViewMasks_ ) VULKAN_HPP_NOEXCEPT
    {
      pCorrelatedViewMasks = pCorrelatedViewMasks_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    RenderPassCreateInfo2 & setCorrelatedViewMasks(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const & correlatedViewMasks_ ) VULKAN_HPP_NOEXCEPT
    {
      correlatedViewMaskCount = static_cast<uint32_t>( correlatedViewMasks_.size() );
      pCorrelatedViewMasks    = correlatedViewMasks_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkRenderPassCreateInfo2 const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkRenderPassCreateInfo2 *>( this );
    }

    operator VkRenderPassCreateInfo2 &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkRenderPassCreateInfo2 *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( RenderPassCreateInfo2 const & ) const = default;
#else
    bool operator==( RenderPassCreateInfo2 const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( attachmentCount == rhs.attachmentCount ) && ( pAttachments == rhs.pAttachments ) &&
             ( subpassCount == rhs.subpassCount ) && ( pSubpasses == rhs.pSubpasses ) &&
             ( dependencyCount == rhs.dependencyCount ) && ( pDependencies == rhs.pDependencies ) &&
             ( correlatedViewMaskCount == rhs.correlatedViewMaskCount ) &&
             ( pCorrelatedViewMasks == rhs.pCorrelatedViewMasks );
    }

    bool operator!=( RenderPassCreateInfo2 const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                  sType           = StructureType::eRenderPassCreateInfo2;
    const void *                                         pNext           = {};
    VULKAN_HPP_NAMESPACE::RenderPassCreateFlags          flags           = {};
    uint32_t                                             attachmentCount = {};
    const VULKAN_HPP_NAMESPACE::AttachmentDescription2 * pAttachments    = {};
    uint32_t                                             subpassCount    = {};
    const VULKAN_HPP_NAMESPACE::SubpassDescription2 *    pSubpasses      = {};
    uint32_t                                             dependencyCount = {};
    const VULKAN_HPP_NAMESPACE::SubpassDependency2 *     pDependencies   = {};
    uint32_t                                             correlatedViewMaskCount = {};
    const uint32_t *                                     pCorrelatedViewMasks    = {};
  };
  static_assert( sizeof( RenderPassCreateInfo2 ) == sizeof( VkRenderPassCreateInfo2 ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<RenderPassCreateInfo2>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eRenderPassCreateInfo2>
  {
    using Type = RenderPassCreateInfo2;
  };
  using RenderPassCreateInfo2KHR = RenderPassCreateInfo2;

  struct RenderPassFragmentDensityMapCreateInfoEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eRenderPassFragmentDensityMapCreateInfoEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR RenderPassFragmentDensityMapCreateInfoEXT(
      VULKAN_HPP_NAMESPACE::AttachmentReference fragmentDensityMapAttachment_ = {} ) VULKAN_HPP_NOEXCEPT
      : fragmentDensityMapAttachment( fragmentDensityMapAttachment_ )
    {}

    VULKAN_HPP_CONSTEXPR RenderPassFragmentDensityMapCreateInfoEXT(
      RenderPassFragmentDensityMapCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    RenderPassFragmentDensityMapCreateInfoEXT( VkRenderPassFragmentDensityMapCreateInfoEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : RenderPassFragmentDensityMapCreateInfoEXT(
          *reinterpret_cast<RenderPassFragmentDensityMapCreateInfoEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 RenderPassFragmentDensityMapCreateInfoEXT &
                            operator=( RenderPassFragmentDensityMapCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    RenderPassFragmentDensityMapCreateInfoEXT &
      operator=( VkRenderPassFragmentDensityMapCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::RenderPassFragmentDensityMapCreateInfoEXT const *>( &rhs );
      return *this;
    }

    RenderPassFragmentDensityMapCreateInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    RenderPassFragmentDensityMapCreateInfoEXT & setFragmentDensityMapAttachment(
      VULKAN_HPP_NAMESPACE::AttachmentReference const & fragmentDensityMapAttachment_ ) VULKAN_HPP_NOEXCEPT
    {
      fragmentDensityMapAttachment = fragmentDensityMapAttachment_;
      return *this;
    }

    operator VkRenderPassFragmentDensityMapCreateInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkRenderPassFragmentDensityMapCreateInfoEXT *>( this );
    }

    operator VkRenderPassFragmentDensityMapCreateInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkRenderPassFragmentDensityMapCreateInfoEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( RenderPassFragmentDensityMapCreateInfoEXT const & ) const = default;
#else
    bool operator==( RenderPassFragmentDensityMapCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( fragmentDensityMapAttachment == rhs.fragmentDensityMapAttachment );
    }

    bool operator!=( RenderPassFragmentDensityMapCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType       sType = StructureType::eRenderPassFragmentDensityMapCreateInfoEXT;
    const void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::AttachmentReference fragmentDensityMapAttachment = {};
  };
  static_assert( sizeof( RenderPassFragmentDensityMapCreateInfoEXT ) ==
                   sizeof( VkRenderPassFragmentDensityMapCreateInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<RenderPassFragmentDensityMapCreateInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eRenderPassFragmentDensityMapCreateInfoEXT>
  {
    using Type = RenderPassFragmentDensityMapCreateInfoEXT;
  };

  struct RenderPassInputAttachmentAspectCreateInfo
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eRenderPassInputAttachmentAspectCreateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR RenderPassInputAttachmentAspectCreateInfo(
      uint32_t                                                     aspectReferenceCount_ = {},
      const VULKAN_HPP_NAMESPACE::InputAttachmentAspectReference * pAspectReferences_    = {} ) VULKAN_HPP_NOEXCEPT
      : aspectReferenceCount( aspectReferenceCount_ )
      , pAspectReferences( pAspectReferences_ )
    {}

    VULKAN_HPP_CONSTEXPR RenderPassInputAttachmentAspectCreateInfo(
      RenderPassInputAttachmentAspectCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    RenderPassInputAttachmentAspectCreateInfo( VkRenderPassInputAttachmentAspectCreateInfo const & rhs )
      VULKAN_HPP_NOEXCEPT
      : RenderPassInputAttachmentAspectCreateInfo(
          *reinterpret_cast<RenderPassInputAttachmentAspectCreateInfo const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    RenderPassInputAttachmentAspectCreateInfo(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::InputAttachmentAspectReference> const &
        aspectReferences_ )
      : aspectReferenceCount( static_cast<uint32_t>( aspectReferences_.size() ) )
      , pAspectReferences( aspectReferences_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 RenderPassInputAttachmentAspectCreateInfo &
                            operator=( RenderPassInputAttachmentAspectCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    RenderPassInputAttachmentAspectCreateInfo &
      operator=( VkRenderPassInputAttachmentAspectCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::RenderPassInputAttachmentAspectCreateInfo const *>( &rhs );
      return *this;
    }

    RenderPassInputAttachmentAspectCreateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    RenderPassInputAttachmentAspectCreateInfo &
      setAspectReferenceCount( uint32_t aspectReferenceCount_ ) VULKAN_HPP_NOEXCEPT
    {
      aspectReferenceCount = aspectReferenceCount_;
      return *this;
    }

    RenderPassInputAttachmentAspectCreateInfo & setPAspectReferences(
      const VULKAN_HPP_NAMESPACE::InputAttachmentAspectReference * pAspectReferences_ ) VULKAN_HPP_NOEXCEPT
    {
      pAspectReferences = pAspectReferences_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    RenderPassInputAttachmentAspectCreateInfo & setAspectReferences(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::InputAttachmentAspectReference> const &
        aspectReferences_ ) VULKAN_HPP_NOEXCEPT
    {
      aspectReferenceCount = static_cast<uint32_t>( aspectReferences_.size() );
      pAspectReferences    = aspectReferences_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkRenderPassInputAttachmentAspectCreateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkRenderPassInputAttachmentAspectCreateInfo *>( this );
    }

    operator VkRenderPassInputAttachmentAspectCreateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkRenderPassInputAttachmentAspectCreateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( RenderPassInputAttachmentAspectCreateInfo const & ) const = default;
#else
    bool operator==( RenderPassInputAttachmentAspectCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( aspectReferenceCount == rhs.aspectReferenceCount ) &&
             ( pAspectReferences == rhs.pAspectReferences );
    }

    bool operator!=( RenderPassInputAttachmentAspectCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::eRenderPassInputAttachmentAspectCreateInfo;
    const void *                        pNext = {};
    uint32_t                            aspectReferenceCount                       = {};
    const VULKAN_HPP_NAMESPACE::InputAttachmentAspectReference * pAspectReferences = {};
  };
  static_assert( sizeof( RenderPassInputAttachmentAspectCreateInfo ) ==
                   sizeof( VkRenderPassInputAttachmentAspectCreateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<RenderPassInputAttachmentAspectCreateInfo>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eRenderPassInputAttachmentAspectCreateInfo>
  {
    using Type = RenderPassInputAttachmentAspectCreateInfo;
  };
  using RenderPassInputAttachmentAspectCreateInfoKHR = RenderPassInputAttachmentAspectCreateInfo;

  struct RenderPassMultiviewCreateInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eRenderPassMultiviewCreateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR RenderPassMultiviewCreateInfo( uint32_t         subpassCount_         = {},
                                                        const uint32_t * pViewMasks_           = {},
                                                        uint32_t         dependencyCount_      = {},
                                                        const int32_t *  pViewOffsets_         = {},
                                                        uint32_t         correlationMaskCount_ = {},
                                                        const uint32_t * pCorrelationMasks_ = {} ) VULKAN_HPP_NOEXCEPT
      : subpassCount( subpassCount_ )
      , pViewMasks( pViewMasks_ )
      , dependencyCount( dependencyCount_ )
      , pViewOffsets( pViewOffsets_ )
      , correlationMaskCount( correlationMaskCount_ )
      , pCorrelationMasks( pCorrelationMasks_ )
    {}

    VULKAN_HPP_CONSTEXPR
      RenderPassMultiviewCreateInfo( RenderPassMultiviewCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    RenderPassMultiviewCreateInfo( VkRenderPassMultiviewCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : RenderPassMultiviewCreateInfo( *reinterpret_cast<RenderPassMultiviewCreateInfo const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    RenderPassMultiviewCreateInfo(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const & viewMasks_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const int32_t> const &  viewOffsets_      = {},
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const & correlationMasks_ = {} )
      : subpassCount( static_cast<uint32_t>( viewMasks_.size() ) )
      , pViewMasks( viewMasks_.data() )
      , dependencyCount( static_cast<uint32_t>( viewOffsets_.size() ) )
      , pViewOffsets( viewOffsets_.data() )
      , correlationMaskCount( static_cast<uint32_t>( correlationMasks_.size() ) )
      , pCorrelationMasks( correlationMasks_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 RenderPassMultiviewCreateInfo &
                            operator=( RenderPassMultiviewCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    RenderPassMultiviewCreateInfo & operator=( VkRenderPassMultiviewCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::RenderPassMultiviewCreateInfo const *>( &rhs );
      return *this;
    }

    RenderPassMultiviewCreateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    RenderPassMultiviewCreateInfo & setSubpassCount( uint32_t subpassCount_ ) VULKAN_HPP_NOEXCEPT
    {
      subpassCount = subpassCount_;
      return *this;
    }

    RenderPassMultiviewCreateInfo & setPViewMasks( const uint32_t * pViewMasks_ ) VULKAN_HPP_NOEXCEPT
    {
      pViewMasks = pViewMasks_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    RenderPassMultiviewCreateInfo & setViewMasks(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const & viewMasks_ ) VULKAN_HPP_NOEXCEPT
    {
      subpassCount = static_cast<uint32_t>( viewMasks_.size() );
      pViewMasks   = viewMasks_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    RenderPassMultiviewCreateInfo & setDependencyCount( uint32_t dependencyCount_ ) VULKAN_HPP_NOEXCEPT
    {
      dependencyCount = dependencyCount_;
      return *this;
    }

    RenderPassMultiviewCreateInfo & setPViewOffsets( const int32_t * pViewOffsets_ ) VULKAN_HPP_NOEXCEPT
    {
      pViewOffsets = pViewOffsets_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    RenderPassMultiviewCreateInfo & setViewOffsets(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const int32_t> const & viewOffsets_ ) VULKAN_HPP_NOEXCEPT
    {
      dependencyCount = static_cast<uint32_t>( viewOffsets_.size() );
      pViewOffsets    = viewOffsets_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    RenderPassMultiviewCreateInfo & setCorrelationMaskCount( uint32_t correlationMaskCount_ ) VULKAN_HPP_NOEXCEPT
    {
      correlationMaskCount = correlationMaskCount_;
      return *this;
    }

    RenderPassMultiviewCreateInfo & setPCorrelationMasks( const uint32_t * pCorrelationMasks_ ) VULKAN_HPP_NOEXCEPT
    {
      pCorrelationMasks = pCorrelationMasks_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    RenderPassMultiviewCreateInfo & setCorrelationMasks(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const & correlationMasks_ ) VULKAN_HPP_NOEXCEPT
    {
      correlationMaskCount = static_cast<uint32_t>( correlationMasks_.size() );
      pCorrelationMasks    = correlationMasks_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkRenderPassMultiviewCreateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkRenderPassMultiviewCreateInfo *>( this );
    }

    operator VkRenderPassMultiviewCreateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkRenderPassMultiviewCreateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( RenderPassMultiviewCreateInfo const & ) const = default;
#else
    bool operator==( RenderPassMultiviewCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( subpassCount == rhs.subpassCount ) &&
             ( pViewMasks == rhs.pViewMasks ) && ( dependencyCount == rhs.dependencyCount ) &&
             ( pViewOffsets == rhs.pViewOffsets ) && ( correlationMaskCount == rhs.correlationMaskCount ) &&
             ( pCorrelationMasks == rhs.pCorrelationMasks );
    }

    bool operator!=( RenderPassMultiviewCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType                = StructureType::eRenderPassMultiviewCreateInfo;
    const void *                        pNext                = {};
    uint32_t                            subpassCount         = {};
    const uint32_t *                    pViewMasks           = {};
    uint32_t                            dependencyCount      = {};
    const int32_t *                     pViewOffsets         = {};
    uint32_t                            correlationMaskCount = {};
    const uint32_t *                    pCorrelationMasks    = {};
  };
  static_assert( sizeof( RenderPassMultiviewCreateInfo ) == sizeof( VkRenderPassMultiviewCreateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<RenderPassMultiviewCreateInfo>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eRenderPassMultiviewCreateInfo>
  {
    using Type = RenderPassMultiviewCreateInfo;
  };
  using RenderPassMultiviewCreateInfoKHR = RenderPassMultiviewCreateInfo;

  struct SubpassSampleLocationsEXT
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR SubpassSampleLocationsEXT(
      uint32_t                                     subpassIndex_        = {},
      VULKAN_HPP_NAMESPACE::SampleLocationsInfoEXT sampleLocationsInfo_ = {} ) VULKAN_HPP_NOEXCEPT
      : subpassIndex( subpassIndex_ )
      , sampleLocationsInfo( sampleLocationsInfo_ )
    {}

    VULKAN_HPP_CONSTEXPR
      SubpassSampleLocationsEXT( SubpassSampleLocationsEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SubpassSampleLocationsEXT( VkSubpassSampleLocationsEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : SubpassSampleLocationsEXT( *reinterpret_cast<SubpassSampleLocationsEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SubpassSampleLocationsEXT &
                            operator=( SubpassSampleLocationsEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SubpassSampleLocationsEXT & operator=( VkSubpassSampleLocationsEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SubpassSampleLocationsEXT const *>( &rhs );
      return *this;
    }

    SubpassSampleLocationsEXT & setSubpassIndex( uint32_t subpassIndex_ ) VULKAN_HPP_NOEXCEPT
    {
      subpassIndex = subpassIndex_;
      return *this;
    }

    SubpassSampleLocationsEXT & setSampleLocationsInfo(
      VULKAN_HPP_NAMESPACE::SampleLocationsInfoEXT const & sampleLocationsInfo_ ) VULKAN_HPP_NOEXCEPT
    {
      sampleLocationsInfo = sampleLocationsInfo_;
      return *this;
    }

    operator VkSubpassSampleLocationsEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSubpassSampleLocationsEXT *>( this );
    }

    operator VkSubpassSampleLocationsEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSubpassSampleLocationsEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SubpassSampleLocationsEXT const & ) const = default;
#else
    bool operator==( SubpassSampleLocationsEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( subpassIndex == rhs.subpassIndex ) && ( sampleLocationsInfo == rhs.sampleLocationsInfo );
    }

    bool operator!=( SubpassSampleLocationsEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    uint32_t                                     subpassIndex        = {};
    VULKAN_HPP_NAMESPACE::SampleLocationsInfoEXT sampleLocationsInfo = {};
  };
  static_assert( sizeof( SubpassSampleLocationsEXT ) == sizeof( VkSubpassSampleLocationsEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SubpassSampleLocationsEXT>::value,
                 "struct wrapper is not a standard layout!" );

  struct RenderPassSampleLocationsBeginInfoEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eRenderPassSampleLocationsBeginInfoEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR RenderPassSampleLocationsBeginInfoEXT(
      uint32_t                                                   attachmentInitialSampleLocationsCount_ = {},
      const VULKAN_HPP_NAMESPACE::AttachmentSampleLocationsEXT * pAttachmentInitialSampleLocations_     = {},
      uint32_t                                                   postSubpassSampleLocationsCount_       = {},
      const VULKAN_HPP_NAMESPACE::SubpassSampleLocationsEXT *    pPostSubpassSampleLocations_ = {} ) VULKAN_HPP_NOEXCEPT
      : attachmentInitialSampleLocationsCount( attachmentInitialSampleLocationsCount_ )
      , pAttachmentInitialSampleLocations( pAttachmentInitialSampleLocations_ )
      , postSubpassSampleLocationsCount( postSubpassSampleLocationsCount_ )
      , pPostSubpassSampleLocations( pPostSubpassSampleLocations_ )
    {}

    VULKAN_HPP_CONSTEXPR RenderPassSampleLocationsBeginInfoEXT( RenderPassSampleLocationsBeginInfoEXT const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    RenderPassSampleLocationsBeginInfoEXT( VkRenderPassSampleLocationsBeginInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : RenderPassSampleLocationsBeginInfoEXT(
          *reinterpret_cast<RenderPassSampleLocationsBeginInfoEXT const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    RenderPassSampleLocationsBeginInfoEXT(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::AttachmentSampleLocationsEXT> const &
        attachmentInitialSampleLocations_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::SubpassSampleLocationsEXT> const &
        postSubpassSampleLocations_ = {} )
      : attachmentInitialSampleLocationsCount( static_cast<uint32_t>( attachmentInitialSampleLocations_.size() ) )
      , pAttachmentInitialSampleLocations( attachmentInitialSampleLocations_.data() )
      , postSubpassSampleLocationsCount( static_cast<uint32_t>( postSubpassSampleLocations_.size() ) )
      , pPostSubpassSampleLocations( postSubpassSampleLocations_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 RenderPassSampleLocationsBeginInfoEXT &
                            operator=( RenderPassSampleLocationsBeginInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    RenderPassSampleLocationsBeginInfoEXT &
      operator=( VkRenderPassSampleLocationsBeginInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::RenderPassSampleLocationsBeginInfoEXT const *>( &rhs );
      return *this;
    }

    RenderPassSampleLocationsBeginInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    RenderPassSampleLocationsBeginInfoEXT &
      setAttachmentInitialSampleLocationsCount( uint32_t attachmentInitialSampleLocationsCount_ ) VULKAN_HPP_NOEXCEPT
    {
      attachmentInitialSampleLocationsCount = attachmentInitialSampleLocationsCount_;
      return *this;
    }

    RenderPassSampleLocationsBeginInfoEXT & setPAttachmentInitialSampleLocations(
      const VULKAN_HPP_NAMESPACE::AttachmentSampleLocationsEXT * pAttachmentInitialSampleLocations_ )
      VULKAN_HPP_NOEXCEPT
    {
      pAttachmentInitialSampleLocations = pAttachmentInitialSampleLocations_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    RenderPassSampleLocationsBeginInfoEXT & setAttachmentInitialSampleLocations(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::AttachmentSampleLocationsEXT> const &
        attachmentInitialSampleLocations_ ) VULKAN_HPP_NOEXCEPT
    {
      attachmentInitialSampleLocationsCount = static_cast<uint32_t>( attachmentInitialSampleLocations_.size() );
      pAttachmentInitialSampleLocations     = attachmentInitialSampleLocations_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    RenderPassSampleLocationsBeginInfoEXT &
      setPostSubpassSampleLocationsCount( uint32_t postSubpassSampleLocationsCount_ ) VULKAN_HPP_NOEXCEPT
    {
      postSubpassSampleLocationsCount = postSubpassSampleLocationsCount_;
      return *this;
    }

    RenderPassSampleLocationsBeginInfoEXT & setPPostSubpassSampleLocations(
      const VULKAN_HPP_NAMESPACE::SubpassSampleLocationsEXT * pPostSubpassSampleLocations_ ) VULKAN_HPP_NOEXCEPT
    {
      pPostSubpassSampleLocations = pPostSubpassSampleLocations_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    RenderPassSampleLocationsBeginInfoEXT & setPostSubpassSampleLocations(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::SubpassSampleLocationsEXT> const &
        postSubpassSampleLocations_ ) VULKAN_HPP_NOEXCEPT
    {
      postSubpassSampleLocationsCount = static_cast<uint32_t>( postSubpassSampleLocations_.size() );
      pPostSubpassSampleLocations     = postSubpassSampleLocations_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkRenderPassSampleLocationsBeginInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkRenderPassSampleLocationsBeginInfoEXT *>( this );
    }

    operator VkRenderPassSampleLocationsBeginInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkRenderPassSampleLocationsBeginInfoEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( RenderPassSampleLocationsBeginInfoEXT const & ) const = default;
#else
    bool operator==( RenderPassSampleLocationsBeginInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( attachmentInitialSampleLocationsCount == rhs.attachmentInitialSampleLocationsCount ) &&
             ( pAttachmentInitialSampleLocations == rhs.pAttachmentInitialSampleLocations ) &&
             ( postSubpassSampleLocationsCount == rhs.postSubpassSampleLocationsCount ) &&
             ( pPostSubpassSampleLocations == rhs.pPostSubpassSampleLocations );
    }

    bool operator!=( RenderPassSampleLocationsBeginInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::eRenderPassSampleLocationsBeginInfoEXT;
    const void *                        pNext = {};
    uint32_t                            attachmentInitialSampleLocationsCount                    = {};
    const VULKAN_HPP_NAMESPACE::AttachmentSampleLocationsEXT * pAttachmentInitialSampleLocations = {};
    uint32_t                                                   postSubpassSampleLocationsCount   = {};
    const VULKAN_HPP_NAMESPACE::SubpassSampleLocationsEXT *    pPostSubpassSampleLocations       = {};
  };
  static_assert( sizeof( RenderPassSampleLocationsBeginInfoEXT ) == sizeof( VkRenderPassSampleLocationsBeginInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<RenderPassSampleLocationsBeginInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eRenderPassSampleLocationsBeginInfoEXT>
  {
    using Type = RenderPassSampleLocationsBeginInfoEXT;
  };

  struct RenderPassTransformBeginInfoQCOM
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eRenderPassTransformBeginInfoQCOM;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR RenderPassTransformBeginInfoQCOM(
      VULKAN_HPP_NAMESPACE::SurfaceTransformFlagBitsKHR transform_ =
        VULKAN_HPP_NAMESPACE::SurfaceTransformFlagBitsKHR::eIdentity ) VULKAN_HPP_NOEXCEPT : transform( transform_ )
    {}

    VULKAN_HPP_CONSTEXPR
      RenderPassTransformBeginInfoQCOM( RenderPassTransformBeginInfoQCOM const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    RenderPassTransformBeginInfoQCOM( VkRenderPassTransformBeginInfoQCOM const & rhs ) VULKAN_HPP_NOEXCEPT
      : RenderPassTransformBeginInfoQCOM( *reinterpret_cast<RenderPassTransformBeginInfoQCOM const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 RenderPassTransformBeginInfoQCOM &
                            operator=( RenderPassTransformBeginInfoQCOM const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    RenderPassTransformBeginInfoQCOM & operator=( VkRenderPassTransformBeginInfoQCOM const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::RenderPassTransformBeginInfoQCOM const *>( &rhs );
      return *this;
    }

    RenderPassTransformBeginInfoQCOM & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    RenderPassTransformBeginInfoQCOM &
      setTransform( VULKAN_HPP_NAMESPACE::SurfaceTransformFlagBitsKHR transform_ ) VULKAN_HPP_NOEXCEPT
    {
      transform = transform_;
      return *this;
    }

    operator VkRenderPassTransformBeginInfoQCOM const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkRenderPassTransformBeginInfoQCOM *>( this );
    }

    operator VkRenderPassTransformBeginInfoQCOM &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkRenderPassTransformBeginInfoQCOM *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( RenderPassTransformBeginInfoQCOM const & ) const = default;
#else
    bool operator==( RenderPassTransformBeginInfoQCOM const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( transform == rhs.transform );
    }

    bool operator!=( RenderPassTransformBeginInfoQCOM const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType               sType = StructureType::eRenderPassTransformBeginInfoQCOM;
    void *                                            pNext = {};
    VULKAN_HPP_NAMESPACE::SurfaceTransformFlagBitsKHR transform =
      VULKAN_HPP_NAMESPACE::SurfaceTransformFlagBitsKHR::eIdentity;
  };
  static_assert( sizeof( RenderPassTransformBeginInfoQCOM ) == sizeof( VkRenderPassTransformBeginInfoQCOM ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<RenderPassTransformBeginInfoQCOM>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eRenderPassTransformBeginInfoQCOM>
  {
    using Type = RenderPassTransformBeginInfoQCOM;
  };

  struct ResolveImageInfo2KHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eResolveImageInfo2KHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ResolveImageInfo2KHR(
      VULKAN_HPP_NAMESPACE::Image                    srcImage_       = {},
      VULKAN_HPP_NAMESPACE::ImageLayout              srcImageLayout_ = VULKAN_HPP_NAMESPACE::ImageLayout::eUndefined,
      VULKAN_HPP_NAMESPACE::Image                    dstImage_       = {},
      VULKAN_HPP_NAMESPACE::ImageLayout              dstImageLayout_ = VULKAN_HPP_NAMESPACE::ImageLayout::eUndefined,
      uint32_t                                       regionCount_    = {},
      const VULKAN_HPP_NAMESPACE::ImageResolve2KHR * pRegions_       = {} ) VULKAN_HPP_NOEXCEPT
      : srcImage( srcImage_ )
      , srcImageLayout( srcImageLayout_ )
      , dstImage( dstImage_ )
      , dstImageLayout( dstImageLayout_ )
      , regionCount( regionCount_ )
      , pRegions( pRegions_ )
    {}

    VULKAN_HPP_CONSTEXPR ResolveImageInfo2KHR( ResolveImageInfo2KHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ResolveImageInfo2KHR( VkResolveImageInfo2KHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : ResolveImageInfo2KHR( *reinterpret_cast<ResolveImageInfo2KHR const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    ResolveImageInfo2KHR(
      VULKAN_HPP_NAMESPACE::Image       srcImage_,
      VULKAN_HPP_NAMESPACE::ImageLayout srcImageLayout_,
      VULKAN_HPP_NAMESPACE::Image       dstImage_,
      VULKAN_HPP_NAMESPACE::ImageLayout dstImageLayout_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::ImageResolve2KHR> const & regions_ )
      : srcImage( srcImage_ )
      , srcImageLayout( srcImageLayout_ )
      , dstImage( dstImage_ )
      , dstImageLayout( dstImageLayout_ )
      , regionCount( static_cast<uint32_t>( regions_.size() ) )
      , pRegions( regions_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ResolveImageInfo2KHR &
                            operator=( ResolveImageInfo2KHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ResolveImageInfo2KHR & operator=( VkResolveImageInfo2KHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ResolveImageInfo2KHR const *>( &rhs );
      return *this;
    }

    ResolveImageInfo2KHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ResolveImageInfo2KHR & setSrcImage( VULKAN_HPP_NAMESPACE::Image srcImage_ ) VULKAN_HPP_NOEXCEPT
    {
      srcImage = srcImage_;
      return *this;
    }

    ResolveImageInfo2KHR & setSrcImageLayout( VULKAN_HPP_NAMESPACE::ImageLayout srcImageLayout_ ) VULKAN_HPP_NOEXCEPT
    {
      srcImageLayout = srcImageLayout_;
      return *this;
    }

    ResolveImageInfo2KHR & setDstImage( VULKAN_HPP_NAMESPACE::Image dstImage_ ) VULKAN_HPP_NOEXCEPT
    {
      dstImage = dstImage_;
      return *this;
    }

    ResolveImageInfo2KHR & setDstImageLayout( VULKAN_HPP_NAMESPACE::ImageLayout dstImageLayout_ ) VULKAN_HPP_NOEXCEPT
    {
      dstImageLayout = dstImageLayout_;
      return *this;
    }

    ResolveImageInfo2KHR & setRegionCount( uint32_t regionCount_ ) VULKAN_HPP_NOEXCEPT
    {
      regionCount = regionCount_;
      return *this;
    }

    ResolveImageInfo2KHR & setPRegions( const VULKAN_HPP_NAMESPACE::ImageResolve2KHR * pRegions_ ) VULKAN_HPP_NOEXCEPT
    {
      pRegions = pRegions_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    ResolveImageInfo2KHR & setRegions(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::ImageResolve2KHR> const & regions_ )
      VULKAN_HPP_NOEXCEPT
    {
      regionCount = static_cast<uint32_t>( regions_.size() );
      pRegions    = regions_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkResolveImageInfo2KHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkResolveImageInfo2KHR *>( this );
    }

    operator VkResolveImageInfo2KHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkResolveImageInfo2KHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ResolveImageInfo2KHR const & ) const = default;
#else
    bool operator==( ResolveImageInfo2KHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( srcImage == rhs.srcImage ) &&
             ( srcImageLayout == rhs.srcImageLayout ) && ( dstImage == rhs.dstImage ) &&
             ( dstImageLayout == rhs.dstImageLayout ) && ( regionCount == rhs.regionCount ) &&
             ( pRegions == rhs.pRegions );
    }

    bool operator!=( ResolveImageInfo2KHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType            sType          = StructureType::eResolveImageInfo2KHR;
    const void *                                   pNext          = {};
    VULKAN_HPP_NAMESPACE::Image                    srcImage       = {};
    VULKAN_HPP_NAMESPACE::ImageLayout              srcImageLayout = VULKAN_HPP_NAMESPACE::ImageLayout::eUndefined;
    VULKAN_HPP_NAMESPACE::Image                    dstImage       = {};
    VULKAN_HPP_NAMESPACE::ImageLayout              dstImageLayout = VULKAN_HPP_NAMESPACE::ImageLayout::eUndefined;
    uint32_t                                       regionCount    = {};
    const VULKAN_HPP_NAMESPACE::ImageResolve2KHR * pRegions       = {};
  };
  static_assert( sizeof( ResolveImageInfo2KHR ) == sizeof( VkResolveImageInfo2KHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ResolveImageInfo2KHR>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eResolveImageInfo2KHR>
  {
    using Type = ResolveImageInfo2KHR;
  };

  struct SamplerCreateInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eSamplerCreateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR SamplerCreateInfo(
      VULKAN_HPP_NAMESPACE::SamplerCreateFlags flags_            = {},
      VULKAN_HPP_NAMESPACE::Filter             magFilter_        = VULKAN_HPP_NAMESPACE::Filter::eNearest,
      VULKAN_HPP_NAMESPACE::Filter             minFilter_        = VULKAN_HPP_NAMESPACE::Filter::eNearest,
      VULKAN_HPP_NAMESPACE::SamplerMipmapMode  mipmapMode_       = VULKAN_HPP_NAMESPACE::SamplerMipmapMode::eNearest,
      VULKAN_HPP_NAMESPACE::SamplerAddressMode addressModeU_     = VULKAN_HPP_NAMESPACE::SamplerAddressMode::eRepeat,
      VULKAN_HPP_NAMESPACE::SamplerAddressMode addressModeV_     = VULKAN_HPP_NAMESPACE::SamplerAddressMode::eRepeat,
      VULKAN_HPP_NAMESPACE::SamplerAddressMode addressModeW_     = VULKAN_HPP_NAMESPACE::SamplerAddressMode::eRepeat,
      float                                    mipLodBias_       = {},
      VULKAN_HPP_NAMESPACE::Bool32             anisotropyEnable_ = {},
      float                                    maxAnisotropy_    = {},
      VULKAN_HPP_NAMESPACE::Bool32             compareEnable_    = {},
      VULKAN_HPP_NAMESPACE::CompareOp          compareOp_        = VULKAN_HPP_NAMESPACE::CompareOp::eNever,
      float                                    minLod_           = {},
      float                                    maxLod_           = {},
      VULKAN_HPP_NAMESPACE::BorderColor        borderColor_ = VULKAN_HPP_NAMESPACE::BorderColor::eFloatTransparentBlack,
      VULKAN_HPP_NAMESPACE::Bool32             unnormalizedCoordinates_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , magFilter( magFilter_ )
      , minFilter( minFilter_ )
      , mipmapMode( mipmapMode_ )
      , addressModeU( addressModeU_ )
      , addressModeV( addressModeV_ )
      , addressModeW( addressModeW_ )
      , mipLodBias( mipLodBias_ )
      , anisotropyEnable( anisotropyEnable_ )
      , maxAnisotropy( maxAnisotropy_ )
      , compareEnable( compareEnable_ )
      , compareOp( compareOp_ )
      , minLod( minLod_ )
      , maxLod( maxLod_ )
      , borderColor( borderColor_ )
      , unnormalizedCoordinates( unnormalizedCoordinates_ )
    {}

    VULKAN_HPP_CONSTEXPR SamplerCreateInfo( SamplerCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SamplerCreateInfo( VkSamplerCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : SamplerCreateInfo( *reinterpret_cast<SamplerCreateInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SamplerCreateInfo &
                            operator=( SamplerCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SamplerCreateInfo & operator=( VkSamplerCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SamplerCreateInfo const *>( &rhs );
      return *this;
    }

    SamplerCreateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    SamplerCreateInfo & setFlags( VULKAN_HPP_NAMESPACE::SamplerCreateFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    SamplerCreateInfo & setMagFilter( VULKAN_HPP_NAMESPACE::Filter magFilter_ ) VULKAN_HPP_NOEXCEPT
    {
      magFilter = magFilter_;
      return *this;
    }

    SamplerCreateInfo & setMinFilter( VULKAN_HPP_NAMESPACE::Filter minFilter_ ) VULKAN_HPP_NOEXCEPT
    {
      minFilter = minFilter_;
      return *this;
    }

    SamplerCreateInfo & setMipmapMode( VULKAN_HPP_NAMESPACE::SamplerMipmapMode mipmapMode_ ) VULKAN_HPP_NOEXCEPT
    {
      mipmapMode = mipmapMode_;
      return *this;
    }

    SamplerCreateInfo & setAddressModeU( VULKAN_HPP_NAMESPACE::SamplerAddressMode addressModeU_ ) VULKAN_HPP_NOEXCEPT
    {
      addressModeU = addressModeU_;
      return *this;
    }

    SamplerCreateInfo & setAddressModeV( VULKAN_HPP_NAMESPACE::SamplerAddressMode addressModeV_ ) VULKAN_HPP_NOEXCEPT
    {
      addressModeV = addressModeV_;
      return *this;
    }

    SamplerCreateInfo & setAddressModeW( VULKAN_HPP_NAMESPACE::SamplerAddressMode addressModeW_ ) VULKAN_HPP_NOEXCEPT
    {
      addressModeW = addressModeW_;
      return *this;
    }

    SamplerCreateInfo & setMipLodBias( float mipLodBias_ ) VULKAN_HPP_NOEXCEPT
    {
      mipLodBias = mipLodBias_;
      return *this;
    }

    SamplerCreateInfo & setAnisotropyEnable( VULKAN_HPP_NAMESPACE::Bool32 anisotropyEnable_ ) VULKAN_HPP_NOEXCEPT
    {
      anisotropyEnable = anisotropyEnable_;
      return *this;
    }

    SamplerCreateInfo & setMaxAnisotropy( float maxAnisotropy_ ) VULKAN_HPP_NOEXCEPT
    {
      maxAnisotropy = maxAnisotropy_;
      return *this;
    }

    SamplerCreateInfo & setCompareEnable( VULKAN_HPP_NAMESPACE::Bool32 compareEnable_ ) VULKAN_HPP_NOEXCEPT
    {
      compareEnable = compareEnable_;
      return *this;
    }

    SamplerCreateInfo & setCompareOp( VULKAN_HPP_NAMESPACE::CompareOp compareOp_ ) VULKAN_HPP_NOEXCEPT
    {
      compareOp = compareOp_;
      return *this;
    }

    SamplerCreateInfo & setMinLod( float minLod_ ) VULKAN_HPP_NOEXCEPT
    {
      minLod = minLod_;
      return *this;
    }

    SamplerCreateInfo & setMaxLod( float maxLod_ ) VULKAN_HPP_NOEXCEPT
    {
      maxLod = maxLod_;
      return *this;
    }

    SamplerCreateInfo & setBorderColor( VULKAN_HPP_NAMESPACE::BorderColor borderColor_ ) VULKAN_HPP_NOEXCEPT
    {
      borderColor = borderColor_;
      return *this;
    }

    SamplerCreateInfo &
      setUnnormalizedCoordinates( VULKAN_HPP_NAMESPACE::Bool32 unnormalizedCoordinates_ ) VULKAN_HPP_NOEXCEPT
    {
      unnormalizedCoordinates = unnormalizedCoordinates_;
      return *this;
    }

    operator VkSamplerCreateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSamplerCreateInfo *>( this );
    }

    operator VkSamplerCreateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSamplerCreateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SamplerCreateInfo const & ) const = default;
#else
    bool operator==( SamplerCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( magFilter == rhs.magFilter ) && ( minFilter == rhs.minFilter ) && ( mipmapMode == rhs.mipmapMode ) &&
             ( addressModeU == rhs.addressModeU ) && ( addressModeV == rhs.addressModeV ) &&
             ( addressModeW == rhs.addressModeW ) && ( mipLodBias == rhs.mipLodBias ) &&
             ( anisotropyEnable == rhs.anisotropyEnable ) && ( maxAnisotropy == rhs.maxAnisotropy ) &&
             ( compareEnable == rhs.compareEnable ) && ( compareOp == rhs.compareOp ) && ( minLod == rhs.minLod ) &&
             ( maxLod == rhs.maxLod ) && ( borderColor == rhs.borderColor ) &&
             ( unnormalizedCoordinates == rhs.unnormalizedCoordinates );
    }

    bool operator!=( SamplerCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType      sType            = StructureType::eSamplerCreateInfo;
    const void *                             pNext            = {};
    VULKAN_HPP_NAMESPACE::SamplerCreateFlags flags            = {};
    VULKAN_HPP_NAMESPACE::Filter             magFilter        = VULKAN_HPP_NAMESPACE::Filter::eNearest;
    VULKAN_HPP_NAMESPACE::Filter             minFilter        = VULKAN_HPP_NAMESPACE::Filter::eNearest;
    VULKAN_HPP_NAMESPACE::SamplerMipmapMode  mipmapMode       = VULKAN_HPP_NAMESPACE::SamplerMipmapMode::eNearest;
    VULKAN_HPP_NAMESPACE::SamplerAddressMode addressModeU     = VULKAN_HPP_NAMESPACE::SamplerAddressMode::eRepeat;
    VULKAN_HPP_NAMESPACE::SamplerAddressMode addressModeV     = VULKAN_HPP_NAMESPACE::SamplerAddressMode::eRepeat;
    VULKAN_HPP_NAMESPACE::SamplerAddressMode addressModeW     = VULKAN_HPP_NAMESPACE::SamplerAddressMode::eRepeat;
    float                                    mipLodBias       = {};
    VULKAN_HPP_NAMESPACE::Bool32             anisotropyEnable = {};
    float                                    maxAnisotropy    = {};
    VULKAN_HPP_NAMESPACE::Bool32             compareEnable    = {};
    VULKAN_HPP_NAMESPACE::CompareOp          compareOp        = VULKAN_HPP_NAMESPACE::CompareOp::eNever;
    float                                    minLod           = {};
    float                                    maxLod           = {};
    VULKAN_HPP_NAMESPACE::BorderColor        borderColor = VULKAN_HPP_NAMESPACE::BorderColor::eFloatTransparentBlack;
    VULKAN_HPP_NAMESPACE::Bool32             unnormalizedCoordinates = {};
  };
  static_assert( sizeof( SamplerCreateInfo ) == sizeof( VkSamplerCreateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SamplerCreateInfo>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eSamplerCreateInfo>
  {
    using Type = SamplerCreateInfo;
  };

  struct SamplerCustomBorderColorCreateInfoEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eSamplerCustomBorderColorCreateInfoEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    SamplerCustomBorderColorCreateInfoEXT(
      VULKAN_HPP_NAMESPACE::ClearColorValue customBorderColor_ = {},
      VULKAN_HPP_NAMESPACE::Format          format_ = VULKAN_HPP_NAMESPACE::Format::eUndefined ) VULKAN_HPP_NOEXCEPT
      : customBorderColor( customBorderColor_ )
      , format( format_ )
    {}

    SamplerCustomBorderColorCreateInfoEXT( SamplerCustomBorderColorCreateInfoEXT const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    SamplerCustomBorderColorCreateInfoEXT( VkSamplerCustomBorderColorCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : SamplerCustomBorderColorCreateInfoEXT(
          *reinterpret_cast<SamplerCustomBorderColorCreateInfoEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    SamplerCustomBorderColorCreateInfoEXT &
      operator=( SamplerCustomBorderColorCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SamplerCustomBorderColorCreateInfoEXT &
      operator=( VkSamplerCustomBorderColorCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SamplerCustomBorderColorCreateInfoEXT const *>( &rhs );
      return *this;
    }

    SamplerCustomBorderColorCreateInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    SamplerCustomBorderColorCreateInfoEXT &
      setCustomBorderColor( VULKAN_HPP_NAMESPACE::ClearColorValue const & customBorderColor_ ) VULKAN_HPP_NOEXCEPT
    {
      customBorderColor = customBorderColor_;
      return *this;
    }

    SamplerCustomBorderColorCreateInfoEXT & setFormat( VULKAN_HPP_NAMESPACE::Format format_ ) VULKAN_HPP_NOEXCEPT
    {
      format = format_;
      return *this;
    }

    operator VkSamplerCustomBorderColorCreateInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSamplerCustomBorderColorCreateInfoEXT *>( this );
    }

    operator VkSamplerCustomBorderColorCreateInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSamplerCustomBorderColorCreateInfoEXT *>( this );
    }

  public:
    VULKAN_HPP_NAMESPACE::StructureType   sType             = StructureType::eSamplerCustomBorderColorCreateInfoEXT;
    const void *                          pNext             = {};
    VULKAN_HPP_NAMESPACE::ClearColorValue customBorderColor = {};
    VULKAN_HPP_NAMESPACE::Format          format            = VULKAN_HPP_NAMESPACE::Format::eUndefined;
  };
  static_assert( sizeof( SamplerCustomBorderColorCreateInfoEXT ) == sizeof( VkSamplerCustomBorderColorCreateInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SamplerCustomBorderColorCreateInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eSamplerCustomBorderColorCreateInfoEXT>
  {
    using Type = SamplerCustomBorderColorCreateInfoEXT;
  };

  struct SamplerReductionModeCreateInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eSamplerReductionModeCreateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR SamplerReductionModeCreateInfo(
      VULKAN_HPP_NAMESPACE::SamplerReductionMode reductionMode_ =
        VULKAN_HPP_NAMESPACE::SamplerReductionMode::eWeightedAverage ) VULKAN_HPP_NOEXCEPT
      : reductionMode( reductionMode_ )
    {}

    VULKAN_HPP_CONSTEXPR
      SamplerReductionModeCreateInfo( SamplerReductionModeCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SamplerReductionModeCreateInfo( VkSamplerReductionModeCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : SamplerReductionModeCreateInfo( *reinterpret_cast<SamplerReductionModeCreateInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SamplerReductionModeCreateInfo &
                            operator=( SamplerReductionModeCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SamplerReductionModeCreateInfo & operator=( VkSamplerReductionModeCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SamplerReductionModeCreateInfo const *>( &rhs );
      return *this;
    }

    SamplerReductionModeCreateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    SamplerReductionModeCreateInfo &
      setReductionMode( VULKAN_HPP_NAMESPACE::SamplerReductionMode reductionMode_ ) VULKAN_HPP_NOEXCEPT
    {
      reductionMode = reductionMode_;
      return *this;
    }

    operator VkSamplerReductionModeCreateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSamplerReductionModeCreateInfo *>( this );
    }

    operator VkSamplerReductionModeCreateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSamplerReductionModeCreateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SamplerReductionModeCreateInfo const & ) const = default;
#else
    bool operator==( SamplerReductionModeCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( reductionMode == rhs.reductionMode );
    }

    bool operator!=( SamplerReductionModeCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType        sType = StructureType::eSamplerReductionModeCreateInfo;
    const void *                               pNext = {};
    VULKAN_HPP_NAMESPACE::SamplerReductionMode reductionMode =
      VULKAN_HPP_NAMESPACE::SamplerReductionMode::eWeightedAverage;
  };
  static_assert( sizeof( SamplerReductionModeCreateInfo ) == sizeof( VkSamplerReductionModeCreateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SamplerReductionModeCreateInfo>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eSamplerReductionModeCreateInfo>
  {
    using Type = SamplerReductionModeCreateInfo;
  };
  using SamplerReductionModeCreateInfoEXT = SamplerReductionModeCreateInfo;

  struct SamplerYcbcrConversionCreateInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eSamplerYcbcrConversionCreateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR SamplerYcbcrConversionCreateInfo(
      VULKAN_HPP_NAMESPACE::Format                      format_ = VULKAN_HPP_NAMESPACE::Format::eUndefined,
      VULKAN_HPP_NAMESPACE::SamplerYcbcrModelConversion ycbcrModel_ =
        VULKAN_HPP_NAMESPACE::SamplerYcbcrModelConversion::eRgbIdentity,
      VULKAN_HPP_NAMESPACE::SamplerYcbcrRange ycbcrRange_    = VULKAN_HPP_NAMESPACE::SamplerYcbcrRange::eItuFull,
      VULKAN_HPP_NAMESPACE::ComponentMapping  components_    = {},
      VULKAN_HPP_NAMESPACE::ChromaLocation    xChromaOffset_ = VULKAN_HPP_NAMESPACE::ChromaLocation::eCositedEven,
      VULKAN_HPP_NAMESPACE::ChromaLocation    yChromaOffset_ = VULKAN_HPP_NAMESPACE::ChromaLocation::eCositedEven,
      VULKAN_HPP_NAMESPACE::Filter            chromaFilter_  = VULKAN_HPP_NAMESPACE::Filter::eNearest,
      VULKAN_HPP_NAMESPACE::Bool32            forceExplicitReconstruction_ = {} ) VULKAN_HPP_NOEXCEPT
      : format( format_ )
      , ycbcrModel( ycbcrModel_ )
      , ycbcrRange( ycbcrRange_ )
      , components( components_ )
      , xChromaOffset( xChromaOffset_ )
      , yChromaOffset( yChromaOffset_ )
      , chromaFilter( chromaFilter_ )
      , forceExplicitReconstruction( forceExplicitReconstruction_ )
    {}

    VULKAN_HPP_CONSTEXPR
      SamplerYcbcrConversionCreateInfo( SamplerYcbcrConversionCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SamplerYcbcrConversionCreateInfo( VkSamplerYcbcrConversionCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : SamplerYcbcrConversionCreateInfo( *reinterpret_cast<SamplerYcbcrConversionCreateInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SamplerYcbcrConversionCreateInfo &
                            operator=( SamplerYcbcrConversionCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SamplerYcbcrConversionCreateInfo & operator=( VkSamplerYcbcrConversionCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SamplerYcbcrConversionCreateInfo const *>( &rhs );
      return *this;
    }

    SamplerYcbcrConversionCreateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    SamplerYcbcrConversionCreateInfo & setFormat( VULKAN_HPP_NAMESPACE::Format format_ ) VULKAN_HPP_NOEXCEPT
    {
      format = format_;
      return *this;
    }

    SamplerYcbcrConversionCreateInfo &
      setYcbcrModel( VULKAN_HPP_NAMESPACE::SamplerYcbcrModelConversion ycbcrModel_ ) VULKAN_HPP_NOEXCEPT
    {
      ycbcrModel = ycbcrModel_;
      return *this;
    }

    SamplerYcbcrConversionCreateInfo &
      setYcbcrRange( VULKAN_HPP_NAMESPACE::SamplerYcbcrRange ycbcrRange_ ) VULKAN_HPP_NOEXCEPT
    {
      ycbcrRange = ycbcrRange_;
      return *this;
    }

    SamplerYcbcrConversionCreateInfo &
      setComponents( VULKAN_HPP_NAMESPACE::ComponentMapping const & components_ ) VULKAN_HPP_NOEXCEPT
    {
      components = components_;
      return *this;
    }

    SamplerYcbcrConversionCreateInfo &
      setXChromaOffset( VULKAN_HPP_NAMESPACE::ChromaLocation xChromaOffset_ ) VULKAN_HPP_NOEXCEPT
    {
      xChromaOffset = xChromaOffset_;
      return *this;
    }

    SamplerYcbcrConversionCreateInfo &
      setYChromaOffset( VULKAN_HPP_NAMESPACE::ChromaLocation yChromaOffset_ ) VULKAN_HPP_NOEXCEPT
    {
      yChromaOffset = yChromaOffset_;
      return *this;
    }

    SamplerYcbcrConversionCreateInfo & setChromaFilter( VULKAN_HPP_NAMESPACE::Filter chromaFilter_ ) VULKAN_HPP_NOEXCEPT
    {
      chromaFilter = chromaFilter_;
      return *this;
    }

    SamplerYcbcrConversionCreateInfo &
      setForceExplicitReconstruction( VULKAN_HPP_NAMESPACE::Bool32 forceExplicitReconstruction_ ) VULKAN_HPP_NOEXCEPT
    {
      forceExplicitReconstruction = forceExplicitReconstruction_;
      return *this;
    }

    operator VkSamplerYcbcrConversionCreateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSamplerYcbcrConversionCreateInfo *>( this );
    }

    operator VkSamplerYcbcrConversionCreateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSamplerYcbcrConversionCreateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SamplerYcbcrConversionCreateInfo const & ) const = default;
#else
    bool operator==( SamplerYcbcrConversionCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( format == rhs.format ) &&
             ( ycbcrModel == rhs.ycbcrModel ) && ( ycbcrRange == rhs.ycbcrRange ) && ( components == rhs.components ) &&
             ( xChromaOffset == rhs.xChromaOffset ) && ( yChromaOffset == rhs.yChromaOffset ) &&
             ( chromaFilter == rhs.chromaFilter ) && ( forceExplicitReconstruction == rhs.forceExplicitReconstruction );
    }

    bool operator!=( SamplerYcbcrConversionCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType               sType  = StructureType::eSamplerYcbcrConversionCreateInfo;
    const void *                                      pNext  = {};
    VULKAN_HPP_NAMESPACE::Format                      format = VULKAN_HPP_NAMESPACE::Format::eUndefined;
    VULKAN_HPP_NAMESPACE::SamplerYcbcrModelConversion ycbcrModel =
      VULKAN_HPP_NAMESPACE::SamplerYcbcrModelConversion::eRgbIdentity;
    VULKAN_HPP_NAMESPACE::SamplerYcbcrRange ycbcrRange    = VULKAN_HPP_NAMESPACE::SamplerYcbcrRange::eItuFull;
    VULKAN_HPP_NAMESPACE::ComponentMapping  components    = {};
    VULKAN_HPP_NAMESPACE::ChromaLocation    xChromaOffset = VULKAN_HPP_NAMESPACE::ChromaLocation::eCositedEven;
    VULKAN_HPP_NAMESPACE::ChromaLocation    yChromaOffset = VULKAN_HPP_NAMESPACE::ChromaLocation::eCositedEven;
    VULKAN_HPP_NAMESPACE::Filter            chromaFilter  = VULKAN_HPP_NAMESPACE::Filter::eNearest;
    VULKAN_HPP_NAMESPACE::Bool32            forceExplicitReconstruction = {};
  };
  static_assert( sizeof( SamplerYcbcrConversionCreateInfo ) == sizeof( VkSamplerYcbcrConversionCreateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SamplerYcbcrConversionCreateInfo>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eSamplerYcbcrConversionCreateInfo>
  {
    using Type = SamplerYcbcrConversionCreateInfo;
  };
  using SamplerYcbcrConversionCreateInfoKHR = SamplerYcbcrConversionCreateInfo;

  struct SamplerYcbcrConversionImageFormatProperties
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eSamplerYcbcrConversionImageFormatProperties;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR SamplerYcbcrConversionImageFormatProperties(
      uint32_t combinedImageSamplerDescriptorCount_ = {} ) VULKAN_HPP_NOEXCEPT
      : combinedImageSamplerDescriptorCount( combinedImageSamplerDescriptorCount_ )
    {}

    VULKAN_HPP_CONSTEXPR SamplerYcbcrConversionImageFormatProperties(
      SamplerYcbcrConversionImageFormatProperties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SamplerYcbcrConversionImageFormatProperties( VkSamplerYcbcrConversionImageFormatProperties const & rhs )
      VULKAN_HPP_NOEXCEPT
      : SamplerYcbcrConversionImageFormatProperties(
          *reinterpret_cast<SamplerYcbcrConversionImageFormatProperties const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SamplerYcbcrConversionImageFormatProperties &
                            operator=( SamplerYcbcrConversionImageFormatProperties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SamplerYcbcrConversionImageFormatProperties &
      operator=( VkSamplerYcbcrConversionImageFormatProperties const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SamplerYcbcrConversionImageFormatProperties const *>( &rhs );
      return *this;
    }

    operator VkSamplerYcbcrConversionImageFormatProperties const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSamplerYcbcrConversionImageFormatProperties *>( this );
    }

    operator VkSamplerYcbcrConversionImageFormatProperties &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSamplerYcbcrConversionImageFormatProperties *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SamplerYcbcrConversionImageFormatProperties const & ) const = default;
#else
    bool operator==( SamplerYcbcrConversionImageFormatProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( combinedImageSamplerDescriptorCount == rhs.combinedImageSamplerDescriptorCount );
    }

    bool operator!=( SamplerYcbcrConversionImageFormatProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::eSamplerYcbcrConversionImageFormatProperties;
    void *                              pNext = {};
    uint32_t                            combinedImageSamplerDescriptorCount = {};
  };
  static_assert( sizeof( SamplerYcbcrConversionImageFormatProperties ) ==
                   sizeof( VkSamplerYcbcrConversionImageFormatProperties ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SamplerYcbcrConversionImageFormatProperties>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eSamplerYcbcrConversionImageFormatProperties>
  {
    using Type = SamplerYcbcrConversionImageFormatProperties;
  };
  using SamplerYcbcrConversionImageFormatPropertiesKHR = SamplerYcbcrConversionImageFormatProperties;

  struct SamplerYcbcrConversionInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eSamplerYcbcrConversionInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      SamplerYcbcrConversionInfo( VULKAN_HPP_NAMESPACE::SamplerYcbcrConversion conversion_ = {} ) VULKAN_HPP_NOEXCEPT
      : conversion( conversion_ )
    {}

    VULKAN_HPP_CONSTEXPR
      SamplerYcbcrConversionInfo( SamplerYcbcrConversionInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SamplerYcbcrConversionInfo( VkSamplerYcbcrConversionInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : SamplerYcbcrConversionInfo( *reinterpret_cast<SamplerYcbcrConversionInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SamplerYcbcrConversionInfo &
                            operator=( SamplerYcbcrConversionInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SamplerYcbcrConversionInfo & operator=( VkSamplerYcbcrConversionInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SamplerYcbcrConversionInfo const *>( &rhs );
      return *this;
    }

    SamplerYcbcrConversionInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    SamplerYcbcrConversionInfo &
      setConversion( VULKAN_HPP_NAMESPACE::SamplerYcbcrConversion conversion_ ) VULKAN_HPP_NOEXCEPT
    {
      conversion = conversion_;
      return *this;
    }

    operator VkSamplerYcbcrConversionInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSamplerYcbcrConversionInfo *>( this );
    }

    operator VkSamplerYcbcrConversionInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSamplerYcbcrConversionInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SamplerYcbcrConversionInfo const & ) const = default;
#else
    bool operator==( SamplerYcbcrConversionInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( conversion == rhs.conversion );
    }

    bool operator!=( SamplerYcbcrConversionInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType          sType      = StructureType::eSamplerYcbcrConversionInfo;
    const void *                                 pNext      = {};
    VULKAN_HPP_NAMESPACE::SamplerYcbcrConversion conversion = {};
  };
  static_assert( sizeof( SamplerYcbcrConversionInfo ) == sizeof( VkSamplerYcbcrConversionInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SamplerYcbcrConversionInfo>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eSamplerYcbcrConversionInfo>
  {
    using Type = SamplerYcbcrConversionInfo;
  };
  using SamplerYcbcrConversionInfoKHR = SamplerYcbcrConversionInfo;

#if defined( VK_USE_PLATFORM_SCREEN_QNX )
  struct ScreenSurfaceCreateInfoQNX
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eScreenSurfaceCreateInfoQNX;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ScreenSurfaceCreateInfoQNX( VULKAN_HPP_NAMESPACE::ScreenSurfaceCreateFlagsQNX flags_   = {},
                                                     struct _screen_context *                          context_ = {},
                                                     struct _screen_window * window_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , context( context_ )
      , window( window_ )
    {}

    VULKAN_HPP_CONSTEXPR
      ScreenSurfaceCreateInfoQNX( ScreenSurfaceCreateInfoQNX const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ScreenSurfaceCreateInfoQNX( VkScreenSurfaceCreateInfoQNX const & rhs ) VULKAN_HPP_NOEXCEPT
      : ScreenSurfaceCreateInfoQNX( *reinterpret_cast<ScreenSurfaceCreateInfoQNX const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ScreenSurfaceCreateInfoQNX &
                            operator=( ScreenSurfaceCreateInfoQNX const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ScreenSurfaceCreateInfoQNX & operator=( VkScreenSurfaceCreateInfoQNX const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ScreenSurfaceCreateInfoQNX const *>( &rhs );
      return *this;
    }

    ScreenSurfaceCreateInfoQNX & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ScreenSurfaceCreateInfoQNX &
      setFlags( VULKAN_HPP_NAMESPACE::ScreenSurfaceCreateFlagsQNX flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    ScreenSurfaceCreateInfoQNX & setContext( struct _screen_context * context_ ) VULKAN_HPP_NOEXCEPT
    {
      context = context_;
      return *this;
    }

    ScreenSurfaceCreateInfoQNX & setWindow( struct _screen_window * window_ ) VULKAN_HPP_NOEXCEPT
    {
      window = window_;
      return *this;
    }

    operator VkScreenSurfaceCreateInfoQNX const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkScreenSurfaceCreateInfoQNX *>( this );
    }

    operator VkScreenSurfaceCreateInfoQNX &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkScreenSurfaceCreateInfoQNX *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ScreenSurfaceCreateInfoQNX const & ) const = default;
#  else
    bool operator==( ScreenSurfaceCreateInfoQNX const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) && ( context == rhs.context ) &&
             ( window == rhs.window );
    }

    bool operator!=( ScreenSurfaceCreateInfoQNX const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType               sType   = StructureType::eScreenSurfaceCreateInfoQNX;
    const void *                                      pNext   = {};
    VULKAN_HPP_NAMESPACE::ScreenSurfaceCreateFlagsQNX flags   = {};
    struct _screen_context *                          context = {};
    struct _screen_window *                           window  = {};
  };
  static_assert( sizeof( ScreenSurfaceCreateInfoQNX ) == sizeof( VkScreenSurfaceCreateInfoQNX ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ScreenSurfaceCreateInfoQNX>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eScreenSurfaceCreateInfoQNX>
  {
    using Type = ScreenSurfaceCreateInfoQNX;
  };
#endif /*VK_USE_PLATFORM_SCREEN_QNX*/

  struct SemaphoreCreateInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eSemaphoreCreateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      SemaphoreCreateInfo( VULKAN_HPP_NAMESPACE::SemaphoreCreateFlags flags_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
    {}

    VULKAN_HPP_CONSTEXPR SemaphoreCreateInfo( SemaphoreCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SemaphoreCreateInfo( VkSemaphoreCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : SemaphoreCreateInfo( *reinterpret_cast<SemaphoreCreateInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SemaphoreCreateInfo &
                            operator=( SemaphoreCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SemaphoreCreateInfo & operator=( VkSemaphoreCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SemaphoreCreateInfo const *>( &rhs );
      return *this;
    }

    SemaphoreCreateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    SemaphoreCreateInfo & setFlags( VULKAN_HPP_NAMESPACE::SemaphoreCreateFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    operator VkSemaphoreCreateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSemaphoreCreateInfo *>( this );
    }

    operator VkSemaphoreCreateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSemaphoreCreateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SemaphoreCreateInfo const & ) const = default;
#else
    bool operator==( SemaphoreCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags );
    }

    bool operator!=( SemaphoreCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType        sType = StructureType::eSemaphoreCreateInfo;
    const void *                               pNext = {};
    VULKAN_HPP_NAMESPACE::SemaphoreCreateFlags flags = {};
  };
  static_assert( sizeof( SemaphoreCreateInfo ) == sizeof( VkSemaphoreCreateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SemaphoreCreateInfo>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eSemaphoreCreateInfo>
  {
    using Type = SemaphoreCreateInfo;
  };

  struct SemaphoreGetFdInfoKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eSemaphoreGetFdInfoKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR SemaphoreGetFdInfoKHR( VULKAN_HPP_NAMESPACE::Semaphore semaphore_ = {},
                                                VULKAN_HPP_NAMESPACE::ExternalSemaphoreHandleTypeFlagBits handleType_ =
                                                  VULKAN_HPP_NAMESPACE::ExternalSemaphoreHandleTypeFlagBits::eOpaqueFd )
      VULKAN_HPP_NOEXCEPT
      : semaphore( semaphore_ )
      , handleType( handleType_ )
    {}

    VULKAN_HPP_CONSTEXPR SemaphoreGetFdInfoKHR( SemaphoreGetFdInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SemaphoreGetFdInfoKHR( VkSemaphoreGetFdInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : SemaphoreGetFdInfoKHR( *reinterpret_cast<SemaphoreGetFdInfoKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SemaphoreGetFdInfoKHR &
                            operator=( SemaphoreGetFdInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SemaphoreGetFdInfoKHR & operator=( VkSemaphoreGetFdInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SemaphoreGetFdInfoKHR const *>( &rhs );
      return *this;
    }

    SemaphoreGetFdInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    SemaphoreGetFdInfoKHR & setSemaphore( VULKAN_HPP_NAMESPACE::Semaphore semaphore_ ) VULKAN_HPP_NOEXCEPT
    {
      semaphore = semaphore_;
      return *this;
    }

    SemaphoreGetFdInfoKHR &
      setHandleType( VULKAN_HPP_NAMESPACE::ExternalSemaphoreHandleTypeFlagBits handleType_ ) VULKAN_HPP_NOEXCEPT
    {
      handleType = handleType_;
      return *this;
    }

    operator VkSemaphoreGetFdInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSemaphoreGetFdInfoKHR *>( this );
    }

    operator VkSemaphoreGetFdInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSemaphoreGetFdInfoKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SemaphoreGetFdInfoKHR const & ) const = default;
#else
    bool operator==( SemaphoreGetFdInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( semaphore == rhs.semaphore ) &&
             ( handleType == rhs.handleType );
    }

    bool operator!=( SemaphoreGetFdInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                       sType     = StructureType::eSemaphoreGetFdInfoKHR;
    const void *                                              pNext     = {};
    VULKAN_HPP_NAMESPACE::Semaphore                           semaphore = {};
    VULKAN_HPP_NAMESPACE::ExternalSemaphoreHandleTypeFlagBits handleType =
      VULKAN_HPP_NAMESPACE::ExternalSemaphoreHandleTypeFlagBits::eOpaqueFd;
  };
  static_assert( sizeof( SemaphoreGetFdInfoKHR ) == sizeof( VkSemaphoreGetFdInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SemaphoreGetFdInfoKHR>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eSemaphoreGetFdInfoKHR>
  {
    using Type = SemaphoreGetFdInfoKHR;
  };

#if defined( VK_USE_PLATFORM_WIN32_KHR )
  struct SemaphoreGetWin32HandleInfoKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eSemaphoreGetWin32HandleInfoKHR;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR SemaphoreGetWin32HandleInfoKHR(
      VULKAN_HPP_NAMESPACE::Semaphore                           semaphore_ = {},
      VULKAN_HPP_NAMESPACE::ExternalSemaphoreHandleTypeFlagBits handleType_ =
        VULKAN_HPP_NAMESPACE::ExternalSemaphoreHandleTypeFlagBits::eOpaqueFd ) VULKAN_HPP_NOEXCEPT
      : semaphore( semaphore_ )
      , handleType( handleType_ )
    {}

    VULKAN_HPP_CONSTEXPR
      SemaphoreGetWin32HandleInfoKHR( SemaphoreGetWin32HandleInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SemaphoreGetWin32HandleInfoKHR( VkSemaphoreGetWin32HandleInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : SemaphoreGetWin32HandleInfoKHR( *reinterpret_cast<SemaphoreGetWin32HandleInfoKHR const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SemaphoreGetWin32HandleInfoKHR &
                            operator=( SemaphoreGetWin32HandleInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SemaphoreGetWin32HandleInfoKHR & operator=( VkSemaphoreGetWin32HandleInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SemaphoreGetWin32HandleInfoKHR const *>( &rhs );
      return *this;
    }

    SemaphoreGetWin32HandleInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    SemaphoreGetWin32HandleInfoKHR & setSemaphore( VULKAN_HPP_NAMESPACE::Semaphore semaphore_ ) VULKAN_HPP_NOEXCEPT
    {
      semaphore = semaphore_;
      return *this;
    }

    SemaphoreGetWin32HandleInfoKHR &
      setHandleType( VULKAN_HPP_NAMESPACE::ExternalSemaphoreHandleTypeFlagBits handleType_ ) VULKAN_HPP_NOEXCEPT
    {
      handleType = handleType_;
      return *this;
    }

    operator VkSemaphoreGetWin32HandleInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSemaphoreGetWin32HandleInfoKHR *>( this );
    }

    operator VkSemaphoreGetWin32HandleInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSemaphoreGetWin32HandleInfoKHR *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SemaphoreGetWin32HandleInfoKHR const & ) const = default;
#  else
    bool operator==( SemaphoreGetWin32HandleInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( semaphore == rhs.semaphore ) &&
             ( handleType == rhs.handleType );
    }

    bool operator!=( SemaphoreGetWin32HandleInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                       sType = StructureType::eSemaphoreGetWin32HandleInfoKHR;
    const void *                                              pNext = {};
    VULKAN_HPP_NAMESPACE::Semaphore                           semaphore = {};
    VULKAN_HPP_NAMESPACE::ExternalSemaphoreHandleTypeFlagBits handleType =
      VULKAN_HPP_NAMESPACE::ExternalSemaphoreHandleTypeFlagBits::eOpaqueFd;
  };
  static_assert( sizeof( SemaphoreGetWin32HandleInfoKHR ) == sizeof( VkSemaphoreGetWin32HandleInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SemaphoreGetWin32HandleInfoKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eSemaphoreGetWin32HandleInfoKHR>
  {
    using Type = SemaphoreGetWin32HandleInfoKHR;
  };
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

#if defined( VK_USE_PLATFORM_FUCHSIA )
  struct SemaphoreGetZirconHandleInfoFUCHSIA
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eSemaphoreGetZirconHandleInfoFUCHSIA;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR SemaphoreGetZirconHandleInfoFUCHSIA(
      VULKAN_HPP_NAMESPACE::Semaphore                           semaphore_ = {},
      VULKAN_HPP_NAMESPACE::ExternalSemaphoreHandleTypeFlagBits handleType_ =
        VULKAN_HPP_NAMESPACE::ExternalSemaphoreHandleTypeFlagBits::eOpaqueFd ) VULKAN_HPP_NOEXCEPT
      : semaphore( semaphore_ )
      , handleType( handleType_ )
    {}

    VULKAN_HPP_CONSTEXPR SemaphoreGetZirconHandleInfoFUCHSIA( SemaphoreGetZirconHandleInfoFUCHSIA const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    SemaphoreGetZirconHandleInfoFUCHSIA( VkSemaphoreGetZirconHandleInfoFUCHSIA const & rhs ) VULKAN_HPP_NOEXCEPT
      : SemaphoreGetZirconHandleInfoFUCHSIA( *reinterpret_cast<SemaphoreGetZirconHandleInfoFUCHSIA const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SemaphoreGetZirconHandleInfoFUCHSIA &
                            operator=( SemaphoreGetZirconHandleInfoFUCHSIA const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SemaphoreGetZirconHandleInfoFUCHSIA &
      operator=( VkSemaphoreGetZirconHandleInfoFUCHSIA const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SemaphoreGetZirconHandleInfoFUCHSIA const *>( &rhs );
      return *this;
    }

    SemaphoreGetZirconHandleInfoFUCHSIA & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    SemaphoreGetZirconHandleInfoFUCHSIA & setSemaphore( VULKAN_HPP_NAMESPACE::Semaphore semaphore_ ) VULKAN_HPP_NOEXCEPT
    {
      semaphore = semaphore_;
      return *this;
    }

    SemaphoreGetZirconHandleInfoFUCHSIA &
      setHandleType( VULKAN_HPP_NAMESPACE::ExternalSemaphoreHandleTypeFlagBits handleType_ ) VULKAN_HPP_NOEXCEPT
    {
      handleType = handleType_;
      return *this;
    }

    operator VkSemaphoreGetZirconHandleInfoFUCHSIA const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSemaphoreGetZirconHandleInfoFUCHSIA *>( this );
    }

    operator VkSemaphoreGetZirconHandleInfoFUCHSIA &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSemaphoreGetZirconHandleInfoFUCHSIA *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SemaphoreGetZirconHandleInfoFUCHSIA const & ) const = default;
#  else
    bool operator==( SemaphoreGetZirconHandleInfoFUCHSIA const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( semaphore == rhs.semaphore ) &&
             ( handleType == rhs.handleType );
    }

    bool operator!=( SemaphoreGetZirconHandleInfoFUCHSIA const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType     = StructureType::eSemaphoreGetZirconHandleInfoFUCHSIA;
    const void *                        pNext     = {};
    VULKAN_HPP_NAMESPACE::Semaphore     semaphore = {};
    VULKAN_HPP_NAMESPACE::ExternalSemaphoreHandleTypeFlagBits handleType =
      VULKAN_HPP_NAMESPACE::ExternalSemaphoreHandleTypeFlagBits::eOpaqueFd;
  };
  static_assert( sizeof( SemaphoreGetZirconHandleInfoFUCHSIA ) == sizeof( VkSemaphoreGetZirconHandleInfoFUCHSIA ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SemaphoreGetZirconHandleInfoFUCHSIA>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eSemaphoreGetZirconHandleInfoFUCHSIA>
  {
    using Type = SemaphoreGetZirconHandleInfoFUCHSIA;
  };
#endif /*VK_USE_PLATFORM_FUCHSIA*/

  struct SemaphoreSignalInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eSemaphoreSignalInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR SemaphoreSignalInfo( VULKAN_HPP_NAMESPACE::Semaphore semaphore_ = {},
                                              uint64_t                        value_     = {} ) VULKAN_HPP_NOEXCEPT
      : semaphore( semaphore_ )
      , value( value_ )
    {}

    VULKAN_HPP_CONSTEXPR SemaphoreSignalInfo( SemaphoreSignalInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SemaphoreSignalInfo( VkSemaphoreSignalInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : SemaphoreSignalInfo( *reinterpret_cast<SemaphoreSignalInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SemaphoreSignalInfo &
                            operator=( SemaphoreSignalInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SemaphoreSignalInfo & operator=( VkSemaphoreSignalInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SemaphoreSignalInfo const *>( &rhs );
      return *this;
    }

    SemaphoreSignalInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    SemaphoreSignalInfo & setSemaphore( VULKAN_HPP_NAMESPACE::Semaphore semaphore_ ) VULKAN_HPP_NOEXCEPT
    {
      semaphore = semaphore_;
      return *this;
    }

    SemaphoreSignalInfo & setValue( uint64_t value_ ) VULKAN_HPP_NOEXCEPT
    {
      value = value_;
      return *this;
    }

    operator VkSemaphoreSignalInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSemaphoreSignalInfo *>( this );
    }

    operator VkSemaphoreSignalInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSemaphoreSignalInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SemaphoreSignalInfo const & ) const = default;
#else
    bool operator==( SemaphoreSignalInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( semaphore == rhs.semaphore ) &&
             ( value == rhs.value );
    }

    bool operator!=( SemaphoreSignalInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType     = StructureType::eSemaphoreSignalInfo;
    const void *                        pNext     = {};
    VULKAN_HPP_NAMESPACE::Semaphore     semaphore = {};
    uint64_t                            value     = {};
  };
  static_assert( sizeof( SemaphoreSignalInfo ) == sizeof( VkSemaphoreSignalInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SemaphoreSignalInfo>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eSemaphoreSignalInfo>
  {
    using Type = SemaphoreSignalInfo;
  };
  using SemaphoreSignalInfoKHR = SemaphoreSignalInfo;

  struct SemaphoreSubmitInfoKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eSemaphoreSubmitInfoKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR SemaphoreSubmitInfoKHR( VULKAN_HPP_NAMESPACE::Semaphore              semaphore_ = {},
                                                 uint64_t                                     value_     = {},
                                                 VULKAN_HPP_NAMESPACE::PipelineStageFlags2KHR stageMask_ = {},
                                                 uint32_t deviceIndex_ = {} ) VULKAN_HPP_NOEXCEPT
      : semaphore( semaphore_ )
      , value( value_ )
      , stageMask( stageMask_ )
      , deviceIndex( deviceIndex_ )
    {}

    VULKAN_HPP_CONSTEXPR SemaphoreSubmitInfoKHR( SemaphoreSubmitInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SemaphoreSubmitInfoKHR( VkSemaphoreSubmitInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : SemaphoreSubmitInfoKHR( *reinterpret_cast<SemaphoreSubmitInfoKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SemaphoreSubmitInfoKHR &
                            operator=( SemaphoreSubmitInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SemaphoreSubmitInfoKHR & operator=( VkSemaphoreSubmitInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SemaphoreSubmitInfoKHR const *>( &rhs );
      return *this;
    }

    SemaphoreSubmitInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    SemaphoreSubmitInfoKHR & setSemaphore( VULKAN_HPP_NAMESPACE::Semaphore semaphore_ ) VULKAN_HPP_NOEXCEPT
    {
      semaphore = semaphore_;
      return *this;
    }

    SemaphoreSubmitInfoKHR & setValue( uint64_t value_ ) VULKAN_HPP_NOEXCEPT
    {
      value = value_;
      return *this;
    }

    SemaphoreSubmitInfoKHR & setStageMask( VULKAN_HPP_NAMESPACE::PipelineStageFlags2KHR stageMask_ ) VULKAN_HPP_NOEXCEPT
    {
      stageMask = stageMask_;
      return *this;
    }

    SemaphoreSubmitInfoKHR & setDeviceIndex( uint32_t deviceIndex_ ) VULKAN_HPP_NOEXCEPT
    {
      deviceIndex = deviceIndex_;
      return *this;
    }

    operator VkSemaphoreSubmitInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSemaphoreSubmitInfoKHR *>( this );
    }

    operator VkSemaphoreSubmitInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSemaphoreSubmitInfoKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SemaphoreSubmitInfoKHR const & ) const = default;
#else
    bool operator==( SemaphoreSubmitInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( semaphore == rhs.semaphore ) &&
             ( value == rhs.value ) && ( stageMask == rhs.stageMask ) && ( deviceIndex == rhs.deviceIndex );
    }

    bool operator!=( SemaphoreSubmitInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType          sType       = StructureType::eSemaphoreSubmitInfoKHR;
    const void *                                 pNext       = {};
    VULKAN_HPP_NAMESPACE::Semaphore              semaphore   = {};
    uint64_t                                     value       = {};
    VULKAN_HPP_NAMESPACE::PipelineStageFlags2KHR stageMask   = {};
    uint32_t                                     deviceIndex = {};
  };
  static_assert( sizeof( SemaphoreSubmitInfoKHR ) == sizeof( VkSemaphoreSubmitInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SemaphoreSubmitInfoKHR>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eSemaphoreSubmitInfoKHR>
  {
    using Type = SemaphoreSubmitInfoKHR;
  };

  struct SemaphoreTypeCreateInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eSemaphoreTypeCreateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR SemaphoreTypeCreateInfo(
      VULKAN_HPP_NAMESPACE::SemaphoreType semaphoreType_ = VULKAN_HPP_NAMESPACE::SemaphoreType::eBinary,
      uint64_t                            initialValue_  = {} ) VULKAN_HPP_NOEXCEPT
      : semaphoreType( semaphoreType_ )
      , initialValue( initialValue_ )
    {}

    VULKAN_HPP_CONSTEXPR SemaphoreTypeCreateInfo( SemaphoreTypeCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SemaphoreTypeCreateInfo( VkSemaphoreTypeCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : SemaphoreTypeCreateInfo( *reinterpret_cast<SemaphoreTypeCreateInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SemaphoreTypeCreateInfo &
                            operator=( SemaphoreTypeCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SemaphoreTypeCreateInfo & operator=( VkSemaphoreTypeCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SemaphoreTypeCreateInfo const *>( &rhs );
      return *this;
    }

    SemaphoreTypeCreateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    SemaphoreTypeCreateInfo & setSemaphoreType( VULKAN_HPP_NAMESPACE::SemaphoreType semaphoreType_ ) VULKAN_HPP_NOEXCEPT
    {
      semaphoreType = semaphoreType_;
      return *this;
    }

    SemaphoreTypeCreateInfo & setInitialValue( uint64_t initialValue_ ) VULKAN_HPP_NOEXCEPT
    {
      initialValue = initialValue_;
      return *this;
    }

    operator VkSemaphoreTypeCreateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSemaphoreTypeCreateInfo *>( this );
    }

    operator VkSemaphoreTypeCreateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSemaphoreTypeCreateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SemaphoreTypeCreateInfo const & ) const = default;
#else
    bool operator==( SemaphoreTypeCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( semaphoreType == rhs.semaphoreType ) &&
             ( initialValue == rhs.initialValue );
    }

    bool operator!=( SemaphoreTypeCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType         = StructureType::eSemaphoreTypeCreateInfo;
    const void *                        pNext         = {};
    VULKAN_HPP_NAMESPACE::SemaphoreType semaphoreType = VULKAN_HPP_NAMESPACE::SemaphoreType::eBinary;
    uint64_t                            initialValue  = {};
  };
  static_assert( sizeof( SemaphoreTypeCreateInfo ) == sizeof( VkSemaphoreTypeCreateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SemaphoreTypeCreateInfo>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eSemaphoreTypeCreateInfo>
  {
    using Type = SemaphoreTypeCreateInfo;
  };
  using SemaphoreTypeCreateInfoKHR = SemaphoreTypeCreateInfo;

  struct SemaphoreWaitInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eSemaphoreWaitInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR SemaphoreWaitInfo( VULKAN_HPP_NAMESPACE::SemaphoreWaitFlags flags_          = {},
                                            uint32_t                                 semaphoreCount_ = {},
                                            const VULKAN_HPP_NAMESPACE::Semaphore *  pSemaphores_    = {},
                                            const uint64_t *                         pValues_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , semaphoreCount( semaphoreCount_ )
      , pSemaphores( pSemaphores_ )
      , pValues( pValues_ )
    {}

    VULKAN_HPP_CONSTEXPR SemaphoreWaitInfo( SemaphoreWaitInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SemaphoreWaitInfo( VkSemaphoreWaitInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : SemaphoreWaitInfo( *reinterpret_cast<SemaphoreWaitInfo const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    SemaphoreWaitInfo(
      VULKAN_HPP_NAMESPACE::SemaphoreWaitFlags                                                     flags_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::Semaphore> const & semaphores_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint64_t> const &                        values_ = {} )
      : flags( flags_ )
      , semaphoreCount( static_cast<uint32_t>( semaphores_.size() ) )
      , pSemaphores( semaphores_.data() )
      , pValues( values_.data() )
    {
#    ifdef VULKAN_HPP_NO_EXCEPTIONS
      VULKAN_HPP_ASSERT( semaphores_.size() == values_.size() );
#    else
      if ( semaphores_.size() != values_.size() )
      {
        throw LogicError( VULKAN_HPP_NAMESPACE_STRING
                          "::SemaphoreWaitInfo::SemaphoreWaitInfo: semaphores_.size() != values_.size()" );
      }
#    endif /*VULKAN_HPP_NO_EXCEPTIONS*/
    }
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SemaphoreWaitInfo &
                            operator=( SemaphoreWaitInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SemaphoreWaitInfo & operator=( VkSemaphoreWaitInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SemaphoreWaitInfo const *>( &rhs );
      return *this;
    }

    SemaphoreWaitInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    SemaphoreWaitInfo & setFlags( VULKAN_HPP_NAMESPACE::SemaphoreWaitFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    SemaphoreWaitInfo & setSemaphoreCount( uint32_t semaphoreCount_ ) VULKAN_HPP_NOEXCEPT
    {
      semaphoreCount = semaphoreCount_;
      return *this;
    }

    SemaphoreWaitInfo & setPSemaphores( const VULKAN_HPP_NAMESPACE::Semaphore * pSemaphores_ ) VULKAN_HPP_NOEXCEPT
    {
      pSemaphores = pSemaphores_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    SemaphoreWaitInfo & setSemaphores(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::Semaphore> const & semaphores_ )
      VULKAN_HPP_NOEXCEPT
    {
      semaphoreCount = static_cast<uint32_t>( semaphores_.size() );
      pSemaphores    = semaphores_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    SemaphoreWaitInfo & setPValues( const uint64_t * pValues_ ) VULKAN_HPP_NOEXCEPT
    {
      pValues = pValues_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    SemaphoreWaitInfo &
      setValues( VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint64_t> const & values_ ) VULKAN_HPP_NOEXCEPT
    {
      semaphoreCount = static_cast<uint32_t>( values_.size() );
      pValues        = values_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkSemaphoreWaitInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSemaphoreWaitInfo *>( this );
    }

    operator VkSemaphoreWaitInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSemaphoreWaitInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SemaphoreWaitInfo const & ) const = default;
#else
    bool operator==( SemaphoreWaitInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( semaphoreCount == rhs.semaphoreCount ) && ( pSemaphores == rhs.pSemaphores ) &&
             ( pValues == rhs.pValues );
    }

    bool operator!=( SemaphoreWaitInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType      sType          = StructureType::eSemaphoreWaitInfo;
    const void *                             pNext          = {};
    VULKAN_HPP_NAMESPACE::SemaphoreWaitFlags flags          = {};
    uint32_t                                 semaphoreCount = {};
    const VULKAN_HPP_NAMESPACE::Semaphore *  pSemaphores    = {};
    const uint64_t *                         pValues        = {};
  };
  static_assert( sizeof( SemaphoreWaitInfo ) == sizeof( VkSemaphoreWaitInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SemaphoreWaitInfo>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eSemaphoreWaitInfo>
  {
    using Type = SemaphoreWaitInfo;
  };
  using SemaphoreWaitInfoKHR = SemaphoreWaitInfo;

  struct SetStateFlagsIndirectCommandNV
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR SetStateFlagsIndirectCommandNV( uint32_t data_ = {} ) VULKAN_HPP_NOEXCEPT : data( data_ ) {}

    VULKAN_HPP_CONSTEXPR
      SetStateFlagsIndirectCommandNV( SetStateFlagsIndirectCommandNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SetStateFlagsIndirectCommandNV( VkSetStateFlagsIndirectCommandNV const & rhs ) VULKAN_HPP_NOEXCEPT
      : SetStateFlagsIndirectCommandNV( *reinterpret_cast<SetStateFlagsIndirectCommandNV const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SetStateFlagsIndirectCommandNV &
                            operator=( SetStateFlagsIndirectCommandNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SetStateFlagsIndirectCommandNV & operator=( VkSetStateFlagsIndirectCommandNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SetStateFlagsIndirectCommandNV const *>( &rhs );
      return *this;
    }

    SetStateFlagsIndirectCommandNV & setData( uint32_t data_ ) VULKAN_HPP_NOEXCEPT
    {
      data = data_;
      return *this;
    }

    operator VkSetStateFlagsIndirectCommandNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSetStateFlagsIndirectCommandNV *>( this );
    }

    operator VkSetStateFlagsIndirectCommandNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSetStateFlagsIndirectCommandNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SetStateFlagsIndirectCommandNV const & ) const = default;
#else
    bool operator==( SetStateFlagsIndirectCommandNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( data == rhs.data );
    }

    bool operator!=( SetStateFlagsIndirectCommandNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    uint32_t data = {};
  };
  static_assert( sizeof( SetStateFlagsIndirectCommandNV ) == sizeof( VkSetStateFlagsIndirectCommandNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SetStateFlagsIndirectCommandNV>::value,
                 "struct wrapper is not a standard layout!" );

  struct ShaderModuleCreateInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eShaderModuleCreateInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ShaderModuleCreateInfo( VULKAN_HPP_NAMESPACE::ShaderModuleCreateFlags flags_    = {},
                                                 size_t                                        codeSize_ = {},
                                                 const uint32_t * pCode_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , codeSize( codeSize_ )
      , pCode( pCode_ )
    {}

    VULKAN_HPP_CONSTEXPR ShaderModuleCreateInfo( ShaderModuleCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ShaderModuleCreateInfo( VkShaderModuleCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : ShaderModuleCreateInfo( *reinterpret_cast<ShaderModuleCreateInfo const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    ShaderModuleCreateInfo( VULKAN_HPP_NAMESPACE::ShaderModuleCreateFlags                         flags_,
                            VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const & code_ )
      : flags( flags_ ), codeSize( code_.size() * 4 ), pCode( code_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ShaderModuleCreateInfo &
                            operator=( ShaderModuleCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ShaderModuleCreateInfo & operator=( VkShaderModuleCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ShaderModuleCreateInfo const *>( &rhs );
      return *this;
    }

    ShaderModuleCreateInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ShaderModuleCreateInfo & setFlags( VULKAN_HPP_NAMESPACE::ShaderModuleCreateFlags flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    ShaderModuleCreateInfo & setCodeSize( size_t codeSize_ ) VULKAN_HPP_NOEXCEPT
    {
      codeSize = codeSize_;
      return *this;
    }

    ShaderModuleCreateInfo & setPCode( const uint32_t * pCode_ ) VULKAN_HPP_NOEXCEPT
    {
      pCode = pCode_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    ShaderModuleCreateInfo &
      setCode( VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const & code_ ) VULKAN_HPP_NOEXCEPT
    {
      codeSize = code_.size() * 4;
      pCode    = code_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkShaderModuleCreateInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkShaderModuleCreateInfo *>( this );
    }

    operator VkShaderModuleCreateInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkShaderModuleCreateInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ShaderModuleCreateInfo const & ) const = default;
#else
    bool operator==( ShaderModuleCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( codeSize == rhs.codeSize ) && ( pCode == rhs.pCode );
    }

    bool operator!=( ShaderModuleCreateInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType           sType    = StructureType::eShaderModuleCreateInfo;
    const void *                                  pNext    = {};
    VULKAN_HPP_NAMESPACE::ShaderModuleCreateFlags flags    = {};
    size_t                                        codeSize = {};
    const uint32_t *                              pCode    = {};
  };
  static_assert( sizeof( ShaderModuleCreateInfo ) == sizeof( VkShaderModuleCreateInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ShaderModuleCreateInfo>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eShaderModuleCreateInfo>
  {
    using Type = ShaderModuleCreateInfo;
  };

  struct ShaderModuleValidationCacheCreateInfoEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eShaderModuleValidationCacheCreateInfoEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ShaderModuleValidationCacheCreateInfoEXT(
      VULKAN_HPP_NAMESPACE::ValidationCacheEXT validationCache_ = {} ) VULKAN_HPP_NOEXCEPT
      : validationCache( validationCache_ )
    {}

    VULKAN_HPP_CONSTEXPR ShaderModuleValidationCacheCreateInfoEXT(
      ShaderModuleValidationCacheCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ShaderModuleValidationCacheCreateInfoEXT( VkShaderModuleValidationCacheCreateInfoEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : ShaderModuleValidationCacheCreateInfoEXT(
          *reinterpret_cast<ShaderModuleValidationCacheCreateInfoEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ShaderModuleValidationCacheCreateInfoEXT &
                            operator=( ShaderModuleValidationCacheCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ShaderModuleValidationCacheCreateInfoEXT &
      operator=( VkShaderModuleValidationCacheCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ShaderModuleValidationCacheCreateInfoEXT const *>( &rhs );
      return *this;
    }

    ShaderModuleValidationCacheCreateInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ShaderModuleValidationCacheCreateInfoEXT &
      setValidationCache( VULKAN_HPP_NAMESPACE::ValidationCacheEXT validationCache_ ) VULKAN_HPP_NOEXCEPT
    {
      validationCache = validationCache_;
      return *this;
    }

    operator VkShaderModuleValidationCacheCreateInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkShaderModuleValidationCacheCreateInfoEXT *>( this );
    }

    operator VkShaderModuleValidationCacheCreateInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkShaderModuleValidationCacheCreateInfoEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ShaderModuleValidationCacheCreateInfoEXT const & ) const = default;
#else
    bool operator==( ShaderModuleValidationCacheCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( validationCache == rhs.validationCache );
    }

    bool operator!=( ShaderModuleValidationCacheCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType      sType           = StructureType::eShaderModuleValidationCacheCreateInfoEXT;
    const void *                             pNext           = {};
    VULKAN_HPP_NAMESPACE::ValidationCacheEXT validationCache = {};
  };
  static_assert( sizeof( ShaderModuleValidationCacheCreateInfoEXT ) ==
                   sizeof( VkShaderModuleValidationCacheCreateInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ShaderModuleValidationCacheCreateInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eShaderModuleValidationCacheCreateInfoEXT>
  {
    using Type = ShaderModuleValidationCacheCreateInfoEXT;
  };

  struct ShaderResourceUsageAMD
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ShaderResourceUsageAMD( uint32_t numUsedVgprs_             = {},
                                                 uint32_t numUsedSgprs_             = {},
                                                 uint32_t ldsSizePerLocalWorkGroup_ = {},
                                                 size_t   ldsUsageSizeInBytes_      = {},
                                                 size_t   scratchMemUsageInBytes_   = {} ) VULKAN_HPP_NOEXCEPT
      : numUsedVgprs( numUsedVgprs_ )
      , numUsedSgprs( numUsedSgprs_ )
      , ldsSizePerLocalWorkGroup( ldsSizePerLocalWorkGroup_ )
      , ldsUsageSizeInBytes( ldsUsageSizeInBytes_ )
      , scratchMemUsageInBytes( scratchMemUsageInBytes_ )
    {}

    VULKAN_HPP_CONSTEXPR ShaderResourceUsageAMD( ShaderResourceUsageAMD const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ShaderResourceUsageAMD( VkShaderResourceUsageAMD const & rhs ) VULKAN_HPP_NOEXCEPT
      : ShaderResourceUsageAMD( *reinterpret_cast<ShaderResourceUsageAMD const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ShaderResourceUsageAMD &
                            operator=( ShaderResourceUsageAMD const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ShaderResourceUsageAMD & operator=( VkShaderResourceUsageAMD const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ShaderResourceUsageAMD const *>( &rhs );
      return *this;
    }

    operator VkShaderResourceUsageAMD const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkShaderResourceUsageAMD *>( this );
    }

    operator VkShaderResourceUsageAMD &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkShaderResourceUsageAMD *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ShaderResourceUsageAMD const & ) const = default;
#else
    bool operator==( ShaderResourceUsageAMD const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( numUsedVgprs == rhs.numUsedVgprs ) && ( numUsedSgprs == rhs.numUsedSgprs ) &&
             ( ldsSizePerLocalWorkGroup == rhs.ldsSizePerLocalWorkGroup ) &&
             ( ldsUsageSizeInBytes == rhs.ldsUsageSizeInBytes ) &&
             ( scratchMemUsageInBytes == rhs.scratchMemUsageInBytes );
    }

    bool operator!=( ShaderResourceUsageAMD const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    uint32_t numUsedVgprs             = {};
    uint32_t numUsedSgprs             = {};
    uint32_t ldsSizePerLocalWorkGroup = {};
    size_t   ldsUsageSizeInBytes      = {};
    size_t   scratchMemUsageInBytes   = {};
  };
  static_assert( sizeof( ShaderResourceUsageAMD ) == sizeof( VkShaderResourceUsageAMD ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ShaderResourceUsageAMD>::value, "struct wrapper is not a standard layout!" );

  struct ShaderStatisticsInfoAMD
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR_14
      ShaderStatisticsInfoAMD( VULKAN_HPP_NAMESPACE::ShaderStageFlags       shaderStageMask_   = {},
                               VULKAN_HPP_NAMESPACE::ShaderResourceUsageAMD resourceUsage_     = {},
                               uint32_t                                     numPhysicalVgprs_  = {},
                               uint32_t                                     numPhysicalSgprs_  = {},
                               uint32_t                                     numAvailableVgprs_ = {},
                               uint32_t                                     numAvailableSgprs_ = {},
                               std::array<uint32_t, 3> const & computeWorkGroupSize_ = {} ) VULKAN_HPP_NOEXCEPT
      : shaderStageMask( shaderStageMask_ )
      , resourceUsage( resourceUsage_ )
      , numPhysicalVgprs( numPhysicalVgprs_ )
      , numPhysicalSgprs( numPhysicalSgprs_ )
      , numAvailableVgprs( numAvailableVgprs_ )
      , numAvailableSgprs( numAvailableSgprs_ )
      , computeWorkGroupSize( computeWorkGroupSize_ )
    {}

    VULKAN_HPP_CONSTEXPR_14
      ShaderStatisticsInfoAMD( ShaderStatisticsInfoAMD const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ShaderStatisticsInfoAMD( VkShaderStatisticsInfoAMD const & rhs ) VULKAN_HPP_NOEXCEPT
      : ShaderStatisticsInfoAMD( *reinterpret_cast<ShaderStatisticsInfoAMD const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ShaderStatisticsInfoAMD &
                            operator=( ShaderStatisticsInfoAMD const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ShaderStatisticsInfoAMD & operator=( VkShaderStatisticsInfoAMD const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ShaderStatisticsInfoAMD const *>( &rhs );
      return *this;
    }

    operator VkShaderStatisticsInfoAMD const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkShaderStatisticsInfoAMD *>( this );
    }

    operator VkShaderStatisticsInfoAMD &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkShaderStatisticsInfoAMD *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ShaderStatisticsInfoAMD const & ) const = default;
#else
    bool operator==( ShaderStatisticsInfoAMD const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( shaderStageMask == rhs.shaderStageMask ) && ( resourceUsage == rhs.resourceUsage ) &&
             ( numPhysicalVgprs == rhs.numPhysicalVgprs ) && ( numPhysicalSgprs == rhs.numPhysicalSgprs ) &&
             ( numAvailableVgprs == rhs.numAvailableVgprs ) && ( numAvailableSgprs == rhs.numAvailableSgprs ) &&
             ( computeWorkGroupSize == rhs.computeWorkGroupSize );
    }

    bool operator!=( ShaderStatisticsInfoAMD const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::ShaderStageFlags            shaderStageMask      = {};
    VULKAN_HPP_NAMESPACE::ShaderResourceUsageAMD      resourceUsage        = {};
    uint32_t                                          numPhysicalVgprs     = {};
    uint32_t                                          numPhysicalSgprs     = {};
    uint32_t                                          numAvailableVgprs    = {};
    uint32_t                                          numAvailableSgprs    = {};
    VULKAN_HPP_NAMESPACE::ArrayWrapper1D<uint32_t, 3> computeWorkGroupSize = {};
  };
  static_assert( sizeof( ShaderStatisticsInfoAMD ) == sizeof( VkShaderStatisticsInfoAMD ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ShaderStatisticsInfoAMD>::value, "struct wrapper is not a standard layout!" );

  struct SharedPresentSurfaceCapabilitiesKHR
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eSharedPresentSurfaceCapabilitiesKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR SharedPresentSurfaceCapabilitiesKHR(
      VULKAN_HPP_NAMESPACE::ImageUsageFlags sharedPresentSupportedUsageFlags_ = {} ) VULKAN_HPP_NOEXCEPT
      : sharedPresentSupportedUsageFlags( sharedPresentSupportedUsageFlags_ )
    {}

    VULKAN_HPP_CONSTEXPR SharedPresentSurfaceCapabilitiesKHR( SharedPresentSurfaceCapabilitiesKHR const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    SharedPresentSurfaceCapabilitiesKHR( VkSharedPresentSurfaceCapabilitiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : SharedPresentSurfaceCapabilitiesKHR( *reinterpret_cast<SharedPresentSurfaceCapabilitiesKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SharedPresentSurfaceCapabilitiesKHR &
                            operator=( SharedPresentSurfaceCapabilitiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SharedPresentSurfaceCapabilitiesKHR &
      operator=( VkSharedPresentSurfaceCapabilitiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SharedPresentSurfaceCapabilitiesKHR const *>( &rhs );
      return *this;
    }

    operator VkSharedPresentSurfaceCapabilitiesKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSharedPresentSurfaceCapabilitiesKHR *>( this );
    }

    operator VkSharedPresentSurfaceCapabilitiesKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSharedPresentSurfaceCapabilitiesKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SharedPresentSurfaceCapabilitiesKHR const & ) const = default;
#else
    bool operator==( SharedPresentSurfaceCapabilitiesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( sharedPresentSupportedUsageFlags == rhs.sharedPresentSupportedUsageFlags );
    }

    bool operator!=( SharedPresentSurfaceCapabilitiesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType   sType = StructureType::eSharedPresentSurfaceCapabilitiesKHR;
    void *                                pNext = {};
    VULKAN_HPP_NAMESPACE::ImageUsageFlags sharedPresentSupportedUsageFlags = {};
  };
  static_assert( sizeof( SharedPresentSurfaceCapabilitiesKHR ) == sizeof( VkSharedPresentSurfaceCapabilitiesKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SharedPresentSurfaceCapabilitiesKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eSharedPresentSurfaceCapabilitiesKHR>
  {
    using Type = SharedPresentSurfaceCapabilitiesKHR;
  };

  struct SparseImageFormatProperties
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      SparseImageFormatProperties( VULKAN_HPP_NAMESPACE::ImageAspectFlags       aspectMask_       = {},
                                   VULKAN_HPP_NAMESPACE::Extent3D               imageGranularity_ = {},
                                   VULKAN_HPP_NAMESPACE::SparseImageFormatFlags flags_ = {} ) VULKAN_HPP_NOEXCEPT
      : aspectMask( aspectMask_ )
      , imageGranularity( imageGranularity_ )
      , flags( flags_ )
    {}

    VULKAN_HPP_CONSTEXPR
      SparseImageFormatProperties( SparseImageFormatProperties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SparseImageFormatProperties( VkSparseImageFormatProperties const & rhs ) VULKAN_HPP_NOEXCEPT
      : SparseImageFormatProperties( *reinterpret_cast<SparseImageFormatProperties const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SparseImageFormatProperties &
                            operator=( SparseImageFormatProperties const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SparseImageFormatProperties & operator=( VkSparseImageFormatProperties const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SparseImageFormatProperties const *>( &rhs );
      return *this;
    }

    operator VkSparseImageFormatProperties const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSparseImageFormatProperties *>( this );
    }

    operator VkSparseImageFormatProperties &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSparseImageFormatProperties *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SparseImageFormatProperties const & ) const = default;
#else
    bool operator==( SparseImageFormatProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( aspectMask == rhs.aspectMask ) && ( imageGranularity == rhs.imageGranularity ) && ( flags == rhs.flags );
    }

    bool operator!=( SparseImageFormatProperties const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::ImageAspectFlags       aspectMask       = {};
    VULKAN_HPP_NAMESPACE::Extent3D               imageGranularity = {};
    VULKAN_HPP_NAMESPACE::SparseImageFormatFlags flags            = {};
  };
  static_assert( sizeof( SparseImageFormatProperties ) == sizeof( VkSparseImageFormatProperties ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SparseImageFormatProperties>::value,
                 "struct wrapper is not a standard layout!" );

  struct SparseImageFormatProperties2
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eSparseImageFormatProperties2;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR SparseImageFormatProperties2(
      VULKAN_HPP_NAMESPACE::SparseImageFormatProperties properties_ = {} ) VULKAN_HPP_NOEXCEPT
      : properties( properties_ )
    {}

    VULKAN_HPP_CONSTEXPR
      SparseImageFormatProperties2( SparseImageFormatProperties2 const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SparseImageFormatProperties2( VkSparseImageFormatProperties2 const & rhs ) VULKAN_HPP_NOEXCEPT
      : SparseImageFormatProperties2( *reinterpret_cast<SparseImageFormatProperties2 const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SparseImageFormatProperties2 &
                            operator=( SparseImageFormatProperties2 const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SparseImageFormatProperties2 & operator=( VkSparseImageFormatProperties2 const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SparseImageFormatProperties2 const *>( &rhs );
      return *this;
    }

    operator VkSparseImageFormatProperties2 const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSparseImageFormatProperties2 *>( this );
    }

    operator VkSparseImageFormatProperties2 &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSparseImageFormatProperties2 *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SparseImageFormatProperties2 const & ) const = default;
#else
    bool operator==( SparseImageFormatProperties2 const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( properties == rhs.properties );
    }

    bool operator!=( SparseImageFormatProperties2 const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType               sType      = StructureType::eSparseImageFormatProperties2;
    void *                                            pNext      = {};
    VULKAN_HPP_NAMESPACE::SparseImageFormatProperties properties = {};
  };
  static_assert( sizeof( SparseImageFormatProperties2 ) == sizeof( VkSparseImageFormatProperties2 ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SparseImageFormatProperties2>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eSparseImageFormatProperties2>
  {
    using Type = SparseImageFormatProperties2;
  };
  using SparseImageFormatProperties2KHR = SparseImageFormatProperties2;

  struct SparseImageMemoryRequirements
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      SparseImageMemoryRequirements( VULKAN_HPP_NAMESPACE::SparseImageFormatProperties formatProperties_     = {},
                                     uint32_t                                          imageMipTailFirstLod_ = {},
                                     VULKAN_HPP_NAMESPACE::DeviceSize                  imageMipTailSize_     = {},
                                     VULKAN_HPP_NAMESPACE::DeviceSize                  imageMipTailOffset_   = {},
                                     VULKAN_HPP_NAMESPACE::DeviceSize imageMipTailStride_ = {} ) VULKAN_HPP_NOEXCEPT
      : formatProperties( formatProperties_ )
      , imageMipTailFirstLod( imageMipTailFirstLod_ )
      , imageMipTailSize( imageMipTailSize_ )
      , imageMipTailOffset( imageMipTailOffset_ )
      , imageMipTailStride( imageMipTailStride_ )
    {}

    VULKAN_HPP_CONSTEXPR
      SparseImageMemoryRequirements( SparseImageMemoryRequirements const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SparseImageMemoryRequirements( VkSparseImageMemoryRequirements const & rhs ) VULKAN_HPP_NOEXCEPT
      : SparseImageMemoryRequirements( *reinterpret_cast<SparseImageMemoryRequirements const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SparseImageMemoryRequirements &
                            operator=( SparseImageMemoryRequirements const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SparseImageMemoryRequirements & operator=( VkSparseImageMemoryRequirements const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SparseImageMemoryRequirements const *>( &rhs );
      return *this;
    }

    operator VkSparseImageMemoryRequirements const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSparseImageMemoryRequirements *>( this );
    }

    operator VkSparseImageMemoryRequirements &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSparseImageMemoryRequirements *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SparseImageMemoryRequirements const & ) const = default;
#else
    bool operator==( SparseImageMemoryRequirements const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( formatProperties == rhs.formatProperties ) && ( imageMipTailFirstLod == rhs.imageMipTailFirstLod ) &&
             ( imageMipTailSize == rhs.imageMipTailSize ) && ( imageMipTailOffset == rhs.imageMipTailOffset ) &&
             ( imageMipTailStride == rhs.imageMipTailStride );
    }

    bool operator!=( SparseImageMemoryRequirements const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::SparseImageFormatProperties formatProperties     = {};
    uint32_t                                          imageMipTailFirstLod = {};
    VULKAN_HPP_NAMESPACE::DeviceSize                  imageMipTailSize     = {};
    VULKAN_HPP_NAMESPACE::DeviceSize                  imageMipTailOffset   = {};
    VULKAN_HPP_NAMESPACE::DeviceSize                  imageMipTailStride   = {};
  };
  static_assert( sizeof( SparseImageMemoryRequirements ) == sizeof( VkSparseImageMemoryRequirements ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SparseImageMemoryRequirements>::value,
                 "struct wrapper is not a standard layout!" );

  struct SparseImageMemoryRequirements2
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eSparseImageMemoryRequirements2;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR SparseImageMemoryRequirements2(
      VULKAN_HPP_NAMESPACE::SparseImageMemoryRequirements memoryRequirements_ = {} ) VULKAN_HPP_NOEXCEPT
      : memoryRequirements( memoryRequirements_ )
    {}

    VULKAN_HPP_CONSTEXPR
      SparseImageMemoryRequirements2( SparseImageMemoryRequirements2 const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SparseImageMemoryRequirements2( VkSparseImageMemoryRequirements2 const & rhs ) VULKAN_HPP_NOEXCEPT
      : SparseImageMemoryRequirements2( *reinterpret_cast<SparseImageMemoryRequirements2 const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SparseImageMemoryRequirements2 &
                            operator=( SparseImageMemoryRequirements2 const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SparseImageMemoryRequirements2 & operator=( VkSparseImageMemoryRequirements2 const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SparseImageMemoryRequirements2 const *>( &rhs );
      return *this;
    }

    operator VkSparseImageMemoryRequirements2 const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSparseImageMemoryRequirements2 *>( this );
    }

    operator VkSparseImageMemoryRequirements2 &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSparseImageMemoryRequirements2 *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SparseImageMemoryRequirements2 const & ) const = default;
#else
    bool operator==( SparseImageMemoryRequirements2 const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( memoryRequirements == rhs.memoryRequirements );
    }

    bool operator!=( SparseImageMemoryRequirements2 const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                 sType = StructureType::eSparseImageMemoryRequirements2;
    void *                                              pNext = {};
    VULKAN_HPP_NAMESPACE::SparseImageMemoryRequirements memoryRequirements = {};
  };
  static_assert( sizeof( SparseImageMemoryRequirements2 ) == sizeof( VkSparseImageMemoryRequirements2 ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SparseImageMemoryRequirements2>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eSparseImageMemoryRequirements2>
  {
    using Type = SparseImageMemoryRequirements2;
  };
  using SparseImageMemoryRequirements2KHR = SparseImageMemoryRequirements2;

#if defined( VK_USE_PLATFORM_GGP )
  struct StreamDescriptorSurfaceCreateInfoGGP
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eStreamDescriptorSurfaceCreateInfoGGP;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      StreamDescriptorSurfaceCreateInfoGGP( VULKAN_HPP_NAMESPACE::StreamDescriptorSurfaceCreateFlagsGGP flags_ = {},
                                            GgpStreamDescriptor streamDescriptor_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , streamDescriptor( streamDescriptor_ )
    {}

    VULKAN_HPP_CONSTEXPR StreamDescriptorSurfaceCreateInfoGGP( StreamDescriptorSurfaceCreateInfoGGP const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    StreamDescriptorSurfaceCreateInfoGGP( VkStreamDescriptorSurfaceCreateInfoGGP const & rhs ) VULKAN_HPP_NOEXCEPT
      : StreamDescriptorSurfaceCreateInfoGGP( *reinterpret_cast<StreamDescriptorSurfaceCreateInfoGGP const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 StreamDescriptorSurfaceCreateInfoGGP &
                            operator=( StreamDescriptorSurfaceCreateInfoGGP const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    StreamDescriptorSurfaceCreateInfoGGP &
      operator=( VkStreamDescriptorSurfaceCreateInfoGGP const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::StreamDescriptorSurfaceCreateInfoGGP const *>( &rhs );
      return *this;
    }

    StreamDescriptorSurfaceCreateInfoGGP & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    StreamDescriptorSurfaceCreateInfoGGP &
      setFlags( VULKAN_HPP_NAMESPACE::StreamDescriptorSurfaceCreateFlagsGGP flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    StreamDescriptorSurfaceCreateInfoGGP &
      setStreamDescriptor( GgpStreamDescriptor streamDescriptor_ ) VULKAN_HPP_NOEXCEPT
    {
      streamDescriptor = streamDescriptor_;
      return *this;
    }

    operator VkStreamDescriptorSurfaceCreateInfoGGP const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkStreamDescriptorSurfaceCreateInfoGGP *>( this );
    }

    operator VkStreamDescriptorSurfaceCreateInfoGGP &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkStreamDescriptorSurfaceCreateInfoGGP *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( StreamDescriptorSurfaceCreateInfoGGP const & ) const = default;
#  else
    bool operator==( StreamDescriptorSurfaceCreateInfoGGP const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( memcmp( &streamDescriptor, &rhs.streamDescriptor, sizeof( GgpStreamDescriptor ) ) == 0 );
    }

    bool operator!=( StreamDescriptorSurfaceCreateInfoGGP const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::eStreamDescriptorSurfaceCreateInfoGGP;
    const void *                        pNext = {};
    VULKAN_HPP_NAMESPACE::StreamDescriptorSurfaceCreateFlagsGGP flags            = {};
    GgpStreamDescriptor                                         streamDescriptor = {};
  };
  static_assert( sizeof( StreamDescriptorSurfaceCreateInfoGGP ) == sizeof( VkStreamDescriptorSurfaceCreateInfoGGP ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<StreamDescriptorSurfaceCreateInfoGGP>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eStreamDescriptorSurfaceCreateInfoGGP>
  {
    using Type = StreamDescriptorSurfaceCreateInfoGGP;
  };
#endif /*VK_USE_PLATFORM_GGP*/

  struct StridedDeviceAddressRegionKHR
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      StridedDeviceAddressRegionKHR( VULKAN_HPP_NAMESPACE::DeviceAddress deviceAddress_ = {},
                                     VULKAN_HPP_NAMESPACE::DeviceSize    stride_        = {},
                                     VULKAN_HPP_NAMESPACE::DeviceSize    size_          = {} ) VULKAN_HPP_NOEXCEPT
      : deviceAddress( deviceAddress_ )
      , stride( stride_ )
      , size( size_ )
    {}

    VULKAN_HPP_CONSTEXPR
      StridedDeviceAddressRegionKHR( StridedDeviceAddressRegionKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    StridedDeviceAddressRegionKHR( VkStridedDeviceAddressRegionKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : StridedDeviceAddressRegionKHR( *reinterpret_cast<StridedDeviceAddressRegionKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 StridedDeviceAddressRegionKHR &
                            operator=( StridedDeviceAddressRegionKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    StridedDeviceAddressRegionKHR & operator=( VkStridedDeviceAddressRegionKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::StridedDeviceAddressRegionKHR const *>( &rhs );
      return *this;
    }

    StridedDeviceAddressRegionKHR &
      setDeviceAddress( VULKAN_HPP_NAMESPACE::DeviceAddress deviceAddress_ ) VULKAN_HPP_NOEXCEPT
    {
      deviceAddress = deviceAddress_;
      return *this;
    }

    StridedDeviceAddressRegionKHR & setStride( VULKAN_HPP_NAMESPACE::DeviceSize stride_ ) VULKAN_HPP_NOEXCEPT
    {
      stride = stride_;
      return *this;
    }

    StridedDeviceAddressRegionKHR & setSize( VULKAN_HPP_NAMESPACE::DeviceSize size_ ) VULKAN_HPP_NOEXCEPT
    {
      size = size_;
      return *this;
    }

    operator VkStridedDeviceAddressRegionKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkStridedDeviceAddressRegionKHR *>( this );
    }

    operator VkStridedDeviceAddressRegionKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkStridedDeviceAddressRegionKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( StridedDeviceAddressRegionKHR const & ) const = default;
#else
    bool operator==( StridedDeviceAddressRegionKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( deviceAddress == rhs.deviceAddress ) && ( stride == rhs.stride ) && ( size == rhs.size );
    }

    bool operator!=( StridedDeviceAddressRegionKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::DeviceAddress deviceAddress = {};
    VULKAN_HPP_NAMESPACE::DeviceSize    stride        = {};
    VULKAN_HPP_NAMESPACE::DeviceSize    size          = {};
  };
  static_assert( sizeof( StridedDeviceAddressRegionKHR ) == sizeof( VkStridedDeviceAddressRegionKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<StridedDeviceAddressRegionKHR>::value,
                 "struct wrapper is not a standard layout!" );

  struct SubmitInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eSubmitInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      SubmitInfo( uint32_t                                         waitSemaphoreCount_   = {},
                  const VULKAN_HPP_NAMESPACE::Semaphore *          pWaitSemaphores_      = {},
                  const VULKAN_HPP_NAMESPACE::PipelineStageFlags * pWaitDstStageMask_    = {},
                  uint32_t                                         commandBufferCount_   = {},
                  const VULKAN_HPP_NAMESPACE::CommandBuffer *      pCommandBuffers_      = {},
                  uint32_t                                         signalSemaphoreCount_ = {},
                  const VULKAN_HPP_NAMESPACE::Semaphore *          pSignalSemaphores_    = {} ) VULKAN_HPP_NOEXCEPT
      : waitSemaphoreCount( waitSemaphoreCount_ )
      , pWaitSemaphores( pWaitSemaphores_ )
      , pWaitDstStageMask( pWaitDstStageMask_ )
      , commandBufferCount( commandBufferCount_ )
      , pCommandBuffers( pCommandBuffers_ )
      , signalSemaphoreCount( signalSemaphoreCount_ )
      , pSignalSemaphores( pSignalSemaphores_ )
    {}

    VULKAN_HPP_CONSTEXPR SubmitInfo( SubmitInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SubmitInfo( VkSubmitInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : SubmitInfo( *reinterpret_cast<SubmitInfo const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    SubmitInfo(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::Semaphore> const & waitSemaphores_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::PipelineStageFlags> const &
        waitDstStageMask_ = {},
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::CommandBuffer> const &
        commandBuffers_ = {},
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::Semaphore> const &
        signalSemaphores_ = {} )
      : waitSemaphoreCount( static_cast<uint32_t>( waitSemaphores_.size() ) )
      , pWaitSemaphores( waitSemaphores_.data() )
      , pWaitDstStageMask( waitDstStageMask_.data() )
      , commandBufferCount( static_cast<uint32_t>( commandBuffers_.size() ) )
      , pCommandBuffers( commandBuffers_.data() )
      , signalSemaphoreCount( static_cast<uint32_t>( signalSemaphores_.size() ) )
      , pSignalSemaphores( signalSemaphores_.data() )
    {
#    ifdef VULKAN_HPP_NO_EXCEPTIONS
      VULKAN_HPP_ASSERT( waitSemaphores_.size() == waitDstStageMask_.size() );
#    else
      if ( waitSemaphores_.size() != waitDstStageMask_.size() )
      {
        throw LogicError( VULKAN_HPP_NAMESPACE_STRING
                          "::SubmitInfo::SubmitInfo: waitSemaphores_.size() != waitDstStageMask_.size()" );
      }
#    endif /*VULKAN_HPP_NO_EXCEPTIONS*/
    }
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SubmitInfo & operator=( SubmitInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SubmitInfo & operator=( VkSubmitInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SubmitInfo const *>( &rhs );
      return *this;
    }

    SubmitInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    SubmitInfo & setWaitSemaphoreCount( uint32_t waitSemaphoreCount_ ) VULKAN_HPP_NOEXCEPT
    {
      waitSemaphoreCount = waitSemaphoreCount_;
      return *this;
    }

    SubmitInfo & setPWaitSemaphores( const VULKAN_HPP_NAMESPACE::Semaphore * pWaitSemaphores_ ) VULKAN_HPP_NOEXCEPT
    {
      pWaitSemaphores = pWaitSemaphores_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    SubmitInfo & setWaitSemaphores(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::Semaphore> const & waitSemaphores_ )
      VULKAN_HPP_NOEXCEPT
    {
      waitSemaphoreCount = static_cast<uint32_t>( waitSemaphores_.size() );
      pWaitSemaphores    = waitSemaphores_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    SubmitInfo &
      setPWaitDstStageMask( const VULKAN_HPP_NAMESPACE::PipelineStageFlags * pWaitDstStageMask_ ) VULKAN_HPP_NOEXCEPT
    {
      pWaitDstStageMask = pWaitDstStageMask_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    SubmitInfo & setWaitDstStageMask(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::PipelineStageFlags> const &
        waitDstStageMask_ ) VULKAN_HPP_NOEXCEPT
    {
      waitSemaphoreCount = static_cast<uint32_t>( waitDstStageMask_.size() );
      pWaitDstStageMask  = waitDstStageMask_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    SubmitInfo & setCommandBufferCount( uint32_t commandBufferCount_ ) VULKAN_HPP_NOEXCEPT
    {
      commandBufferCount = commandBufferCount_;
      return *this;
    }

    SubmitInfo & setPCommandBuffers( const VULKAN_HPP_NAMESPACE::CommandBuffer * pCommandBuffers_ ) VULKAN_HPP_NOEXCEPT
    {
      pCommandBuffers = pCommandBuffers_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    SubmitInfo & setCommandBuffers(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::CommandBuffer> const & commandBuffers_ )
      VULKAN_HPP_NOEXCEPT
    {
      commandBufferCount = static_cast<uint32_t>( commandBuffers_.size() );
      pCommandBuffers    = commandBuffers_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    SubmitInfo & setSignalSemaphoreCount( uint32_t signalSemaphoreCount_ ) VULKAN_HPP_NOEXCEPT
    {
      signalSemaphoreCount = signalSemaphoreCount_;
      return *this;
    }

    SubmitInfo & setPSignalSemaphores( const VULKAN_HPP_NAMESPACE::Semaphore * pSignalSemaphores_ ) VULKAN_HPP_NOEXCEPT
    {
      pSignalSemaphores = pSignalSemaphores_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    SubmitInfo & setSignalSemaphores(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::Semaphore> const & signalSemaphores_ )
      VULKAN_HPP_NOEXCEPT
    {
      signalSemaphoreCount = static_cast<uint32_t>( signalSemaphores_.size() );
      pSignalSemaphores    = signalSemaphores_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkSubmitInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSubmitInfo *>( this );
    }

    operator VkSubmitInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSubmitInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SubmitInfo const & ) const = default;
#else
    bool operator==( SubmitInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( waitSemaphoreCount == rhs.waitSemaphoreCount ) &&
             ( pWaitSemaphores == rhs.pWaitSemaphores ) && ( pWaitDstStageMask == rhs.pWaitDstStageMask ) &&
             ( commandBufferCount == rhs.commandBufferCount ) && ( pCommandBuffers == rhs.pCommandBuffers ) &&
             ( signalSemaphoreCount == rhs.signalSemaphoreCount ) && ( pSignalSemaphores == rhs.pSignalSemaphores );
    }

    bool operator!=( SubmitInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType              sType                = StructureType::eSubmitInfo;
    const void *                                     pNext                = {};
    uint32_t                                         waitSemaphoreCount   = {};
    const VULKAN_HPP_NAMESPACE::Semaphore *          pWaitSemaphores      = {};
    const VULKAN_HPP_NAMESPACE::PipelineStageFlags * pWaitDstStageMask    = {};
    uint32_t                                         commandBufferCount   = {};
    const VULKAN_HPP_NAMESPACE::CommandBuffer *      pCommandBuffers      = {};
    uint32_t                                         signalSemaphoreCount = {};
    const VULKAN_HPP_NAMESPACE::Semaphore *          pSignalSemaphores    = {};
  };
  static_assert( sizeof( SubmitInfo ) == sizeof( VkSubmitInfo ), "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SubmitInfo>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eSubmitInfo>
  {
    using Type = SubmitInfo;
  };

  struct SubmitInfo2KHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eSubmitInfo2KHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR SubmitInfo2KHR(
      VULKAN_HPP_NAMESPACE::SubmitFlagsKHR                     flags_                    = {},
      uint32_t                                                 waitSemaphoreInfoCount_   = {},
      const VULKAN_HPP_NAMESPACE::SemaphoreSubmitInfoKHR *     pWaitSemaphoreInfos_      = {},
      uint32_t                                                 commandBufferInfoCount_   = {},
      const VULKAN_HPP_NAMESPACE::CommandBufferSubmitInfoKHR * pCommandBufferInfos_      = {},
      uint32_t                                                 signalSemaphoreInfoCount_ = {},
      const VULKAN_HPP_NAMESPACE::SemaphoreSubmitInfoKHR *     pSignalSemaphoreInfos_    = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , waitSemaphoreInfoCount( waitSemaphoreInfoCount_ )
      , pWaitSemaphoreInfos( pWaitSemaphoreInfos_ )
      , commandBufferInfoCount( commandBufferInfoCount_ )
      , pCommandBufferInfos( pCommandBufferInfos_ )
      , signalSemaphoreInfoCount( signalSemaphoreInfoCount_ )
      , pSignalSemaphoreInfos( pSignalSemaphoreInfos_ )
    {}

    VULKAN_HPP_CONSTEXPR SubmitInfo2KHR( SubmitInfo2KHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SubmitInfo2KHR( VkSubmitInfo2KHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : SubmitInfo2KHR( *reinterpret_cast<SubmitInfo2KHR const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    SubmitInfo2KHR(
      VULKAN_HPP_NAMESPACE::SubmitFlagsKHR flags_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::SemaphoreSubmitInfoKHR> const &
        waitSemaphoreInfos_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::CommandBufferSubmitInfoKHR> const &
        commandBufferInfos_ = {},
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::SemaphoreSubmitInfoKHR> const &
        signalSemaphoreInfos_ = {} )
      : flags( flags_ )
      , waitSemaphoreInfoCount( static_cast<uint32_t>( waitSemaphoreInfos_.size() ) )
      , pWaitSemaphoreInfos( waitSemaphoreInfos_.data() )
      , commandBufferInfoCount( static_cast<uint32_t>( commandBufferInfos_.size() ) )
      , pCommandBufferInfos( commandBufferInfos_.data() )
      , signalSemaphoreInfoCount( static_cast<uint32_t>( signalSemaphoreInfos_.size() ) )
      , pSignalSemaphoreInfos( signalSemaphoreInfos_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SubmitInfo2KHR & operator=( SubmitInfo2KHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SubmitInfo2KHR & operator=( VkSubmitInfo2KHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SubmitInfo2KHR const *>( &rhs );
      return *this;
    }

    SubmitInfo2KHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    SubmitInfo2KHR & setFlags( VULKAN_HPP_NAMESPACE::SubmitFlagsKHR flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    SubmitInfo2KHR & setWaitSemaphoreInfoCount( uint32_t waitSemaphoreInfoCount_ ) VULKAN_HPP_NOEXCEPT
    {
      waitSemaphoreInfoCount = waitSemaphoreInfoCount_;
      return *this;
    }

    SubmitInfo2KHR & setPWaitSemaphoreInfos( const VULKAN_HPP_NAMESPACE::SemaphoreSubmitInfoKHR * pWaitSemaphoreInfos_ )
      VULKAN_HPP_NOEXCEPT
    {
      pWaitSemaphoreInfos = pWaitSemaphoreInfos_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    SubmitInfo2KHR & setWaitSemaphoreInfos(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::SemaphoreSubmitInfoKHR> const &
        waitSemaphoreInfos_ ) VULKAN_HPP_NOEXCEPT
    {
      waitSemaphoreInfoCount = static_cast<uint32_t>( waitSemaphoreInfos_.size() );
      pWaitSemaphoreInfos    = waitSemaphoreInfos_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    SubmitInfo2KHR & setCommandBufferInfoCount( uint32_t commandBufferInfoCount_ ) VULKAN_HPP_NOEXCEPT
    {
      commandBufferInfoCount = commandBufferInfoCount_;
      return *this;
    }

    SubmitInfo2KHR & setPCommandBufferInfos(
      const VULKAN_HPP_NAMESPACE::CommandBufferSubmitInfoKHR * pCommandBufferInfos_ ) VULKAN_HPP_NOEXCEPT
    {
      pCommandBufferInfos = pCommandBufferInfos_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    SubmitInfo2KHR & setCommandBufferInfos(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::CommandBufferSubmitInfoKHR> const &
        commandBufferInfos_ ) VULKAN_HPP_NOEXCEPT
    {
      commandBufferInfoCount = static_cast<uint32_t>( commandBufferInfos_.size() );
      pCommandBufferInfos    = commandBufferInfos_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    SubmitInfo2KHR & setSignalSemaphoreInfoCount( uint32_t signalSemaphoreInfoCount_ ) VULKAN_HPP_NOEXCEPT
    {
      signalSemaphoreInfoCount = signalSemaphoreInfoCount_;
      return *this;
    }

    SubmitInfo2KHR & setPSignalSemaphoreInfos(
      const VULKAN_HPP_NAMESPACE::SemaphoreSubmitInfoKHR * pSignalSemaphoreInfos_ ) VULKAN_HPP_NOEXCEPT
    {
      pSignalSemaphoreInfos = pSignalSemaphoreInfos_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    SubmitInfo2KHR & setSignalSemaphoreInfos(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::SemaphoreSubmitInfoKHR> const &
        signalSemaphoreInfos_ ) VULKAN_HPP_NOEXCEPT
    {
      signalSemaphoreInfoCount = static_cast<uint32_t>( signalSemaphoreInfos_.size() );
      pSignalSemaphoreInfos    = signalSemaphoreInfos_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkSubmitInfo2KHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSubmitInfo2KHR *>( this );
    }

    operator VkSubmitInfo2KHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSubmitInfo2KHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SubmitInfo2KHR const & ) const = default;
#else
    bool operator==( SubmitInfo2KHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( waitSemaphoreInfoCount == rhs.waitSemaphoreInfoCount ) &&
             ( pWaitSemaphoreInfos == rhs.pWaitSemaphoreInfos ) &&
             ( commandBufferInfoCount == rhs.commandBufferInfoCount ) &&
             ( pCommandBufferInfos == rhs.pCommandBufferInfos ) &&
             ( signalSemaphoreInfoCount == rhs.signalSemaphoreInfoCount ) &&
             ( pSignalSemaphoreInfos == rhs.pSignalSemaphoreInfos );
    }

    bool operator!=( SubmitInfo2KHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                      sType                    = StructureType::eSubmitInfo2KHR;
    const void *                                             pNext                    = {};
    VULKAN_HPP_NAMESPACE::SubmitFlagsKHR                     flags                    = {};
    uint32_t                                                 waitSemaphoreInfoCount   = {};
    const VULKAN_HPP_NAMESPACE::SemaphoreSubmitInfoKHR *     pWaitSemaphoreInfos      = {};
    uint32_t                                                 commandBufferInfoCount   = {};
    const VULKAN_HPP_NAMESPACE::CommandBufferSubmitInfoKHR * pCommandBufferInfos      = {};
    uint32_t                                                 signalSemaphoreInfoCount = {};
    const VULKAN_HPP_NAMESPACE::SemaphoreSubmitInfoKHR *     pSignalSemaphoreInfos    = {};
  };
  static_assert( sizeof( SubmitInfo2KHR ) == sizeof( VkSubmitInfo2KHR ), "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SubmitInfo2KHR>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eSubmitInfo2KHR>
  {
    using Type = SubmitInfo2KHR;
  };

  struct SubpassBeginInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eSubpassBeginInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR SubpassBeginInfo( VULKAN_HPP_NAMESPACE::SubpassContents contents_ =
                                             VULKAN_HPP_NAMESPACE::SubpassContents::eInline ) VULKAN_HPP_NOEXCEPT
      : contents( contents_ )
    {}

    VULKAN_HPP_CONSTEXPR SubpassBeginInfo( SubpassBeginInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SubpassBeginInfo( VkSubpassBeginInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : SubpassBeginInfo( *reinterpret_cast<SubpassBeginInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SubpassBeginInfo & operator=( SubpassBeginInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SubpassBeginInfo & operator=( VkSubpassBeginInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SubpassBeginInfo const *>( &rhs );
      return *this;
    }

    SubpassBeginInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    SubpassBeginInfo & setContents( VULKAN_HPP_NAMESPACE::SubpassContents contents_ ) VULKAN_HPP_NOEXCEPT
    {
      contents = contents_;
      return *this;
    }

    operator VkSubpassBeginInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSubpassBeginInfo *>( this );
    }

    operator VkSubpassBeginInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSubpassBeginInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SubpassBeginInfo const & ) const = default;
#else
    bool operator==( SubpassBeginInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( contents == rhs.contents );
    }

    bool operator!=( SubpassBeginInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType   sType    = StructureType::eSubpassBeginInfo;
    const void *                          pNext    = {};
    VULKAN_HPP_NAMESPACE::SubpassContents contents = VULKAN_HPP_NAMESPACE::SubpassContents::eInline;
  };
  static_assert( sizeof( SubpassBeginInfo ) == sizeof( VkSubpassBeginInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SubpassBeginInfo>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eSubpassBeginInfo>
  {
    using Type = SubpassBeginInfo;
  };
  using SubpassBeginInfoKHR = SubpassBeginInfo;

  struct SubpassDescriptionDepthStencilResolve
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eSubpassDescriptionDepthStencilResolve;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR SubpassDescriptionDepthStencilResolve(
      VULKAN_HPP_NAMESPACE::ResolveModeFlagBits depthResolveMode_   = VULKAN_HPP_NAMESPACE::ResolveModeFlagBits::eNone,
      VULKAN_HPP_NAMESPACE::ResolveModeFlagBits stencilResolveMode_ = VULKAN_HPP_NAMESPACE::ResolveModeFlagBits::eNone,
      const VULKAN_HPP_NAMESPACE::AttachmentReference2 * pDepthStencilResolveAttachment_ = {} ) VULKAN_HPP_NOEXCEPT
      : depthResolveMode( depthResolveMode_ )
      , stencilResolveMode( stencilResolveMode_ )
      , pDepthStencilResolveAttachment( pDepthStencilResolveAttachment_ )
    {}

    VULKAN_HPP_CONSTEXPR SubpassDescriptionDepthStencilResolve( SubpassDescriptionDepthStencilResolve const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    SubpassDescriptionDepthStencilResolve( VkSubpassDescriptionDepthStencilResolve const & rhs ) VULKAN_HPP_NOEXCEPT
      : SubpassDescriptionDepthStencilResolve(
          *reinterpret_cast<SubpassDescriptionDepthStencilResolve const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SubpassDescriptionDepthStencilResolve &
                            operator=( SubpassDescriptionDepthStencilResolve const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SubpassDescriptionDepthStencilResolve &
      operator=( VkSubpassDescriptionDepthStencilResolve const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SubpassDescriptionDepthStencilResolve const *>( &rhs );
      return *this;
    }

    SubpassDescriptionDepthStencilResolve & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    SubpassDescriptionDepthStencilResolve &
      setDepthResolveMode( VULKAN_HPP_NAMESPACE::ResolveModeFlagBits depthResolveMode_ ) VULKAN_HPP_NOEXCEPT
    {
      depthResolveMode = depthResolveMode_;
      return *this;
    }

    SubpassDescriptionDepthStencilResolve &
      setStencilResolveMode( VULKAN_HPP_NAMESPACE::ResolveModeFlagBits stencilResolveMode_ ) VULKAN_HPP_NOEXCEPT
    {
      stencilResolveMode = stencilResolveMode_;
      return *this;
    }

    SubpassDescriptionDepthStencilResolve & setPDepthStencilResolveAttachment(
      const VULKAN_HPP_NAMESPACE::AttachmentReference2 * pDepthStencilResolveAttachment_ ) VULKAN_HPP_NOEXCEPT
    {
      pDepthStencilResolveAttachment = pDepthStencilResolveAttachment_;
      return *this;
    }

    operator VkSubpassDescriptionDepthStencilResolve const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSubpassDescriptionDepthStencilResolve *>( this );
    }

    operator VkSubpassDescriptionDepthStencilResolve &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSubpassDescriptionDepthStencilResolve *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SubpassDescriptionDepthStencilResolve const & ) const = default;
#else
    bool operator==( SubpassDescriptionDepthStencilResolve const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( depthResolveMode == rhs.depthResolveMode ) &&
             ( stencilResolveMode == rhs.stencilResolveMode ) &&
             ( pDepthStencilResolveAttachment == rhs.pDepthStencilResolveAttachment );
    }

    bool operator!=( SubpassDescriptionDepthStencilResolve const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType       sType            = StructureType::eSubpassDescriptionDepthStencilResolve;
    const void *                              pNext            = {};
    VULKAN_HPP_NAMESPACE::ResolveModeFlagBits depthResolveMode = VULKAN_HPP_NAMESPACE::ResolveModeFlagBits::eNone;
    VULKAN_HPP_NAMESPACE::ResolveModeFlagBits stencilResolveMode = VULKAN_HPP_NAMESPACE::ResolveModeFlagBits::eNone;
    const VULKAN_HPP_NAMESPACE::AttachmentReference2 * pDepthStencilResolveAttachment = {};
  };
  static_assert( sizeof( SubpassDescriptionDepthStencilResolve ) == sizeof( VkSubpassDescriptionDepthStencilResolve ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SubpassDescriptionDepthStencilResolve>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eSubpassDescriptionDepthStencilResolve>
  {
    using Type = SubpassDescriptionDepthStencilResolve;
  };
  using SubpassDescriptionDepthStencilResolveKHR = SubpassDescriptionDepthStencilResolve;

  struct SubpassEndInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eSubpassEndInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR SubpassEndInfo() VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_CONSTEXPR SubpassEndInfo( SubpassEndInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SubpassEndInfo( VkSubpassEndInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : SubpassEndInfo( *reinterpret_cast<SubpassEndInfo const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SubpassEndInfo & operator=( SubpassEndInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SubpassEndInfo & operator=( VkSubpassEndInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SubpassEndInfo const *>( &rhs );
      return *this;
    }

    SubpassEndInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    operator VkSubpassEndInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSubpassEndInfo *>( this );
    }

    operator VkSubpassEndInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSubpassEndInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SubpassEndInfo const & ) const = default;
#else
    bool operator==( SubpassEndInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext );
    }

    bool operator!=( SubpassEndInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::eSubpassEndInfo;
    const void *                        pNext = {};
  };
  static_assert( sizeof( SubpassEndInfo ) == sizeof( VkSubpassEndInfo ), "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SubpassEndInfo>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eSubpassEndInfo>
  {
    using Type = SubpassEndInfo;
  };
  using SubpassEndInfoKHR = SubpassEndInfo;

  struct SubpassShadingPipelineCreateInfoHUAWEI
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eSubpasssShadingPipelineCreateInfoHUAWEI;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR SubpassShadingPipelineCreateInfoHUAWEI( VULKAN_HPP_NAMESPACE::RenderPass renderPass_ = {},
                                                                 uint32_t subpass_ = {} ) VULKAN_HPP_NOEXCEPT
      : renderPass( renderPass_ )
      , subpass( subpass_ )
    {}

    VULKAN_HPP_CONSTEXPR SubpassShadingPipelineCreateInfoHUAWEI( SubpassShadingPipelineCreateInfoHUAWEI const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    SubpassShadingPipelineCreateInfoHUAWEI( VkSubpassShadingPipelineCreateInfoHUAWEI const & rhs ) VULKAN_HPP_NOEXCEPT
      : SubpassShadingPipelineCreateInfoHUAWEI(
          *reinterpret_cast<SubpassShadingPipelineCreateInfoHUAWEI const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SubpassShadingPipelineCreateInfoHUAWEI &
                            operator=( SubpassShadingPipelineCreateInfoHUAWEI const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SubpassShadingPipelineCreateInfoHUAWEI &
      operator=( VkSubpassShadingPipelineCreateInfoHUAWEI const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SubpassShadingPipelineCreateInfoHUAWEI const *>( &rhs );
      return *this;
    }

    operator VkSubpassShadingPipelineCreateInfoHUAWEI const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSubpassShadingPipelineCreateInfoHUAWEI *>( this );
    }

    operator VkSubpassShadingPipelineCreateInfoHUAWEI &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSubpassShadingPipelineCreateInfoHUAWEI *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SubpassShadingPipelineCreateInfoHUAWEI const & ) const = default;
#else
    bool operator==( SubpassShadingPipelineCreateInfoHUAWEI const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( renderPass == rhs.renderPass ) &&
             ( subpass == rhs.subpass );
    }

    bool operator!=( SubpassShadingPipelineCreateInfoHUAWEI const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType      = StructureType::eSubpasssShadingPipelineCreateInfoHUAWEI;
    void *                              pNext      = {};
    VULKAN_HPP_NAMESPACE::RenderPass    renderPass = {};
    uint32_t                            subpass    = {};
  };
  static_assert( sizeof( SubpassShadingPipelineCreateInfoHUAWEI ) == sizeof( VkSubpassShadingPipelineCreateInfoHUAWEI ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SubpassShadingPipelineCreateInfoHUAWEI>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eSubpasssShadingPipelineCreateInfoHUAWEI>
  {
    using Type = SubpassShadingPipelineCreateInfoHUAWEI;
  };

  struct SurfaceCapabilities2EXT
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eSurfaceCapabilities2EXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR SurfaceCapabilities2EXT(
      uint32_t                                          minImageCount_       = {},
      uint32_t                                          maxImageCount_       = {},
      VULKAN_HPP_NAMESPACE::Extent2D                    currentExtent_       = {},
      VULKAN_HPP_NAMESPACE::Extent2D                    minImageExtent_      = {},
      VULKAN_HPP_NAMESPACE::Extent2D                    maxImageExtent_      = {},
      uint32_t                                          maxImageArrayLayers_ = {},
      VULKAN_HPP_NAMESPACE::SurfaceTransformFlagsKHR    supportedTransforms_ = {},
      VULKAN_HPP_NAMESPACE::SurfaceTransformFlagBitsKHR currentTransform_ =
        VULKAN_HPP_NAMESPACE::SurfaceTransformFlagBitsKHR::eIdentity,
      VULKAN_HPP_NAMESPACE::CompositeAlphaFlagsKHR supportedCompositeAlpha_  = {},
      VULKAN_HPP_NAMESPACE::ImageUsageFlags        supportedUsageFlags_      = {},
      VULKAN_HPP_NAMESPACE::SurfaceCounterFlagsEXT supportedSurfaceCounters_ = {} ) VULKAN_HPP_NOEXCEPT
      : minImageCount( minImageCount_ )
      , maxImageCount( maxImageCount_ )
      , currentExtent( currentExtent_ )
      , minImageExtent( minImageExtent_ )
      , maxImageExtent( maxImageExtent_ )
      , maxImageArrayLayers( maxImageArrayLayers_ )
      , supportedTransforms( supportedTransforms_ )
      , currentTransform( currentTransform_ )
      , supportedCompositeAlpha( supportedCompositeAlpha_ )
      , supportedUsageFlags( supportedUsageFlags_ )
      , supportedSurfaceCounters( supportedSurfaceCounters_ )
    {}

    VULKAN_HPP_CONSTEXPR SurfaceCapabilities2EXT( SurfaceCapabilities2EXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SurfaceCapabilities2EXT( VkSurfaceCapabilities2EXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : SurfaceCapabilities2EXT( *reinterpret_cast<SurfaceCapabilities2EXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SurfaceCapabilities2EXT &
                            operator=( SurfaceCapabilities2EXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SurfaceCapabilities2EXT & operator=( VkSurfaceCapabilities2EXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SurfaceCapabilities2EXT const *>( &rhs );
      return *this;
    }

    operator VkSurfaceCapabilities2EXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSurfaceCapabilities2EXT *>( this );
    }

    operator VkSurfaceCapabilities2EXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSurfaceCapabilities2EXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SurfaceCapabilities2EXT const & ) const = default;
#else
    bool operator==( SurfaceCapabilities2EXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( minImageCount == rhs.minImageCount ) &&
             ( maxImageCount == rhs.maxImageCount ) && ( currentExtent == rhs.currentExtent ) &&
             ( minImageExtent == rhs.minImageExtent ) && ( maxImageExtent == rhs.maxImageExtent ) &&
             ( maxImageArrayLayers == rhs.maxImageArrayLayers ) && ( supportedTransforms == rhs.supportedTransforms ) &&
             ( currentTransform == rhs.currentTransform ) &&
             ( supportedCompositeAlpha == rhs.supportedCompositeAlpha ) &&
             ( supportedUsageFlags == rhs.supportedUsageFlags ) &&
             ( supportedSurfaceCounters == rhs.supportedSurfaceCounters );
    }

    bool operator!=( SurfaceCapabilities2EXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType               sType               = StructureType::eSurfaceCapabilities2EXT;
    void *                                            pNext               = {};
    uint32_t                                          minImageCount       = {};
    uint32_t                                          maxImageCount       = {};
    VULKAN_HPP_NAMESPACE::Extent2D                    currentExtent       = {};
    VULKAN_HPP_NAMESPACE::Extent2D                    minImageExtent      = {};
    VULKAN_HPP_NAMESPACE::Extent2D                    maxImageExtent      = {};
    uint32_t                                          maxImageArrayLayers = {};
    VULKAN_HPP_NAMESPACE::SurfaceTransformFlagsKHR    supportedTransforms = {};
    VULKAN_HPP_NAMESPACE::SurfaceTransformFlagBitsKHR currentTransform =
      VULKAN_HPP_NAMESPACE::SurfaceTransformFlagBitsKHR::eIdentity;
    VULKAN_HPP_NAMESPACE::CompositeAlphaFlagsKHR supportedCompositeAlpha  = {};
    VULKAN_HPP_NAMESPACE::ImageUsageFlags        supportedUsageFlags      = {};
    VULKAN_HPP_NAMESPACE::SurfaceCounterFlagsEXT supportedSurfaceCounters = {};
  };
  static_assert( sizeof( SurfaceCapabilities2EXT ) == sizeof( VkSurfaceCapabilities2EXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SurfaceCapabilities2EXT>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eSurfaceCapabilities2EXT>
  {
    using Type = SurfaceCapabilities2EXT;
  };

  struct SurfaceCapabilitiesKHR
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      SurfaceCapabilitiesKHR( uint32_t                                          minImageCount_       = {},
                              uint32_t                                          maxImageCount_       = {},
                              VULKAN_HPP_NAMESPACE::Extent2D                    currentExtent_       = {},
                              VULKAN_HPP_NAMESPACE::Extent2D                    minImageExtent_      = {},
                              VULKAN_HPP_NAMESPACE::Extent2D                    maxImageExtent_      = {},
                              uint32_t                                          maxImageArrayLayers_ = {},
                              VULKAN_HPP_NAMESPACE::SurfaceTransformFlagsKHR    supportedTransforms_ = {},
                              VULKAN_HPP_NAMESPACE::SurfaceTransformFlagBitsKHR currentTransform_ =
                                VULKAN_HPP_NAMESPACE::SurfaceTransformFlagBitsKHR::eIdentity,
                              VULKAN_HPP_NAMESPACE::CompositeAlphaFlagsKHR supportedCompositeAlpha_ = {},
                              VULKAN_HPP_NAMESPACE::ImageUsageFlags supportedUsageFlags_ = {} ) VULKAN_HPP_NOEXCEPT
      : minImageCount( minImageCount_ )
      , maxImageCount( maxImageCount_ )
      , currentExtent( currentExtent_ )
      , minImageExtent( minImageExtent_ )
      , maxImageExtent( maxImageExtent_ )
      , maxImageArrayLayers( maxImageArrayLayers_ )
      , supportedTransforms( supportedTransforms_ )
      , currentTransform( currentTransform_ )
      , supportedCompositeAlpha( supportedCompositeAlpha_ )
      , supportedUsageFlags( supportedUsageFlags_ )
    {}

    VULKAN_HPP_CONSTEXPR SurfaceCapabilitiesKHR( SurfaceCapabilitiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SurfaceCapabilitiesKHR( VkSurfaceCapabilitiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : SurfaceCapabilitiesKHR( *reinterpret_cast<SurfaceCapabilitiesKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SurfaceCapabilitiesKHR &
                            operator=( SurfaceCapabilitiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SurfaceCapabilitiesKHR & operator=( VkSurfaceCapabilitiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SurfaceCapabilitiesKHR const *>( &rhs );
      return *this;
    }

    operator VkSurfaceCapabilitiesKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSurfaceCapabilitiesKHR *>( this );
    }

    operator VkSurfaceCapabilitiesKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSurfaceCapabilitiesKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SurfaceCapabilitiesKHR const & ) const = default;
#else
    bool operator==( SurfaceCapabilitiesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( minImageCount == rhs.minImageCount ) && ( maxImageCount == rhs.maxImageCount ) &&
             ( currentExtent == rhs.currentExtent ) && ( minImageExtent == rhs.minImageExtent ) &&
             ( maxImageExtent == rhs.maxImageExtent ) && ( maxImageArrayLayers == rhs.maxImageArrayLayers ) &&
             ( supportedTransforms == rhs.supportedTransforms ) && ( currentTransform == rhs.currentTransform ) &&
             ( supportedCompositeAlpha == rhs.supportedCompositeAlpha ) &&
             ( supportedUsageFlags == rhs.supportedUsageFlags );
    }

    bool operator!=( SurfaceCapabilitiesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    uint32_t                                          minImageCount       = {};
    uint32_t                                          maxImageCount       = {};
    VULKAN_HPP_NAMESPACE::Extent2D                    currentExtent       = {};
    VULKAN_HPP_NAMESPACE::Extent2D                    minImageExtent      = {};
    VULKAN_HPP_NAMESPACE::Extent2D                    maxImageExtent      = {};
    uint32_t                                          maxImageArrayLayers = {};
    VULKAN_HPP_NAMESPACE::SurfaceTransformFlagsKHR    supportedTransforms = {};
    VULKAN_HPP_NAMESPACE::SurfaceTransformFlagBitsKHR currentTransform =
      VULKAN_HPP_NAMESPACE::SurfaceTransformFlagBitsKHR::eIdentity;
    VULKAN_HPP_NAMESPACE::CompositeAlphaFlagsKHR supportedCompositeAlpha = {};
    VULKAN_HPP_NAMESPACE::ImageUsageFlags        supportedUsageFlags     = {};
  };
  static_assert( sizeof( SurfaceCapabilitiesKHR ) == sizeof( VkSurfaceCapabilitiesKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SurfaceCapabilitiesKHR>::value, "struct wrapper is not a standard layout!" );

  struct SurfaceCapabilities2KHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eSurfaceCapabilities2KHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR SurfaceCapabilities2KHR(
      VULKAN_HPP_NAMESPACE::SurfaceCapabilitiesKHR surfaceCapabilities_ = {} ) VULKAN_HPP_NOEXCEPT
      : surfaceCapabilities( surfaceCapabilities_ )
    {}

    VULKAN_HPP_CONSTEXPR SurfaceCapabilities2KHR( SurfaceCapabilities2KHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SurfaceCapabilities2KHR( VkSurfaceCapabilities2KHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : SurfaceCapabilities2KHR( *reinterpret_cast<SurfaceCapabilities2KHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SurfaceCapabilities2KHR &
                            operator=( SurfaceCapabilities2KHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SurfaceCapabilities2KHR & operator=( VkSurfaceCapabilities2KHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SurfaceCapabilities2KHR const *>( &rhs );
      return *this;
    }

    operator VkSurfaceCapabilities2KHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSurfaceCapabilities2KHR *>( this );
    }

    operator VkSurfaceCapabilities2KHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSurfaceCapabilities2KHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SurfaceCapabilities2KHR const & ) const = default;
#else
    bool operator==( SurfaceCapabilities2KHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( surfaceCapabilities == rhs.surfaceCapabilities );
    }

    bool operator!=( SurfaceCapabilities2KHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType          sType               = StructureType::eSurfaceCapabilities2KHR;
    void *                                       pNext               = {};
    VULKAN_HPP_NAMESPACE::SurfaceCapabilitiesKHR surfaceCapabilities = {};
  };
  static_assert( sizeof( SurfaceCapabilities2KHR ) == sizeof( VkSurfaceCapabilities2KHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SurfaceCapabilities2KHR>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eSurfaceCapabilities2KHR>
  {
    using Type = SurfaceCapabilities2KHR;
  };

#if defined( VK_USE_PLATFORM_WIN32_KHR )
  struct SurfaceCapabilitiesFullScreenExclusiveEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eSurfaceCapabilitiesFullScreenExclusiveEXT;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR SurfaceCapabilitiesFullScreenExclusiveEXT(
      VULKAN_HPP_NAMESPACE::Bool32 fullScreenExclusiveSupported_ = {} ) VULKAN_HPP_NOEXCEPT
      : fullScreenExclusiveSupported( fullScreenExclusiveSupported_ )
    {}

    VULKAN_HPP_CONSTEXPR SurfaceCapabilitiesFullScreenExclusiveEXT(
      SurfaceCapabilitiesFullScreenExclusiveEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SurfaceCapabilitiesFullScreenExclusiveEXT( VkSurfaceCapabilitiesFullScreenExclusiveEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : SurfaceCapabilitiesFullScreenExclusiveEXT(
          *reinterpret_cast<SurfaceCapabilitiesFullScreenExclusiveEXT const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SurfaceCapabilitiesFullScreenExclusiveEXT &
                            operator=( SurfaceCapabilitiesFullScreenExclusiveEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SurfaceCapabilitiesFullScreenExclusiveEXT &
      operator=( VkSurfaceCapabilitiesFullScreenExclusiveEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SurfaceCapabilitiesFullScreenExclusiveEXT const *>( &rhs );
      return *this;
    }

    SurfaceCapabilitiesFullScreenExclusiveEXT & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    SurfaceCapabilitiesFullScreenExclusiveEXT &
      setFullScreenExclusiveSupported( VULKAN_HPP_NAMESPACE::Bool32 fullScreenExclusiveSupported_ ) VULKAN_HPP_NOEXCEPT
    {
      fullScreenExclusiveSupported = fullScreenExclusiveSupported_;
      return *this;
    }

    operator VkSurfaceCapabilitiesFullScreenExclusiveEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSurfaceCapabilitiesFullScreenExclusiveEXT *>( this );
    }

    operator VkSurfaceCapabilitiesFullScreenExclusiveEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSurfaceCapabilitiesFullScreenExclusiveEXT *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SurfaceCapabilitiesFullScreenExclusiveEXT const & ) const = default;
#  else
    bool operator==( SurfaceCapabilitiesFullScreenExclusiveEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( fullScreenExclusiveSupported == rhs.fullScreenExclusiveSupported );
    }

    bool operator!=( SurfaceCapabilitiesFullScreenExclusiveEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::eSurfaceCapabilitiesFullScreenExclusiveEXT;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        fullScreenExclusiveSupported = {};
  };
  static_assert( sizeof( SurfaceCapabilitiesFullScreenExclusiveEXT ) ==
                   sizeof( VkSurfaceCapabilitiesFullScreenExclusiveEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SurfaceCapabilitiesFullScreenExclusiveEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eSurfaceCapabilitiesFullScreenExclusiveEXT>
  {
    using Type = SurfaceCapabilitiesFullScreenExclusiveEXT;
  };
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

  struct SurfaceFormatKHR
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      SurfaceFormatKHR( VULKAN_HPP_NAMESPACE::Format        format_ = VULKAN_HPP_NAMESPACE::Format::eUndefined,
                        VULKAN_HPP_NAMESPACE::ColorSpaceKHR colorSpace_ =
                          VULKAN_HPP_NAMESPACE::ColorSpaceKHR::eSrgbNonlinear ) VULKAN_HPP_NOEXCEPT
      : format( format_ )
      , colorSpace( colorSpace_ )
    {}

    VULKAN_HPP_CONSTEXPR SurfaceFormatKHR( SurfaceFormatKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SurfaceFormatKHR( VkSurfaceFormatKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : SurfaceFormatKHR( *reinterpret_cast<SurfaceFormatKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SurfaceFormatKHR & operator=( SurfaceFormatKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SurfaceFormatKHR & operator=( VkSurfaceFormatKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SurfaceFormatKHR const *>( &rhs );
      return *this;
    }

    operator VkSurfaceFormatKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSurfaceFormatKHR *>( this );
    }

    operator VkSurfaceFormatKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSurfaceFormatKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SurfaceFormatKHR const & ) const = default;
#else
    bool operator==( SurfaceFormatKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( format == rhs.format ) && ( colorSpace == rhs.colorSpace );
    }

    bool operator!=( SurfaceFormatKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::Format        format     = VULKAN_HPP_NAMESPACE::Format::eUndefined;
    VULKAN_HPP_NAMESPACE::ColorSpaceKHR colorSpace = VULKAN_HPP_NAMESPACE::ColorSpaceKHR::eSrgbNonlinear;
  };
  static_assert( sizeof( SurfaceFormatKHR ) == sizeof( VkSurfaceFormatKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SurfaceFormatKHR>::value, "struct wrapper is not a standard layout!" );

  struct SurfaceFormat2KHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eSurfaceFormat2KHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      SurfaceFormat2KHR( VULKAN_HPP_NAMESPACE::SurfaceFormatKHR surfaceFormat_ = {} ) VULKAN_HPP_NOEXCEPT
      : surfaceFormat( surfaceFormat_ )
    {}

    VULKAN_HPP_CONSTEXPR SurfaceFormat2KHR( SurfaceFormat2KHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SurfaceFormat2KHR( VkSurfaceFormat2KHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : SurfaceFormat2KHR( *reinterpret_cast<SurfaceFormat2KHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SurfaceFormat2KHR &
                            operator=( SurfaceFormat2KHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SurfaceFormat2KHR & operator=( VkSurfaceFormat2KHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SurfaceFormat2KHR const *>( &rhs );
      return *this;
    }

    operator VkSurfaceFormat2KHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSurfaceFormat2KHR *>( this );
    }

    operator VkSurfaceFormat2KHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSurfaceFormat2KHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SurfaceFormat2KHR const & ) const = default;
#else
    bool operator==( SurfaceFormat2KHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( surfaceFormat == rhs.surfaceFormat );
    }

    bool operator!=( SurfaceFormat2KHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType    sType         = StructureType::eSurfaceFormat2KHR;
    void *                                 pNext         = {};
    VULKAN_HPP_NAMESPACE::SurfaceFormatKHR surfaceFormat = {};
  };
  static_assert( sizeof( SurfaceFormat2KHR ) == sizeof( VkSurfaceFormat2KHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SurfaceFormat2KHR>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eSurfaceFormat2KHR>
  {
    using Type = SurfaceFormat2KHR;
  };

#if defined( VK_USE_PLATFORM_WIN32_KHR )
  struct SurfaceFullScreenExclusiveInfoEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eSurfaceFullScreenExclusiveInfoEXT;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      SurfaceFullScreenExclusiveInfoEXT( VULKAN_HPP_NAMESPACE::FullScreenExclusiveEXT fullScreenExclusive_ =
                                           VULKAN_HPP_NAMESPACE::FullScreenExclusiveEXT::eDefault ) VULKAN_HPP_NOEXCEPT
      : fullScreenExclusive( fullScreenExclusive_ )
    {}

    VULKAN_HPP_CONSTEXPR
      SurfaceFullScreenExclusiveInfoEXT( SurfaceFullScreenExclusiveInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SurfaceFullScreenExclusiveInfoEXT( VkSurfaceFullScreenExclusiveInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : SurfaceFullScreenExclusiveInfoEXT( *reinterpret_cast<SurfaceFullScreenExclusiveInfoEXT const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SurfaceFullScreenExclusiveInfoEXT &
                            operator=( SurfaceFullScreenExclusiveInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SurfaceFullScreenExclusiveInfoEXT & operator=( VkSurfaceFullScreenExclusiveInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SurfaceFullScreenExclusiveInfoEXT const *>( &rhs );
      return *this;
    }

    SurfaceFullScreenExclusiveInfoEXT & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    SurfaceFullScreenExclusiveInfoEXT &
      setFullScreenExclusive( VULKAN_HPP_NAMESPACE::FullScreenExclusiveEXT fullScreenExclusive_ ) VULKAN_HPP_NOEXCEPT
    {
      fullScreenExclusive = fullScreenExclusive_;
      return *this;
    }

    operator VkSurfaceFullScreenExclusiveInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSurfaceFullScreenExclusiveInfoEXT *>( this );
    }

    operator VkSurfaceFullScreenExclusiveInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSurfaceFullScreenExclusiveInfoEXT *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SurfaceFullScreenExclusiveInfoEXT const & ) const = default;
#  else
    bool operator==( SurfaceFullScreenExclusiveInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( fullScreenExclusive == rhs.fullScreenExclusive );
    }

    bool operator!=( SurfaceFullScreenExclusiveInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType          sType = StructureType::eSurfaceFullScreenExclusiveInfoEXT;
    void *                                       pNext = {};
    VULKAN_HPP_NAMESPACE::FullScreenExclusiveEXT fullScreenExclusive =
      VULKAN_HPP_NAMESPACE::FullScreenExclusiveEXT::eDefault;
  };
  static_assert( sizeof( SurfaceFullScreenExclusiveInfoEXT ) == sizeof( VkSurfaceFullScreenExclusiveInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SurfaceFullScreenExclusiveInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eSurfaceFullScreenExclusiveInfoEXT>
  {
    using Type = SurfaceFullScreenExclusiveInfoEXT;
  };
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

#if defined( VK_USE_PLATFORM_WIN32_KHR )
  struct SurfaceFullScreenExclusiveWin32InfoEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eSurfaceFullScreenExclusiveWin32InfoEXT;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR SurfaceFullScreenExclusiveWin32InfoEXT( HMONITOR hmonitor_ = {} ) VULKAN_HPP_NOEXCEPT
      : hmonitor( hmonitor_ )
    {}

    VULKAN_HPP_CONSTEXPR SurfaceFullScreenExclusiveWin32InfoEXT( SurfaceFullScreenExclusiveWin32InfoEXT const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    SurfaceFullScreenExclusiveWin32InfoEXT( VkSurfaceFullScreenExclusiveWin32InfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : SurfaceFullScreenExclusiveWin32InfoEXT(
          *reinterpret_cast<SurfaceFullScreenExclusiveWin32InfoEXT const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SurfaceFullScreenExclusiveWin32InfoEXT &
                            operator=( SurfaceFullScreenExclusiveWin32InfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SurfaceFullScreenExclusiveWin32InfoEXT &
      operator=( VkSurfaceFullScreenExclusiveWin32InfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SurfaceFullScreenExclusiveWin32InfoEXT const *>( &rhs );
      return *this;
    }

    SurfaceFullScreenExclusiveWin32InfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    SurfaceFullScreenExclusiveWin32InfoEXT & setHmonitor( HMONITOR hmonitor_ ) VULKAN_HPP_NOEXCEPT
    {
      hmonitor = hmonitor_;
      return *this;
    }

    operator VkSurfaceFullScreenExclusiveWin32InfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSurfaceFullScreenExclusiveWin32InfoEXT *>( this );
    }

    operator VkSurfaceFullScreenExclusiveWin32InfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSurfaceFullScreenExclusiveWin32InfoEXT *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SurfaceFullScreenExclusiveWin32InfoEXT const & ) const = default;
#  else
    bool operator==( SurfaceFullScreenExclusiveWin32InfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( hmonitor == rhs.hmonitor );
    }

    bool operator!=( SurfaceFullScreenExclusiveWin32InfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType    = StructureType::eSurfaceFullScreenExclusiveWin32InfoEXT;
    const void *                        pNext    = {};
    HMONITOR                            hmonitor = {};
  };
  static_assert( sizeof( SurfaceFullScreenExclusiveWin32InfoEXT ) == sizeof( VkSurfaceFullScreenExclusiveWin32InfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SurfaceFullScreenExclusiveWin32InfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eSurfaceFullScreenExclusiveWin32InfoEXT>
  {
    using Type = SurfaceFullScreenExclusiveWin32InfoEXT;
  };
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

  struct SurfaceProtectedCapabilitiesKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eSurfaceProtectedCapabilitiesKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      SurfaceProtectedCapabilitiesKHR( VULKAN_HPP_NAMESPACE::Bool32 supportsProtected_ = {} ) VULKAN_HPP_NOEXCEPT
      : supportsProtected( supportsProtected_ )
    {}

    VULKAN_HPP_CONSTEXPR
      SurfaceProtectedCapabilitiesKHR( SurfaceProtectedCapabilitiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SurfaceProtectedCapabilitiesKHR( VkSurfaceProtectedCapabilitiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : SurfaceProtectedCapabilitiesKHR( *reinterpret_cast<SurfaceProtectedCapabilitiesKHR const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SurfaceProtectedCapabilitiesKHR &
                            operator=( SurfaceProtectedCapabilitiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SurfaceProtectedCapabilitiesKHR & operator=( VkSurfaceProtectedCapabilitiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SurfaceProtectedCapabilitiesKHR const *>( &rhs );
      return *this;
    }

    SurfaceProtectedCapabilitiesKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    SurfaceProtectedCapabilitiesKHR &
      setSupportsProtected( VULKAN_HPP_NAMESPACE::Bool32 supportsProtected_ ) VULKAN_HPP_NOEXCEPT
    {
      supportsProtected = supportsProtected_;
      return *this;
    }

    operator VkSurfaceProtectedCapabilitiesKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSurfaceProtectedCapabilitiesKHR *>( this );
    }

    operator VkSurfaceProtectedCapabilitiesKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSurfaceProtectedCapabilitiesKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SurfaceProtectedCapabilitiesKHR const & ) const = default;
#else
    bool operator==( SurfaceProtectedCapabilitiesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( supportsProtected == rhs.supportsProtected );
    }

    bool operator!=( SurfaceProtectedCapabilitiesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType             = StructureType::eSurfaceProtectedCapabilitiesKHR;
    const void *                        pNext             = {};
    VULKAN_HPP_NAMESPACE::Bool32        supportsProtected = {};
  };
  static_assert( sizeof( SurfaceProtectedCapabilitiesKHR ) == sizeof( VkSurfaceProtectedCapabilitiesKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SurfaceProtectedCapabilitiesKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eSurfaceProtectedCapabilitiesKHR>
  {
    using Type = SurfaceProtectedCapabilitiesKHR;
  };

  struct SwapchainCounterCreateInfoEXT
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eSwapchainCounterCreateInfoEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR SwapchainCounterCreateInfoEXT(
      VULKAN_HPP_NAMESPACE::SurfaceCounterFlagsEXT surfaceCounters_ = {} ) VULKAN_HPP_NOEXCEPT
      : surfaceCounters( surfaceCounters_ )
    {}

    VULKAN_HPP_CONSTEXPR
      SwapchainCounterCreateInfoEXT( SwapchainCounterCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SwapchainCounterCreateInfoEXT( VkSwapchainCounterCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : SwapchainCounterCreateInfoEXT( *reinterpret_cast<SwapchainCounterCreateInfoEXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SwapchainCounterCreateInfoEXT &
                            operator=( SwapchainCounterCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SwapchainCounterCreateInfoEXT & operator=( VkSwapchainCounterCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SwapchainCounterCreateInfoEXT const *>( &rhs );
      return *this;
    }

    SwapchainCounterCreateInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    SwapchainCounterCreateInfoEXT &
      setSurfaceCounters( VULKAN_HPP_NAMESPACE::SurfaceCounterFlagsEXT surfaceCounters_ ) VULKAN_HPP_NOEXCEPT
    {
      surfaceCounters = surfaceCounters_;
      return *this;
    }

    operator VkSwapchainCounterCreateInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSwapchainCounterCreateInfoEXT *>( this );
    }

    operator VkSwapchainCounterCreateInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSwapchainCounterCreateInfoEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SwapchainCounterCreateInfoEXT const & ) const = default;
#else
    bool operator==( SwapchainCounterCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( surfaceCounters == rhs.surfaceCounters );
    }

    bool operator!=( SwapchainCounterCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType          sType           = StructureType::eSwapchainCounterCreateInfoEXT;
    const void *                                 pNext           = {};
    VULKAN_HPP_NAMESPACE::SurfaceCounterFlagsEXT surfaceCounters = {};
  };
  static_assert( sizeof( SwapchainCounterCreateInfoEXT ) == sizeof( VkSwapchainCounterCreateInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SwapchainCounterCreateInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eSwapchainCounterCreateInfoEXT>
  {
    using Type = SwapchainCounterCreateInfoEXT;
  };

  struct SwapchainCreateInfoKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eSwapchainCreateInfoKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR SwapchainCreateInfoKHR(
      VULKAN_HPP_NAMESPACE::SwapchainCreateFlagsKHR flags_         = {},
      VULKAN_HPP_NAMESPACE::SurfaceKHR              surface_       = {},
      uint32_t                                      minImageCount_ = {},
      VULKAN_HPP_NAMESPACE::Format                  imageFormat_   = VULKAN_HPP_NAMESPACE::Format::eUndefined,
      VULKAN_HPP_NAMESPACE::ColorSpaceKHR   imageColorSpace_  = VULKAN_HPP_NAMESPACE::ColorSpaceKHR::eSrgbNonlinear,
      VULKAN_HPP_NAMESPACE::Extent2D        imageExtent_      = {},
      uint32_t                              imageArrayLayers_ = {},
      VULKAN_HPP_NAMESPACE::ImageUsageFlags imageUsage_       = {},
      VULKAN_HPP_NAMESPACE::SharingMode     imageSharingMode_ = VULKAN_HPP_NAMESPACE::SharingMode::eExclusive,
      uint32_t                              queueFamilyIndexCount_ = {},
      const uint32_t *                      pQueueFamilyIndices_   = {},
      VULKAN_HPP_NAMESPACE::SurfaceTransformFlagBitsKHR preTransform_ =
        VULKAN_HPP_NAMESPACE::SurfaceTransformFlagBitsKHR::eIdentity,
      VULKAN_HPP_NAMESPACE::CompositeAlphaFlagBitsKHR compositeAlpha_ =
        VULKAN_HPP_NAMESPACE::CompositeAlphaFlagBitsKHR::eOpaque,
      VULKAN_HPP_NAMESPACE::PresentModeKHR presentMode_  = VULKAN_HPP_NAMESPACE::PresentModeKHR::eImmediate,
      VULKAN_HPP_NAMESPACE::Bool32         clipped_      = {},
      VULKAN_HPP_NAMESPACE::SwapchainKHR   oldSwapchain_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , surface( surface_ )
      , minImageCount( minImageCount_ )
      , imageFormat( imageFormat_ )
      , imageColorSpace( imageColorSpace_ )
      , imageExtent( imageExtent_ )
      , imageArrayLayers( imageArrayLayers_ )
      , imageUsage( imageUsage_ )
      , imageSharingMode( imageSharingMode_ )
      , queueFamilyIndexCount( queueFamilyIndexCount_ )
      , pQueueFamilyIndices( pQueueFamilyIndices_ )
      , preTransform( preTransform_ )
      , compositeAlpha( compositeAlpha_ )
      , presentMode( presentMode_ )
      , clipped( clipped_ )
      , oldSwapchain( oldSwapchain_ )
    {}

    VULKAN_HPP_CONSTEXPR SwapchainCreateInfoKHR( SwapchainCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SwapchainCreateInfoKHR( VkSwapchainCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : SwapchainCreateInfoKHR( *reinterpret_cast<SwapchainCreateInfoKHR const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    SwapchainCreateInfoKHR(
      VULKAN_HPP_NAMESPACE::SwapchainCreateFlagsKHR                         flags_,
      VULKAN_HPP_NAMESPACE::SurfaceKHR                                      surface_,
      uint32_t                                                              minImageCount_,
      VULKAN_HPP_NAMESPACE::Format                                          imageFormat_,
      VULKAN_HPP_NAMESPACE::ColorSpaceKHR                                   imageColorSpace_,
      VULKAN_HPP_NAMESPACE::Extent2D                                        imageExtent_,
      uint32_t                                                              imageArrayLayers_,
      VULKAN_HPP_NAMESPACE::ImageUsageFlags                                 imageUsage_,
      VULKAN_HPP_NAMESPACE::SharingMode                                     imageSharingMode_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const & queueFamilyIndices_,
      VULKAN_HPP_NAMESPACE::SurfaceTransformFlagBitsKHR                     preTransform_ =
        VULKAN_HPP_NAMESPACE::SurfaceTransformFlagBitsKHR::eIdentity,
      VULKAN_HPP_NAMESPACE::CompositeAlphaFlagBitsKHR compositeAlpha_ =
        VULKAN_HPP_NAMESPACE::CompositeAlphaFlagBitsKHR::eOpaque,
      VULKAN_HPP_NAMESPACE::PresentModeKHR presentMode_  = VULKAN_HPP_NAMESPACE::PresentModeKHR::eImmediate,
      VULKAN_HPP_NAMESPACE::Bool32         clipped_      = {},
      VULKAN_HPP_NAMESPACE::SwapchainKHR   oldSwapchain_ = {} )
      : flags( flags_ )
      , surface( surface_ )
      , minImageCount( minImageCount_ )
      , imageFormat( imageFormat_ )
      , imageColorSpace( imageColorSpace_ )
      , imageExtent( imageExtent_ )
      , imageArrayLayers( imageArrayLayers_ )
      , imageUsage( imageUsage_ )
      , imageSharingMode( imageSharingMode_ )
      , queueFamilyIndexCount( static_cast<uint32_t>( queueFamilyIndices_.size() ) )
      , pQueueFamilyIndices( queueFamilyIndices_.data() )
      , preTransform( preTransform_ )
      , compositeAlpha( compositeAlpha_ )
      , presentMode( presentMode_ )
      , clipped( clipped_ )
      , oldSwapchain( oldSwapchain_ )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SwapchainCreateInfoKHR &
                            operator=( SwapchainCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SwapchainCreateInfoKHR & operator=( VkSwapchainCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SwapchainCreateInfoKHR const *>( &rhs );
      return *this;
    }

    SwapchainCreateInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    SwapchainCreateInfoKHR & setFlags( VULKAN_HPP_NAMESPACE::SwapchainCreateFlagsKHR flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    SwapchainCreateInfoKHR & setSurface( VULKAN_HPP_NAMESPACE::SurfaceKHR surface_ ) VULKAN_HPP_NOEXCEPT
    {
      surface = surface_;
      return *this;
    }

    SwapchainCreateInfoKHR & setMinImageCount( uint32_t minImageCount_ ) VULKAN_HPP_NOEXCEPT
    {
      minImageCount = minImageCount_;
      return *this;
    }

    SwapchainCreateInfoKHR & setImageFormat( VULKAN_HPP_NAMESPACE::Format imageFormat_ ) VULKAN_HPP_NOEXCEPT
    {
      imageFormat = imageFormat_;
      return *this;
    }

    SwapchainCreateInfoKHR &
      setImageColorSpace( VULKAN_HPP_NAMESPACE::ColorSpaceKHR imageColorSpace_ ) VULKAN_HPP_NOEXCEPT
    {
      imageColorSpace = imageColorSpace_;
      return *this;
    }

    SwapchainCreateInfoKHR & setImageExtent( VULKAN_HPP_NAMESPACE::Extent2D const & imageExtent_ ) VULKAN_HPP_NOEXCEPT
    {
      imageExtent = imageExtent_;
      return *this;
    }

    SwapchainCreateInfoKHR & setImageArrayLayers( uint32_t imageArrayLayers_ ) VULKAN_HPP_NOEXCEPT
    {
      imageArrayLayers = imageArrayLayers_;
      return *this;
    }

    SwapchainCreateInfoKHR & setImageUsage( VULKAN_HPP_NAMESPACE::ImageUsageFlags imageUsage_ ) VULKAN_HPP_NOEXCEPT
    {
      imageUsage = imageUsage_;
      return *this;
    }

    SwapchainCreateInfoKHR &
      setImageSharingMode( VULKAN_HPP_NAMESPACE::SharingMode imageSharingMode_ ) VULKAN_HPP_NOEXCEPT
    {
      imageSharingMode = imageSharingMode_;
      return *this;
    }

    SwapchainCreateInfoKHR & setQueueFamilyIndexCount( uint32_t queueFamilyIndexCount_ ) VULKAN_HPP_NOEXCEPT
    {
      queueFamilyIndexCount = queueFamilyIndexCount_;
      return *this;
    }

    SwapchainCreateInfoKHR & setPQueueFamilyIndices( const uint32_t * pQueueFamilyIndices_ ) VULKAN_HPP_NOEXCEPT
    {
      pQueueFamilyIndices = pQueueFamilyIndices_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    SwapchainCreateInfoKHR & setQueueFamilyIndices(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const & queueFamilyIndices_ ) VULKAN_HPP_NOEXCEPT
    {
      queueFamilyIndexCount = static_cast<uint32_t>( queueFamilyIndices_.size() );
      pQueueFamilyIndices   = queueFamilyIndices_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    SwapchainCreateInfoKHR &
      setPreTransform( VULKAN_HPP_NAMESPACE::SurfaceTransformFlagBitsKHR preTransform_ ) VULKAN_HPP_NOEXCEPT
    {
      preTransform = preTransform_;
      return *this;
    }

    SwapchainCreateInfoKHR &
      setCompositeAlpha( VULKAN_HPP_NAMESPACE::CompositeAlphaFlagBitsKHR compositeAlpha_ ) VULKAN_HPP_NOEXCEPT
    {
      compositeAlpha = compositeAlpha_;
      return *this;
    }

    SwapchainCreateInfoKHR & setPresentMode( VULKAN_HPP_NAMESPACE::PresentModeKHR presentMode_ ) VULKAN_HPP_NOEXCEPT
    {
      presentMode = presentMode_;
      return *this;
    }

    SwapchainCreateInfoKHR & setClipped( VULKAN_HPP_NAMESPACE::Bool32 clipped_ ) VULKAN_HPP_NOEXCEPT
    {
      clipped = clipped_;
      return *this;
    }

    SwapchainCreateInfoKHR & setOldSwapchain( VULKAN_HPP_NAMESPACE::SwapchainKHR oldSwapchain_ ) VULKAN_HPP_NOEXCEPT
    {
      oldSwapchain = oldSwapchain_;
      return *this;
    }

    operator VkSwapchainCreateInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSwapchainCreateInfoKHR *>( this );
    }

    operator VkSwapchainCreateInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSwapchainCreateInfoKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SwapchainCreateInfoKHR const & ) const = default;
#else
    bool operator==( SwapchainCreateInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) && ( surface == rhs.surface ) &&
             ( minImageCount == rhs.minImageCount ) && ( imageFormat == rhs.imageFormat ) &&
             ( imageColorSpace == rhs.imageColorSpace ) && ( imageExtent == rhs.imageExtent ) &&
             ( imageArrayLayers == rhs.imageArrayLayers ) && ( imageUsage == rhs.imageUsage ) &&
             ( imageSharingMode == rhs.imageSharingMode ) && ( queueFamilyIndexCount == rhs.queueFamilyIndexCount ) &&
             ( pQueueFamilyIndices == rhs.pQueueFamilyIndices ) && ( preTransform == rhs.preTransform ) &&
             ( compositeAlpha == rhs.compositeAlpha ) && ( presentMode == rhs.presentMode ) &&
             ( clipped == rhs.clipped ) && ( oldSwapchain == rhs.oldSwapchain );
    }

    bool operator!=( SwapchainCreateInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType           sType           = StructureType::eSwapchainCreateInfoKHR;
    const void *                                  pNext           = {};
    VULKAN_HPP_NAMESPACE::SwapchainCreateFlagsKHR flags           = {};
    VULKAN_HPP_NAMESPACE::SurfaceKHR              surface         = {};
    uint32_t                                      minImageCount   = {};
    VULKAN_HPP_NAMESPACE::Format                  imageFormat     = VULKAN_HPP_NAMESPACE::Format::eUndefined;
    VULKAN_HPP_NAMESPACE::ColorSpaceKHR           imageColorSpace = VULKAN_HPP_NAMESPACE::ColorSpaceKHR::eSrgbNonlinear;
    VULKAN_HPP_NAMESPACE::Extent2D                imageExtent     = {};
    uint32_t                                      imageArrayLayers      = {};
    VULKAN_HPP_NAMESPACE::ImageUsageFlags         imageUsage            = {};
    VULKAN_HPP_NAMESPACE::SharingMode             imageSharingMode      = VULKAN_HPP_NAMESPACE::SharingMode::eExclusive;
    uint32_t                                      queueFamilyIndexCount = {};
    const uint32_t *                              pQueueFamilyIndices   = {};
    VULKAN_HPP_NAMESPACE::SurfaceTransformFlagBitsKHR preTransform =
      VULKAN_HPP_NAMESPACE::SurfaceTransformFlagBitsKHR::eIdentity;
    VULKAN_HPP_NAMESPACE::CompositeAlphaFlagBitsKHR compositeAlpha =
      VULKAN_HPP_NAMESPACE::CompositeAlphaFlagBitsKHR::eOpaque;
    VULKAN_HPP_NAMESPACE::PresentModeKHR presentMode  = VULKAN_HPP_NAMESPACE::PresentModeKHR::eImmediate;
    VULKAN_HPP_NAMESPACE::Bool32         clipped      = {};
    VULKAN_HPP_NAMESPACE::SwapchainKHR   oldSwapchain = {};
  };
  static_assert( sizeof( SwapchainCreateInfoKHR ) == sizeof( VkSwapchainCreateInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SwapchainCreateInfoKHR>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eSwapchainCreateInfoKHR>
  {
    using Type = SwapchainCreateInfoKHR;
  };

  struct SwapchainDisplayNativeHdrCreateInfoAMD
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eSwapchainDisplayNativeHdrCreateInfoAMD;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR SwapchainDisplayNativeHdrCreateInfoAMD( VULKAN_HPP_NAMESPACE::Bool32 localDimmingEnable_ = {} )
      VULKAN_HPP_NOEXCEPT : localDimmingEnable( localDimmingEnable_ )
    {}

    VULKAN_HPP_CONSTEXPR SwapchainDisplayNativeHdrCreateInfoAMD( SwapchainDisplayNativeHdrCreateInfoAMD const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    SwapchainDisplayNativeHdrCreateInfoAMD( VkSwapchainDisplayNativeHdrCreateInfoAMD const & rhs ) VULKAN_HPP_NOEXCEPT
      : SwapchainDisplayNativeHdrCreateInfoAMD(
          *reinterpret_cast<SwapchainDisplayNativeHdrCreateInfoAMD const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 SwapchainDisplayNativeHdrCreateInfoAMD &
                            operator=( SwapchainDisplayNativeHdrCreateInfoAMD const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    SwapchainDisplayNativeHdrCreateInfoAMD &
      operator=( VkSwapchainDisplayNativeHdrCreateInfoAMD const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::SwapchainDisplayNativeHdrCreateInfoAMD const *>( &rhs );
      return *this;
    }

    SwapchainDisplayNativeHdrCreateInfoAMD & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    SwapchainDisplayNativeHdrCreateInfoAMD &
      setLocalDimmingEnable( VULKAN_HPP_NAMESPACE::Bool32 localDimmingEnable_ ) VULKAN_HPP_NOEXCEPT
    {
      localDimmingEnable = localDimmingEnable_;
      return *this;
    }

    operator VkSwapchainDisplayNativeHdrCreateInfoAMD const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkSwapchainDisplayNativeHdrCreateInfoAMD *>( this );
    }

    operator VkSwapchainDisplayNativeHdrCreateInfoAMD &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkSwapchainDisplayNativeHdrCreateInfoAMD *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( SwapchainDisplayNativeHdrCreateInfoAMD const & ) const = default;
#else
    bool operator==( SwapchainDisplayNativeHdrCreateInfoAMD const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( localDimmingEnable == rhs.localDimmingEnable );
    }

    bool operator!=( SwapchainDisplayNativeHdrCreateInfoAMD const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType              = StructureType::eSwapchainDisplayNativeHdrCreateInfoAMD;
    const void *                        pNext              = {};
    VULKAN_HPP_NAMESPACE::Bool32        localDimmingEnable = {};
  };
  static_assert( sizeof( SwapchainDisplayNativeHdrCreateInfoAMD ) == sizeof( VkSwapchainDisplayNativeHdrCreateInfoAMD ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<SwapchainDisplayNativeHdrCreateInfoAMD>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eSwapchainDisplayNativeHdrCreateInfoAMD>
  {
    using Type = SwapchainDisplayNativeHdrCreateInfoAMD;
  };

  struct TextureLODGatherFormatPropertiesAMD
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eTextureLodGatherFormatPropertiesAMD;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR TextureLODGatherFormatPropertiesAMD(
      VULKAN_HPP_NAMESPACE::Bool32 supportsTextureGatherLODBiasAMD_ = {} ) VULKAN_HPP_NOEXCEPT
      : supportsTextureGatherLODBiasAMD( supportsTextureGatherLODBiasAMD_ )
    {}

    VULKAN_HPP_CONSTEXPR TextureLODGatherFormatPropertiesAMD( TextureLODGatherFormatPropertiesAMD const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    TextureLODGatherFormatPropertiesAMD( VkTextureLODGatherFormatPropertiesAMD const & rhs ) VULKAN_HPP_NOEXCEPT
      : TextureLODGatherFormatPropertiesAMD( *reinterpret_cast<TextureLODGatherFormatPropertiesAMD const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 TextureLODGatherFormatPropertiesAMD &
                            operator=( TextureLODGatherFormatPropertiesAMD const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    TextureLODGatherFormatPropertiesAMD &
      operator=( VkTextureLODGatherFormatPropertiesAMD const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::TextureLODGatherFormatPropertiesAMD const *>( &rhs );
      return *this;
    }

    operator VkTextureLODGatherFormatPropertiesAMD const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkTextureLODGatherFormatPropertiesAMD *>( this );
    }

    operator VkTextureLODGatherFormatPropertiesAMD &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkTextureLODGatherFormatPropertiesAMD *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( TextureLODGatherFormatPropertiesAMD const & ) const = default;
#else
    bool operator==( TextureLODGatherFormatPropertiesAMD const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( supportsTextureGatherLODBiasAMD == rhs.supportsTextureGatherLODBiasAMD );
    }

    bool operator!=( TextureLODGatherFormatPropertiesAMD const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::eTextureLodGatherFormatPropertiesAMD;
    void *                              pNext = {};
    VULKAN_HPP_NAMESPACE::Bool32        supportsTextureGatherLODBiasAMD = {};
  };
  static_assert( sizeof( TextureLODGatherFormatPropertiesAMD ) == sizeof( VkTextureLODGatherFormatPropertiesAMD ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<TextureLODGatherFormatPropertiesAMD>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eTextureLodGatherFormatPropertiesAMD>
  {
    using Type = TextureLODGatherFormatPropertiesAMD;
  };

  struct TimelineSemaphoreSubmitInfo
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eTimelineSemaphoreSubmitInfo;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      TimelineSemaphoreSubmitInfo( uint32_t         waitSemaphoreValueCount_   = {},
                                   const uint64_t * pWaitSemaphoreValues_      = {},
                                   uint32_t         signalSemaphoreValueCount_ = {},
                                   const uint64_t * pSignalSemaphoreValues_    = {} ) VULKAN_HPP_NOEXCEPT
      : waitSemaphoreValueCount( waitSemaphoreValueCount_ )
      , pWaitSemaphoreValues( pWaitSemaphoreValues_ )
      , signalSemaphoreValueCount( signalSemaphoreValueCount_ )
      , pSignalSemaphoreValues( pSignalSemaphoreValues_ )
    {}

    VULKAN_HPP_CONSTEXPR
      TimelineSemaphoreSubmitInfo( TimelineSemaphoreSubmitInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    TimelineSemaphoreSubmitInfo( VkTimelineSemaphoreSubmitInfo const & rhs ) VULKAN_HPP_NOEXCEPT
      : TimelineSemaphoreSubmitInfo( *reinterpret_cast<TimelineSemaphoreSubmitInfo const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    TimelineSemaphoreSubmitInfo(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint64_t> const & waitSemaphoreValues_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint64_t> const & signalSemaphoreValues_ = {} )
      : waitSemaphoreValueCount( static_cast<uint32_t>( waitSemaphoreValues_.size() ) )
      , pWaitSemaphoreValues( waitSemaphoreValues_.data() )
      , signalSemaphoreValueCount( static_cast<uint32_t>( signalSemaphoreValues_.size() ) )
      , pSignalSemaphoreValues( signalSemaphoreValues_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 TimelineSemaphoreSubmitInfo &
                            operator=( TimelineSemaphoreSubmitInfo const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    TimelineSemaphoreSubmitInfo & operator=( VkTimelineSemaphoreSubmitInfo const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::TimelineSemaphoreSubmitInfo const *>( &rhs );
      return *this;
    }

    TimelineSemaphoreSubmitInfo & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    TimelineSemaphoreSubmitInfo & setWaitSemaphoreValueCount( uint32_t waitSemaphoreValueCount_ ) VULKAN_HPP_NOEXCEPT
    {
      waitSemaphoreValueCount = waitSemaphoreValueCount_;
      return *this;
    }

    TimelineSemaphoreSubmitInfo & setPWaitSemaphoreValues( const uint64_t * pWaitSemaphoreValues_ ) VULKAN_HPP_NOEXCEPT
    {
      pWaitSemaphoreValues = pWaitSemaphoreValues_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    TimelineSemaphoreSubmitInfo & setWaitSemaphoreValues(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint64_t> const & waitSemaphoreValues_ ) VULKAN_HPP_NOEXCEPT
    {
      waitSemaphoreValueCount = static_cast<uint32_t>( waitSemaphoreValues_.size() );
      pWaitSemaphoreValues    = waitSemaphoreValues_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    TimelineSemaphoreSubmitInfo &
      setSignalSemaphoreValueCount( uint32_t signalSemaphoreValueCount_ ) VULKAN_HPP_NOEXCEPT
    {
      signalSemaphoreValueCount = signalSemaphoreValueCount_;
      return *this;
    }

    TimelineSemaphoreSubmitInfo &
      setPSignalSemaphoreValues( const uint64_t * pSignalSemaphoreValues_ ) VULKAN_HPP_NOEXCEPT
    {
      pSignalSemaphoreValues = pSignalSemaphoreValues_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    TimelineSemaphoreSubmitInfo & setSignalSemaphoreValues(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint64_t> const & signalSemaphoreValues_ ) VULKAN_HPP_NOEXCEPT
    {
      signalSemaphoreValueCount = static_cast<uint32_t>( signalSemaphoreValues_.size() );
      pSignalSemaphoreValues    = signalSemaphoreValues_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkTimelineSemaphoreSubmitInfo const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkTimelineSemaphoreSubmitInfo *>( this );
    }

    operator VkTimelineSemaphoreSubmitInfo &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkTimelineSemaphoreSubmitInfo *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( TimelineSemaphoreSubmitInfo const & ) const = default;
#else
    bool operator==( TimelineSemaphoreSubmitInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( waitSemaphoreValueCount == rhs.waitSemaphoreValueCount ) &&
             ( pWaitSemaphoreValues == rhs.pWaitSemaphoreValues ) &&
             ( signalSemaphoreValueCount == rhs.signalSemaphoreValueCount ) &&
             ( pSignalSemaphoreValues == rhs.pSignalSemaphoreValues );
    }

    bool operator!=( TimelineSemaphoreSubmitInfo const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType                     = StructureType::eTimelineSemaphoreSubmitInfo;
    const void *                        pNext                     = {};
    uint32_t                            waitSemaphoreValueCount   = {};
    const uint64_t *                    pWaitSemaphoreValues      = {};
    uint32_t                            signalSemaphoreValueCount = {};
    const uint64_t *                    pSignalSemaphoreValues    = {};
  };
  static_assert( sizeof( TimelineSemaphoreSubmitInfo ) == sizeof( VkTimelineSemaphoreSubmitInfo ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<TimelineSemaphoreSubmitInfo>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eTimelineSemaphoreSubmitInfo>
  {
    using Type = TimelineSemaphoreSubmitInfo;
  };
  using TimelineSemaphoreSubmitInfoKHR = TimelineSemaphoreSubmitInfo;

  struct TraceRaysIndirectCommandKHR
  {
#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR TraceRaysIndirectCommandKHR( uint32_t width_  = {},
                                                      uint32_t height_ = {},
                                                      uint32_t depth_  = {} ) VULKAN_HPP_NOEXCEPT
      : width( width_ )
      , height( height_ )
      , depth( depth_ )
    {}

    VULKAN_HPP_CONSTEXPR
      TraceRaysIndirectCommandKHR( TraceRaysIndirectCommandKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    TraceRaysIndirectCommandKHR( VkTraceRaysIndirectCommandKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : TraceRaysIndirectCommandKHR( *reinterpret_cast<TraceRaysIndirectCommandKHR const *>( &rhs ) )
    {}

    explicit TraceRaysIndirectCommandKHR( Extent2D const & extent2D, uint32_t depth_ = {} )
      : width( extent2D.width ), height( extent2D.height ), depth( depth_ )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 TraceRaysIndirectCommandKHR &
                            operator=( TraceRaysIndirectCommandKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    TraceRaysIndirectCommandKHR & operator=( VkTraceRaysIndirectCommandKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::TraceRaysIndirectCommandKHR const *>( &rhs );
      return *this;
    }

    TraceRaysIndirectCommandKHR & setWidth( uint32_t width_ ) VULKAN_HPP_NOEXCEPT
    {
      width = width_;
      return *this;
    }

    TraceRaysIndirectCommandKHR & setHeight( uint32_t height_ ) VULKAN_HPP_NOEXCEPT
    {
      height = height_;
      return *this;
    }

    TraceRaysIndirectCommandKHR & setDepth( uint32_t depth_ ) VULKAN_HPP_NOEXCEPT
    {
      depth = depth_;
      return *this;
    }

    operator VkTraceRaysIndirectCommandKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkTraceRaysIndirectCommandKHR *>( this );
    }

    operator VkTraceRaysIndirectCommandKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkTraceRaysIndirectCommandKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( TraceRaysIndirectCommandKHR const & ) const = default;
#else
    bool operator==( TraceRaysIndirectCommandKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( width == rhs.width ) && ( height == rhs.height ) && ( depth == rhs.depth );
    }

    bool operator!=( TraceRaysIndirectCommandKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    uint32_t width  = {};
    uint32_t height = {};
    uint32_t depth  = {};
  };
  static_assert( sizeof( TraceRaysIndirectCommandKHR ) == sizeof( VkTraceRaysIndirectCommandKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<TraceRaysIndirectCommandKHR>::value,
                 "struct wrapper is not a standard layout!" );

  struct ValidationCacheCreateInfoEXT
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eValidationCacheCreateInfoEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ValidationCacheCreateInfoEXT( VULKAN_HPP_NAMESPACE::ValidationCacheCreateFlagsEXT flags_ = {},
                                                       size_t       initialDataSize_                              = {},
                                                       const void * pInitialData_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , initialDataSize( initialDataSize_ )
      , pInitialData( pInitialData_ )
    {}

    VULKAN_HPP_CONSTEXPR
      ValidationCacheCreateInfoEXT( ValidationCacheCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ValidationCacheCreateInfoEXT( VkValidationCacheCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : ValidationCacheCreateInfoEXT( *reinterpret_cast<ValidationCacheCreateInfoEXT const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    template <typename T>
    ValidationCacheCreateInfoEXT( VULKAN_HPP_NAMESPACE::ValidationCacheCreateFlagsEXT            flags_,
                                  VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const T> const & initialData_ )
      : flags( flags_ ), initialDataSize( initialData_.size() * sizeof( T ) ), pInitialData( initialData_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ValidationCacheCreateInfoEXT &
                            operator=( ValidationCacheCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ValidationCacheCreateInfoEXT & operator=( VkValidationCacheCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ValidationCacheCreateInfoEXT const *>( &rhs );
      return *this;
    }

    ValidationCacheCreateInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ValidationCacheCreateInfoEXT &
      setFlags( VULKAN_HPP_NAMESPACE::ValidationCacheCreateFlagsEXT flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    ValidationCacheCreateInfoEXT & setInitialDataSize( size_t initialDataSize_ ) VULKAN_HPP_NOEXCEPT
    {
      initialDataSize = initialDataSize_;
      return *this;
    }

    ValidationCacheCreateInfoEXT & setPInitialData( const void * pInitialData_ ) VULKAN_HPP_NOEXCEPT
    {
      pInitialData = pInitialData_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    template <typename T>
    ValidationCacheCreateInfoEXT &
      setInitialData( VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const T> const & initialData_ ) VULKAN_HPP_NOEXCEPT
    {
      initialDataSize = initialData_.size() * sizeof( T );
      pInitialData    = initialData_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkValidationCacheCreateInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkValidationCacheCreateInfoEXT *>( this );
    }

    operator VkValidationCacheCreateInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkValidationCacheCreateInfoEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ValidationCacheCreateInfoEXT const & ) const = default;
#else
    bool operator==( ValidationCacheCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( initialDataSize == rhs.initialDataSize ) && ( pInitialData == rhs.pInitialData );
    }

    bool operator!=( ValidationCacheCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                 sType           = StructureType::eValidationCacheCreateInfoEXT;
    const void *                                        pNext           = {};
    VULKAN_HPP_NAMESPACE::ValidationCacheCreateFlagsEXT flags           = {};
    size_t                                              initialDataSize = {};
    const void *                                        pInitialData    = {};
  };
  static_assert( sizeof( ValidationCacheCreateInfoEXT ) == sizeof( VkValidationCacheCreateInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ValidationCacheCreateInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eValidationCacheCreateInfoEXT>
  {
    using Type = ValidationCacheCreateInfoEXT;
  };

  struct ValidationFeaturesEXT
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eValidationFeaturesEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ValidationFeaturesEXT(
      uint32_t                                                  enabledValidationFeatureCount_  = {},
      const VULKAN_HPP_NAMESPACE::ValidationFeatureEnableEXT *  pEnabledValidationFeatures_     = {},
      uint32_t                                                  disabledValidationFeatureCount_ = {},
      const VULKAN_HPP_NAMESPACE::ValidationFeatureDisableEXT * pDisabledValidationFeatures_ = {} ) VULKAN_HPP_NOEXCEPT
      : enabledValidationFeatureCount( enabledValidationFeatureCount_ )
      , pEnabledValidationFeatures( pEnabledValidationFeatures_ )
      , disabledValidationFeatureCount( disabledValidationFeatureCount_ )
      , pDisabledValidationFeatures( pDisabledValidationFeatures_ )
    {}

    VULKAN_HPP_CONSTEXPR ValidationFeaturesEXT( ValidationFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ValidationFeaturesEXT( VkValidationFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : ValidationFeaturesEXT( *reinterpret_cast<ValidationFeaturesEXT const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    ValidationFeaturesEXT(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::ValidationFeatureEnableEXT> const &
        enabledValidationFeatures_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::ValidationFeatureDisableEXT> const &
        disabledValidationFeatures_ = {} )
      : enabledValidationFeatureCount( static_cast<uint32_t>( enabledValidationFeatures_.size() ) )
      , pEnabledValidationFeatures( enabledValidationFeatures_.data() )
      , disabledValidationFeatureCount( static_cast<uint32_t>( disabledValidationFeatures_.size() ) )
      , pDisabledValidationFeatures( disabledValidationFeatures_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ValidationFeaturesEXT &
                            operator=( ValidationFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ValidationFeaturesEXT & operator=( VkValidationFeaturesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ValidationFeaturesEXT const *>( &rhs );
      return *this;
    }

    ValidationFeaturesEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ValidationFeaturesEXT &
      setEnabledValidationFeatureCount( uint32_t enabledValidationFeatureCount_ ) VULKAN_HPP_NOEXCEPT
    {
      enabledValidationFeatureCount = enabledValidationFeatureCount_;
      return *this;
    }

    ValidationFeaturesEXT & setPEnabledValidationFeatures(
      const VULKAN_HPP_NAMESPACE::ValidationFeatureEnableEXT * pEnabledValidationFeatures_ ) VULKAN_HPP_NOEXCEPT
    {
      pEnabledValidationFeatures = pEnabledValidationFeatures_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    ValidationFeaturesEXT & setEnabledValidationFeatures(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::ValidationFeatureEnableEXT> const &
        enabledValidationFeatures_ ) VULKAN_HPP_NOEXCEPT
    {
      enabledValidationFeatureCount = static_cast<uint32_t>( enabledValidationFeatures_.size() );
      pEnabledValidationFeatures    = enabledValidationFeatures_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    ValidationFeaturesEXT &
      setDisabledValidationFeatureCount( uint32_t disabledValidationFeatureCount_ ) VULKAN_HPP_NOEXCEPT
    {
      disabledValidationFeatureCount = disabledValidationFeatureCount_;
      return *this;
    }

    ValidationFeaturesEXT & setPDisabledValidationFeatures(
      const VULKAN_HPP_NAMESPACE::ValidationFeatureDisableEXT * pDisabledValidationFeatures_ ) VULKAN_HPP_NOEXCEPT
    {
      pDisabledValidationFeatures = pDisabledValidationFeatures_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    ValidationFeaturesEXT & setDisabledValidationFeatures(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::ValidationFeatureDisableEXT> const &
        disabledValidationFeatures_ ) VULKAN_HPP_NOEXCEPT
    {
      disabledValidationFeatureCount = static_cast<uint32_t>( disabledValidationFeatures_.size() );
      pDisabledValidationFeatures    = disabledValidationFeatures_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkValidationFeaturesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkValidationFeaturesEXT *>( this );
    }

    operator VkValidationFeaturesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkValidationFeaturesEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ValidationFeaturesEXT const & ) const = default;
#else
    bool operator==( ValidationFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( enabledValidationFeatureCount == rhs.enabledValidationFeatureCount ) &&
             ( pEnabledValidationFeatures == rhs.pEnabledValidationFeatures ) &&
             ( disabledValidationFeatureCount == rhs.disabledValidationFeatureCount ) &&
             ( pDisabledValidationFeatures == rhs.pDisabledValidationFeatures );
    }

    bool operator!=( ValidationFeaturesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                       sType = StructureType::eValidationFeaturesEXT;
    const void *                                              pNext = {};
    uint32_t                                                  enabledValidationFeatureCount  = {};
    const VULKAN_HPP_NAMESPACE::ValidationFeatureEnableEXT *  pEnabledValidationFeatures     = {};
    uint32_t                                                  disabledValidationFeatureCount = {};
    const VULKAN_HPP_NAMESPACE::ValidationFeatureDisableEXT * pDisabledValidationFeatures    = {};
  };
  static_assert( sizeof( ValidationFeaturesEXT ) == sizeof( VkValidationFeaturesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ValidationFeaturesEXT>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eValidationFeaturesEXT>
  {
    using Type = ValidationFeaturesEXT;
  };

  struct ValidationFlagsEXT
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eValidationFlagsEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ValidationFlagsEXT(
      uint32_t                                         disabledValidationCheckCount_ = {},
      const VULKAN_HPP_NAMESPACE::ValidationCheckEXT * pDisabledValidationChecks_    = {} ) VULKAN_HPP_NOEXCEPT
      : disabledValidationCheckCount( disabledValidationCheckCount_ )
      , pDisabledValidationChecks( pDisabledValidationChecks_ )
    {}

    VULKAN_HPP_CONSTEXPR ValidationFlagsEXT( ValidationFlagsEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ValidationFlagsEXT( VkValidationFlagsEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : ValidationFlagsEXT( *reinterpret_cast<ValidationFlagsEXT const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    ValidationFlagsEXT(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::ValidationCheckEXT> const &
        disabledValidationChecks_ )
      : disabledValidationCheckCount( static_cast<uint32_t>( disabledValidationChecks_.size() ) )
      , pDisabledValidationChecks( disabledValidationChecks_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ValidationFlagsEXT &
                            operator=( ValidationFlagsEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ValidationFlagsEXT & operator=( VkValidationFlagsEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ValidationFlagsEXT const *>( &rhs );
      return *this;
    }

    ValidationFlagsEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ValidationFlagsEXT & setDisabledValidationCheckCount( uint32_t disabledValidationCheckCount_ ) VULKAN_HPP_NOEXCEPT
    {
      disabledValidationCheckCount = disabledValidationCheckCount_;
      return *this;
    }

    ValidationFlagsEXT & setPDisabledValidationChecks(
      const VULKAN_HPP_NAMESPACE::ValidationCheckEXT * pDisabledValidationChecks_ ) VULKAN_HPP_NOEXCEPT
    {
      pDisabledValidationChecks = pDisabledValidationChecks_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    ValidationFlagsEXT & setDisabledValidationChecks(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::ValidationCheckEXT> const &
        disabledValidationChecks_ ) VULKAN_HPP_NOEXCEPT
    {
      disabledValidationCheckCount = static_cast<uint32_t>( disabledValidationChecks_.size() );
      pDisabledValidationChecks    = disabledValidationChecks_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkValidationFlagsEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkValidationFlagsEXT *>( this );
    }

    operator VkValidationFlagsEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkValidationFlagsEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ValidationFlagsEXT const & ) const = default;
#else
    bool operator==( ValidationFlagsEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( disabledValidationCheckCount == rhs.disabledValidationCheckCount ) &&
             ( pDisabledValidationChecks == rhs.pDisabledValidationChecks );
    }

    bool operator!=( ValidationFlagsEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType              sType                        = StructureType::eValidationFlagsEXT;
    const void *                                     pNext                        = {};
    uint32_t                                         disabledValidationCheckCount = {};
    const VULKAN_HPP_NAMESPACE::ValidationCheckEXT * pDisabledValidationChecks    = {};
  };
  static_assert( sizeof( ValidationFlagsEXT ) == sizeof( VkValidationFlagsEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ValidationFlagsEXT>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eValidationFlagsEXT>
  {
    using Type = ValidationFlagsEXT;
  };

  struct VertexInputAttributeDescription2EXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eVertexInputAttributeDescription2EXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR VertexInputAttributeDescription2EXT(
      uint32_t                     location_ = {},
      uint32_t                     binding_  = {},
      VULKAN_HPP_NAMESPACE::Format format_   = VULKAN_HPP_NAMESPACE::Format::eUndefined,
      uint32_t                     offset_   = {} ) VULKAN_HPP_NOEXCEPT
      : location( location_ )
      , binding( binding_ )
      , format( format_ )
      , offset( offset_ )
    {}

    VULKAN_HPP_CONSTEXPR VertexInputAttributeDescription2EXT( VertexInputAttributeDescription2EXT const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    VertexInputAttributeDescription2EXT( VkVertexInputAttributeDescription2EXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : VertexInputAttributeDescription2EXT( *reinterpret_cast<VertexInputAttributeDescription2EXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 VertexInputAttributeDescription2EXT &
                            operator=( VertexInputAttributeDescription2EXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VertexInputAttributeDescription2EXT &
      operator=( VkVertexInputAttributeDescription2EXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::VertexInputAttributeDescription2EXT const *>( &rhs );
      return *this;
    }

    VertexInputAttributeDescription2EXT & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    VertexInputAttributeDescription2EXT & setLocation( uint32_t location_ ) VULKAN_HPP_NOEXCEPT
    {
      location = location_;
      return *this;
    }

    VertexInputAttributeDescription2EXT & setBinding( uint32_t binding_ ) VULKAN_HPP_NOEXCEPT
    {
      binding = binding_;
      return *this;
    }

    VertexInputAttributeDescription2EXT & setFormat( VULKAN_HPP_NAMESPACE::Format format_ ) VULKAN_HPP_NOEXCEPT
    {
      format = format_;
      return *this;
    }

    VertexInputAttributeDescription2EXT & setOffset( uint32_t offset_ ) VULKAN_HPP_NOEXCEPT
    {
      offset = offset_;
      return *this;
    }

    operator VkVertexInputAttributeDescription2EXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkVertexInputAttributeDescription2EXT *>( this );
    }

    operator VkVertexInputAttributeDescription2EXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkVertexInputAttributeDescription2EXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( VertexInputAttributeDescription2EXT const & ) const = default;
#else
    bool operator==( VertexInputAttributeDescription2EXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( location == rhs.location ) &&
             ( binding == rhs.binding ) && ( format == rhs.format ) && ( offset == rhs.offset );
    }

    bool operator!=( VertexInputAttributeDescription2EXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType    = StructureType::eVertexInputAttributeDescription2EXT;
    void *                              pNext    = {};
    uint32_t                            location = {};
    uint32_t                            binding  = {};
    VULKAN_HPP_NAMESPACE::Format        format   = VULKAN_HPP_NAMESPACE::Format::eUndefined;
    uint32_t                            offset   = {};
  };
  static_assert( sizeof( VertexInputAttributeDescription2EXT ) == sizeof( VkVertexInputAttributeDescription2EXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<VertexInputAttributeDescription2EXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eVertexInputAttributeDescription2EXT>
  {
    using Type = VertexInputAttributeDescription2EXT;
  };

  struct VertexInputBindingDescription2EXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eVertexInputBindingDescription2EXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR VertexInputBindingDescription2EXT(
      uint32_t                              binding_   = {},
      uint32_t                              stride_    = {},
      VULKAN_HPP_NAMESPACE::VertexInputRate inputRate_ = VULKAN_HPP_NAMESPACE::VertexInputRate::eVertex,
      uint32_t                              divisor_   = {} ) VULKAN_HPP_NOEXCEPT
      : binding( binding_ )
      , stride( stride_ )
      , inputRate( inputRate_ )
      , divisor( divisor_ )
    {}

    VULKAN_HPP_CONSTEXPR
      VertexInputBindingDescription2EXT( VertexInputBindingDescription2EXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VertexInputBindingDescription2EXT( VkVertexInputBindingDescription2EXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : VertexInputBindingDescription2EXT( *reinterpret_cast<VertexInputBindingDescription2EXT const *>( &rhs ) )
    {}
#endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 VertexInputBindingDescription2EXT &
                            operator=( VertexInputBindingDescription2EXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VertexInputBindingDescription2EXT & operator=( VkVertexInputBindingDescription2EXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::VertexInputBindingDescription2EXT const *>( &rhs );
      return *this;
    }

    VertexInputBindingDescription2EXT & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    VertexInputBindingDescription2EXT & setBinding( uint32_t binding_ ) VULKAN_HPP_NOEXCEPT
    {
      binding = binding_;
      return *this;
    }

    VertexInputBindingDescription2EXT & setStride( uint32_t stride_ ) VULKAN_HPP_NOEXCEPT
    {
      stride = stride_;
      return *this;
    }

    VertexInputBindingDescription2EXT &
      setInputRate( VULKAN_HPP_NAMESPACE::VertexInputRate inputRate_ ) VULKAN_HPP_NOEXCEPT
    {
      inputRate = inputRate_;
      return *this;
    }

    VertexInputBindingDescription2EXT & setDivisor( uint32_t divisor_ ) VULKAN_HPP_NOEXCEPT
    {
      divisor = divisor_;
      return *this;
    }

    operator VkVertexInputBindingDescription2EXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkVertexInputBindingDescription2EXT *>( this );
    }

    operator VkVertexInputBindingDescription2EXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkVertexInputBindingDescription2EXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( VertexInputBindingDescription2EXT const & ) const = default;
#else
    bool operator==( VertexInputBindingDescription2EXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( binding == rhs.binding ) &&
             ( stride == rhs.stride ) && ( inputRate == rhs.inputRate ) && ( divisor == rhs.divisor );
    }

    bool operator!=( VertexInputBindingDescription2EXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType   sType     = StructureType::eVertexInputBindingDescription2EXT;
    void *                                pNext     = {};
    uint32_t                              binding   = {};
    uint32_t                              stride    = {};
    VULKAN_HPP_NAMESPACE::VertexInputRate inputRate = VULKAN_HPP_NAMESPACE::VertexInputRate::eVertex;
    uint32_t                              divisor   = {};
  };
  static_assert( sizeof( VertexInputBindingDescription2EXT ) == sizeof( VkVertexInputBindingDescription2EXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<VertexInputBindingDescription2EXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eVertexInputBindingDescription2EXT>
  {
    using Type = VertexInputBindingDescription2EXT;
  };

#if defined( VK_USE_PLATFORM_VI_NN )
  struct ViSurfaceCreateInfoNN
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eViSurfaceCreateInfoNN;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR ViSurfaceCreateInfoNN( VULKAN_HPP_NAMESPACE::ViSurfaceCreateFlagsNN flags_ = {},
                                                void * window_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , window( window_ )
    {}

    VULKAN_HPP_CONSTEXPR ViSurfaceCreateInfoNN( ViSurfaceCreateInfoNN const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ViSurfaceCreateInfoNN( VkViSurfaceCreateInfoNN const & rhs ) VULKAN_HPP_NOEXCEPT
      : ViSurfaceCreateInfoNN( *reinterpret_cast<ViSurfaceCreateInfoNN const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 ViSurfaceCreateInfoNN &
                            operator=( ViSurfaceCreateInfoNN const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    ViSurfaceCreateInfoNN & operator=( VkViSurfaceCreateInfoNN const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::ViSurfaceCreateInfoNN const *>( &rhs );
      return *this;
    }

    ViSurfaceCreateInfoNN & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    ViSurfaceCreateInfoNN & setFlags( VULKAN_HPP_NAMESPACE::ViSurfaceCreateFlagsNN flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    ViSurfaceCreateInfoNN & setWindow( void * window_ ) VULKAN_HPP_NOEXCEPT
    {
      window = window_;
      return *this;
    }

    operator VkViSurfaceCreateInfoNN const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkViSurfaceCreateInfoNN *>( this );
    }

    operator VkViSurfaceCreateInfoNN &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkViSurfaceCreateInfoNN *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( ViSurfaceCreateInfoNN const & ) const = default;
#  else
    bool operator==( ViSurfaceCreateInfoNN const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) && ( window == rhs.window );
    }

    bool operator!=( ViSurfaceCreateInfoNN const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType          sType  = StructureType::eViSurfaceCreateInfoNN;
    const void *                                 pNext  = {};
    VULKAN_HPP_NAMESPACE::ViSurfaceCreateFlagsNN flags  = {};
    void *                                       window = {};
  };
  static_assert( sizeof( ViSurfaceCreateInfoNN ) == sizeof( VkViSurfaceCreateInfoNN ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<ViSurfaceCreateInfoNN>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eViSurfaceCreateInfoNN>
  {
    using Type = ViSurfaceCreateInfoNN;
  };
#endif /*VK_USE_PLATFORM_VI_NN*/

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  struct VideoPictureResourceKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eVideoPictureResourceKHR;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      VideoPictureResourceKHR( VULKAN_HPP_NAMESPACE::Offset2D  codedOffset_      = {},
                               VULKAN_HPP_NAMESPACE::Extent2D  codedExtent_      = {},
                               uint32_t                        baseArrayLayer_   = {},
                               VULKAN_HPP_NAMESPACE::ImageView imageViewBinding_ = {} ) VULKAN_HPP_NOEXCEPT
      : codedOffset( codedOffset_ )
      , codedExtent( codedExtent_ )
      , baseArrayLayer( baseArrayLayer_ )
      , imageViewBinding( imageViewBinding_ )
    {}

    VULKAN_HPP_CONSTEXPR VideoPictureResourceKHR( VideoPictureResourceKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoPictureResourceKHR( VkVideoPictureResourceKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : VideoPictureResourceKHR( *reinterpret_cast<VideoPictureResourceKHR const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 VideoPictureResourceKHR &
                            operator=( VideoPictureResourceKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoPictureResourceKHR & operator=( VkVideoPictureResourceKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::VideoPictureResourceKHR const *>( &rhs );
      return *this;
    }

    VideoPictureResourceKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    VideoPictureResourceKHR & setCodedOffset( VULKAN_HPP_NAMESPACE::Offset2D const & codedOffset_ ) VULKAN_HPP_NOEXCEPT
    {
      codedOffset = codedOffset_;
      return *this;
    }

    VideoPictureResourceKHR & setCodedExtent( VULKAN_HPP_NAMESPACE::Extent2D const & codedExtent_ ) VULKAN_HPP_NOEXCEPT
    {
      codedExtent = codedExtent_;
      return *this;
    }

    VideoPictureResourceKHR & setBaseArrayLayer( uint32_t baseArrayLayer_ ) VULKAN_HPP_NOEXCEPT
    {
      baseArrayLayer = baseArrayLayer_;
      return *this;
    }

    VideoPictureResourceKHR &
      setImageViewBinding( VULKAN_HPP_NAMESPACE::ImageView imageViewBinding_ ) VULKAN_HPP_NOEXCEPT
    {
      imageViewBinding = imageViewBinding_;
      return *this;
    }

    operator VkVideoPictureResourceKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkVideoPictureResourceKHR *>( this );
    }

    operator VkVideoPictureResourceKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkVideoPictureResourceKHR *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( VideoPictureResourceKHR const & ) const = default;
#  else
    bool operator==( VideoPictureResourceKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( codedOffset == rhs.codedOffset ) &&
             ( codedExtent == rhs.codedExtent ) && ( baseArrayLayer == rhs.baseArrayLayer ) &&
             ( imageViewBinding == rhs.imageViewBinding );
    }

    bool operator!=( VideoPictureResourceKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType            = StructureType::eVideoPictureResourceKHR;
    const void *                        pNext            = {};
    VULKAN_HPP_NAMESPACE::Offset2D      codedOffset      = {};
    VULKAN_HPP_NAMESPACE::Extent2D      codedExtent      = {};
    uint32_t                            baseArrayLayer   = {};
    VULKAN_HPP_NAMESPACE::ImageView     imageViewBinding = {};
  };
  static_assert( sizeof( VideoPictureResourceKHR ) == sizeof( VkVideoPictureResourceKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<VideoPictureResourceKHR>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eVideoPictureResourceKHR>
  {
    using Type = VideoPictureResourceKHR;
  };
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  struct VideoReferenceSlotKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eVideoReferenceSlotKHR;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR VideoReferenceSlotKHR(
      int8_t                                                slotIndex_        = {},
      const VULKAN_HPP_NAMESPACE::VideoPictureResourceKHR * pPictureResource_ = {} ) VULKAN_HPP_NOEXCEPT
      : slotIndex( slotIndex_ )
      , pPictureResource( pPictureResource_ )
    {}

    VULKAN_HPP_CONSTEXPR VideoReferenceSlotKHR( VideoReferenceSlotKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoReferenceSlotKHR( VkVideoReferenceSlotKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : VideoReferenceSlotKHR( *reinterpret_cast<VideoReferenceSlotKHR const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 VideoReferenceSlotKHR &
                            operator=( VideoReferenceSlotKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoReferenceSlotKHR & operator=( VkVideoReferenceSlotKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::VideoReferenceSlotKHR const *>( &rhs );
      return *this;
    }

    VideoReferenceSlotKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    VideoReferenceSlotKHR & setSlotIndex( int8_t slotIndex_ ) VULKAN_HPP_NOEXCEPT
    {
      slotIndex = slotIndex_;
      return *this;
    }

    VideoReferenceSlotKHR &
      setPPictureResource( const VULKAN_HPP_NAMESPACE::VideoPictureResourceKHR * pPictureResource_ ) VULKAN_HPP_NOEXCEPT
    {
      pPictureResource = pPictureResource_;
      return *this;
    }

    operator VkVideoReferenceSlotKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkVideoReferenceSlotKHR *>( this );
    }

    operator VkVideoReferenceSlotKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkVideoReferenceSlotKHR *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( VideoReferenceSlotKHR const & ) const = default;
#  else
    bool operator==( VideoReferenceSlotKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( slotIndex == rhs.slotIndex ) &&
             ( pPictureResource == rhs.pPictureResource );
    }

    bool operator!=( VideoReferenceSlotKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                   sType            = StructureType::eVideoReferenceSlotKHR;
    const void *                                          pNext            = {};
    int8_t                                                slotIndex        = {};
    const VULKAN_HPP_NAMESPACE::VideoPictureResourceKHR * pPictureResource = {};
  };
  static_assert( sizeof( VideoReferenceSlotKHR ) == sizeof( VkVideoReferenceSlotKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<VideoReferenceSlotKHR>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eVideoReferenceSlotKHR>
  {
    using Type = VideoReferenceSlotKHR;
  };
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  struct VideoBeginCodingInfoKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eVideoBeginCodingInfoKHR;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR VideoBeginCodingInfoKHR(
      VULKAN_HPP_NAMESPACE::VideoBeginCodingFlagsKHR         flags_                  = {},
      VULKAN_HPP_NAMESPACE::VideoCodingQualityPresetFlagsKHR codecQualityPreset_     = {},
      VULKAN_HPP_NAMESPACE::VideoSessionKHR                  videoSession_           = {},
      VULKAN_HPP_NAMESPACE::VideoSessionParametersKHR        videoSessionParameters_ = {},
      uint32_t                                               referenceSlotCount_     = {},
      const VULKAN_HPP_NAMESPACE::VideoReferenceSlotKHR *    pReferenceSlots_        = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , codecQualityPreset( codecQualityPreset_ )
      , videoSession( videoSession_ )
      , videoSessionParameters( videoSessionParameters_ )
      , referenceSlotCount( referenceSlotCount_ )
      , pReferenceSlots( pReferenceSlots_ )
    {}

    VULKAN_HPP_CONSTEXPR VideoBeginCodingInfoKHR( VideoBeginCodingInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoBeginCodingInfoKHR( VkVideoBeginCodingInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : VideoBeginCodingInfoKHR( *reinterpret_cast<VideoBeginCodingInfoKHR const *>( &rhs ) )
    {}

#    if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    VideoBeginCodingInfoKHR(
      VULKAN_HPP_NAMESPACE::VideoBeginCodingFlagsKHR         flags_,
      VULKAN_HPP_NAMESPACE::VideoCodingQualityPresetFlagsKHR codecQualityPreset_,
      VULKAN_HPP_NAMESPACE::VideoSessionKHR                  videoSession_,
      VULKAN_HPP_NAMESPACE::VideoSessionParametersKHR        videoSessionParameters_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::VideoReferenceSlotKHR> const &
        referenceSlots_ )
      : flags( flags_ )
      , codecQualityPreset( codecQualityPreset_ )
      , videoSession( videoSession_ )
      , videoSessionParameters( videoSessionParameters_ )
      , referenceSlotCount( static_cast<uint32_t>( referenceSlots_.size() ) )
      , pReferenceSlots( referenceSlots_.data() )
    {}
#    endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#  endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 VideoBeginCodingInfoKHR &
                            operator=( VideoBeginCodingInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoBeginCodingInfoKHR & operator=( VkVideoBeginCodingInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::VideoBeginCodingInfoKHR const *>( &rhs );
      return *this;
    }

    VideoBeginCodingInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    VideoBeginCodingInfoKHR & setFlags( VULKAN_HPP_NAMESPACE::VideoBeginCodingFlagsKHR flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    VideoBeginCodingInfoKHR & setCodecQualityPreset(
      VULKAN_HPP_NAMESPACE::VideoCodingQualityPresetFlagsKHR codecQualityPreset_ ) VULKAN_HPP_NOEXCEPT
    {
      codecQualityPreset = codecQualityPreset_;
      return *this;
    }

    VideoBeginCodingInfoKHR & setVideoSession( VULKAN_HPP_NAMESPACE::VideoSessionKHR videoSession_ ) VULKAN_HPP_NOEXCEPT
    {
      videoSession = videoSession_;
      return *this;
    }

    VideoBeginCodingInfoKHR & setVideoSessionParameters(
      VULKAN_HPP_NAMESPACE::VideoSessionParametersKHR videoSessionParameters_ ) VULKAN_HPP_NOEXCEPT
    {
      videoSessionParameters = videoSessionParameters_;
      return *this;
    }

    VideoBeginCodingInfoKHR & setReferenceSlotCount( uint32_t referenceSlotCount_ ) VULKAN_HPP_NOEXCEPT
    {
      referenceSlotCount = referenceSlotCount_;
      return *this;
    }

    VideoBeginCodingInfoKHR &
      setPReferenceSlots( const VULKAN_HPP_NAMESPACE::VideoReferenceSlotKHR * pReferenceSlots_ ) VULKAN_HPP_NOEXCEPT
    {
      pReferenceSlots = pReferenceSlots_;
      return *this;
    }

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    VideoBeginCodingInfoKHR & setReferenceSlots(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::VideoReferenceSlotKHR> const &
        referenceSlots_ ) VULKAN_HPP_NOEXCEPT
    {
      referenceSlotCount = static_cast<uint32_t>( referenceSlots_.size() );
      pReferenceSlots    = referenceSlots_.data();
      return *this;
    }
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkVideoBeginCodingInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkVideoBeginCodingInfoKHR *>( this );
    }

    operator VkVideoBeginCodingInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkVideoBeginCodingInfoKHR *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( VideoBeginCodingInfoKHR const & ) const = default;
#  else
    bool operator==( VideoBeginCodingInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( codecQualityPreset == rhs.codecQualityPreset ) && ( videoSession == rhs.videoSession ) &&
             ( videoSessionParameters == rhs.videoSessionParameters ) &&
             ( referenceSlotCount == rhs.referenceSlotCount ) && ( pReferenceSlots == rhs.pReferenceSlots );
    }

    bool operator!=( VideoBeginCodingInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                    sType              = StructureType::eVideoBeginCodingInfoKHR;
    const void *                                           pNext              = {};
    VULKAN_HPP_NAMESPACE::VideoBeginCodingFlagsKHR         flags              = {};
    VULKAN_HPP_NAMESPACE::VideoCodingQualityPresetFlagsKHR codecQualityPreset = {};
    VULKAN_HPP_NAMESPACE::VideoSessionKHR                  videoSession       = {};
    VULKAN_HPP_NAMESPACE::VideoSessionParametersKHR        videoSessionParameters = {};
    uint32_t                                               referenceSlotCount     = {};
    const VULKAN_HPP_NAMESPACE::VideoReferenceSlotKHR *    pReferenceSlots        = {};
  };
  static_assert( sizeof( VideoBeginCodingInfoKHR ) == sizeof( VkVideoBeginCodingInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<VideoBeginCodingInfoKHR>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eVideoBeginCodingInfoKHR>
  {
    using Type = VideoBeginCodingInfoKHR;
  };
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  struct VideoBindMemoryKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eVideoBindMemoryKHR;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR VideoBindMemoryKHR( uint32_t                           memoryBindIndex_ = {},
                                             VULKAN_HPP_NAMESPACE::DeviceMemory memory_          = {},
                                             VULKAN_HPP_NAMESPACE::DeviceSize   memoryOffset_    = {},
                                             VULKAN_HPP_NAMESPACE::DeviceSize   memorySize_ = {} ) VULKAN_HPP_NOEXCEPT
      : memoryBindIndex( memoryBindIndex_ )
      , memory( memory_ )
      , memoryOffset( memoryOffset_ )
      , memorySize( memorySize_ )
    {}

    VULKAN_HPP_CONSTEXPR VideoBindMemoryKHR( VideoBindMemoryKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoBindMemoryKHR( VkVideoBindMemoryKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : VideoBindMemoryKHR( *reinterpret_cast<VideoBindMemoryKHR const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 VideoBindMemoryKHR &
                            operator=( VideoBindMemoryKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoBindMemoryKHR & operator=( VkVideoBindMemoryKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::VideoBindMemoryKHR const *>( &rhs );
      return *this;
    }

    VideoBindMemoryKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    VideoBindMemoryKHR & setMemoryBindIndex( uint32_t memoryBindIndex_ ) VULKAN_HPP_NOEXCEPT
    {
      memoryBindIndex = memoryBindIndex_;
      return *this;
    }

    VideoBindMemoryKHR & setMemory( VULKAN_HPP_NAMESPACE::DeviceMemory memory_ ) VULKAN_HPP_NOEXCEPT
    {
      memory = memory_;
      return *this;
    }

    VideoBindMemoryKHR & setMemoryOffset( VULKAN_HPP_NAMESPACE::DeviceSize memoryOffset_ ) VULKAN_HPP_NOEXCEPT
    {
      memoryOffset = memoryOffset_;
      return *this;
    }

    VideoBindMemoryKHR & setMemorySize( VULKAN_HPP_NAMESPACE::DeviceSize memorySize_ ) VULKAN_HPP_NOEXCEPT
    {
      memorySize = memorySize_;
      return *this;
    }

    operator VkVideoBindMemoryKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkVideoBindMemoryKHR *>( this );
    }

    operator VkVideoBindMemoryKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkVideoBindMemoryKHR *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( VideoBindMemoryKHR const & ) const = default;
#  else
    bool operator==( VideoBindMemoryKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( memoryBindIndex == rhs.memoryBindIndex ) &&
             ( memory == rhs.memory ) && ( memoryOffset == rhs.memoryOffset ) && ( memorySize == rhs.memorySize );
    }

    bool operator!=( VideoBindMemoryKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType           = StructureType::eVideoBindMemoryKHR;
    const void *                        pNext           = {};
    uint32_t                            memoryBindIndex = {};
    VULKAN_HPP_NAMESPACE::DeviceMemory  memory          = {};
    VULKAN_HPP_NAMESPACE::DeviceSize    memoryOffset    = {};
    VULKAN_HPP_NAMESPACE::DeviceSize    memorySize      = {};
  };
  static_assert( sizeof( VideoBindMemoryKHR ) == sizeof( VkVideoBindMemoryKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<VideoBindMemoryKHR>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eVideoBindMemoryKHR>
  {
    using Type = VideoBindMemoryKHR;
  };
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  struct VideoCapabilitiesKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eVideoCapabilitiesKHR;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR VideoCapabilitiesKHR( VULKAN_HPP_NAMESPACE::VideoCapabilitiesFlagsKHR capabilityFlags_    = {},
                                               VULKAN_HPP_NAMESPACE::DeviceSize minBitstreamBufferOffsetAlignment_ = {},
                                               VULKAN_HPP_NAMESPACE::DeviceSize minBitstreamBufferSizeAlignment_   = {},
                                               VULKAN_HPP_NAMESPACE::Extent2D   videoPictureExtentGranularity_     = {},
                                               VULKAN_HPP_NAMESPACE::Extent2D   minExtent_                         = {},
                                               VULKAN_HPP_NAMESPACE::Extent2D   maxExtent_                         = {},
                                               uint32_t                         maxReferencePicturesSlotsCount_    = {},
                                               uint32_t maxReferencePicturesActiveCount_ = {} ) VULKAN_HPP_NOEXCEPT
      : capabilityFlags( capabilityFlags_ )
      , minBitstreamBufferOffsetAlignment( minBitstreamBufferOffsetAlignment_ )
      , minBitstreamBufferSizeAlignment( minBitstreamBufferSizeAlignment_ )
      , videoPictureExtentGranularity( videoPictureExtentGranularity_ )
      , minExtent( minExtent_ )
      , maxExtent( maxExtent_ )
      , maxReferencePicturesSlotsCount( maxReferencePicturesSlotsCount_ )
      , maxReferencePicturesActiveCount( maxReferencePicturesActiveCount_ )
    {}

    VULKAN_HPP_CONSTEXPR VideoCapabilitiesKHR( VideoCapabilitiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoCapabilitiesKHR( VkVideoCapabilitiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : VideoCapabilitiesKHR( *reinterpret_cast<VideoCapabilitiesKHR const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 VideoCapabilitiesKHR &
                            operator=( VideoCapabilitiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoCapabilitiesKHR & operator=( VkVideoCapabilitiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::VideoCapabilitiesKHR const *>( &rhs );
      return *this;
    }

    operator VkVideoCapabilitiesKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkVideoCapabilitiesKHR *>( this );
    }

    operator VkVideoCapabilitiesKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkVideoCapabilitiesKHR *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( VideoCapabilitiesKHR const & ) const = default;
#  else
    bool operator==( VideoCapabilitiesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( capabilityFlags == rhs.capabilityFlags ) &&
             ( minBitstreamBufferOffsetAlignment == rhs.minBitstreamBufferOffsetAlignment ) &&
             ( minBitstreamBufferSizeAlignment == rhs.minBitstreamBufferSizeAlignment ) &&
             ( videoPictureExtentGranularity == rhs.videoPictureExtentGranularity ) && ( minExtent == rhs.minExtent ) &&
             ( maxExtent == rhs.maxExtent ) &&
             ( maxReferencePicturesSlotsCount == rhs.maxReferencePicturesSlotsCount ) &&
             ( maxReferencePicturesActiveCount == rhs.maxReferencePicturesActiveCount );
    }

    bool operator!=( VideoCapabilitiesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType             sType           = StructureType::eVideoCapabilitiesKHR;
    void *                                          pNext           = {};
    VULKAN_HPP_NAMESPACE::VideoCapabilitiesFlagsKHR capabilityFlags = {};
    VULKAN_HPP_NAMESPACE::DeviceSize                minBitstreamBufferOffsetAlignment = {};
    VULKAN_HPP_NAMESPACE::DeviceSize                minBitstreamBufferSizeAlignment   = {};
    VULKAN_HPP_NAMESPACE::Extent2D                  videoPictureExtentGranularity     = {};
    VULKAN_HPP_NAMESPACE::Extent2D                  minExtent                         = {};
    VULKAN_HPP_NAMESPACE::Extent2D                  maxExtent                         = {};
    uint32_t                                        maxReferencePicturesSlotsCount    = {};
    uint32_t                                        maxReferencePicturesActiveCount   = {};
  };
  static_assert( sizeof( VideoCapabilitiesKHR ) == sizeof( VkVideoCapabilitiesKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<VideoCapabilitiesKHR>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eVideoCapabilitiesKHR>
  {
    using Type = VideoCapabilitiesKHR;
  };
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  struct VideoCodingControlInfoKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eVideoCodingControlInfoKHR;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      VideoCodingControlInfoKHR( VULKAN_HPP_NAMESPACE::VideoCodingControlFlagsKHR flags_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
    {}

    VULKAN_HPP_CONSTEXPR
      VideoCodingControlInfoKHR( VideoCodingControlInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoCodingControlInfoKHR( VkVideoCodingControlInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : VideoCodingControlInfoKHR( *reinterpret_cast<VideoCodingControlInfoKHR const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 VideoCodingControlInfoKHR &
                            operator=( VideoCodingControlInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoCodingControlInfoKHR & operator=( VkVideoCodingControlInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::VideoCodingControlInfoKHR const *>( &rhs );
      return *this;
    }

    VideoCodingControlInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    VideoCodingControlInfoKHR & setFlags( VULKAN_HPP_NAMESPACE::VideoCodingControlFlagsKHR flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    operator VkVideoCodingControlInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkVideoCodingControlInfoKHR *>( this );
    }

    operator VkVideoCodingControlInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkVideoCodingControlInfoKHR *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( VideoCodingControlInfoKHR const & ) const = default;
#  else
    bool operator==( VideoCodingControlInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags );
    }

    bool operator!=( VideoCodingControlInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType              sType = StructureType::eVideoCodingControlInfoKHR;
    const void *                                     pNext = {};
    VULKAN_HPP_NAMESPACE::VideoCodingControlFlagsKHR flags = {};
  };
  static_assert( sizeof( VideoCodingControlInfoKHR ) == sizeof( VkVideoCodingControlInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<VideoCodingControlInfoKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eVideoCodingControlInfoKHR>
  {
    using Type = VideoCodingControlInfoKHR;
  };
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  struct VideoDecodeH264CapabilitiesEXT
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eVideoDecodeH264CapabilitiesEXT;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR_14 VideoDecodeH264CapabilitiesEXT(
      uint32_t                                  maxLevel_               = {},
      VULKAN_HPP_NAMESPACE::Offset2D            fieldOffsetGranularity_ = {},
      VULKAN_HPP_NAMESPACE::ExtensionProperties stdExtensionVersion_    = {} ) VULKAN_HPP_NOEXCEPT
      : maxLevel( maxLevel_ )
      , fieldOffsetGranularity( fieldOffsetGranularity_ )
      , stdExtensionVersion( stdExtensionVersion_ )
    {}

    VULKAN_HPP_CONSTEXPR_14
      VideoDecodeH264CapabilitiesEXT( VideoDecodeH264CapabilitiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoDecodeH264CapabilitiesEXT( VkVideoDecodeH264CapabilitiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : VideoDecodeH264CapabilitiesEXT( *reinterpret_cast<VideoDecodeH264CapabilitiesEXT const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 VideoDecodeH264CapabilitiesEXT &
                            operator=( VideoDecodeH264CapabilitiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoDecodeH264CapabilitiesEXT & operator=( VkVideoDecodeH264CapabilitiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::VideoDecodeH264CapabilitiesEXT const *>( &rhs );
      return *this;
    }

    operator VkVideoDecodeH264CapabilitiesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkVideoDecodeH264CapabilitiesEXT *>( this );
    }

    operator VkVideoDecodeH264CapabilitiesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkVideoDecodeH264CapabilitiesEXT *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( VideoDecodeH264CapabilitiesEXT const & ) const = default;
#  else
    bool operator==( VideoDecodeH264CapabilitiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( maxLevel == rhs.maxLevel ) &&
             ( fieldOffsetGranularity == rhs.fieldOffsetGranularity ) &&
             ( stdExtensionVersion == rhs.stdExtensionVersion );
    }

    bool operator!=( VideoDecodeH264CapabilitiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType       sType                  = StructureType::eVideoDecodeH264CapabilitiesEXT;
    void *                                    pNext                  = {};
    uint32_t                                  maxLevel               = {};
    VULKAN_HPP_NAMESPACE::Offset2D            fieldOffsetGranularity = {};
    VULKAN_HPP_NAMESPACE::ExtensionProperties stdExtensionVersion    = {};
  };
  static_assert( sizeof( VideoDecodeH264CapabilitiesEXT ) == sizeof( VkVideoDecodeH264CapabilitiesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<VideoDecodeH264CapabilitiesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eVideoDecodeH264CapabilitiesEXT>
  {
    using Type = VideoDecodeH264CapabilitiesEXT;
  };
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  struct VideoDecodeH264DpbSlotInfoEXT
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eVideoDecodeH264DpbSlotInfoEXT;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR VideoDecodeH264DpbSlotInfoEXT(
      const StdVideoDecodeH264ReferenceInfo * pStdReferenceInfo_ = {} ) VULKAN_HPP_NOEXCEPT
      : pStdReferenceInfo( pStdReferenceInfo_ )
    {}

    VULKAN_HPP_CONSTEXPR
      VideoDecodeH264DpbSlotInfoEXT( VideoDecodeH264DpbSlotInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoDecodeH264DpbSlotInfoEXT( VkVideoDecodeH264DpbSlotInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : VideoDecodeH264DpbSlotInfoEXT( *reinterpret_cast<VideoDecodeH264DpbSlotInfoEXT const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 VideoDecodeH264DpbSlotInfoEXT &
                            operator=( VideoDecodeH264DpbSlotInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoDecodeH264DpbSlotInfoEXT & operator=( VkVideoDecodeH264DpbSlotInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::VideoDecodeH264DpbSlotInfoEXT const *>( &rhs );
      return *this;
    }

    VideoDecodeH264DpbSlotInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    VideoDecodeH264DpbSlotInfoEXT &
      setPStdReferenceInfo( const StdVideoDecodeH264ReferenceInfo * pStdReferenceInfo_ ) VULKAN_HPP_NOEXCEPT
    {
      pStdReferenceInfo = pStdReferenceInfo_;
      return *this;
    }

    operator VkVideoDecodeH264DpbSlotInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkVideoDecodeH264DpbSlotInfoEXT *>( this );
    }

    operator VkVideoDecodeH264DpbSlotInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkVideoDecodeH264DpbSlotInfoEXT *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( VideoDecodeH264DpbSlotInfoEXT const & ) const = default;
#  else
    bool operator==( VideoDecodeH264DpbSlotInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( pStdReferenceInfo == rhs.pStdReferenceInfo );
    }

    bool operator!=( VideoDecodeH264DpbSlotInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType     sType             = StructureType::eVideoDecodeH264DpbSlotInfoEXT;
    const void *                            pNext             = {};
    const StdVideoDecodeH264ReferenceInfo * pStdReferenceInfo = {};
  };
  static_assert( sizeof( VideoDecodeH264DpbSlotInfoEXT ) == sizeof( VkVideoDecodeH264DpbSlotInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<VideoDecodeH264DpbSlotInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eVideoDecodeH264DpbSlotInfoEXT>
  {
    using Type = VideoDecodeH264DpbSlotInfoEXT;
  };
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  struct VideoDecodeH264MvcEXT
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eVideoDecodeH264MvcEXT;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR VideoDecodeH264MvcEXT( const StdVideoDecodeH264Mvc * pStdMvc_ = {} ) VULKAN_HPP_NOEXCEPT
      : pStdMvc( pStdMvc_ )
    {}

    VULKAN_HPP_CONSTEXPR VideoDecodeH264MvcEXT( VideoDecodeH264MvcEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoDecodeH264MvcEXT( VkVideoDecodeH264MvcEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : VideoDecodeH264MvcEXT( *reinterpret_cast<VideoDecodeH264MvcEXT const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 VideoDecodeH264MvcEXT &
                            operator=( VideoDecodeH264MvcEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoDecodeH264MvcEXT & operator=( VkVideoDecodeH264MvcEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::VideoDecodeH264MvcEXT const *>( &rhs );
      return *this;
    }

    VideoDecodeH264MvcEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    VideoDecodeH264MvcEXT & setPStdMvc( const StdVideoDecodeH264Mvc * pStdMvc_ ) VULKAN_HPP_NOEXCEPT
    {
      pStdMvc = pStdMvc_;
      return *this;
    }

    operator VkVideoDecodeH264MvcEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkVideoDecodeH264MvcEXT *>( this );
    }

    operator VkVideoDecodeH264MvcEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkVideoDecodeH264MvcEXT *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( VideoDecodeH264MvcEXT const & ) const = default;
#  else
    bool operator==( VideoDecodeH264MvcEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( pStdMvc == rhs.pStdMvc );
    }

    bool operator!=( VideoDecodeH264MvcEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType   = StructureType::eVideoDecodeH264MvcEXT;
    const void *                        pNext   = {};
    const StdVideoDecodeH264Mvc *       pStdMvc = {};
  };
  static_assert( sizeof( VideoDecodeH264MvcEXT ) == sizeof( VkVideoDecodeH264MvcEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<VideoDecodeH264MvcEXT>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eVideoDecodeH264MvcEXT>
  {
    using Type = VideoDecodeH264MvcEXT;
  };
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  struct VideoDecodeH264PictureInfoEXT
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eVideoDecodeH264PictureInfoEXT;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR VideoDecodeH264PictureInfoEXT( const StdVideoDecodeH264PictureInfo * pStdPictureInfo_ = {},
                                                        uint32_t                              slicesCount_     = {},
                                                        const uint32_t * pSlicesDataOffsets_ = {} ) VULKAN_HPP_NOEXCEPT
      : pStdPictureInfo( pStdPictureInfo_ )
      , slicesCount( slicesCount_ )
      , pSlicesDataOffsets( pSlicesDataOffsets_ )
    {}

    VULKAN_HPP_CONSTEXPR
      VideoDecodeH264PictureInfoEXT( VideoDecodeH264PictureInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoDecodeH264PictureInfoEXT( VkVideoDecodeH264PictureInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : VideoDecodeH264PictureInfoEXT( *reinterpret_cast<VideoDecodeH264PictureInfoEXT const *>( &rhs ) )
    {}

#    if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    VideoDecodeH264PictureInfoEXT(
      const StdVideoDecodeH264PictureInfo *                                 pStdPictureInfo_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const & slicesDataOffsets_ )
      : pStdPictureInfo( pStdPictureInfo_ )
      , slicesCount( static_cast<uint32_t>( slicesDataOffsets_.size() ) )
      , pSlicesDataOffsets( slicesDataOffsets_.data() )
    {}
#    endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#  endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 VideoDecodeH264PictureInfoEXT &
                            operator=( VideoDecodeH264PictureInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoDecodeH264PictureInfoEXT & operator=( VkVideoDecodeH264PictureInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::VideoDecodeH264PictureInfoEXT const *>( &rhs );
      return *this;
    }

    VideoDecodeH264PictureInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    VideoDecodeH264PictureInfoEXT &
      setPStdPictureInfo( const StdVideoDecodeH264PictureInfo * pStdPictureInfo_ ) VULKAN_HPP_NOEXCEPT
    {
      pStdPictureInfo = pStdPictureInfo_;
      return *this;
    }

    VideoDecodeH264PictureInfoEXT & setSlicesCount( uint32_t slicesCount_ ) VULKAN_HPP_NOEXCEPT
    {
      slicesCount = slicesCount_;
      return *this;
    }

    VideoDecodeH264PictureInfoEXT & setPSlicesDataOffsets( const uint32_t * pSlicesDataOffsets_ ) VULKAN_HPP_NOEXCEPT
    {
      pSlicesDataOffsets = pSlicesDataOffsets_;
      return *this;
    }

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    VideoDecodeH264PictureInfoEXT & setSlicesDataOffsets(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const & slicesDataOffsets_ ) VULKAN_HPP_NOEXCEPT
    {
      slicesCount        = static_cast<uint32_t>( slicesDataOffsets_.size() );
      pSlicesDataOffsets = slicesDataOffsets_.data();
      return *this;
    }
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkVideoDecodeH264PictureInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkVideoDecodeH264PictureInfoEXT *>( this );
    }

    operator VkVideoDecodeH264PictureInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkVideoDecodeH264PictureInfoEXT *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( VideoDecodeH264PictureInfoEXT const & ) const = default;
#  else
    bool operator==( VideoDecodeH264PictureInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( pStdPictureInfo == rhs.pStdPictureInfo ) &&
             ( slicesCount == rhs.slicesCount ) && ( pSlicesDataOffsets == rhs.pSlicesDataOffsets );
    }

    bool operator!=( VideoDecodeH264PictureInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType   sType              = StructureType::eVideoDecodeH264PictureInfoEXT;
    const void *                          pNext              = {};
    const StdVideoDecodeH264PictureInfo * pStdPictureInfo    = {};
    uint32_t                              slicesCount        = {};
    const uint32_t *                      pSlicesDataOffsets = {};
  };
  static_assert( sizeof( VideoDecodeH264PictureInfoEXT ) == sizeof( VkVideoDecodeH264PictureInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<VideoDecodeH264PictureInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eVideoDecodeH264PictureInfoEXT>
  {
    using Type = VideoDecodeH264PictureInfoEXT;
  };
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  struct VideoDecodeH264ProfileEXT
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eVideoDecodeH264ProfileEXT;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR VideoDecodeH264ProfileEXT(
      StdVideoH264ProfileIdc                                   stdProfileIdc_ = {},
      VULKAN_HPP_NAMESPACE::VideoDecodeH264FieldLayoutFlagsEXT fieldLayout_   = {} ) VULKAN_HPP_NOEXCEPT
      : stdProfileIdc( stdProfileIdc_ )
      , fieldLayout( fieldLayout_ )
    {}

    VULKAN_HPP_CONSTEXPR
      VideoDecodeH264ProfileEXT( VideoDecodeH264ProfileEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoDecodeH264ProfileEXT( VkVideoDecodeH264ProfileEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : VideoDecodeH264ProfileEXT( *reinterpret_cast<VideoDecodeH264ProfileEXT const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 VideoDecodeH264ProfileEXT &
                            operator=( VideoDecodeH264ProfileEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoDecodeH264ProfileEXT & operator=( VkVideoDecodeH264ProfileEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::VideoDecodeH264ProfileEXT const *>( &rhs );
      return *this;
    }

    VideoDecodeH264ProfileEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    VideoDecodeH264ProfileEXT & setStdProfileIdc( StdVideoH264ProfileIdc stdProfileIdc_ ) VULKAN_HPP_NOEXCEPT
    {
      stdProfileIdc = stdProfileIdc_;
      return *this;
    }

    VideoDecodeH264ProfileEXT &
      setFieldLayout( VULKAN_HPP_NAMESPACE::VideoDecodeH264FieldLayoutFlagsEXT fieldLayout_ ) VULKAN_HPP_NOEXCEPT
    {
      fieldLayout = fieldLayout_;
      return *this;
    }

    operator VkVideoDecodeH264ProfileEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkVideoDecodeH264ProfileEXT *>( this );
    }

    operator VkVideoDecodeH264ProfileEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkVideoDecodeH264ProfileEXT *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( VideoDecodeH264ProfileEXT const & ) const = default;
#  else
    bool operator==( VideoDecodeH264ProfileEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( memcmp( &stdProfileIdc, &rhs.stdProfileIdc, sizeof( StdVideoH264ProfileIdc ) ) == 0 ) &&
             ( fieldLayout == rhs.fieldLayout );
    }

    bool operator!=( VideoDecodeH264ProfileEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                      sType         = StructureType::eVideoDecodeH264ProfileEXT;
    const void *                                             pNext         = {};
    StdVideoH264ProfileIdc                                   stdProfileIdc = {};
    VULKAN_HPP_NAMESPACE::VideoDecodeH264FieldLayoutFlagsEXT fieldLayout   = {};
  };
  static_assert( sizeof( VideoDecodeH264ProfileEXT ) == sizeof( VkVideoDecodeH264ProfileEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<VideoDecodeH264ProfileEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eVideoDecodeH264ProfileEXT>
  {
    using Type = VideoDecodeH264ProfileEXT;
  };
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  struct VideoDecodeH264SessionCreateInfoEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eVideoDecodeH264SessionCreateInfoEXT;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR_14 VideoDecodeH264SessionCreateInfoEXT(
      VULKAN_HPP_NAMESPACE::VideoDecodeH264CreateFlagsEXT flags_                = {},
      const VULKAN_HPP_NAMESPACE::ExtensionProperties *   pStdExtensionVersion_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , pStdExtensionVersion( pStdExtensionVersion_ )
    {}

    VULKAN_HPP_CONSTEXPR_14 VideoDecodeH264SessionCreateInfoEXT( VideoDecodeH264SessionCreateInfoEXT const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    VideoDecodeH264SessionCreateInfoEXT( VkVideoDecodeH264SessionCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : VideoDecodeH264SessionCreateInfoEXT( *reinterpret_cast<VideoDecodeH264SessionCreateInfoEXT const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 VideoDecodeH264SessionCreateInfoEXT &
                            operator=( VideoDecodeH264SessionCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoDecodeH264SessionCreateInfoEXT &
      operator=( VkVideoDecodeH264SessionCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::VideoDecodeH264SessionCreateInfoEXT const *>( &rhs );
      return *this;
    }

    VideoDecodeH264SessionCreateInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    VideoDecodeH264SessionCreateInfoEXT &
      setFlags( VULKAN_HPP_NAMESPACE::VideoDecodeH264CreateFlagsEXT flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    VideoDecodeH264SessionCreateInfoEXT & setPStdExtensionVersion(
      const VULKAN_HPP_NAMESPACE::ExtensionProperties * pStdExtensionVersion_ ) VULKAN_HPP_NOEXCEPT
    {
      pStdExtensionVersion = pStdExtensionVersion_;
      return *this;
    }

    operator VkVideoDecodeH264SessionCreateInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkVideoDecodeH264SessionCreateInfoEXT *>( this );
    }

    operator VkVideoDecodeH264SessionCreateInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkVideoDecodeH264SessionCreateInfoEXT *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( VideoDecodeH264SessionCreateInfoEXT const & ) const = default;
#  else
    bool operator==( VideoDecodeH264SessionCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( pStdExtensionVersion == rhs.pStdExtensionVersion );
    }

    bool operator!=( VideoDecodeH264SessionCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                 sType = StructureType::eVideoDecodeH264SessionCreateInfoEXT;
    const void *                                        pNext = {};
    VULKAN_HPP_NAMESPACE::VideoDecodeH264CreateFlagsEXT flags = {};
    const VULKAN_HPP_NAMESPACE::ExtensionProperties *   pStdExtensionVersion = {};
  };
  static_assert( sizeof( VideoDecodeH264SessionCreateInfoEXT ) == sizeof( VkVideoDecodeH264SessionCreateInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<VideoDecodeH264SessionCreateInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eVideoDecodeH264SessionCreateInfoEXT>
  {
    using Type = VideoDecodeH264SessionCreateInfoEXT;
  };
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  struct VideoDecodeH264SessionParametersAddInfoEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eVideoDecodeH264SessionParametersAddInfoEXT;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR VideoDecodeH264SessionParametersAddInfoEXT(
      uint32_t                                 spsStdCount_ = {},
      const StdVideoH264SequenceParameterSet * pSpsStd_     = {},
      uint32_t                                 ppsStdCount_ = {},
      const StdVideoH264PictureParameterSet *  pPpsStd_     = {} ) VULKAN_HPP_NOEXCEPT
      : spsStdCount( spsStdCount_ )
      , pSpsStd( pSpsStd_ )
      , ppsStdCount( ppsStdCount_ )
      , pPpsStd( pPpsStd_ )
    {}

    VULKAN_HPP_CONSTEXPR VideoDecodeH264SessionParametersAddInfoEXT(
      VideoDecodeH264SessionParametersAddInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoDecodeH264SessionParametersAddInfoEXT( VkVideoDecodeH264SessionParametersAddInfoEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : VideoDecodeH264SessionParametersAddInfoEXT(
          *reinterpret_cast<VideoDecodeH264SessionParametersAddInfoEXT const *>( &rhs ) )
    {}

#    if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    VideoDecodeH264SessionParametersAddInfoEXT(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const StdVideoH264SequenceParameterSet> const & spsStd_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const StdVideoH264PictureParameterSet> const &  ppsStd_ = {} )
      : spsStdCount( static_cast<uint32_t>( spsStd_.size() ) )
      , pSpsStd( spsStd_.data() )
      , ppsStdCount( static_cast<uint32_t>( ppsStd_.size() ) )
      , pPpsStd( ppsStd_.data() )
    {}
#    endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#  endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 VideoDecodeH264SessionParametersAddInfoEXT &
                            operator=( VideoDecodeH264SessionParametersAddInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoDecodeH264SessionParametersAddInfoEXT &
      operator=( VkVideoDecodeH264SessionParametersAddInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::VideoDecodeH264SessionParametersAddInfoEXT const *>( &rhs );
      return *this;
    }

    VideoDecodeH264SessionParametersAddInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    VideoDecodeH264SessionParametersAddInfoEXT & setSpsStdCount( uint32_t spsStdCount_ ) VULKAN_HPP_NOEXCEPT
    {
      spsStdCount = spsStdCount_;
      return *this;
    }

    VideoDecodeH264SessionParametersAddInfoEXT &
      setPSpsStd( const StdVideoH264SequenceParameterSet * pSpsStd_ ) VULKAN_HPP_NOEXCEPT
    {
      pSpsStd = pSpsStd_;
      return *this;
    }

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    VideoDecodeH264SessionParametersAddInfoEXT &
      setSpsStd( VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const StdVideoH264SequenceParameterSet> const & spsStd_ )
        VULKAN_HPP_NOEXCEPT
    {
      spsStdCount = static_cast<uint32_t>( spsStd_.size() );
      pSpsStd     = spsStd_.data();
      return *this;
    }
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    VideoDecodeH264SessionParametersAddInfoEXT & setPpsStdCount( uint32_t ppsStdCount_ ) VULKAN_HPP_NOEXCEPT
    {
      ppsStdCount = ppsStdCount_;
      return *this;
    }

    VideoDecodeH264SessionParametersAddInfoEXT &
      setPPpsStd( const StdVideoH264PictureParameterSet * pPpsStd_ ) VULKAN_HPP_NOEXCEPT
    {
      pPpsStd = pPpsStd_;
      return *this;
    }

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    VideoDecodeH264SessionParametersAddInfoEXT &
      setPpsStd( VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const StdVideoH264PictureParameterSet> const & ppsStd_ )
        VULKAN_HPP_NOEXCEPT
    {
      ppsStdCount = static_cast<uint32_t>( ppsStd_.size() );
      pPpsStd     = ppsStd_.data();
      return *this;
    }
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkVideoDecodeH264SessionParametersAddInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkVideoDecodeH264SessionParametersAddInfoEXT *>( this );
    }

    operator VkVideoDecodeH264SessionParametersAddInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkVideoDecodeH264SessionParametersAddInfoEXT *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( VideoDecodeH264SessionParametersAddInfoEXT const & ) const = default;
#  else
    bool operator==( VideoDecodeH264SessionParametersAddInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( spsStdCount == rhs.spsStdCount ) &&
             ( pSpsStd == rhs.pSpsStd ) && ( ppsStdCount == rhs.ppsStdCount ) && ( pPpsStd == rhs.pPpsStd );
    }

    bool operator!=( VideoDecodeH264SessionParametersAddInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType      sType       = StructureType::eVideoDecodeH264SessionParametersAddInfoEXT;
    const void *                             pNext       = {};
    uint32_t                                 spsStdCount = {};
    const StdVideoH264SequenceParameterSet * pSpsStd     = {};
    uint32_t                                 ppsStdCount = {};
    const StdVideoH264PictureParameterSet *  pPpsStd     = {};
  };
  static_assert( sizeof( VideoDecodeH264SessionParametersAddInfoEXT ) ==
                   sizeof( VkVideoDecodeH264SessionParametersAddInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<VideoDecodeH264SessionParametersAddInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eVideoDecodeH264SessionParametersAddInfoEXT>
  {
    using Type = VideoDecodeH264SessionParametersAddInfoEXT;
  };
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  struct VideoDecodeH264SessionParametersCreateInfoEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eVideoDecodeH264SessionParametersCreateInfoEXT;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR VideoDecodeH264SessionParametersCreateInfoEXT(
      uint32_t                                                                 maxSpsStdCount_     = {},
      uint32_t                                                                 maxPpsStdCount_     = {},
      const VULKAN_HPP_NAMESPACE::VideoDecodeH264SessionParametersAddInfoEXT * pParametersAddInfo_ = {} )
      VULKAN_HPP_NOEXCEPT
      : maxSpsStdCount( maxSpsStdCount_ )
      , maxPpsStdCount( maxPpsStdCount_ )
      , pParametersAddInfo( pParametersAddInfo_ )
    {}

    VULKAN_HPP_CONSTEXPR VideoDecodeH264SessionParametersCreateInfoEXT(
      VideoDecodeH264SessionParametersCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoDecodeH264SessionParametersCreateInfoEXT( VkVideoDecodeH264SessionParametersCreateInfoEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : VideoDecodeH264SessionParametersCreateInfoEXT(
          *reinterpret_cast<VideoDecodeH264SessionParametersCreateInfoEXT const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 VideoDecodeH264SessionParametersCreateInfoEXT &
                            operator=( VideoDecodeH264SessionParametersCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoDecodeH264SessionParametersCreateInfoEXT &
      operator=( VkVideoDecodeH264SessionParametersCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::VideoDecodeH264SessionParametersCreateInfoEXT const *>( &rhs );
      return *this;
    }

    VideoDecodeH264SessionParametersCreateInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    VideoDecodeH264SessionParametersCreateInfoEXT & setMaxSpsStdCount( uint32_t maxSpsStdCount_ ) VULKAN_HPP_NOEXCEPT
    {
      maxSpsStdCount = maxSpsStdCount_;
      return *this;
    }

    VideoDecodeH264SessionParametersCreateInfoEXT & setMaxPpsStdCount( uint32_t maxPpsStdCount_ ) VULKAN_HPP_NOEXCEPT
    {
      maxPpsStdCount = maxPpsStdCount_;
      return *this;
    }

    VideoDecodeH264SessionParametersCreateInfoEXT & setPParametersAddInfo(
      const VULKAN_HPP_NAMESPACE::VideoDecodeH264SessionParametersAddInfoEXT * pParametersAddInfo_ ) VULKAN_HPP_NOEXCEPT
    {
      pParametersAddInfo = pParametersAddInfo_;
      return *this;
    }

    operator VkVideoDecodeH264SessionParametersCreateInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkVideoDecodeH264SessionParametersCreateInfoEXT *>( this );
    }

    operator VkVideoDecodeH264SessionParametersCreateInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkVideoDecodeH264SessionParametersCreateInfoEXT *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( VideoDecodeH264SessionParametersCreateInfoEXT const & ) const = default;
#  else
    bool operator==( VideoDecodeH264SessionParametersCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( maxSpsStdCount == rhs.maxSpsStdCount ) &&
             ( maxPpsStdCount == rhs.maxPpsStdCount ) && ( pParametersAddInfo == rhs.pParametersAddInfo );
    }

    bool operator!=( VideoDecodeH264SessionParametersCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType          = StructureType::eVideoDecodeH264SessionParametersCreateInfoEXT;
    const void *                        pNext          = {};
    uint32_t                            maxSpsStdCount = {};
    uint32_t                            maxPpsStdCount = {};
    const VULKAN_HPP_NAMESPACE::VideoDecodeH264SessionParametersAddInfoEXT * pParametersAddInfo = {};
  };
  static_assert( sizeof( VideoDecodeH264SessionParametersCreateInfoEXT ) ==
                   sizeof( VkVideoDecodeH264SessionParametersCreateInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<VideoDecodeH264SessionParametersCreateInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eVideoDecodeH264SessionParametersCreateInfoEXT>
  {
    using Type = VideoDecodeH264SessionParametersCreateInfoEXT;
  };
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  struct VideoDecodeH265CapabilitiesEXT
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eVideoDecodeH265CapabilitiesEXT;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR_14 VideoDecodeH265CapabilitiesEXT(
      uint32_t maxLevel_ = {}, VULKAN_HPP_NAMESPACE::ExtensionProperties stdExtensionVersion_ = {} ) VULKAN_HPP_NOEXCEPT
      : maxLevel( maxLevel_ )
      , stdExtensionVersion( stdExtensionVersion_ )
    {}

    VULKAN_HPP_CONSTEXPR_14
      VideoDecodeH265CapabilitiesEXT( VideoDecodeH265CapabilitiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoDecodeH265CapabilitiesEXT( VkVideoDecodeH265CapabilitiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : VideoDecodeH265CapabilitiesEXT( *reinterpret_cast<VideoDecodeH265CapabilitiesEXT const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 VideoDecodeH265CapabilitiesEXT &
                            operator=( VideoDecodeH265CapabilitiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoDecodeH265CapabilitiesEXT & operator=( VkVideoDecodeH265CapabilitiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::VideoDecodeH265CapabilitiesEXT const *>( &rhs );
      return *this;
    }

    operator VkVideoDecodeH265CapabilitiesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkVideoDecodeH265CapabilitiesEXT *>( this );
    }

    operator VkVideoDecodeH265CapabilitiesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkVideoDecodeH265CapabilitiesEXT *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( VideoDecodeH265CapabilitiesEXT const & ) const = default;
#  else
    bool operator==( VideoDecodeH265CapabilitiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( maxLevel == rhs.maxLevel ) &&
             ( stdExtensionVersion == rhs.stdExtensionVersion );
    }

    bool operator!=( VideoDecodeH265CapabilitiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType       sType               = StructureType::eVideoDecodeH265CapabilitiesEXT;
    void *                                    pNext               = {};
    uint32_t                                  maxLevel            = {};
    VULKAN_HPP_NAMESPACE::ExtensionProperties stdExtensionVersion = {};
  };
  static_assert( sizeof( VideoDecodeH265CapabilitiesEXT ) == sizeof( VkVideoDecodeH265CapabilitiesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<VideoDecodeH265CapabilitiesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eVideoDecodeH265CapabilitiesEXT>
  {
    using Type = VideoDecodeH265CapabilitiesEXT;
  };
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  struct VideoDecodeH265DpbSlotInfoEXT
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eVideoDecodeH265DpbSlotInfoEXT;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR VideoDecodeH265DpbSlotInfoEXT(
      const StdVideoDecodeH265ReferenceInfo * pStdReferenceInfo_ = {} ) VULKAN_HPP_NOEXCEPT
      : pStdReferenceInfo( pStdReferenceInfo_ )
    {}

    VULKAN_HPP_CONSTEXPR
      VideoDecodeH265DpbSlotInfoEXT( VideoDecodeH265DpbSlotInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoDecodeH265DpbSlotInfoEXT( VkVideoDecodeH265DpbSlotInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : VideoDecodeH265DpbSlotInfoEXT( *reinterpret_cast<VideoDecodeH265DpbSlotInfoEXT const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 VideoDecodeH265DpbSlotInfoEXT &
                            operator=( VideoDecodeH265DpbSlotInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoDecodeH265DpbSlotInfoEXT & operator=( VkVideoDecodeH265DpbSlotInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::VideoDecodeH265DpbSlotInfoEXT const *>( &rhs );
      return *this;
    }

    VideoDecodeH265DpbSlotInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    VideoDecodeH265DpbSlotInfoEXT &
      setPStdReferenceInfo( const StdVideoDecodeH265ReferenceInfo * pStdReferenceInfo_ ) VULKAN_HPP_NOEXCEPT
    {
      pStdReferenceInfo = pStdReferenceInfo_;
      return *this;
    }

    operator VkVideoDecodeH265DpbSlotInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkVideoDecodeH265DpbSlotInfoEXT *>( this );
    }

    operator VkVideoDecodeH265DpbSlotInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkVideoDecodeH265DpbSlotInfoEXT *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( VideoDecodeH265DpbSlotInfoEXT const & ) const = default;
#  else
    bool operator==( VideoDecodeH265DpbSlotInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( pStdReferenceInfo == rhs.pStdReferenceInfo );
    }

    bool operator!=( VideoDecodeH265DpbSlotInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType     sType             = StructureType::eVideoDecodeH265DpbSlotInfoEXT;
    const void *                            pNext             = {};
    const StdVideoDecodeH265ReferenceInfo * pStdReferenceInfo = {};
  };
  static_assert( sizeof( VideoDecodeH265DpbSlotInfoEXT ) == sizeof( VkVideoDecodeH265DpbSlotInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<VideoDecodeH265DpbSlotInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eVideoDecodeH265DpbSlotInfoEXT>
  {
    using Type = VideoDecodeH265DpbSlotInfoEXT;
  };
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  struct VideoDecodeH265PictureInfoEXT
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eVideoDecodeH265PictureInfoEXT;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR VideoDecodeH265PictureInfoEXT( StdVideoDecodeH265PictureInfo * pStdPictureInfo_ = {},
                                                        uint32_t                        slicesCount_     = {},
                                                        const uint32_t * pSlicesDataOffsets_ = {} ) VULKAN_HPP_NOEXCEPT
      : pStdPictureInfo( pStdPictureInfo_ )
      , slicesCount( slicesCount_ )
      , pSlicesDataOffsets( pSlicesDataOffsets_ )
    {}

    VULKAN_HPP_CONSTEXPR
      VideoDecodeH265PictureInfoEXT( VideoDecodeH265PictureInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoDecodeH265PictureInfoEXT( VkVideoDecodeH265PictureInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : VideoDecodeH265PictureInfoEXT( *reinterpret_cast<VideoDecodeH265PictureInfoEXT const *>( &rhs ) )
    {}

#    if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    VideoDecodeH265PictureInfoEXT(
      StdVideoDecodeH265PictureInfo *                                       pStdPictureInfo_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const & slicesDataOffsets_ )
      : pStdPictureInfo( pStdPictureInfo_ )
      , slicesCount( static_cast<uint32_t>( slicesDataOffsets_.size() ) )
      , pSlicesDataOffsets( slicesDataOffsets_.data() )
    {}
#    endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#  endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 VideoDecodeH265PictureInfoEXT &
                            operator=( VideoDecodeH265PictureInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoDecodeH265PictureInfoEXT & operator=( VkVideoDecodeH265PictureInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::VideoDecodeH265PictureInfoEXT const *>( &rhs );
      return *this;
    }

    VideoDecodeH265PictureInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    VideoDecodeH265PictureInfoEXT &
      setPStdPictureInfo( StdVideoDecodeH265PictureInfo * pStdPictureInfo_ ) VULKAN_HPP_NOEXCEPT
    {
      pStdPictureInfo = pStdPictureInfo_;
      return *this;
    }

    VideoDecodeH265PictureInfoEXT & setSlicesCount( uint32_t slicesCount_ ) VULKAN_HPP_NOEXCEPT
    {
      slicesCount = slicesCount_;
      return *this;
    }

    VideoDecodeH265PictureInfoEXT & setPSlicesDataOffsets( const uint32_t * pSlicesDataOffsets_ ) VULKAN_HPP_NOEXCEPT
    {
      pSlicesDataOffsets = pSlicesDataOffsets_;
      return *this;
    }

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    VideoDecodeH265PictureInfoEXT & setSlicesDataOffsets(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const & slicesDataOffsets_ ) VULKAN_HPP_NOEXCEPT
    {
      slicesCount        = static_cast<uint32_t>( slicesDataOffsets_.size() );
      pSlicesDataOffsets = slicesDataOffsets_.data();
      return *this;
    }
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkVideoDecodeH265PictureInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkVideoDecodeH265PictureInfoEXT *>( this );
    }

    operator VkVideoDecodeH265PictureInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkVideoDecodeH265PictureInfoEXT *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( VideoDecodeH265PictureInfoEXT const & ) const = default;
#  else
    bool operator==( VideoDecodeH265PictureInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( pStdPictureInfo == rhs.pStdPictureInfo ) &&
             ( slicesCount == rhs.slicesCount ) && ( pSlicesDataOffsets == rhs.pSlicesDataOffsets );
    }

    bool operator!=( VideoDecodeH265PictureInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType              = StructureType::eVideoDecodeH265PictureInfoEXT;
    const void *                        pNext              = {};
    StdVideoDecodeH265PictureInfo *     pStdPictureInfo    = {};
    uint32_t                            slicesCount        = {};
    const uint32_t *                    pSlicesDataOffsets = {};
  };
  static_assert( sizeof( VideoDecodeH265PictureInfoEXT ) == sizeof( VkVideoDecodeH265PictureInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<VideoDecodeH265PictureInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eVideoDecodeH265PictureInfoEXT>
  {
    using Type = VideoDecodeH265PictureInfoEXT;
  };
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  struct VideoDecodeH265ProfileEXT
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eVideoDecodeH265ProfileEXT;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR VideoDecodeH265ProfileEXT( StdVideoH265ProfileIdc stdProfileIdc_ = {} ) VULKAN_HPP_NOEXCEPT
      : stdProfileIdc( stdProfileIdc_ )
    {}

    VULKAN_HPP_CONSTEXPR
      VideoDecodeH265ProfileEXT( VideoDecodeH265ProfileEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoDecodeH265ProfileEXT( VkVideoDecodeH265ProfileEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : VideoDecodeH265ProfileEXT( *reinterpret_cast<VideoDecodeH265ProfileEXT const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 VideoDecodeH265ProfileEXT &
                            operator=( VideoDecodeH265ProfileEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoDecodeH265ProfileEXT & operator=( VkVideoDecodeH265ProfileEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::VideoDecodeH265ProfileEXT const *>( &rhs );
      return *this;
    }

    VideoDecodeH265ProfileEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    VideoDecodeH265ProfileEXT & setStdProfileIdc( StdVideoH265ProfileIdc stdProfileIdc_ ) VULKAN_HPP_NOEXCEPT
    {
      stdProfileIdc = stdProfileIdc_;
      return *this;
    }

    operator VkVideoDecodeH265ProfileEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkVideoDecodeH265ProfileEXT *>( this );
    }

    operator VkVideoDecodeH265ProfileEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkVideoDecodeH265ProfileEXT *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( VideoDecodeH265ProfileEXT const & ) const = default;
#  else
    bool operator==( VideoDecodeH265ProfileEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( memcmp( &stdProfileIdc, &rhs.stdProfileIdc, sizeof( StdVideoH265ProfileIdc ) ) == 0 );
    }

    bool operator!=( VideoDecodeH265ProfileEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType         = StructureType::eVideoDecodeH265ProfileEXT;
    const void *                        pNext         = {};
    StdVideoH265ProfileIdc              stdProfileIdc = {};
  };
  static_assert( sizeof( VideoDecodeH265ProfileEXT ) == sizeof( VkVideoDecodeH265ProfileEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<VideoDecodeH265ProfileEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eVideoDecodeH265ProfileEXT>
  {
    using Type = VideoDecodeH265ProfileEXT;
  };
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  struct VideoDecodeH265SessionCreateInfoEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eVideoDecodeH265SessionCreateInfoEXT;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR_14 VideoDecodeH265SessionCreateInfoEXT(
      VULKAN_HPP_NAMESPACE::VideoDecodeH265CreateFlagsEXT flags_                = {},
      const VULKAN_HPP_NAMESPACE::ExtensionProperties *   pStdExtensionVersion_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , pStdExtensionVersion( pStdExtensionVersion_ )
    {}

    VULKAN_HPP_CONSTEXPR_14 VideoDecodeH265SessionCreateInfoEXT( VideoDecodeH265SessionCreateInfoEXT const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    VideoDecodeH265SessionCreateInfoEXT( VkVideoDecodeH265SessionCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : VideoDecodeH265SessionCreateInfoEXT( *reinterpret_cast<VideoDecodeH265SessionCreateInfoEXT const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 VideoDecodeH265SessionCreateInfoEXT &
                            operator=( VideoDecodeH265SessionCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoDecodeH265SessionCreateInfoEXT &
      operator=( VkVideoDecodeH265SessionCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::VideoDecodeH265SessionCreateInfoEXT const *>( &rhs );
      return *this;
    }

    VideoDecodeH265SessionCreateInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    VideoDecodeH265SessionCreateInfoEXT &
      setFlags( VULKAN_HPP_NAMESPACE::VideoDecodeH265CreateFlagsEXT flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    VideoDecodeH265SessionCreateInfoEXT & setPStdExtensionVersion(
      const VULKAN_HPP_NAMESPACE::ExtensionProperties * pStdExtensionVersion_ ) VULKAN_HPP_NOEXCEPT
    {
      pStdExtensionVersion = pStdExtensionVersion_;
      return *this;
    }

    operator VkVideoDecodeH265SessionCreateInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkVideoDecodeH265SessionCreateInfoEXT *>( this );
    }

    operator VkVideoDecodeH265SessionCreateInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkVideoDecodeH265SessionCreateInfoEXT *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( VideoDecodeH265SessionCreateInfoEXT const & ) const = default;
#  else
    bool operator==( VideoDecodeH265SessionCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( pStdExtensionVersion == rhs.pStdExtensionVersion );
    }

    bool operator!=( VideoDecodeH265SessionCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                 sType = StructureType::eVideoDecodeH265SessionCreateInfoEXT;
    const void *                                        pNext = {};
    VULKAN_HPP_NAMESPACE::VideoDecodeH265CreateFlagsEXT flags = {};
    const VULKAN_HPP_NAMESPACE::ExtensionProperties *   pStdExtensionVersion = {};
  };
  static_assert( sizeof( VideoDecodeH265SessionCreateInfoEXT ) == sizeof( VkVideoDecodeH265SessionCreateInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<VideoDecodeH265SessionCreateInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eVideoDecodeH265SessionCreateInfoEXT>
  {
    using Type = VideoDecodeH265SessionCreateInfoEXT;
  };
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  struct VideoDecodeH265SessionParametersAddInfoEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eVideoDecodeH265SessionParametersAddInfoEXT;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR VideoDecodeH265SessionParametersAddInfoEXT(
      uint32_t                                 spsStdCount_ = {},
      const StdVideoH265SequenceParameterSet * pSpsStd_     = {},
      uint32_t                                 ppsStdCount_ = {},
      const StdVideoH265PictureParameterSet *  pPpsStd_     = {} ) VULKAN_HPP_NOEXCEPT
      : spsStdCount( spsStdCount_ )
      , pSpsStd( pSpsStd_ )
      , ppsStdCount( ppsStdCount_ )
      , pPpsStd( pPpsStd_ )
    {}

    VULKAN_HPP_CONSTEXPR VideoDecodeH265SessionParametersAddInfoEXT(
      VideoDecodeH265SessionParametersAddInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoDecodeH265SessionParametersAddInfoEXT( VkVideoDecodeH265SessionParametersAddInfoEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : VideoDecodeH265SessionParametersAddInfoEXT(
          *reinterpret_cast<VideoDecodeH265SessionParametersAddInfoEXT const *>( &rhs ) )
    {}

#    if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    VideoDecodeH265SessionParametersAddInfoEXT(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const StdVideoH265SequenceParameterSet> const & spsStd_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const StdVideoH265PictureParameterSet> const &  ppsStd_ = {} )
      : spsStdCount( static_cast<uint32_t>( spsStd_.size() ) )
      , pSpsStd( spsStd_.data() )
      , ppsStdCount( static_cast<uint32_t>( ppsStd_.size() ) )
      , pPpsStd( ppsStd_.data() )
    {}
#    endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#  endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 VideoDecodeH265SessionParametersAddInfoEXT &
                            operator=( VideoDecodeH265SessionParametersAddInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoDecodeH265SessionParametersAddInfoEXT &
      operator=( VkVideoDecodeH265SessionParametersAddInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::VideoDecodeH265SessionParametersAddInfoEXT const *>( &rhs );
      return *this;
    }

    VideoDecodeH265SessionParametersAddInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    VideoDecodeH265SessionParametersAddInfoEXT & setSpsStdCount( uint32_t spsStdCount_ ) VULKAN_HPP_NOEXCEPT
    {
      spsStdCount = spsStdCount_;
      return *this;
    }

    VideoDecodeH265SessionParametersAddInfoEXT &
      setPSpsStd( const StdVideoH265SequenceParameterSet * pSpsStd_ ) VULKAN_HPP_NOEXCEPT
    {
      pSpsStd = pSpsStd_;
      return *this;
    }

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    VideoDecodeH265SessionParametersAddInfoEXT &
      setSpsStd( VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const StdVideoH265SequenceParameterSet> const & spsStd_ )
        VULKAN_HPP_NOEXCEPT
    {
      spsStdCount = static_cast<uint32_t>( spsStd_.size() );
      pSpsStd     = spsStd_.data();
      return *this;
    }
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    VideoDecodeH265SessionParametersAddInfoEXT & setPpsStdCount( uint32_t ppsStdCount_ ) VULKAN_HPP_NOEXCEPT
    {
      ppsStdCount = ppsStdCount_;
      return *this;
    }

    VideoDecodeH265SessionParametersAddInfoEXT &
      setPPpsStd( const StdVideoH265PictureParameterSet * pPpsStd_ ) VULKAN_HPP_NOEXCEPT
    {
      pPpsStd = pPpsStd_;
      return *this;
    }

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    VideoDecodeH265SessionParametersAddInfoEXT &
      setPpsStd( VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const StdVideoH265PictureParameterSet> const & ppsStd_ )
        VULKAN_HPP_NOEXCEPT
    {
      ppsStdCount = static_cast<uint32_t>( ppsStd_.size() );
      pPpsStd     = ppsStd_.data();
      return *this;
    }
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkVideoDecodeH265SessionParametersAddInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkVideoDecodeH265SessionParametersAddInfoEXT *>( this );
    }

    operator VkVideoDecodeH265SessionParametersAddInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkVideoDecodeH265SessionParametersAddInfoEXT *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( VideoDecodeH265SessionParametersAddInfoEXT const & ) const = default;
#  else
    bool operator==( VideoDecodeH265SessionParametersAddInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( spsStdCount == rhs.spsStdCount ) &&
             ( pSpsStd == rhs.pSpsStd ) && ( ppsStdCount == rhs.ppsStdCount ) && ( pPpsStd == rhs.pPpsStd );
    }

    bool operator!=( VideoDecodeH265SessionParametersAddInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType      sType       = StructureType::eVideoDecodeH265SessionParametersAddInfoEXT;
    const void *                             pNext       = {};
    uint32_t                                 spsStdCount = {};
    const StdVideoH265SequenceParameterSet * pSpsStd     = {};
    uint32_t                                 ppsStdCount = {};
    const StdVideoH265PictureParameterSet *  pPpsStd     = {};
  };
  static_assert( sizeof( VideoDecodeH265SessionParametersAddInfoEXT ) ==
                   sizeof( VkVideoDecodeH265SessionParametersAddInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<VideoDecodeH265SessionParametersAddInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eVideoDecodeH265SessionParametersAddInfoEXT>
  {
    using Type = VideoDecodeH265SessionParametersAddInfoEXT;
  };
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  struct VideoDecodeH265SessionParametersCreateInfoEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eVideoDecodeH265SessionParametersCreateInfoEXT;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR VideoDecodeH265SessionParametersCreateInfoEXT(
      uint32_t                                                                 maxSpsStdCount_     = {},
      uint32_t                                                                 maxPpsStdCount_     = {},
      const VULKAN_HPP_NAMESPACE::VideoDecodeH265SessionParametersAddInfoEXT * pParametersAddInfo_ = {} )
      VULKAN_HPP_NOEXCEPT
      : maxSpsStdCount( maxSpsStdCount_ )
      , maxPpsStdCount( maxPpsStdCount_ )
      , pParametersAddInfo( pParametersAddInfo_ )
    {}

    VULKAN_HPP_CONSTEXPR VideoDecodeH265SessionParametersCreateInfoEXT(
      VideoDecodeH265SessionParametersCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoDecodeH265SessionParametersCreateInfoEXT( VkVideoDecodeH265SessionParametersCreateInfoEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : VideoDecodeH265SessionParametersCreateInfoEXT(
          *reinterpret_cast<VideoDecodeH265SessionParametersCreateInfoEXT const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 VideoDecodeH265SessionParametersCreateInfoEXT &
                            operator=( VideoDecodeH265SessionParametersCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoDecodeH265SessionParametersCreateInfoEXT &
      operator=( VkVideoDecodeH265SessionParametersCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::VideoDecodeH265SessionParametersCreateInfoEXT const *>( &rhs );
      return *this;
    }

    VideoDecodeH265SessionParametersCreateInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    VideoDecodeH265SessionParametersCreateInfoEXT & setMaxSpsStdCount( uint32_t maxSpsStdCount_ ) VULKAN_HPP_NOEXCEPT
    {
      maxSpsStdCount = maxSpsStdCount_;
      return *this;
    }

    VideoDecodeH265SessionParametersCreateInfoEXT & setMaxPpsStdCount( uint32_t maxPpsStdCount_ ) VULKAN_HPP_NOEXCEPT
    {
      maxPpsStdCount = maxPpsStdCount_;
      return *this;
    }

    VideoDecodeH265SessionParametersCreateInfoEXT & setPParametersAddInfo(
      const VULKAN_HPP_NAMESPACE::VideoDecodeH265SessionParametersAddInfoEXT * pParametersAddInfo_ ) VULKAN_HPP_NOEXCEPT
    {
      pParametersAddInfo = pParametersAddInfo_;
      return *this;
    }

    operator VkVideoDecodeH265SessionParametersCreateInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkVideoDecodeH265SessionParametersCreateInfoEXT *>( this );
    }

    operator VkVideoDecodeH265SessionParametersCreateInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkVideoDecodeH265SessionParametersCreateInfoEXT *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( VideoDecodeH265SessionParametersCreateInfoEXT const & ) const = default;
#  else
    bool operator==( VideoDecodeH265SessionParametersCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( maxSpsStdCount == rhs.maxSpsStdCount ) &&
             ( maxPpsStdCount == rhs.maxPpsStdCount ) && ( pParametersAddInfo == rhs.pParametersAddInfo );
    }

    bool operator!=( VideoDecodeH265SessionParametersCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType          = StructureType::eVideoDecodeH265SessionParametersCreateInfoEXT;
    const void *                        pNext          = {};
    uint32_t                            maxSpsStdCount = {};
    uint32_t                            maxPpsStdCount = {};
    const VULKAN_HPP_NAMESPACE::VideoDecodeH265SessionParametersAddInfoEXT * pParametersAddInfo = {};
  };
  static_assert( sizeof( VideoDecodeH265SessionParametersCreateInfoEXT ) ==
                   sizeof( VkVideoDecodeH265SessionParametersCreateInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<VideoDecodeH265SessionParametersCreateInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eVideoDecodeH265SessionParametersCreateInfoEXT>
  {
    using Type = VideoDecodeH265SessionParametersCreateInfoEXT;
  };
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  struct VideoDecodeInfoKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eVideoDecodeInfoKHR;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR VideoDecodeInfoKHR(
      VULKAN_HPP_NAMESPACE::VideoDecodeFlagsKHR           flags_               = {},
      VULKAN_HPP_NAMESPACE::Offset2D                      codedOffset_         = {},
      VULKAN_HPP_NAMESPACE::Extent2D                      codedExtent_         = {},
      VULKAN_HPP_NAMESPACE::Buffer                        srcBuffer_           = {},
      VULKAN_HPP_NAMESPACE::DeviceSize                    srcBufferOffset_     = {},
      VULKAN_HPP_NAMESPACE::DeviceSize                    srcBufferRange_      = {},
      VULKAN_HPP_NAMESPACE::VideoPictureResourceKHR       dstPictureResource_  = {},
      const VULKAN_HPP_NAMESPACE::VideoReferenceSlotKHR * pSetupReferenceSlot_ = {},
      uint32_t                                            referenceSlotCount_  = {},
      const VULKAN_HPP_NAMESPACE::VideoReferenceSlotKHR * pReferenceSlots_     = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , codedOffset( codedOffset_ )
      , codedExtent( codedExtent_ )
      , srcBuffer( srcBuffer_ )
      , srcBufferOffset( srcBufferOffset_ )
      , srcBufferRange( srcBufferRange_ )
      , dstPictureResource( dstPictureResource_ )
      , pSetupReferenceSlot( pSetupReferenceSlot_ )
      , referenceSlotCount( referenceSlotCount_ )
      , pReferenceSlots( pReferenceSlots_ )
    {}

    VULKAN_HPP_CONSTEXPR VideoDecodeInfoKHR( VideoDecodeInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoDecodeInfoKHR( VkVideoDecodeInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : VideoDecodeInfoKHR( *reinterpret_cast<VideoDecodeInfoKHR const *>( &rhs ) )
    {}

#    if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    VideoDecodeInfoKHR(
      VULKAN_HPP_NAMESPACE::VideoDecodeFlagsKHR           flags_,
      VULKAN_HPP_NAMESPACE::Offset2D                      codedOffset_,
      VULKAN_HPP_NAMESPACE::Extent2D                      codedExtent_,
      VULKAN_HPP_NAMESPACE::Buffer                        srcBuffer_,
      VULKAN_HPP_NAMESPACE::DeviceSize                    srcBufferOffset_,
      VULKAN_HPP_NAMESPACE::DeviceSize                    srcBufferRange_,
      VULKAN_HPP_NAMESPACE::VideoPictureResourceKHR       dstPictureResource_,
      const VULKAN_HPP_NAMESPACE::VideoReferenceSlotKHR * pSetupReferenceSlot_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::VideoReferenceSlotKHR> const &
        referenceSlots_ )
      : flags( flags_ )
      , codedOffset( codedOffset_ )
      , codedExtent( codedExtent_ )
      , srcBuffer( srcBuffer_ )
      , srcBufferOffset( srcBufferOffset_ )
      , srcBufferRange( srcBufferRange_ )
      , dstPictureResource( dstPictureResource_ )
      , pSetupReferenceSlot( pSetupReferenceSlot_ )
      , referenceSlotCount( static_cast<uint32_t>( referenceSlots_.size() ) )
      , pReferenceSlots( referenceSlots_.data() )
    {}
#    endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#  endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 VideoDecodeInfoKHR &
                            operator=( VideoDecodeInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoDecodeInfoKHR & operator=( VkVideoDecodeInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::VideoDecodeInfoKHR const *>( &rhs );
      return *this;
    }

    VideoDecodeInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    VideoDecodeInfoKHR & setFlags( VULKAN_HPP_NAMESPACE::VideoDecodeFlagsKHR flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    VideoDecodeInfoKHR & setCodedOffset( VULKAN_HPP_NAMESPACE::Offset2D const & codedOffset_ ) VULKAN_HPP_NOEXCEPT
    {
      codedOffset = codedOffset_;
      return *this;
    }

    VideoDecodeInfoKHR & setCodedExtent( VULKAN_HPP_NAMESPACE::Extent2D const & codedExtent_ ) VULKAN_HPP_NOEXCEPT
    {
      codedExtent = codedExtent_;
      return *this;
    }

    VideoDecodeInfoKHR & setSrcBuffer( VULKAN_HPP_NAMESPACE::Buffer srcBuffer_ ) VULKAN_HPP_NOEXCEPT
    {
      srcBuffer = srcBuffer_;
      return *this;
    }

    VideoDecodeInfoKHR & setSrcBufferOffset( VULKAN_HPP_NAMESPACE::DeviceSize srcBufferOffset_ ) VULKAN_HPP_NOEXCEPT
    {
      srcBufferOffset = srcBufferOffset_;
      return *this;
    }

    VideoDecodeInfoKHR & setSrcBufferRange( VULKAN_HPP_NAMESPACE::DeviceSize srcBufferRange_ ) VULKAN_HPP_NOEXCEPT
    {
      srcBufferRange = srcBufferRange_;
      return *this;
    }

    VideoDecodeInfoKHR & setDstPictureResource(
      VULKAN_HPP_NAMESPACE::VideoPictureResourceKHR const & dstPictureResource_ ) VULKAN_HPP_NOEXCEPT
    {
      dstPictureResource = dstPictureResource_;
      return *this;
    }

    VideoDecodeInfoKHR & setPSetupReferenceSlot(
      const VULKAN_HPP_NAMESPACE::VideoReferenceSlotKHR * pSetupReferenceSlot_ ) VULKAN_HPP_NOEXCEPT
    {
      pSetupReferenceSlot = pSetupReferenceSlot_;
      return *this;
    }

    VideoDecodeInfoKHR & setReferenceSlotCount( uint32_t referenceSlotCount_ ) VULKAN_HPP_NOEXCEPT
    {
      referenceSlotCount = referenceSlotCount_;
      return *this;
    }

    VideoDecodeInfoKHR &
      setPReferenceSlots( const VULKAN_HPP_NAMESPACE::VideoReferenceSlotKHR * pReferenceSlots_ ) VULKAN_HPP_NOEXCEPT
    {
      pReferenceSlots = pReferenceSlots_;
      return *this;
    }

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    VideoDecodeInfoKHR & setReferenceSlots(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::VideoReferenceSlotKHR> const &
        referenceSlots_ ) VULKAN_HPP_NOEXCEPT
    {
      referenceSlotCount = static_cast<uint32_t>( referenceSlots_.size() );
      pReferenceSlots    = referenceSlots_.data();
      return *this;
    }
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkVideoDecodeInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkVideoDecodeInfoKHR *>( this );
    }

    operator VkVideoDecodeInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkVideoDecodeInfoKHR *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( VideoDecodeInfoKHR const & ) const = default;
#  else
    bool operator==( VideoDecodeInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( codedOffset == rhs.codedOffset ) && ( codedExtent == rhs.codedExtent ) &&
             ( srcBuffer == rhs.srcBuffer ) && ( srcBufferOffset == rhs.srcBufferOffset ) &&
             ( srcBufferRange == rhs.srcBufferRange ) && ( dstPictureResource == rhs.dstPictureResource ) &&
             ( pSetupReferenceSlot == rhs.pSetupReferenceSlot ) && ( referenceSlotCount == rhs.referenceSlotCount ) &&
             ( pReferenceSlots == rhs.pReferenceSlots );
    }

    bool operator!=( VideoDecodeInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                 sType               = StructureType::eVideoDecodeInfoKHR;
    const void *                                        pNext               = {};
    VULKAN_HPP_NAMESPACE::VideoDecodeFlagsKHR           flags               = {};
    VULKAN_HPP_NAMESPACE::Offset2D                      codedOffset         = {};
    VULKAN_HPP_NAMESPACE::Extent2D                      codedExtent         = {};
    VULKAN_HPP_NAMESPACE::Buffer                        srcBuffer           = {};
    VULKAN_HPP_NAMESPACE::DeviceSize                    srcBufferOffset     = {};
    VULKAN_HPP_NAMESPACE::DeviceSize                    srcBufferRange      = {};
    VULKAN_HPP_NAMESPACE::VideoPictureResourceKHR       dstPictureResource  = {};
    const VULKAN_HPP_NAMESPACE::VideoReferenceSlotKHR * pSetupReferenceSlot = {};
    uint32_t                                            referenceSlotCount  = {};
    const VULKAN_HPP_NAMESPACE::VideoReferenceSlotKHR * pReferenceSlots     = {};
  };
  static_assert( sizeof( VideoDecodeInfoKHR ) == sizeof( VkVideoDecodeInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<VideoDecodeInfoKHR>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eVideoDecodeInfoKHR>
  {
    using Type = VideoDecodeInfoKHR;
  };
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  struct VideoEncodeH264CapabilitiesEXT
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eVideoEncodeH264CapabilitiesEXT;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR_14 VideoEncodeH264CapabilitiesEXT(
      VULKAN_HPP_NAMESPACE::VideoEncodeH264CapabilitiesFlagsEXT flags_                   = {},
      VULKAN_HPP_NAMESPACE::VideoEncodeH264InputModeFlagsEXT    inputModeFlags_          = {},
      VULKAN_HPP_NAMESPACE::VideoEncodeH264OutputModeFlagsEXT   outputModeFlags_         = {},
      VULKAN_HPP_NAMESPACE::Extent2D                            minPictureSizeInMbs_     = {},
      VULKAN_HPP_NAMESPACE::Extent2D                            maxPictureSizeInMbs_     = {},
      VULKAN_HPP_NAMESPACE::Extent2D                            inputImageDataAlignment_ = {},
      uint8_t                                                   maxNumL0ReferenceForP_   = {},
      uint8_t                                                   maxNumL0ReferenceForB_   = {},
      uint8_t                                                   maxNumL1Reference_       = {},
      uint8_t                                                   qualityLevelCount_       = {},
      VULKAN_HPP_NAMESPACE::ExtensionProperties                 stdExtensionVersion_     = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , inputModeFlags( inputModeFlags_ )
      , outputModeFlags( outputModeFlags_ )
      , minPictureSizeInMbs( minPictureSizeInMbs_ )
      , maxPictureSizeInMbs( maxPictureSizeInMbs_ )
      , inputImageDataAlignment( inputImageDataAlignment_ )
      , maxNumL0ReferenceForP( maxNumL0ReferenceForP_ )
      , maxNumL0ReferenceForB( maxNumL0ReferenceForB_ )
      , maxNumL1Reference( maxNumL1Reference_ )
      , qualityLevelCount( qualityLevelCount_ )
      , stdExtensionVersion( stdExtensionVersion_ )
    {}

    VULKAN_HPP_CONSTEXPR_14
      VideoEncodeH264CapabilitiesEXT( VideoEncodeH264CapabilitiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoEncodeH264CapabilitiesEXT( VkVideoEncodeH264CapabilitiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : VideoEncodeH264CapabilitiesEXT( *reinterpret_cast<VideoEncodeH264CapabilitiesEXT const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 VideoEncodeH264CapabilitiesEXT &
                            operator=( VideoEncodeH264CapabilitiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoEncodeH264CapabilitiesEXT & operator=( VkVideoEncodeH264CapabilitiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::VideoEncodeH264CapabilitiesEXT const *>( &rhs );
      return *this;
    }

    VideoEncodeH264CapabilitiesEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    VideoEncodeH264CapabilitiesEXT &
      setFlags( VULKAN_HPP_NAMESPACE::VideoEncodeH264CapabilitiesFlagsEXT flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    VideoEncodeH264CapabilitiesEXT &
      setInputModeFlags( VULKAN_HPP_NAMESPACE::VideoEncodeH264InputModeFlagsEXT inputModeFlags_ ) VULKAN_HPP_NOEXCEPT
    {
      inputModeFlags = inputModeFlags_;
      return *this;
    }

    VideoEncodeH264CapabilitiesEXT &
      setOutputModeFlags( VULKAN_HPP_NAMESPACE::VideoEncodeH264OutputModeFlagsEXT outputModeFlags_ ) VULKAN_HPP_NOEXCEPT
    {
      outputModeFlags = outputModeFlags_;
      return *this;
    }

    VideoEncodeH264CapabilitiesEXT &
      setMinPictureSizeInMbs( VULKAN_HPP_NAMESPACE::Extent2D const & minPictureSizeInMbs_ ) VULKAN_HPP_NOEXCEPT
    {
      minPictureSizeInMbs = minPictureSizeInMbs_;
      return *this;
    }

    VideoEncodeH264CapabilitiesEXT &
      setMaxPictureSizeInMbs( VULKAN_HPP_NAMESPACE::Extent2D const & maxPictureSizeInMbs_ ) VULKAN_HPP_NOEXCEPT
    {
      maxPictureSizeInMbs = maxPictureSizeInMbs_;
      return *this;
    }

    VideoEncodeH264CapabilitiesEXT &
      setInputImageDataAlignment( VULKAN_HPP_NAMESPACE::Extent2D const & inputImageDataAlignment_ ) VULKAN_HPP_NOEXCEPT
    {
      inputImageDataAlignment = inputImageDataAlignment_;
      return *this;
    }

    VideoEncodeH264CapabilitiesEXT & setMaxNumL0ReferenceForP( uint8_t maxNumL0ReferenceForP_ ) VULKAN_HPP_NOEXCEPT
    {
      maxNumL0ReferenceForP = maxNumL0ReferenceForP_;
      return *this;
    }

    VideoEncodeH264CapabilitiesEXT & setMaxNumL0ReferenceForB( uint8_t maxNumL0ReferenceForB_ ) VULKAN_HPP_NOEXCEPT
    {
      maxNumL0ReferenceForB = maxNumL0ReferenceForB_;
      return *this;
    }

    VideoEncodeH264CapabilitiesEXT & setMaxNumL1Reference( uint8_t maxNumL1Reference_ ) VULKAN_HPP_NOEXCEPT
    {
      maxNumL1Reference = maxNumL1Reference_;
      return *this;
    }

    VideoEncodeH264CapabilitiesEXT & setQualityLevelCount( uint8_t qualityLevelCount_ ) VULKAN_HPP_NOEXCEPT
    {
      qualityLevelCount = qualityLevelCount_;
      return *this;
    }

    VideoEncodeH264CapabilitiesEXT & setStdExtensionVersion(
      VULKAN_HPP_NAMESPACE::ExtensionProperties const & stdExtensionVersion_ ) VULKAN_HPP_NOEXCEPT
    {
      stdExtensionVersion = stdExtensionVersion_;
      return *this;
    }

    operator VkVideoEncodeH264CapabilitiesEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkVideoEncodeH264CapabilitiesEXT *>( this );
    }

    operator VkVideoEncodeH264CapabilitiesEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkVideoEncodeH264CapabilitiesEXT *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( VideoEncodeH264CapabilitiesEXT const & ) const = default;
#  else
    bool operator==( VideoEncodeH264CapabilitiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( inputModeFlags == rhs.inputModeFlags ) && ( outputModeFlags == rhs.outputModeFlags ) &&
             ( minPictureSizeInMbs == rhs.minPictureSizeInMbs ) && ( maxPictureSizeInMbs == rhs.maxPictureSizeInMbs ) &&
             ( inputImageDataAlignment == rhs.inputImageDataAlignment ) &&
             ( maxNumL0ReferenceForP == rhs.maxNumL0ReferenceForP ) &&
             ( maxNumL0ReferenceForB == rhs.maxNumL0ReferenceForB ) && ( maxNumL1Reference == rhs.maxNumL1Reference ) &&
             ( qualityLevelCount == rhs.qualityLevelCount ) && ( stdExtensionVersion == rhs.stdExtensionVersion );
    }

    bool operator!=( VideoEncodeH264CapabilitiesEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                       sType = StructureType::eVideoEncodeH264CapabilitiesEXT;
    const void *                                              pNext = {};
    VULKAN_HPP_NAMESPACE::VideoEncodeH264CapabilitiesFlagsEXT flags = {};
    VULKAN_HPP_NAMESPACE::VideoEncodeH264InputModeFlagsEXT    inputModeFlags          = {};
    VULKAN_HPP_NAMESPACE::VideoEncodeH264OutputModeFlagsEXT   outputModeFlags         = {};
    VULKAN_HPP_NAMESPACE::Extent2D                            minPictureSizeInMbs     = {};
    VULKAN_HPP_NAMESPACE::Extent2D                            maxPictureSizeInMbs     = {};
    VULKAN_HPP_NAMESPACE::Extent2D                            inputImageDataAlignment = {};
    uint8_t                                                   maxNumL0ReferenceForP   = {};
    uint8_t                                                   maxNumL0ReferenceForB   = {};
    uint8_t                                                   maxNumL1Reference       = {};
    uint8_t                                                   qualityLevelCount       = {};
    VULKAN_HPP_NAMESPACE::ExtensionProperties                 stdExtensionVersion     = {};
  };
  static_assert( sizeof( VideoEncodeH264CapabilitiesEXT ) == sizeof( VkVideoEncodeH264CapabilitiesEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<VideoEncodeH264CapabilitiesEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eVideoEncodeH264CapabilitiesEXT>
  {
    using Type = VideoEncodeH264CapabilitiesEXT;
  };
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  struct VideoEncodeH264DpbSlotInfoEXT
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eVideoEncodeH264DpbSlotInfoEXT;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      VideoEncodeH264DpbSlotInfoEXT( int8_t                                slotIndex_       = {},
                                     const StdVideoEncodeH264PictureInfo * pStdPictureInfo_ = {} ) VULKAN_HPP_NOEXCEPT
      : slotIndex( slotIndex_ )
      , pStdPictureInfo( pStdPictureInfo_ )
    {}

    VULKAN_HPP_CONSTEXPR
      VideoEncodeH264DpbSlotInfoEXT( VideoEncodeH264DpbSlotInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoEncodeH264DpbSlotInfoEXT( VkVideoEncodeH264DpbSlotInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : VideoEncodeH264DpbSlotInfoEXT( *reinterpret_cast<VideoEncodeH264DpbSlotInfoEXT const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 VideoEncodeH264DpbSlotInfoEXT &
                            operator=( VideoEncodeH264DpbSlotInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoEncodeH264DpbSlotInfoEXT & operator=( VkVideoEncodeH264DpbSlotInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::VideoEncodeH264DpbSlotInfoEXT const *>( &rhs );
      return *this;
    }

    VideoEncodeH264DpbSlotInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    VideoEncodeH264DpbSlotInfoEXT & setSlotIndex( int8_t slotIndex_ ) VULKAN_HPP_NOEXCEPT
    {
      slotIndex = slotIndex_;
      return *this;
    }

    VideoEncodeH264DpbSlotInfoEXT &
      setPStdPictureInfo( const StdVideoEncodeH264PictureInfo * pStdPictureInfo_ ) VULKAN_HPP_NOEXCEPT
    {
      pStdPictureInfo = pStdPictureInfo_;
      return *this;
    }

    operator VkVideoEncodeH264DpbSlotInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkVideoEncodeH264DpbSlotInfoEXT *>( this );
    }

    operator VkVideoEncodeH264DpbSlotInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkVideoEncodeH264DpbSlotInfoEXT *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( VideoEncodeH264DpbSlotInfoEXT const & ) const = default;
#  else
    bool operator==( VideoEncodeH264DpbSlotInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( slotIndex == rhs.slotIndex ) &&
             ( pStdPictureInfo == rhs.pStdPictureInfo );
    }

    bool operator!=( VideoEncodeH264DpbSlotInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType   sType           = StructureType::eVideoEncodeH264DpbSlotInfoEXT;
    const void *                          pNext           = {};
    int8_t                                slotIndex       = {};
    const StdVideoEncodeH264PictureInfo * pStdPictureInfo = {};
  };
  static_assert( sizeof( VideoEncodeH264DpbSlotInfoEXT ) == sizeof( VkVideoEncodeH264DpbSlotInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<VideoEncodeH264DpbSlotInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eVideoEncodeH264DpbSlotInfoEXT>
  {
    using Type = VideoEncodeH264DpbSlotInfoEXT;
  };
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  struct VideoEncodeH264EmitPictureParametersEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eVideoEncodeH264EmitPictureParametersEXT;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      VideoEncodeH264EmitPictureParametersEXT( uint8_t                      spsId_           = {},
                                               VULKAN_HPP_NAMESPACE::Bool32 emitSpsEnable_   = {},
                                               uint32_t                     ppsIdEntryCount_ = {},
                                               const uint8_t *              ppsIdEntries_    = {} ) VULKAN_HPP_NOEXCEPT
      : spsId( spsId_ )
      , emitSpsEnable( emitSpsEnable_ )
      , ppsIdEntryCount( ppsIdEntryCount_ )
      , ppsIdEntries( ppsIdEntries_ )
    {}

    VULKAN_HPP_CONSTEXPR VideoEncodeH264EmitPictureParametersEXT( VideoEncodeH264EmitPictureParametersEXT const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    VideoEncodeH264EmitPictureParametersEXT( VkVideoEncodeH264EmitPictureParametersEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : VideoEncodeH264EmitPictureParametersEXT(
          *reinterpret_cast<VideoEncodeH264EmitPictureParametersEXT const *>( &rhs ) )
    {}

#    if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    VideoEncodeH264EmitPictureParametersEXT(
      uint8_t                                                              spsId_,
      VULKAN_HPP_NAMESPACE::Bool32                                         emitSpsEnable_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint8_t> const & psIdEntries_ )
      : spsId( spsId_ )
      , emitSpsEnable( emitSpsEnable_ )
      , ppsIdEntryCount( static_cast<uint32_t>( psIdEntries_.size() ) )
      , ppsIdEntries( psIdEntries_.data() )
    {}
#    endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#  endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 VideoEncodeH264EmitPictureParametersEXT &
                            operator=( VideoEncodeH264EmitPictureParametersEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoEncodeH264EmitPictureParametersEXT &
      operator=( VkVideoEncodeH264EmitPictureParametersEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::VideoEncodeH264EmitPictureParametersEXT const *>( &rhs );
      return *this;
    }

    VideoEncodeH264EmitPictureParametersEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    VideoEncodeH264EmitPictureParametersEXT & setSpsId( uint8_t spsId_ ) VULKAN_HPP_NOEXCEPT
    {
      spsId = spsId_;
      return *this;
    }

    VideoEncodeH264EmitPictureParametersEXT &
      setEmitSpsEnable( VULKAN_HPP_NAMESPACE::Bool32 emitSpsEnable_ ) VULKAN_HPP_NOEXCEPT
    {
      emitSpsEnable = emitSpsEnable_;
      return *this;
    }

    VideoEncodeH264EmitPictureParametersEXT & setPpsIdEntryCount( uint32_t ppsIdEntryCount_ ) VULKAN_HPP_NOEXCEPT
    {
      ppsIdEntryCount = ppsIdEntryCount_;
      return *this;
    }

    VideoEncodeH264EmitPictureParametersEXT & setPpsIdEntries( const uint8_t * ppsIdEntries_ ) VULKAN_HPP_NOEXCEPT
    {
      ppsIdEntries = ppsIdEntries_;
      return *this;
    }

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    VideoEncodeH264EmitPictureParametersEXT & setPsIdEntries(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint8_t> const & psIdEntries_ ) VULKAN_HPP_NOEXCEPT
    {
      ppsIdEntryCount = static_cast<uint32_t>( psIdEntries_.size() );
      ppsIdEntries    = psIdEntries_.data();
      return *this;
    }
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkVideoEncodeH264EmitPictureParametersEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkVideoEncodeH264EmitPictureParametersEXT *>( this );
    }

    operator VkVideoEncodeH264EmitPictureParametersEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkVideoEncodeH264EmitPictureParametersEXT *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( VideoEncodeH264EmitPictureParametersEXT const & ) const = default;
#  else
    bool operator==( VideoEncodeH264EmitPictureParametersEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( spsId == rhs.spsId ) &&
             ( emitSpsEnable == rhs.emitSpsEnable ) && ( ppsIdEntryCount == rhs.ppsIdEntryCount ) &&
             ( ppsIdEntries == rhs.ppsIdEntries );
    }

    bool operator!=( VideoEncodeH264EmitPictureParametersEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType           = StructureType::eVideoEncodeH264EmitPictureParametersEXT;
    const void *                        pNext           = {};
    uint8_t                             spsId           = {};
    VULKAN_HPP_NAMESPACE::Bool32        emitSpsEnable   = {};
    uint32_t                            ppsIdEntryCount = {};
    const uint8_t *                     ppsIdEntries    = {};
  };
  static_assert( sizeof( VideoEncodeH264EmitPictureParametersEXT ) ==
                   sizeof( VkVideoEncodeH264EmitPictureParametersEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<VideoEncodeH264EmitPictureParametersEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eVideoEncodeH264EmitPictureParametersEXT>
  {
    using Type = VideoEncodeH264EmitPictureParametersEXT;
  };
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  struct VideoEncodeH264NaluSliceEXT
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eVideoEncodeH264NaluSliceEXT;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR VideoEncodeH264NaluSliceEXT(
      const StdVideoEncodeH264SliceHeader *                       pSliceHeaderStd_         = {},
      uint32_t                                                    mbCount_                 = {},
      uint8_t                                                     refFinalList0EntryCount_ = {},
      const VULKAN_HPP_NAMESPACE::VideoEncodeH264DpbSlotInfoEXT * pRefFinalList0Entries_   = {},
      uint8_t                                                     refFinalList1EntryCount_ = {},
      const VULKAN_HPP_NAMESPACE::VideoEncodeH264DpbSlotInfoEXT * pRefFinalList1Entries_   = {},
      uint32_t                                                    precedingNaluBytes_      = {},
      uint8_t                                                     minQp_                   = {},
      uint8_t                                                     maxQp_                   = {} ) VULKAN_HPP_NOEXCEPT
      : pSliceHeaderStd( pSliceHeaderStd_ )
      , mbCount( mbCount_ )
      , refFinalList0EntryCount( refFinalList0EntryCount_ )
      , pRefFinalList0Entries( pRefFinalList0Entries_ )
      , refFinalList1EntryCount( refFinalList1EntryCount_ )
      , pRefFinalList1Entries( pRefFinalList1Entries_ )
      , precedingNaluBytes( precedingNaluBytes_ )
      , minQp( minQp_ )
      , maxQp( maxQp_ )
    {}

    VULKAN_HPP_CONSTEXPR
      VideoEncodeH264NaluSliceEXT( VideoEncodeH264NaluSliceEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoEncodeH264NaluSliceEXT( VkVideoEncodeH264NaluSliceEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : VideoEncodeH264NaluSliceEXT( *reinterpret_cast<VideoEncodeH264NaluSliceEXT const *>( &rhs ) )
    {}

#    if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    VideoEncodeH264NaluSliceEXT(
      const StdVideoEncodeH264SliceHeader * pSliceHeaderStd_,
      uint32_t                              mbCount_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::VideoEncodeH264DpbSlotInfoEXT> const &
        refFinalList0Entries_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::VideoEncodeH264DpbSlotInfoEXT> const &
               refFinalList1Entries_ = {},
      uint32_t precedingNaluBytes_   = {},
      uint8_t  minQp_                = {},
      uint8_t  maxQp_                = {} )
      : pSliceHeaderStd( pSliceHeaderStd_ )
      , mbCount( mbCount_ )
      , refFinalList0EntryCount( static_cast<uint8_t>( refFinalList0Entries_.size() ) )
      , pRefFinalList0Entries( refFinalList0Entries_.data() )
      , refFinalList1EntryCount( static_cast<uint8_t>( refFinalList1Entries_.size() ) )
      , pRefFinalList1Entries( refFinalList1Entries_.data() )
      , precedingNaluBytes( precedingNaluBytes_ )
      , minQp( minQp_ )
      , maxQp( maxQp_ )
    {}
#    endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#  endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 VideoEncodeH264NaluSliceEXT &
                            operator=( VideoEncodeH264NaluSliceEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoEncodeH264NaluSliceEXT & operator=( VkVideoEncodeH264NaluSliceEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::VideoEncodeH264NaluSliceEXT const *>( &rhs );
      return *this;
    }

    VideoEncodeH264NaluSliceEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    VideoEncodeH264NaluSliceEXT &
      setPSliceHeaderStd( const StdVideoEncodeH264SliceHeader * pSliceHeaderStd_ ) VULKAN_HPP_NOEXCEPT
    {
      pSliceHeaderStd = pSliceHeaderStd_;
      return *this;
    }

    VideoEncodeH264NaluSliceEXT & setMbCount( uint32_t mbCount_ ) VULKAN_HPP_NOEXCEPT
    {
      mbCount = mbCount_;
      return *this;
    }

    VideoEncodeH264NaluSliceEXT & setRefFinalList0EntryCount( uint8_t refFinalList0EntryCount_ ) VULKAN_HPP_NOEXCEPT
    {
      refFinalList0EntryCount = refFinalList0EntryCount_;
      return *this;
    }

    VideoEncodeH264NaluSliceEXT & setPRefFinalList0Entries(
      const VULKAN_HPP_NAMESPACE::VideoEncodeH264DpbSlotInfoEXT * pRefFinalList0Entries_ ) VULKAN_HPP_NOEXCEPT
    {
      pRefFinalList0Entries = pRefFinalList0Entries_;
      return *this;
    }

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    VideoEncodeH264NaluSliceEXT & setRefFinalList0Entries(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::VideoEncodeH264DpbSlotInfoEXT> const &
        refFinalList0Entries_ ) VULKAN_HPP_NOEXCEPT
    {
      refFinalList0EntryCount = static_cast<uint8_t>( refFinalList0Entries_.size() );
      pRefFinalList0Entries   = refFinalList0Entries_.data();
      return *this;
    }
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    VideoEncodeH264NaluSliceEXT & setRefFinalList1EntryCount( uint8_t refFinalList1EntryCount_ ) VULKAN_HPP_NOEXCEPT
    {
      refFinalList1EntryCount = refFinalList1EntryCount_;
      return *this;
    }

    VideoEncodeH264NaluSliceEXT & setPRefFinalList1Entries(
      const VULKAN_HPP_NAMESPACE::VideoEncodeH264DpbSlotInfoEXT * pRefFinalList1Entries_ ) VULKAN_HPP_NOEXCEPT
    {
      pRefFinalList1Entries = pRefFinalList1Entries_;
      return *this;
    }

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    VideoEncodeH264NaluSliceEXT & setRefFinalList1Entries(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::VideoEncodeH264DpbSlotInfoEXT> const &
        refFinalList1Entries_ ) VULKAN_HPP_NOEXCEPT
    {
      refFinalList1EntryCount = static_cast<uint8_t>( refFinalList1Entries_.size() );
      pRefFinalList1Entries   = refFinalList1Entries_.data();
      return *this;
    }
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    VideoEncodeH264NaluSliceEXT & setPrecedingNaluBytes( uint32_t precedingNaluBytes_ ) VULKAN_HPP_NOEXCEPT
    {
      precedingNaluBytes = precedingNaluBytes_;
      return *this;
    }

    VideoEncodeH264NaluSliceEXT & setMinQp( uint8_t minQp_ ) VULKAN_HPP_NOEXCEPT
    {
      minQp = minQp_;
      return *this;
    }

    VideoEncodeH264NaluSliceEXT & setMaxQp( uint8_t maxQp_ ) VULKAN_HPP_NOEXCEPT
    {
      maxQp = maxQp_;
      return *this;
    }

    operator VkVideoEncodeH264NaluSliceEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkVideoEncodeH264NaluSliceEXT *>( this );
    }

    operator VkVideoEncodeH264NaluSliceEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkVideoEncodeH264NaluSliceEXT *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( VideoEncodeH264NaluSliceEXT const & ) const = default;
#  else
    bool operator==( VideoEncodeH264NaluSliceEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( pSliceHeaderStd == rhs.pSliceHeaderStd ) &&
             ( mbCount == rhs.mbCount ) && ( refFinalList0EntryCount == rhs.refFinalList0EntryCount ) &&
             ( pRefFinalList0Entries == rhs.pRefFinalList0Entries ) &&
             ( refFinalList1EntryCount == rhs.refFinalList1EntryCount ) &&
             ( pRefFinalList1Entries == rhs.pRefFinalList1Entries ) &&
             ( precedingNaluBytes == rhs.precedingNaluBytes ) && ( minQp == rhs.minQp ) && ( maxQp == rhs.maxQp );
    }

    bool operator!=( VideoEncodeH264NaluSliceEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                         sType = StructureType::eVideoEncodeH264NaluSliceEXT;
    const void *                                                pNext = {};
    const StdVideoEncodeH264SliceHeader *                       pSliceHeaderStd         = {};
    uint32_t                                                    mbCount                 = {};
    uint8_t                                                     refFinalList0EntryCount = {};
    const VULKAN_HPP_NAMESPACE::VideoEncodeH264DpbSlotInfoEXT * pRefFinalList0Entries   = {};
    uint8_t                                                     refFinalList1EntryCount = {};
    const VULKAN_HPP_NAMESPACE::VideoEncodeH264DpbSlotInfoEXT * pRefFinalList1Entries   = {};
    uint32_t                                                    precedingNaluBytes      = {};
    uint8_t                                                     minQp                   = {};
    uint8_t                                                     maxQp                   = {};
  };
  static_assert( sizeof( VideoEncodeH264NaluSliceEXT ) == sizeof( VkVideoEncodeH264NaluSliceEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<VideoEncodeH264NaluSliceEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eVideoEncodeH264NaluSliceEXT>
  {
    using Type = VideoEncodeH264NaluSliceEXT;
  };
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  struct VideoEncodeH264ProfileEXT
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eVideoEncodeH264ProfileEXT;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR VideoEncodeH264ProfileEXT( StdVideoH264ProfileIdc stdProfileIdc_ = {} ) VULKAN_HPP_NOEXCEPT
      : stdProfileIdc( stdProfileIdc_ )
    {}

    VULKAN_HPP_CONSTEXPR
      VideoEncodeH264ProfileEXT( VideoEncodeH264ProfileEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoEncodeH264ProfileEXT( VkVideoEncodeH264ProfileEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : VideoEncodeH264ProfileEXT( *reinterpret_cast<VideoEncodeH264ProfileEXT const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 VideoEncodeH264ProfileEXT &
                            operator=( VideoEncodeH264ProfileEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoEncodeH264ProfileEXT & operator=( VkVideoEncodeH264ProfileEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::VideoEncodeH264ProfileEXT const *>( &rhs );
      return *this;
    }

    VideoEncodeH264ProfileEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    VideoEncodeH264ProfileEXT & setStdProfileIdc( StdVideoH264ProfileIdc stdProfileIdc_ ) VULKAN_HPP_NOEXCEPT
    {
      stdProfileIdc = stdProfileIdc_;
      return *this;
    }

    operator VkVideoEncodeH264ProfileEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkVideoEncodeH264ProfileEXT *>( this );
    }

    operator VkVideoEncodeH264ProfileEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkVideoEncodeH264ProfileEXT *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( VideoEncodeH264ProfileEXT const & ) const = default;
#  else
    bool operator==( VideoEncodeH264ProfileEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( memcmp( &stdProfileIdc, &rhs.stdProfileIdc, sizeof( StdVideoH264ProfileIdc ) ) == 0 );
    }

    bool operator!=( VideoEncodeH264ProfileEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType         = StructureType::eVideoEncodeH264ProfileEXT;
    const void *                        pNext         = {};
    StdVideoH264ProfileIdc              stdProfileIdc = {};
  };
  static_assert( sizeof( VideoEncodeH264ProfileEXT ) == sizeof( VkVideoEncodeH264ProfileEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<VideoEncodeH264ProfileEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eVideoEncodeH264ProfileEXT>
  {
    using Type = VideoEncodeH264ProfileEXT;
  };
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  struct VideoEncodeH264SessionCreateInfoEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eVideoEncodeH264SessionCreateInfoEXT;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR_14 VideoEncodeH264SessionCreateInfoEXT(
      VULKAN_HPP_NAMESPACE::VideoEncodeH264CreateFlagsEXT flags_                = {},
      VULKAN_HPP_NAMESPACE::Extent2D                      maxPictureSizeInMbs_  = {},
      const VULKAN_HPP_NAMESPACE::ExtensionProperties *   pStdExtensionVersion_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , maxPictureSizeInMbs( maxPictureSizeInMbs_ )
      , pStdExtensionVersion( pStdExtensionVersion_ )
    {}

    VULKAN_HPP_CONSTEXPR_14 VideoEncodeH264SessionCreateInfoEXT( VideoEncodeH264SessionCreateInfoEXT const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    VideoEncodeH264SessionCreateInfoEXT( VkVideoEncodeH264SessionCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : VideoEncodeH264SessionCreateInfoEXT( *reinterpret_cast<VideoEncodeH264SessionCreateInfoEXT const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 VideoEncodeH264SessionCreateInfoEXT &
                            operator=( VideoEncodeH264SessionCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoEncodeH264SessionCreateInfoEXT &
      operator=( VkVideoEncodeH264SessionCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::VideoEncodeH264SessionCreateInfoEXT const *>( &rhs );
      return *this;
    }

    VideoEncodeH264SessionCreateInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    VideoEncodeH264SessionCreateInfoEXT &
      setFlags( VULKAN_HPP_NAMESPACE::VideoEncodeH264CreateFlagsEXT flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    VideoEncodeH264SessionCreateInfoEXT &
      setMaxPictureSizeInMbs( VULKAN_HPP_NAMESPACE::Extent2D const & maxPictureSizeInMbs_ ) VULKAN_HPP_NOEXCEPT
    {
      maxPictureSizeInMbs = maxPictureSizeInMbs_;
      return *this;
    }

    VideoEncodeH264SessionCreateInfoEXT & setPStdExtensionVersion(
      const VULKAN_HPP_NAMESPACE::ExtensionProperties * pStdExtensionVersion_ ) VULKAN_HPP_NOEXCEPT
    {
      pStdExtensionVersion = pStdExtensionVersion_;
      return *this;
    }

    operator VkVideoEncodeH264SessionCreateInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkVideoEncodeH264SessionCreateInfoEXT *>( this );
    }

    operator VkVideoEncodeH264SessionCreateInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkVideoEncodeH264SessionCreateInfoEXT *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( VideoEncodeH264SessionCreateInfoEXT const & ) const = default;
#  else
    bool operator==( VideoEncodeH264SessionCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( maxPictureSizeInMbs == rhs.maxPictureSizeInMbs ) && ( pStdExtensionVersion == rhs.pStdExtensionVersion );
    }

    bool operator!=( VideoEncodeH264SessionCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                 sType = StructureType::eVideoEncodeH264SessionCreateInfoEXT;
    const void *                                        pNext = {};
    VULKAN_HPP_NAMESPACE::VideoEncodeH264CreateFlagsEXT flags = {};
    VULKAN_HPP_NAMESPACE::Extent2D                      maxPictureSizeInMbs  = {};
    const VULKAN_HPP_NAMESPACE::ExtensionProperties *   pStdExtensionVersion = {};
  };
  static_assert( sizeof( VideoEncodeH264SessionCreateInfoEXT ) == sizeof( VkVideoEncodeH264SessionCreateInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<VideoEncodeH264SessionCreateInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eVideoEncodeH264SessionCreateInfoEXT>
  {
    using Type = VideoEncodeH264SessionCreateInfoEXT;
  };
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  struct VideoEncodeH264SessionParametersAddInfoEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eVideoEncodeH264SessionParametersAddInfoEXT;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR VideoEncodeH264SessionParametersAddInfoEXT(
      uint32_t                                 spsStdCount_ = {},
      const StdVideoH264SequenceParameterSet * pSpsStd_     = {},
      uint32_t                                 ppsStdCount_ = {},
      const StdVideoH264PictureParameterSet *  pPpsStd_     = {} ) VULKAN_HPP_NOEXCEPT
      : spsStdCount( spsStdCount_ )
      , pSpsStd( pSpsStd_ )
      , ppsStdCount( ppsStdCount_ )
      , pPpsStd( pPpsStd_ )
    {}

    VULKAN_HPP_CONSTEXPR VideoEncodeH264SessionParametersAddInfoEXT(
      VideoEncodeH264SessionParametersAddInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoEncodeH264SessionParametersAddInfoEXT( VkVideoEncodeH264SessionParametersAddInfoEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : VideoEncodeH264SessionParametersAddInfoEXT(
          *reinterpret_cast<VideoEncodeH264SessionParametersAddInfoEXT const *>( &rhs ) )
    {}

#    if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    VideoEncodeH264SessionParametersAddInfoEXT(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const StdVideoH264SequenceParameterSet> const & spsStd_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const StdVideoH264PictureParameterSet> const &  ppsStd_ = {} )
      : spsStdCount( static_cast<uint32_t>( spsStd_.size() ) )
      , pSpsStd( spsStd_.data() )
      , ppsStdCount( static_cast<uint32_t>( ppsStd_.size() ) )
      , pPpsStd( ppsStd_.data() )
    {}
#    endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#  endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 VideoEncodeH264SessionParametersAddInfoEXT &
                            operator=( VideoEncodeH264SessionParametersAddInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoEncodeH264SessionParametersAddInfoEXT &
      operator=( VkVideoEncodeH264SessionParametersAddInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::VideoEncodeH264SessionParametersAddInfoEXT const *>( &rhs );
      return *this;
    }

    VideoEncodeH264SessionParametersAddInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    VideoEncodeH264SessionParametersAddInfoEXT & setSpsStdCount( uint32_t spsStdCount_ ) VULKAN_HPP_NOEXCEPT
    {
      spsStdCount = spsStdCount_;
      return *this;
    }

    VideoEncodeH264SessionParametersAddInfoEXT &
      setPSpsStd( const StdVideoH264SequenceParameterSet * pSpsStd_ ) VULKAN_HPP_NOEXCEPT
    {
      pSpsStd = pSpsStd_;
      return *this;
    }

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    VideoEncodeH264SessionParametersAddInfoEXT &
      setSpsStd( VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const StdVideoH264SequenceParameterSet> const & spsStd_ )
        VULKAN_HPP_NOEXCEPT
    {
      spsStdCount = static_cast<uint32_t>( spsStd_.size() );
      pSpsStd     = spsStd_.data();
      return *this;
    }
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    VideoEncodeH264SessionParametersAddInfoEXT & setPpsStdCount( uint32_t ppsStdCount_ ) VULKAN_HPP_NOEXCEPT
    {
      ppsStdCount = ppsStdCount_;
      return *this;
    }

    VideoEncodeH264SessionParametersAddInfoEXT &
      setPPpsStd( const StdVideoH264PictureParameterSet * pPpsStd_ ) VULKAN_HPP_NOEXCEPT
    {
      pPpsStd = pPpsStd_;
      return *this;
    }

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    VideoEncodeH264SessionParametersAddInfoEXT &
      setPpsStd( VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const StdVideoH264PictureParameterSet> const & ppsStd_ )
        VULKAN_HPP_NOEXCEPT
    {
      ppsStdCount = static_cast<uint32_t>( ppsStd_.size() );
      pPpsStd     = ppsStd_.data();
      return *this;
    }
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkVideoEncodeH264SessionParametersAddInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkVideoEncodeH264SessionParametersAddInfoEXT *>( this );
    }

    operator VkVideoEncodeH264SessionParametersAddInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkVideoEncodeH264SessionParametersAddInfoEXT *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( VideoEncodeH264SessionParametersAddInfoEXT const & ) const = default;
#  else
    bool operator==( VideoEncodeH264SessionParametersAddInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( spsStdCount == rhs.spsStdCount ) &&
             ( pSpsStd == rhs.pSpsStd ) && ( ppsStdCount == rhs.ppsStdCount ) && ( pPpsStd == rhs.pPpsStd );
    }

    bool operator!=( VideoEncodeH264SessionParametersAddInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType      sType       = StructureType::eVideoEncodeH264SessionParametersAddInfoEXT;
    const void *                             pNext       = {};
    uint32_t                                 spsStdCount = {};
    const StdVideoH264SequenceParameterSet * pSpsStd     = {};
    uint32_t                                 ppsStdCount = {};
    const StdVideoH264PictureParameterSet *  pPpsStd     = {};
  };
  static_assert( sizeof( VideoEncodeH264SessionParametersAddInfoEXT ) ==
                   sizeof( VkVideoEncodeH264SessionParametersAddInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<VideoEncodeH264SessionParametersAddInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eVideoEncodeH264SessionParametersAddInfoEXT>
  {
    using Type = VideoEncodeH264SessionParametersAddInfoEXT;
  };
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  struct VideoEncodeH264SessionParametersCreateInfoEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eVideoEncodeH264SessionParametersCreateInfoEXT;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR VideoEncodeH264SessionParametersCreateInfoEXT(
      uint32_t                                                                 maxSpsStdCount_     = {},
      uint32_t                                                                 maxPpsStdCount_     = {},
      const VULKAN_HPP_NAMESPACE::VideoEncodeH264SessionParametersAddInfoEXT * pParametersAddInfo_ = {} )
      VULKAN_HPP_NOEXCEPT
      : maxSpsStdCount( maxSpsStdCount_ )
      , maxPpsStdCount( maxPpsStdCount_ )
      , pParametersAddInfo( pParametersAddInfo_ )
    {}

    VULKAN_HPP_CONSTEXPR VideoEncodeH264SessionParametersCreateInfoEXT(
      VideoEncodeH264SessionParametersCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoEncodeH264SessionParametersCreateInfoEXT( VkVideoEncodeH264SessionParametersCreateInfoEXT const & rhs )
      VULKAN_HPP_NOEXCEPT
      : VideoEncodeH264SessionParametersCreateInfoEXT(
          *reinterpret_cast<VideoEncodeH264SessionParametersCreateInfoEXT const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 VideoEncodeH264SessionParametersCreateInfoEXT &
                            operator=( VideoEncodeH264SessionParametersCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoEncodeH264SessionParametersCreateInfoEXT &
      operator=( VkVideoEncodeH264SessionParametersCreateInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::VideoEncodeH264SessionParametersCreateInfoEXT const *>( &rhs );
      return *this;
    }

    VideoEncodeH264SessionParametersCreateInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    VideoEncodeH264SessionParametersCreateInfoEXT & setMaxSpsStdCount( uint32_t maxSpsStdCount_ ) VULKAN_HPP_NOEXCEPT
    {
      maxSpsStdCount = maxSpsStdCount_;
      return *this;
    }

    VideoEncodeH264SessionParametersCreateInfoEXT & setMaxPpsStdCount( uint32_t maxPpsStdCount_ ) VULKAN_HPP_NOEXCEPT
    {
      maxPpsStdCount = maxPpsStdCount_;
      return *this;
    }

    VideoEncodeH264SessionParametersCreateInfoEXT & setPParametersAddInfo(
      const VULKAN_HPP_NAMESPACE::VideoEncodeH264SessionParametersAddInfoEXT * pParametersAddInfo_ ) VULKAN_HPP_NOEXCEPT
    {
      pParametersAddInfo = pParametersAddInfo_;
      return *this;
    }

    operator VkVideoEncodeH264SessionParametersCreateInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkVideoEncodeH264SessionParametersCreateInfoEXT *>( this );
    }

    operator VkVideoEncodeH264SessionParametersCreateInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkVideoEncodeH264SessionParametersCreateInfoEXT *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( VideoEncodeH264SessionParametersCreateInfoEXT const & ) const = default;
#  else
    bool operator==( VideoEncodeH264SessionParametersCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( maxSpsStdCount == rhs.maxSpsStdCount ) &&
             ( maxPpsStdCount == rhs.maxPpsStdCount ) && ( pParametersAddInfo == rhs.pParametersAddInfo );
    }

    bool operator!=( VideoEncodeH264SessionParametersCreateInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType          = StructureType::eVideoEncodeH264SessionParametersCreateInfoEXT;
    const void *                        pNext          = {};
    uint32_t                            maxSpsStdCount = {};
    uint32_t                            maxPpsStdCount = {};
    const VULKAN_HPP_NAMESPACE::VideoEncodeH264SessionParametersAddInfoEXT * pParametersAddInfo = {};
  };
  static_assert( sizeof( VideoEncodeH264SessionParametersCreateInfoEXT ) ==
                   sizeof( VkVideoEncodeH264SessionParametersCreateInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<VideoEncodeH264SessionParametersCreateInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eVideoEncodeH264SessionParametersCreateInfoEXT>
  {
    using Type = VideoEncodeH264SessionParametersCreateInfoEXT;
  };
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  struct VideoEncodeH264VclFrameInfoEXT
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eVideoEncodeH264VclFrameInfoEXT;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR VideoEncodeH264VclFrameInfoEXT(
      uint8_t                                                     refDefaultFinalList0EntryCount_ = {},
      const VULKAN_HPP_NAMESPACE::VideoEncodeH264DpbSlotInfoEXT * pRefDefaultFinalList0Entries_   = {},
      uint8_t                                                     refDefaultFinalList1EntryCount_ = {},
      const VULKAN_HPP_NAMESPACE::VideoEncodeH264DpbSlotInfoEXT * pRefDefaultFinalList1Entries_   = {},
      uint32_t                                                    naluSliceEntryCount_            = {},
      const VULKAN_HPP_NAMESPACE::VideoEncodeH264NaluSliceEXT *   pNaluSliceEntries_              = {},
      const VULKAN_HPP_NAMESPACE::VideoEncodeH264DpbSlotInfoEXT * pCurrentPictureInfo_ = {} ) VULKAN_HPP_NOEXCEPT
      : refDefaultFinalList0EntryCount( refDefaultFinalList0EntryCount_ )
      , pRefDefaultFinalList0Entries( pRefDefaultFinalList0Entries_ )
      , refDefaultFinalList1EntryCount( refDefaultFinalList1EntryCount_ )
      , pRefDefaultFinalList1Entries( pRefDefaultFinalList1Entries_ )
      , naluSliceEntryCount( naluSliceEntryCount_ )
      , pNaluSliceEntries( pNaluSliceEntries_ )
      , pCurrentPictureInfo( pCurrentPictureInfo_ )
    {}

    VULKAN_HPP_CONSTEXPR
      VideoEncodeH264VclFrameInfoEXT( VideoEncodeH264VclFrameInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoEncodeH264VclFrameInfoEXT( VkVideoEncodeH264VclFrameInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : VideoEncodeH264VclFrameInfoEXT( *reinterpret_cast<VideoEncodeH264VclFrameInfoEXT const *>( &rhs ) )
    {}

#    if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    VideoEncodeH264VclFrameInfoEXT(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::VideoEncodeH264DpbSlotInfoEXT> const &
        refDefaultFinalList0Entries_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::VideoEncodeH264DpbSlotInfoEXT> const &
        refDefaultFinalList1Entries_ = {},
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::VideoEncodeH264NaluSliceEXT> const &
                                                                  naluSliceEntries_    = {},
      const VULKAN_HPP_NAMESPACE::VideoEncodeH264DpbSlotInfoEXT * pCurrentPictureInfo_ = {} )
      : refDefaultFinalList0EntryCount( static_cast<uint8_t>( refDefaultFinalList0Entries_.size() ) )
      , pRefDefaultFinalList0Entries( refDefaultFinalList0Entries_.data() )
      , refDefaultFinalList1EntryCount( static_cast<uint8_t>( refDefaultFinalList1Entries_.size() ) )
      , pRefDefaultFinalList1Entries( refDefaultFinalList1Entries_.data() )
      , naluSliceEntryCount( static_cast<uint32_t>( naluSliceEntries_.size() ) )
      , pNaluSliceEntries( naluSliceEntries_.data() )
      , pCurrentPictureInfo( pCurrentPictureInfo_ )
    {}
#    endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#  endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 VideoEncodeH264VclFrameInfoEXT &
                            operator=( VideoEncodeH264VclFrameInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoEncodeH264VclFrameInfoEXT & operator=( VkVideoEncodeH264VclFrameInfoEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::VideoEncodeH264VclFrameInfoEXT const *>( &rhs );
      return *this;
    }

    VideoEncodeH264VclFrameInfoEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    VideoEncodeH264VclFrameInfoEXT &
      setRefDefaultFinalList0EntryCount( uint8_t refDefaultFinalList0EntryCount_ ) VULKAN_HPP_NOEXCEPT
    {
      refDefaultFinalList0EntryCount = refDefaultFinalList0EntryCount_;
      return *this;
    }

    VideoEncodeH264VclFrameInfoEXT & setPRefDefaultFinalList0Entries(
      const VULKAN_HPP_NAMESPACE::VideoEncodeH264DpbSlotInfoEXT * pRefDefaultFinalList0Entries_ ) VULKAN_HPP_NOEXCEPT
    {
      pRefDefaultFinalList0Entries = pRefDefaultFinalList0Entries_;
      return *this;
    }

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    VideoEncodeH264VclFrameInfoEXT & setRefDefaultFinalList0Entries(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::VideoEncodeH264DpbSlotInfoEXT> const &
        refDefaultFinalList0Entries_ ) VULKAN_HPP_NOEXCEPT
    {
      refDefaultFinalList0EntryCount = static_cast<uint8_t>( refDefaultFinalList0Entries_.size() );
      pRefDefaultFinalList0Entries   = refDefaultFinalList0Entries_.data();
      return *this;
    }
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    VideoEncodeH264VclFrameInfoEXT &
      setRefDefaultFinalList1EntryCount( uint8_t refDefaultFinalList1EntryCount_ ) VULKAN_HPP_NOEXCEPT
    {
      refDefaultFinalList1EntryCount = refDefaultFinalList1EntryCount_;
      return *this;
    }

    VideoEncodeH264VclFrameInfoEXT & setPRefDefaultFinalList1Entries(
      const VULKAN_HPP_NAMESPACE::VideoEncodeH264DpbSlotInfoEXT * pRefDefaultFinalList1Entries_ ) VULKAN_HPP_NOEXCEPT
    {
      pRefDefaultFinalList1Entries = pRefDefaultFinalList1Entries_;
      return *this;
    }

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    VideoEncodeH264VclFrameInfoEXT & setRefDefaultFinalList1Entries(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::VideoEncodeH264DpbSlotInfoEXT> const &
        refDefaultFinalList1Entries_ ) VULKAN_HPP_NOEXCEPT
    {
      refDefaultFinalList1EntryCount = static_cast<uint8_t>( refDefaultFinalList1Entries_.size() );
      pRefDefaultFinalList1Entries   = refDefaultFinalList1Entries_.data();
      return *this;
    }
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    VideoEncodeH264VclFrameInfoEXT & setNaluSliceEntryCount( uint32_t naluSliceEntryCount_ ) VULKAN_HPP_NOEXCEPT
    {
      naluSliceEntryCount = naluSliceEntryCount_;
      return *this;
    }

    VideoEncodeH264VclFrameInfoEXT & setPNaluSliceEntries(
      const VULKAN_HPP_NAMESPACE::VideoEncodeH264NaluSliceEXT * pNaluSliceEntries_ ) VULKAN_HPP_NOEXCEPT
    {
      pNaluSliceEntries = pNaluSliceEntries_;
      return *this;
    }

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    VideoEncodeH264VclFrameInfoEXT & setNaluSliceEntries(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::VideoEncodeH264NaluSliceEXT> const &
        naluSliceEntries_ ) VULKAN_HPP_NOEXCEPT
    {
      naluSliceEntryCount = static_cast<uint32_t>( naluSliceEntries_.size() );
      pNaluSliceEntries   = naluSliceEntries_.data();
      return *this;
    }
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    VideoEncodeH264VclFrameInfoEXT & setPCurrentPictureInfo(
      const VULKAN_HPP_NAMESPACE::VideoEncodeH264DpbSlotInfoEXT * pCurrentPictureInfo_ ) VULKAN_HPP_NOEXCEPT
    {
      pCurrentPictureInfo = pCurrentPictureInfo_;
      return *this;
    }

    operator VkVideoEncodeH264VclFrameInfoEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkVideoEncodeH264VclFrameInfoEXT *>( this );
    }

    operator VkVideoEncodeH264VclFrameInfoEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkVideoEncodeH264VclFrameInfoEXT *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( VideoEncodeH264VclFrameInfoEXT const & ) const = default;
#  else
    bool operator==( VideoEncodeH264VclFrameInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( refDefaultFinalList0EntryCount == rhs.refDefaultFinalList0EntryCount ) &&
             ( pRefDefaultFinalList0Entries == rhs.pRefDefaultFinalList0Entries ) &&
             ( refDefaultFinalList1EntryCount == rhs.refDefaultFinalList1EntryCount ) &&
             ( pRefDefaultFinalList1Entries == rhs.pRefDefaultFinalList1Entries ) &&
             ( naluSliceEntryCount == rhs.naluSliceEntryCount ) && ( pNaluSliceEntries == rhs.pNaluSliceEntries ) &&
             ( pCurrentPictureInfo == rhs.pCurrentPictureInfo );
    }

    bool operator!=( VideoEncodeH264VclFrameInfoEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                         sType = StructureType::eVideoEncodeH264VclFrameInfoEXT;
    const void *                                                pNext = {};
    uint8_t                                                     refDefaultFinalList0EntryCount = {};
    const VULKAN_HPP_NAMESPACE::VideoEncodeH264DpbSlotInfoEXT * pRefDefaultFinalList0Entries   = {};
    uint8_t                                                     refDefaultFinalList1EntryCount = {};
    const VULKAN_HPP_NAMESPACE::VideoEncodeH264DpbSlotInfoEXT * pRefDefaultFinalList1Entries   = {};
    uint32_t                                                    naluSliceEntryCount            = {};
    const VULKAN_HPP_NAMESPACE::VideoEncodeH264NaluSliceEXT *   pNaluSliceEntries              = {};
    const VULKAN_HPP_NAMESPACE::VideoEncodeH264DpbSlotInfoEXT * pCurrentPictureInfo            = {};
  };
  static_assert( sizeof( VideoEncodeH264VclFrameInfoEXT ) == sizeof( VkVideoEncodeH264VclFrameInfoEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<VideoEncodeH264VclFrameInfoEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eVideoEncodeH264VclFrameInfoEXT>
  {
    using Type = VideoEncodeH264VclFrameInfoEXT;
  };
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  struct VideoEncodeInfoKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eVideoEncodeInfoKHR;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR VideoEncodeInfoKHR(
      VULKAN_HPP_NAMESPACE::VideoEncodeFlagsKHR           flags_                      = {},
      uint32_t                                            qualityLevel_               = {},
      VULKAN_HPP_NAMESPACE::Extent2D                      codedExtent_                = {},
      VULKAN_HPP_NAMESPACE::Buffer                        dstBitstreamBuffer_         = {},
      VULKAN_HPP_NAMESPACE::DeviceSize                    dstBitstreamBufferOffset_   = {},
      VULKAN_HPP_NAMESPACE::DeviceSize                    dstBitstreamBufferMaxRange_ = {},
      VULKAN_HPP_NAMESPACE::VideoPictureResourceKHR       srcPictureResource_         = {},
      const VULKAN_HPP_NAMESPACE::VideoReferenceSlotKHR * pSetupReferenceSlot_        = {},
      uint32_t                                            referenceSlotCount_         = {},
      const VULKAN_HPP_NAMESPACE::VideoReferenceSlotKHR * pReferenceSlots_            = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , qualityLevel( qualityLevel_ )
      , codedExtent( codedExtent_ )
      , dstBitstreamBuffer( dstBitstreamBuffer_ )
      , dstBitstreamBufferOffset( dstBitstreamBufferOffset_ )
      , dstBitstreamBufferMaxRange( dstBitstreamBufferMaxRange_ )
      , srcPictureResource( srcPictureResource_ )
      , pSetupReferenceSlot( pSetupReferenceSlot_ )
      , referenceSlotCount( referenceSlotCount_ )
      , pReferenceSlots( pReferenceSlots_ )
    {}

    VULKAN_HPP_CONSTEXPR VideoEncodeInfoKHR( VideoEncodeInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoEncodeInfoKHR( VkVideoEncodeInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : VideoEncodeInfoKHR( *reinterpret_cast<VideoEncodeInfoKHR const *>( &rhs ) )
    {}

#    if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    VideoEncodeInfoKHR(
      VULKAN_HPP_NAMESPACE::VideoEncodeFlagsKHR           flags_,
      uint32_t                                            qualityLevel_,
      VULKAN_HPP_NAMESPACE::Extent2D                      codedExtent_,
      VULKAN_HPP_NAMESPACE::Buffer                        dstBitstreamBuffer_,
      VULKAN_HPP_NAMESPACE::DeviceSize                    dstBitstreamBufferOffset_,
      VULKAN_HPP_NAMESPACE::DeviceSize                    dstBitstreamBufferMaxRange_,
      VULKAN_HPP_NAMESPACE::VideoPictureResourceKHR       srcPictureResource_,
      const VULKAN_HPP_NAMESPACE::VideoReferenceSlotKHR * pSetupReferenceSlot_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::VideoReferenceSlotKHR> const &
        referenceSlots_ )
      : flags( flags_ )
      , qualityLevel( qualityLevel_ )
      , codedExtent( codedExtent_ )
      , dstBitstreamBuffer( dstBitstreamBuffer_ )
      , dstBitstreamBufferOffset( dstBitstreamBufferOffset_ )
      , dstBitstreamBufferMaxRange( dstBitstreamBufferMaxRange_ )
      , srcPictureResource( srcPictureResource_ )
      , pSetupReferenceSlot( pSetupReferenceSlot_ )
      , referenceSlotCount( static_cast<uint32_t>( referenceSlots_.size() ) )
      , pReferenceSlots( referenceSlots_.data() )
    {}
#    endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#  endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 VideoEncodeInfoKHR &
                            operator=( VideoEncodeInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoEncodeInfoKHR & operator=( VkVideoEncodeInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::VideoEncodeInfoKHR const *>( &rhs );
      return *this;
    }

    VideoEncodeInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    VideoEncodeInfoKHR & setFlags( VULKAN_HPP_NAMESPACE::VideoEncodeFlagsKHR flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    VideoEncodeInfoKHR & setQualityLevel( uint32_t qualityLevel_ ) VULKAN_HPP_NOEXCEPT
    {
      qualityLevel = qualityLevel_;
      return *this;
    }

    VideoEncodeInfoKHR & setCodedExtent( VULKAN_HPP_NAMESPACE::Extent2D const & codedExtent_ ) VULKAN_HPP_NOEXCEPT
    {
      codedExtent = codedExtent_;
      return *this;
    }

    VideoEncodeInfoKHR & setDstBitstreamBuffer( VULKAN_HPP_NAMESPACE::Buffer dstBitstreamBuffer_ ) VULKAN_HPP_NOEXCEPT
    {
      dstBitstreamBuffer = dstBitstreamBuffer_;
      return *this;
    }

    VideoEncodeInfoKHR &
      setDstBitstreamBufferOffset( VULKAN_HPP_NAMESPACE::DeviceSize dstBitstreamBufferOffset_ ) VULKAN_HPP_NOEXCEPT
    {
      dstBitstreamBufferOffset = dstBitstreamBufferOffset_;
      return *this;
    }

    VideoEncodeInfoKHR &
      setDstBitstreamBufferMaxRange( VULKAN_HPP_NAMESPACE::DeviceSize dstBitstreamBufferMaxRange_ ) VULKAN_HPP_NOEXCEPT
    {
      dstBitstreamBufferMaxRange = dstBitstreamBufferMaxRange_;
      return *this;
    }

    VideoEncodeInfoKHR & setSrcPictureResource(
      VULKAN_HPP_NAMESPACE::VideoPictureResourceKHR const & srcPictureResource_ ) VULKAN_HPP_NOEXCEPT
    {
      srcPictureResource = srcPictureResource_;
      return *this;
    }

    VideoEncodeInfoKHR & setPSetupReferenceSlot(
      const VULKAN_HPP_NAMESPACE::VideoReferenceSlotKHR * pSetupReferenceSlot_ ) VULKAN_HPP_NOEXCEPT
    {
      pSetupReferenceSlot = pSetupReferenceSlot_;
      return *this;
    }

    VideoEncodeInfoKHR & setReferenceSlotCount( uint32_t referenceSlotCount_ ) VULKAN_HPP_NOEXCEPT
    {
      referenceSlotCount = referenceSlotCount_;
      return *this;
    }

    VideoEncodeInfoKHR &
      setPReferenceSlots( const VULKAN_HPP_NAMESPACE::VideoReferenceSlotKHR * pReferenceSlots_ ) VULKAN_HPP_NOEXCEPT
    {
      pReferenceSlots = pReferenceSlots_;
      return *this;
    }

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    VideoEncodeInfoKHR & setReferenceSlots(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::VideoReferenceSlotKHR> const &
        referenceSlots_ ) VULKAN_HPP_NOEXCEPT
    {
      referenceSlotCount = static_cast<uint32_t>( referenceSlots_.size() );
      pReferenceSlots    = referenceSlots_.data();
      return *this;
    }
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkVideoEncodeInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkVideoEncodeInfoKHR *>( this );
    }

    operator VkVideoEncodeInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkVideoEncodeInfoKHR *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( VideoEncodeInfoKHR const & ) const = default;
#  else
    bool operator==( VideoEncodeInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( qualityLevel == rhs.qualityLevel ) && ( codedExtent == rhs.codedExtent ) &&
             ( dstBitstreamBuffer == rhs.dstBitstreamBuffer ) &&
             ( dstBitstreamBufferOffset == rhs.dstBitstreamBufferOffset ) &&
             ( dstBitstreamBufferMaxRange == rhs.dstBitstreamBufferMaxRange ) &&
             ( srcPictureResource == rhs.srcPictureResource ) && ( pSetupReferenceSlot == rhs.pSetupReferenceSlot ) &&
             ( referenceSlotCount == rhs.referenceSlotCount ) && ( pReferenceSlots == rhs.pReferenceSlots );
    }

    bool operator!=( VideoEncodeInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                 sType                      = StructureType::eVideoEncodeInfoKHR;
    const void *                                        pNext                      = {};
    VULKAN_HPP_NAMESPACE::VideoEncodeFlagsKHR           flags                      = {};
    uint32_t                                            qualityLevel               = {};
    VULKAN_HPP_NAMESPACE::Extent2D                      codedExtent                = {};
    VULKAN_HPP_NAMESPACE::Buffer                        dstBitstreamBuffer         = {};
    VULKAN_HPP_NAMESPACE::DeviceSize                    dstBitstreamBufferOffset   = {};
    VULKAN_HPP_NAMESPACE::DeviceSize                    dstBitstreamBufferMaxRange = {};
    VULKAN_HPP_NAMESPACE::VideoPictureResourceKHR       srcPictureResource         = {};
    const VULKAN_HPP_NAMESPACE::VideoReferenceSlotKHR * pSetupReferenceSlot        = {};
    uint32_t                                            referenceSlotCount         = {};
    const VULKAN_HPP_NAMESPACE::VideoReferenceSlotKHR * pReferenceSlots            = {};
  };
  static_assert( sizeof( VideoEncodeInfoKHR ) == sizeof( VkVideoEncodeInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<VideoEncodeInfoKHR>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eVideoEncodeInfoKHR>
  {
    using Type = VideoEncodeInfoKHR;
  };
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  struct VideoEncodeRateControlInfoKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eVideoEncodeRateControlInfoKHR;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      VideoEncodeRateControlInfoKHR( VULKAN_HPP_NAMESPACE::VideoEncodeRateControlFlagsKHR        flags_ = {},
                                     VULKAN_HPP_NAMESPACE::VideoEncodeRateControlModeFlagBitsKHR rateControlMode_ =
                                       VULKAN_HPP_NAMESPACE::VideoEncodeRateControlModeFlagBitsKHR::eNone,
                                     uint32_t averageBitrate_            = {},
                                     uint16_t peakToAverageBitrateRatio_ = {},
                                     uint16_t frameRateNumerator_        = {},
                                     uint16_t frameRateDenominator_      = {},
                                     uint32_t virtualBufferSizeInMs_     = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , rateControlMode( rateControlMode_ )
      , averageBitrate( averageBitrate_ )
      , peakToAverageBitrateRatio( peakToAverageBitrateRatio_ )
      , frameRateNumerator( frameRateNumerator_ )
      , frameRateDenominator( frameRateDenominator_ )
      , virtualBufferSizeInMs( virtualBufferSizeInMs_ )
    {}

    VULKAN_HPP_CONSTEXPR
      VideoEncodeRateControlInfoKHR( VideoEncodeRateControlInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoEncodeRateControlInfoKHR( VkVideoEncodeRateControlInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : VideoEncodeRateControlInfoKHR( *reinterpret_cast<VideoEncodeRateControlInfoKHR const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 VideoEncodeRateControlInfoKHR &
                            operator=( VideoEncodeRateControlInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoEncodeRateControlInfoKHR & operator=( VkVideoEncodeRateControlInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::VideoEncodeRateControlInfoKHR const *>( &rhs );
      return *this;
    }

    VideoEncodeRateControlInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    VideoEncodeRateControlInfoKHR &
      setFlags( VULKAN_HPP_NAMESPACE::VideoEncodeRateControlFlagsKHR flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    VideoEncodeRateControlInfoKHR & setRateControlMode(
      VULKAN_HPP_NAMESPACE::VideoEncodeRateControlModeFlagBitsKHR rateControlMode_ ) VULKAN_HPP_NOEXCEPT
    {
      rateControlMode = rateControlMode_;
      return *this;
    }

    VideoEncodeRateControlInfoKHR & setAverageBitrate( uint32_t averageBitrate_ ) VULKAN_HPP_NOEXCEPT
    {
      averageBitrate = averageBitrate_;
      return *this;
    }

    VideoEncodeRateControlInfoKHR &
      setPeakToAverageBitrateRatio( uint16_t peakToAverageBitrateRatio_ ) VULKAN_HPP_NOEXCEPT
    {
      peakToAverageBitrateRatio = peakToAverageBitrateRatio_;
      return *this;
    }

    VideoEncodeRateControlInfoKHR & setFrameRateNumerator( uint16_t frameRateNumerator_ ) VULKAN_HPP_NOEXCEPT
    {
      frameRateNumerator = frameRateNumerator_;
      return *this;
    }

    VideoEncodeRateControlInfoKHR & setFrameRateDenominator( uint16_t frameRateDenominator_ ) VULKAN_HPP_NOEXCEPT
    {
      frameRateDenominator = frameRateDenominator_;
      return *this;
    }

    VideoEncodeRateControlInfoKHR & setVirtualBufferSizeInMs( uint32_t virtualBufferSizeInMs_ ) VULKAN_HPP_NOEXCEPT
    {
      virtualBufferSizeInMs = virtualBufferSizeInMs_;
      return *this;
    }

    operator VkVideoEncodeRateControlInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkVideoEncodeRateControlInfoKHR *>( this );
    }

    operator VkVideoEncodeRateControlInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkVideoEncodeRateControlInfoKHR *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( VideoEncodeRateControlInfoKHR const & ) const = default;
#  else
    bool operator==( VideoEncodeRateControlInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( rateControlMode == rhs.rateControlMode ) && ( averageBitrate == rhs.averageBitrate ) &&
             ( peakToAverageBitrateRatio == rhs.peakToAverageBitrateRatio ) &&
             ( frameRateNumerator == rhs.frameRateNumerator ) && ( frameRateDenominator == rhs.frameRateDenominator ) &&
             ( virtualBufferSizeInMs == rhs.virtualBufferSizeInMs );
    }

    bool operator!=( VideoEncodeRateControlInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                         sType = StructureType::eVideoEncodeRateControlInfoKHR;
    const void *                                                pNext = {};
    VULKAN_HPP_NAMESPACE::VideoEncodeRateControlFlagsKHR        flags = {};
    VULKAN_HPP_NAMESPACE::VideoEncodeRateControlModeFlagBitsKHR rateControlMode =
      VULKAN_HPP_NAMESPACE::VideoEncodeRateControlModeFlagBitsKHR::eNone;
    uint32_t averageBitrate            = {};
    uint16_t peakToAverageBitrateRatio = {};
    uint16_t frameRateNumerator        = {};
    uint16_t frameRateDenominator      = {};
    uint32_t virtualBufferSizeInMs     = {};
  };
  static_assert( sizeof( VideoEncodeRateControlInfoKHR ) == sizeof( VkVideoEncodeRateControlInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<VideoEncodeRateControlInfoKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eVideoEncodeRateControlInfoKHR>
  {
    using Type = VideoEncodeRateControlInfoKHR;
  };
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  struct VideoEndCodingInfoKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eVideoEndCodingInfoKHR;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      VideoEndCodingInfoKHR( VULKAN_HPP_NAMESPACE::VideoEndCodingFlagsKHR flags_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
    {}

    VULKAN_HPP_CONSTEXPR VideoEndCodingInfoKHR( VideoEndCodingInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoEndCodingInfoKHR( VkVideoEndCodingInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : VideoEndCodingInfoKHR( *reinterpret_cast<VideoEndCodingInfoKHR const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 VideoEndCodingInfoKHR &
                            operator=( VideoEndCodingInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoEndCodingInfoKHR & operator=( VkVideoEndCodingInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::VideoEndCodingInfoKHR const *>( &rhs );
      return *this;
    }

    VideoEndCodingInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    VideoEndCodingInfoKHR & setFlags( VULKAN_HPP_NAMESPACE::VideoEndCodingFlagsKHR flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    operator VkVideoEndCodingInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkVideoEndCodingInfoKHR *>( this );
    }

    operator VkVideoEndCodingInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkVideoEndCodingInfoKHR *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( VideoEndCodingInfoKHR const & ) const = default;
#  else
    bool operator==( VideoEndCodingInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags );
    }

    bool operator!=( VideoEndCodingInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType          sType = StructureType::eVideoEndCodingInfoKHR;
    const void *                                 pNext = {};
    VULKAN_HPP_NAMESPACE::VideoEndCodingFlagsKHR flags = {};
  };
  static_assert( sizeof( VideoEndCodingInfoKHR ) == sizeof( VkVideoEndCodingInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<VideoEndCodingInfoKHR>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eVideoEndCodingInfoKHR>
  {
    using Type = VideoEndCodingInfoKHR;
  };
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  struct VideoFormatPropertiesKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eVideoFormatPropertiesKHR;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR VideoFormatPropertiesKHR(
      VULKAN_HPP_NAMESPACE::Format format_ = VULKAN_HPP_NAMESPACE::Format::eUndefined ) VULKAN_HPP_NOEXCEPT
      : format( format_ )
    {}

    VULKAN_HPP_CONSTEXPR VideoFormatPropertiesKHR( VideoFormatPropertiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoFormatPropertiesKHR( VkVideoFormatPropertiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : VideoFormatPropertiesKHR( *reinterpret_cast<VideoFormatPropertiesKHR const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 VideoFormatPropertiesKHR &
                            operator=( VideoFormatPropertiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoFormatPropertiesKHR & operator=( VkVideoFormatPropertiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::VideoFormatPropertiesKHR const *>( &rhs );
      return *this;
    }

    operator VkVideoFormatPropertiesKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkVideoFormatPropertiesKHR *>( this );
    }

    operator VkVideoFormatPropertiesKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkVideoFormatPropertiesKHR *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( VideoFormatPropertiesKHR const & ) const = default;
#  else
    bool operator==( VideoFormatPropertiesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( format == rhs.format );
    }

    bool operator!=( VideoFormatPropertiesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType  = StructureType::eVideoFormatPropertiesKHR;
    void *                              pNext  = {};
    VULKAN_HPP_NAMESPACE::Format        format = VULKAN_HPP_NAMESPACE::Format::eUndefined;
  };
  static_assert( sizeof( VideoFormatPropertiesKHR ) == sizeof( VkVideoFormatPropertiesKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<VideoFormatPropertiesKHR>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eVideoFormatPropertiesKHR>
  {
    using Type = VideoFormatPropertiesKHR;
  };
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  struct VideoGetMemoryPropertiesKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eVideoGetMemoryPropertiesKHR;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR VideoGetMemoryPropertiesKHR(
      uint32_t                                    memoryBindIndex_     = {},
      VULKAN_HPP_NAMESPACE::MemoryRequirements2 * pMemoryRequirements_ = {} ) VULKAN_HPP_NOEXCEPT
      : memoryBindIndex( memoryBindIndex_ )
      , pMemoryRequirements( pMemoryRequirements_ )
    {}

    VULKAN_HPP_CONSTEXPR
      VideoGetMemoryPropertiesKHR( VideoGetMemoryPropertiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoGetMemoryPropertiesKHR( VkVideoGetMemoryPropertiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : VideoGetMemoryPropertiesKHR( *reinterpret_cast<VideoGetMemoryPropertiesKHR const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 VideoGetMemoryPropertiesKHR &
                            operator=( VideoGetMemoryPropertiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoGetMemoryPropertiesKHR & operator=( VkVideoGetMemoryPropertiesKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::VideoGetMemoryPropertiesKHR const *>( &rhs );
      return *this;
    }

    VideoGetMemoryPropertiesKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    VideoGetMemoryPropertiesKHR & setMemoryBindIndex( uint32_t memoryBindIndex_ ) VULKAN_HPP_NOEXCEPT
    {
      memoryBindIndex = memoryBindIndex_;
      return *this;
    }

    VideoGetMemoryPropertiesKHR &
      setPMemoryRequirements( VULKAN_HPP_NAMESPACE::MemoryRequirements2 * pMemoryRequirements_ ) VULKAN_HPP_NOEXCEPT
    {
      pMemoryRequirements = pMemoryRequirements_;
      return *this;
    }

    operator VkVideoGetMemoryPropertiesKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkVideoGetMemoryPropertiesKHR *>( this );
    }

    operator VkVideoGetMemoryPropertiesKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkVideoGetMemoryPropertiesKHR *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( VideoGetMemoryPropertiesKHR const & ) const = default;
#  else
    bool operator==( VideoGetMemoryPropertiesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( memoryBindIndex == rhs.memoryBindIndex ) &&
             ( pMemoryRequirements == rhs.pMemoryRequirements );
    }

    bool operator!=( VideoGetMemoryPropertiesKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType         sType               = StructureType::eVideoGetMemoryPropertiesKHR;
    const void *                                pNext               = {};
    uint32_t                                    memoryBindIndex     = {};
    VULKAN_HPP_NAMESPACE::MemoryRequirements2 * pMemoryRequirements = {};
  };
  static_assert( sizeof( VideoGetMemoryPropertiesKHR ) == sizeof( VkVideoGetMemoryPropertiesKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<VideoGetMemoryPropertiesKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eVideoGetMemoryPropertiesKHR>
  {
    using Type = VideoGetMemoryPropertiesKHR;
  };
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  struct VideoQueueFamilyProperties2KHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eVideoQueueFamilyProperties2KHR;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR VideoQueueFamilyProperties2KHR(
      VULKAN_HPP_NAMESPACE::VideoCodecOperationFlagsKHR videoCodecOperations_ = {} ) VULKAN_HPP_NOEXCEPT
      : videoCodecOperations( videoCodecOperations_ )
    {}

    VULKAN_HPP_CONSTEXPR
      VideoQueueFamilyProperties2KHR( VideoQueueFamilyProperties2KHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoQueueFamilyProperties2KHR( VkVideoQueueFamilyProperties2KHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : VideoQueueFamilyProperties2KHR( *reinterpret_cast<VideoQueueFamilyProperties2KHR const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 VideoQueueFamilyProperties2KHR &
                            operator=( VideoQueueFamilyProperties2KHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoQueueFamilyProperties2KHR & operator=( VkVideoQueueFamilyProperties2KHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::VideoQueueFamilyProperties2KHR const *>( &rhs );
      return *this;
    }

    VideoQueueFamilyProperties2KHR & setPNext( void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    VideoQueueFamilyProperties2KHR & setVideoCodecOperations(
      VULKAN_HPP_NAMESPACE::VideoCodecOperationFlagsKHR videoCodecOperations_ ) VULKAN_HPP_NOEXCEPT
    {
      videoCodecOperations = videoCodecOperations_;
      return *this;
    }

    operator VkVideoQueueFamilyProperties2KHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkVideoQueueFamilyProperties2KHR *>( this );
    }

    operator VkVideoQueueFamilyProperties2KHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkVideoQueueFamilyProperties2KHR *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( VideoQueueFamilyProperties2KHR const & ) const = default;
#  else
    bool operator==( VideoQueueFamilyProperties2KHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( videoCodecOperations == rhs.videoCodecOperations );
    }

    bool operator!=( VideoQueueFamilyProperties2KHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType               sType = StructureType::eVideoQueueFamilyProperties2KHR;
    void *                                            pNext = {};
    VULKAN_HPP_NAMESPACE::VideoCodecOperationFlagsKHR videoCodecOperations = {};
  };
  static_assert( sizeof( VideoQueueFamilyProperties2KHR ) == sizeof( VkVideoQueueFamilyProperties2KHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<VideoQueueFamilyProperties2KHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eVideoQueueFamilyProperties2KHR>
  {
    using Type = VideoQueueFamilyProperties2KHR;
  };
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  struct VideoSessionCreateInfoKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eVideoSessionCreateInfoKHR;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR VideoSessionCreateInfoKHR(
      uint32_t                                         queueFamilyIndex_ = {},
      VULKAN_HPP_NAMESPACE::VideoSessionCreateFlagsKHR flags_            = {},
      const VULKAN_HPP_NAMESPACE::VideoProfileKHR *    pVideoProfile_    = {},
      VULKAN_HPP_NAMESPACE::Format                     pictureFormat_    = VULKAN_HPP_NAMESPACE::Format::eUndefined,
      VULKAN_HPP_NAMESPACE::Extent2D                   maxCodedExtent_   = {},
      VULKAN_HPP_NAMESPACE::Format referencePicturesFormat_              = VULKAN_HPP_NAMESPACE::Format::eUndefined,
      uint32_t                     maxReferencePicturesSlotsCount_       = {},
      uint32_t                     maxReferencePicturesActiveCount_      = {} ) VULKAN_HPP_NOEXCEPT
      : queueFamilyIndex( queueFamilyIndex_ )
      , flags( flags_ )
      , pVideoProfile( pVideoProfile_ )
      , pictureFormat( pictureFormat_ )
      , maxCodedExtent( maxCodedExtent_ )
      , referencePicturesFormat( referencePicturesFormat_ )
      , maxReferencePicturesSlotsCount( maxReferencePicturesSlotsCount_ )
      , maxReferencePicturesActiveCount( maxReferencePicturesActiveCount_ )
    {}

    VULKAN_HPP_CONSTEXPR
      VideoSessionCreateInfoKHR( VideoSessionCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoSessionCreateInfoKHR( VkVideoSessionCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : VideoSessionCreateInfoKHR( *reinterpret_cast<VideoSessionCreateInfoKHR const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 VideoSessionCreateInfoKHR &
                            operator=( VideoSessionCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoSessionCreateInfoKHR & operator=( VkVideoSessionCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::VideoSessionCreateInfoKHR const *>( &rhs );
      return *this;
    }

    VideoSessionCreateInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    VideoSessionCreateInfoKHR & setQueueFamilyIndex( uint32_t queueFamilyIndex_ ) VULKAN_HPP_NOEXCEPT
    {
      queueFamilyIndex = queueFamilyIndex_;
      return *this;
    }

    VideoSessionCreateInfoKHR & setFlags( VULKAN_HPP_NAMESPACE::VideoSessionCreateFlagsKHR flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    VideoSessionCreateInfoKHR &
      setPVideoProfile( const VULKAN_HPP_NAMESPACE::VideoProfileKHR * pVideoProfile_ ) VULKAN_HPP_NOEXCEPT
    {
      pVideoProfile = pVideoProfile_;
      return *this;
    }

    VideoSessionCreateInfoKHR & setPictureFormat( VULKAN_HPP_NAMESPACE::Format pictureFormat_ ) VULKAN_HPP_NOEXCEPT
    {
      pictureFormat = pictureFormat_;
      return *this;
    }

    VideoSessionCreateInfoKHR &
      setMaxCodedExtent( VULKAN_HPP_NAMESPACE::Extent2D const & maxCodedExtent_ ) VULKAN_HPP_NOEXCEPT
    {
      maxCodedExtent = maxCodedExtent_;
      return *this;
    }

    VideoSessionCreateInfoKHR &
      setReferencePicturesFormat( VULKAN_HPP_NAMESPACE::Format referencePicturesFormat_ ) VULKAN_HPP_NOEXCEPT
    {
      referencePicturesFormat = referencePicturesFormat_;
      return *this;
    }

    VideoSessionCreateInfoKHR &
      setMaxReferencePicturesSlotsCount( uint32_t maxReferencePicturesSlotsCount_ ) VULKAN_HPP_NOEXCEPT
    {
      maxReferencePicturesSlotsCount = maxReferencePicturesSlotsCount_;
      return *this;
    }

    VideoSessionCreateInfoKHR &
      setMaxReferencePicturesActiveCount( uint32_t maxReferencePicturesActiveCount_ ) VULKAN_HPP_NOEXCEPT
    {
      maxReferencePicturesActiveCount = maxReferencePicturesActiveCount_;
      return *this;
    }

    operator VkVideoSessionCreateInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkVideoSessionCreateInfoKHR *>( this );
    }

    operator VkVideoSessionCreateInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkVideoSessionCreateInfoKHR *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( VideoSessionCreateInfoKHR const & ) const = default;
#  else
    bool operator==( VideoSessionCreateInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( queueFamilyIndex == rhs.queueFamilyIndex ) &&
             ( flags == rhs.flags ) && ( pVideoProfile == rhs.pVideoProfile ) &&
             ( pictureFormat == rhs.pictureFormat ) && ( maxCodedExtent == rhs.maxCodedExtent ) &&
             ( referencePicturesFormat == rhs.referencePicturesFormat ) &&
             ( maxReferencePicturesSlotsCount == rhs.maxReferencePicturesSlotsCount ) &&
             ( maxReferencePicturesActiveCount == rhs.maxReferencePicturesActiveCount );
    }

    bool operator!=( VideoSessionCreateInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType              sType            = StructureType::eVideoSessionCreateInfoKHR;
    const void *                                     pNext            = {};
    uint32_t                                         queueFamilyIndex = {};
    VULKAN_HPP_NAMESPACE::VideoSessionCreateFlagsKHR flags            = {};
    const VULKAN_HPP_NAMESPACE::VideoProfileKHR *    pVideoProfile    = {};
    VULKAN_HPP_NAMESPACE::Format                     pictureFormat    = VULKAN_HPP_NAMESPACE::Format::eUndefined;
    VULKAN_HPP_NAMESPACE::Extent2D                   maxCodedExtent   = {};
    VULKAN_HPP_NAMESPACE::Format                     referencePicturesFormat = VULKAN_HPP_NAMESPACE::Format::eUndefined;
    uint32_t                                         maxReferencePicturesSlotsCount  = {};
    uint32_t                                         maxReferencePicturesActiveCount = {};
  };
  static_assert( sizeof( VideoSessionCreateInfoKHR ) == sizeof( VkVideoSessionCreateInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<VideoSessionCreateInfoKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eVideoSessionCreateInfoKHR>
  {
    using Type = VideoSessionCreateInfoKHR;
  };
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  struct VideoSessionParametersCreateInfoKHR
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eVideoSessionParametersCreateInfoKHR;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR VideoSessionParametersCreateInfoKHR(
      VULKAN_HPP_NAMESPACE::VideoSessionParametersKHR videoSessionParametersTemplate_ = {},
      VULKAN_HPP_NAMESPACE::VideoSessionKHR           videoSession_                   = {} ) VULKAN_HPP_NOEXCEPT
      : videoSessionParametersTemplate( videoSessionParametersTemplate_ )
      , videoSession( videoSession_ )
    {}

    VULKAN_HPP_CONSTEXPR VideoSessionParametersCreateInfoKHR( VideoSessionParametersCreateInfoKHR const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    VideoSessionParametersCreateInfoKHR( VkVideoSessionParametersCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : VideoSessionParametersCreateInfoKHR( *reinterpret_cast<VideoSessionParametersCreateInfoKHR const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 VideoSessionParametersCreateInfoKHR &
                            operator=( VideoSessionParametersCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoSessionParametersCreateInfoKHR &
      operator=( VkVideoSessionParametersCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::VideoSessionParametersCreateInfoKHR const *>( &rhs );
      return *this;
    }

    VideoSessionParametersCreateInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    VideoSessionParametersCreateInfoKHR & setVideoSessionParametersTemplate(
      VULKAN_HPP_NAMESPACE::VideoSessionParametersKHR videoSessionParametersTemplate_ ) VULKAN_HPP_NOEXCEPT
    {
      videoSessionParametersTemplate = videoSessionParametersTemplate_;
      return *this;
    }

    VideoSessionParametersCreateInfoKHR &
      setVideoSession( VULKAN_HPP_NAMESPACE::VideoSessionKHR videoSession_ ) VULKAN_HPP_NOEXCEPT
    {
      videoSession = videoSession_;
      return *this;
    }

    operator VkVideoSessionParametersCreateInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkVideoSessionParametersCreateInfoKHR *>( this );
    }

    operator VkVideoSessionParametersCreateInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkVideoSessionParametersCreateInfoKHR *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( VideoSessionParametersCreateInfoKHR const & ) const = default;
#  else
    bool operator==( VideoSessionParametersCreateInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( videoSessionParametersTemplate == rhs.videoSessionParametersTemplate ) &&
             ( videoSession == rhs.videoSession );
    }

    bool operator!=( VideoSessionParametersCreateInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType             sType = StructureType::eVideoSessionParametersCreateInfoKHR;
    const void *                                    pNext = {};
    VULKAN_HPP_NAMESPACE::VideoSessionParametersKHR videoSessionParametersTemplate = {};
    VULKAN_HPP_NAMESPACE::VideoSessionKHR           videoSession                   = {};
  };
  static_assert( sizeof( VideoSessionParametersCreateInfoKHR ) == sizeof( VkVideoSessionParametersCreateInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<VideoSessionParametersCreateInfoKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eVideoSessionParametersCreateInfoKHR>
  {
    using Type = VideoSessionParametersCreateInfoKHR;
  };
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  struct VideoSessionParametersUpdateInfoKHR
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eVideoSessionParametersUpdateInfoKHR;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR VideoSessionParametersUpdateInfoKHR( uint32_t updateSequenceCount_ = {} ) VULKAN_HPP_NOEXCEPT
      : updateSequenceCount( updateSequenceCount_ )
    {}

    VULKAN_HPP_CONSTEXPR VideoSessionParametersUpdateInfoKHR( VideoSessionParametersUpdateInfoKHR const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    VideoSessionParametersUpdateInfoKHR( VkVideoSessionParametersUpdateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : VideoSessionParametersUpdateInfoKHR( *reinterpret_cast<VideoSessionParametersUpdateInfoKHR const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 VideoSessionParametersUpdateInfoKHR &
                            operator=( VideoSessionParametersUpdateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    VideoSessionParametersUpdateInfoKHR &
      operator=( VkVideoSessionParametersUpdateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::VideoSessionParametersUpdateInfoKHR const *>( &rhs );
      return *this;
    }

    VideoSessionParametersUpdateInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    VideoSessionParametersUpdateInfoKHR & setUpdateSequenceCount( uint32_t updateSequenceCount_ ) VULKAN_HPP_NOEXCEPT
    {
      updateSequenceCount = updateSequenceCount_;
      return *this;
    }

    operator VkVideoSessionParametersUpdateInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkVideoSessionParametersUpdateInfoKHR *>( this );
    }

    operator VkVideoSessionParametersUpdateInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkVideoSessionParametersUpdateInfoKHR *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( VideoSessionParametersUpdateInfoKHR const & ) const = default;
#  else
    bool operator==( VideoSessionParametersUpdateInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( updateSequenceCount == rhs.updateSequenceCount );
    }

    bool operator!=( VideoSessionParametersUpdateInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType               = StructureType::eVideoSessionParametersUpdateInfoKHR;
    const void *                        pNext               = {};
    uint32_t                            updateSequenceCount = {};
  };
  static_assert( sizeof( VideoSessionParametersUpdateInfoKHR ) == sizeof( VkVideoSessionParametersUpdateInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<VideoSessionParametersUpdateInfoKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eVideoSessionParametersUpdateInfoKHR>
  {
    using Type = VideoSessionParametersUpdateInfoKHR;
  };
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

#if defined( VK_USE_PLATFORM_WAYLAND_KHR )
  struct WaylandSurfaceCreateInfoKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eWaylandSurfaceCreateInfoKHR;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR WaylandSurfaceCreateInfoKHR( VULKAN_HPP_NAMESPACE::WaylandSurfaceCreateFlagsKHR flags_   = {},
                                                      struct wl_display *                                display_ = {},
                                                      struct wl_surface * surface_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , display( display_ )
      , surface( surface_ )
    {}

    VULKAN_HPP_CONSTEXPR
      WaylandSurfaceCreateInfoKHR( WaylandSurfaceCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    WaylandSurfaceCreateInfoKHR( VkWaylandSurfaceCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : WaylandSurfaceCreateInfoKHR( *reinterpret_cast<WaylandSurfaceCreateInfoKHR const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 WaylandSurfaceCreateInfoKHR &
                            operator=( WaylandSurfaceCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    WaylandSurfaceCreateInfoKHR & operator=( VkWaylandSurfaceCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::WaylandSurfaceCreateInfoKHR const *>( &rhs );
      return *this;
    }

    WaylandSurfaceCreateInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    WaylandSurfaceCreateInfoKHR &
      setFlags( VULKAN_HPP_NAMESPACE::WaylandSurfaceCreateFlagsKHR flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    WaylandSurfaceCreateInfoKHR & setDisplay( struct wl_display * display_ ) VULKAN_HPP_NOEXCEPT
    {
      display = display_;
      return *this;
    }

    WaylandSurfaceCreateInfoKHR & setSurface( struct wl_surface * surface_ ) VULKAN_HPP_NOEXCEPT
    {
      surface = surface_;
      return *this;
    }

    operator VkWaylandSurfaceCreateInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkWaylandSurfaceCreateInfoKHR *>( this );
    }

    operator VkWaylandSurfaceCreateInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkWaylandSurfaceCreateInfoKHR *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( WaylandSurfaceCreateInfoKHR const & ) const = default;
#  else
    bool operator==( WaylandSurfaceCreateInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) && ( display == rhs.display ) &&
             ( surface == rhs.surface );
    }

    bool operator!=( WaylandSurfaceCreateInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                sType   = StructureType::eWaylandSurfaceCreateInfoKHR;
    const void *                                       pNext   = {};
    VULKAN_HPP_NAMESPACE::WaylandSurfaceCreateFlagsKHR flags   = {};
    struct wl_display *                                display = {};
    struct wl_surface *                                surface = {};
  };
  static_assert( sizeof( WaylandSurfaceCreateInfoKHR ) == sizeof( VkWaylandSurfaceCreateInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<WaylandSurfaceCreateInfoKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eWaylandSurfaceCreateInfoKHR>
  {
    using Type = WaylandSurfaceCreateInfoKHR;
  };
#endif /*VK_USE_PLATFORM_WAYLAND_KHR*/

#if defined( VK_USE_PLATFORM_WIN32_KHR )
  struct Win32KeyedMutexAcquireReleaseInfoKHR
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eWin32KeyedMutexAcquireReleaseInfoKHR;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      Win32KeyedMutexAcquireReleaseInfoKHR( uint32_t                                   acquireCount_     = {},
                                            const VULKAN_HPP_NAMESPACE::DeviceMemory * pAcquireSyncs_    = {},
                                            const uint64_t *                           pAcquireKeys_     = {},
                                            const uint32_t *                           pAcquireTimeouts_ = {},
                                            uint32_t                                   releaseCount_     = {},
                                            const VULKAN_HPP_NAMESPACE::DeviceMemory * pReleaseSyncs_    = {},
                                            const uint64_t * pReleaseKeys_ = {} ) VULKAN_HPP_NOEXCEPT
      : acquireCount( acquireCount_ )
      , pAcquireSyncs( pAcquireSyncs_ )
      , pAcquireKeys( pAcquireKeys_ )
      , pAcquireTimeouts( pAcquireTimeouts_ )
      , releaseCount( releaseCount_ )
      , pReleaseSyncs( pReleaseSyncs_ )
      , pReleaseKeys( pReleaseKeys_ )
    {}

    VULKAN_HPP_CONSTEXPR Win32KeyedMutexAcquireReleaseInfoKHR( Win32KeyedMutexAcquireReleaseInfoKHR const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    Win32KeyedMutexAcquireReleaseInfoKHR( VkWin32KeyedMutexAcquireReleaseInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : Win32KeyedMutexAcquireReleaseInfoKHR( *reinterpret_cast<Win32KeyedMutexAcquireReleaseInfoKHR const *>( &rhs ) )
    {}

#    if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    Win32KeyedMutexAcquireReleaseInfoKHR(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::DeviceMemory> const & acquireSyncs_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint64_t> const &                           acquireKeys_ = {},
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const & acquireTimeouts_                       = {},
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::DeviceMemory> const &
                                                                            releaseSyncs_ = {},
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint64_t> const & releaseKeys_  = {} )
      : acquireCount( static_cast<uint32_t>( acquireSyncs_.size() ) )
      , pAcquireSyncs( acquireSyncs_.data() )
      , pAcquireKeys( acquireKeys_.data() )
      , pAcquireTimeouts( acquireTimeouts_.data() )
      , releaseCount( static_cast<uint32_t>( releaseSyncs_.size() ) )
      , pReleaseSyncs( releaseSyncs_.data() )
      , pReleaseKeys( releaseKeys_.data() )
    {
#      ifdef VULKAN_HPP_NO_EXCEPTIONS
      VULKAN_HPP_ASSERT( acquireSyncs_.size() == acquireKeys_.size() );
      VULKAN_HPP_ASSERT( acquireSyncs_.size() == acquireTimeouts_.size() );
      VULKAN_HPP_ASSERT( acquireKeys_.size() == acquireTimeouts_.size() );
#      else
      if ( acquireSyncs_.size() != acquireKeys_.size() )
      {
        throw LogicError(
          VULKAN_HPP_NAMESPACE_STRING
          "::Win32KeyedMutexAcquireReleaseInfoKHR::Win32KeyedMutexAcquireReleaseInfoKHR: acquireSyncs_.size() != acquireKeys_.size()" );
      }
      if ( acquireSyncs_.size() != acquireTimeouts_.size() )
      {
        throw LogicError(
          VULKAN_HPP_NAMESPACE_STRING
          "::Win32KeyedMutexAcquireReleaseInfoKHR::Win32KeyedMutexAcquireReleaseInfoKHR: acquireSyncs_.size() != acquireTimeouts_.size()" );
      }
      if ( acquireKeys_.size() != acquireTimeouts_.size() )
      {
        throw LogicError(
          VULKAN_HPP_NAMESPACE_STRING
          "::Win32KeyedMutexAcquireReleaseInfoKHR::Win32KeyedMutexAcquireReleaseInfoKHR: acquireKeys_.size() != acquireTimeouts_.size()" );
      }
#      endif /*VULKAN_HPP_NO_EXCEPTIONS*/

#      ifdef VULKAN_HPP_NO_EXCEPTIONS
      VULKAN_HPP_ASSERT( releaseSyncs_.size() == releaseKeys_.size() );
#      else
      if ( releaseSyncs_.size() != releaseKeys_.size() )
      {
        throw LogicError(
          VULKAN_HPP_NAMESPACE_STRING
          "::Win32KeyedMutexAcquireReleaseInfoKHR::Win32KeyedMutexAcquireReleaseInfoKHR: releaseSyncs_.size() != releaseKeys_.size()" );
      }
#      endif /*VULKAN_HPP_NO_EXCEPTIONS*/
    }
#    endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#  endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 Win32KeyedMutexAcquireReleaseInfoKHR &
                            operator=( Win32KeyedMutexAcquireReleaseInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    Win32KeyedMutexAcquireReleaseInfoKHR &
      operator=( VkWin32KeyedMutexAcquireReleaseInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::Win32KeyedMutexAcquireReleaseInfoKHR const *>( &rhs );
      return *this;
    }

    Win32KeyedMutexAcquireReleaseInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    Win32KeyedMutexAcquireReleaseInfoKHR & setAcquireCount( uint32_t acquireCount_ ) VULKAN_HPP_NOEXCEPT
    {
      acquireCount = acquireCount_;
      return *this;
    }

    Win32KeyedMutexAcquireReleaseInfoKHR &
      setPAcquireSyncs( const VULKAN_HPP_NAMESPACE::DeviceMemory * pAcquireSyncs_ ) VULKAN_HPP_NOEXCEPT
    {
      pAcquireSyncs = pAcquireSyncs_;
      return *this;
    }

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    Win32KeyedMutexAcquireReleaseInfoKHR & setAcquireSyncs(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::DeviceMemory> const & acquireSyncs_ )
      VULKAN_HPP_NOEXCEPT
    {
      acquireCount  = static_cast<uint32_t>( acquireSyncs_.size() );
      pAcquireSyncs = acquireSyncs_.data();
      return *this;
    }
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    Win32KeyedMutexAcquireReleaseInfoKHR & setPAcquireKeys( const uint64_t * pAcquireKeys_ ) VULKAN_HPP_NOEXCEPT
    {
      pAcquireKeys = pAcquireKeys_;
      return *this;
    }

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    Win32KeyedMutexAcquireReleaseInfoKHR & setAcquireKeys(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint64_t> const & acquireKeys_ ) VULKAN_HPP_NOEXCEPT
    {
      acquireCount = static_cast<uint32_t>( acquireKeys_.size() );
      pAcquireKeys = acquireKeys_.data();
      return *this;
    }
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    Win32KeyedMutexAcquireReleaseInfoKHR & setPAcquireTimeouts( const uint32_t * pAcquireTimeouts_ ) VULKAN_HPP_NOEXCEPT
    {
      pAcquireTimeouts = pAcquireTimeouts_;
      return *this;
    }

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    Win32KeyedMutexAcquireReleaseInfoKHR & setAcquireTimeouts(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const & acquireTimeouts_ ) VULKAN_HPP_NOEXCEPT
    {
      acquireCount     = static_cast<uint32_t>( acquireTimeouts_.size() );
      pAcquireTimeouts = acquireTimeouts_.data();
      return *this;
    }
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    Win32KeyedMutexAcquireReleaseInfoKHR & setReleaseCount( uint32_t releaseCount_ ) VULKAN_HPP_NOEXCEPT
    {
      releaseCount = releaseCount_;
      return *this;
    }

    Win32KeyedMutexAcquireReleaseInfoKHR &
      setPReleaseSyncs( const VULKAN_HPP_NAMESPACE::DeviceMemory * pReleaseSyncs_ ) VULKAN_HPP_NOEXCEPT
    {
      pReleaseSyncs = pReleaseSyncs_;
      return *this;
    }

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    Win32KeyedMutexAcquireReleaseInfoKHR & setReleaseSyncs(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::DeviceMemory> const & releaseSyncs_ )
      VULKAN_HPP_NOEXCEPT
    {
      releaseCount  = static_cast<uint32_t>( releaseSyncs_.size() );
      pReleaseSyncs = releaseSyncs_.data();
      return *this;
    }
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    Win32KeyedMutexAcquireReleaseInfoKHR & setPReleaseKeys( const uint64_t * pReleaseKeys_ ) VULKAN_HPP_NOEXCEPT
    {
      pReleaseKeys = pReleaseKeys_;
      return *this;
    }

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    Win32KeyedMutexAcquireReleaseInfoKHR & setReleaseKeys(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint64_t> const & releaseKeys_ ) VULKAN_HPP_NOEXCEPT
    {
      releaseCount = static_cast<uint32_t>( releaseKeys_.size() );
      pReleaseKeys = releaseKeys_.data();
      return *this;
    }
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkWin32KeyedMutexAcquireReleaseInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkWin32KeyedMutexAcquireReleaseInfoKHR *>( this );
    }

    operator VkWin32KeyedMutexAcquireReleaseInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkWin32KeyedMutexAcquireReleaseInfoKHR *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( Win32KeyedMutexAcquireReleaseInfoKHR const & ) const = default;
#  else
    bool operator==( Win32KeyedMutexAcquireReleaseInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( acquireCount == rhs.acquireCount ) &&
             ( pAcquireSyncs == rhs.pAcquireSyncs ) && ( pAcquireKeys == rhs.pAcquireKeys ) &&
             ( pAcquireTimeouts == rhs.pAcquireTimeouts ) && ( releaseCount == rhs.releaseCount ) &&
             ( pReleaseSyncs == rhs.pReleaseSyncs ) && ( pReleaseKeys == rhs.pReleaseKeys );
    }

    bool operator!=( Win32KeyedMutexAcquireReleaseInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType        sType            = StructureType::eWin32KeyedMutexAcquireReleaseInfoKHR;
    const void *                               pNext            = {};
    uint32_t                                   acquireCount     = {};
    const VULKAN_HPP_NAMESPACE::DeviceMemory * pAcquireSyncs    = {};
    const uint64_t *                           pAcquireKeys     = {};
    const uint32_t *                           pAcquireTimeouts = {};
    uint32_t                                   releaseCount     = {};
    const VULKAN_HPP_NAMESPACE::DeviceMemory * pReleaseSyncs    = {};
    const uint64_t *                           pReleaseKeys     = {};
  };
  static_assert( sizeof( Win32KeyedMutexAcquireReleaseInfoKHR ) == sizeof( VkWin32KeyedMutexAcquireReleaseInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<Win32KeyedMutexAcquireReleaseInfoKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eWin32KeyedMutexAcquireReleaseInfoKHR>
  {
    using Type = Win32KeyedMutexAcquireReleaseInfoKHR;
  };
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

#if defined( VK_USE_PLATFORM_WIN32_KHR )
  struct Win32KeyedMutexAcquireReleaseInfoNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eWin32KeyedMutexAcquireReleaseInfoNV;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR
      Win32KeyedMutexAcquireReleaseInfoNV( uint32_t                                   acquireCount_                = {},
                                           const VULKAN_HPP_NAMESPACE::DeviceMemory * pAcquireSyncs_               = {},
                                           const uint64_t *                           pAcquireKeys_                = {},
                                           const uint32_t *                           pAcquireTimeoutMilliseconds_ = {},
                                           uint32_t                                   releaseCount_                = {},
                                           const VULKAN_HPP_NAMESPACE::DeviceMemory * pReleaseSyncs_               = {},
                                           const uint64_t * pReleaseKeys_ = {} ) VULKAN_HPP_NOEXCEPT
      : acquireCount( acquireCount_ )
      , pAcquireSyncs( pAcquireSyncs_ )
      , pAcquireKeys( pAcquireKeys_ )
      , pAcquireTimeoutMilliseconds( pAcquireTimeoutMilliseconds_ )
      , releaseCount( releaseCount_ )
      , pReleaseSyncs( pReleaseSyncs_ )
      , pReleaseKeys( pReleaseKeys_ )
    {}

    VULKAN_HPP_CONSTEXPR Win32KeyedMutexAcquireReleaseInfoNV( Win32KeyedMutexAcquireReleaseInfoNV const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    Win32KeyedMutexAcquireReleaseInfoNV( VkWin32KeyedMutexAcquireReleaseInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
      : Win32KeyedMutexAcquireReleaseInfoNV( *reinterpret_cast<Win32KeyedMutexAcquireReleaseInfoNV const *>( &rhs ) )
    {}

#    if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    Win32KeyedMutexAcquireReleaseInfoNV(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::DeviceMemory> const & acquireSyncs_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint64_t> const &                           acquireKeys_ = {},
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const & acquireTimeoutMilliseconds_            = {},
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::DeviceMemory> const &
                                                                            releaseSyncs_ = {},
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint64_t> const & releaseKeys_  = {} )
      : acquireCount( static_cast<uint32_t>( acquireSyncs_.size() ) )
      , pAcquireSyncs( acquireSyncs_.data() )
      , pAcquireKeys( acquireKeys_.data() )
      , pAcquireTimeoutMilliseconds( acquireTimeoutMilliseconds_.data() )
      , releaseCount( static_cast<uint32_t>( releaseSyncs_.size() ) )
      , pReleaseSyncs( releaseSyncs_.data() )
      , pReleaseKeys( releaseKeys_.data() )
    {
#      ifdef VULKAN_HPP_NO_EXCEPTIONS
      VULKAN_HPP_ASSERT( acquireSyncs_.size() == acquireKeys_.size() );
      VULKAN_HPP_ASSERT( acquireSyncs_.size() == acquireTimeoutMilliseconds_.size() );
      VULKAN_HPP_ASSERT( acquireKeys_.size() == acquireTimeoutMilliseconds_.size() );
#      else
      if ( acquireSyncs_.size() != acquireKeys_.size() )
      {
        throw LogicError(
          VULKAN_HPP_NAMESPACE_STRING
          "::Win32KeyedMutexAcquireReleaseInfoNV::Win32KeyedMutexAcquireReleaseInfoNV: acquireSyncs_.size() != acquireKeys_.size()" );
      }
      if ( acquireSyncs_.size() != acquireTimeoutMilliseconds_.size() )
      {
        throw LogicError(
          VULKAN_HPP_NAMESPACE_STRING
          "::Win32KeyedMutexAcquireReleaseInfoNV::Win32KeyedMutexAcquireReleaseInfoNV: acquireSyncs_.size() != acquireTimeoutMilliseconds_.size()" );
      }
      if ( acquireKeys_.size() != acquireTimeoutMilliseconds_.size() )
      {
        throw LogicError(
          VULKAN_HPP_NAMESPACE_STRING
          "::Win32KeyedMutexAcquireReleaseInfoNV::Win32KeyedMutexAcquireReleaseInfoNV: acquireKeys_.size() != acquireTimeoutMilliseconds_.size()" );
      }
#      endif /*VULKAN_HPP_NO_EXCEPTIONS*/

#      ifdef VULKAN_HPP_NO_EXCEPTIONS
      VULKAN_HPP_ASSERT( releaseSyncs_.size() == releaseKeys_.size() );
#      else
      if ( releaseSyncs_.size() != releaseKeys_.size() )
      {
        throw LogicError(
          VULKAN_HPP_NAMESPACE_STRING
          "::Win32KeyedMutexAcquireReleaseInfoNV::Win32KeyedMutexAcquireReleaseInfoNV: releaseSyncs_.size() != releaseKeys_.size()" );
      }
#      endif /*VULKAN_HPP_NO_EXCEPTIONS*/
    }
#    endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#  endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 Win32KeyedMutexAcquireReleaseInfoNV &
                            operator=( Win32KeyedMutexAcquireReleaseInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    Win32KeyedMutexAcquireReleaseInfoNV &
      operator=( VkWin32KeyedMutexAcquireReleaseInfoNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::Win32KeyedMutexAcquireReleaseInfoNV const *>( &rhs );
      return *this;
    }

    Win32KeyedMutexAcquireReleaseInfoNV & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    Win32KeyedMutexAcquireReleaseInfoNV & setAcquireCount( uint32_t acquireCount_ ) VULKAN_HPP_NOEXCEPT
    {
      acquireCount = acquireCount_;
      return *this;
    }

    Win32KeyedMutexAcquireReleaseInfoNV &
      setPAcquireSyncs( const VULKAN_HPP_NAMESPACE::DeviceMemory * pAcquireSyncs_ ) VULKAN_HPP_NOEXCEPT
    {
      pAcquireSyncs = pAcquireSyncs_;
      return *this;
    }

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    Win32KeyedMutexAcquireReleaseInfoNV & setAcquireSyncs(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::DeviceMemory> const & acquireSyncs_ )
      VULKAN_HPP_NOEXCEPT
    {
      acquireCount  = static_cast<uint32_t>( acquireSyncs_.size() );
      pAcquireSyncs = acquireSyncs_.data();
      return *this;
    }
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    Win32KeyedMutexAcquireReleaseInfoNV & setPAcquireKeys( const uint64_t * pAcquireKeys_ ) VULKAN_HPP_NOEXCEPT
    {
      pAcquireKeys = pAcquireKeys_;
      return *this;
    }

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    Win32KeyedMutexAcquireReleaseInfoNV & setAcquireKeys(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint64_t> const & acquireKeys_ ) VULKAN_HPP_NOEXCEPT
    {
      acquireCount = static_cast<uint32_t>( acquireKeys_.size() );
      pAcquireKeys = acquireKeys_.data();
      return *this;
    }
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    Win32KeyedMutexAcquireReleaseInfoNV &
      setPAcquireTimeoutMilliseconds( const uint32_t * pAcquireTimeoutMilliseconds_ ) VULKAN_HPP_NOEXCEPT
    {
      pAcquireTimeoutMilliseconds = pAcquireTimeoutMilliseconds_;
      return *this;
    }

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    Win32KeyedMutexAcquireReleaseInfoNV & setAcquireTimeoutMilliseconds(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint32_t> const & acquireTimeoutMilliseconds_ )
      VULKAN_HPP_NOEXCEPT
    {
      acquireCount                = static_cast<uint32_t>( acquireTimeoutMilliseconds_.size() );
      pAcquireTimeoutMilliseconds = acquireTimeoutMilliseconds_.data();
      return *this;
    }
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    Win32KeyedMutexAcquireReleaseInfoNV & setReleaseCount( uint32_t releaseCount_ ) VULKAN_HPP_NOEXCEPT
    {
      releaseCount = releaseCount_;
      return *this;
    }

    Win32KeyedMutexAcquireReleaseInfoNV &
      setPReleaseSyncs( const VULKAN_HPP_NAMESPACE::DeviceMemory * pReleaseSyncs_ ) VULKAN_HPP_NOEXCEPT
    {
      pReleaseSyncs = pReleaseSyncs_;
      return *this;
    }

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    Win32KeyedMutexAcquireReleaseInfoNV & setReleaseSyncs(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::DeviceMemory> const & releaseSyncs_ )
      VULKAN_HPP_NOEXCEPT
    {
      releaseCount  = static_cast<uint32_t>( releaseSyncs_.size() );
      pReleaseSyncs = releaseSyncs_.data();
      return *this;
    }
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    Win32KeyedMutexAcquireReleaseInfoNV & setPReleaseKeys( const uint64_t * pReleaseKeys_ ) VULKAN_HPP_NOEXCEPT
    {
      pReleaseKeys = pReleaseKeys_;
      return *this;
    }

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    Win32KeyedMutexAcquireReleaseInfoNV & setReleaseKeys(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const uint64_t> const & releaseKeys_ ) VULKAN_HPP_NOEXCEPT
    {
      releaseCount = static_cast<uint32_t>( releaseKeys_.size() );
      pReleaseKeys = releaseKeys_.data();
      return *this;
    }
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkWin32KeyedMutexAcquireReleaseInfoNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkWin32KeyedMutexAcquireReleaseInfoNV *>( this );
    }

    operator VkWin32KeyedMutexAcquireReleaseInfoNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkWin32KeyedMutexAcquireReleaseInfoNV *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( Win32KeyedMutexAcquireReleaseInfoNV const & ) const = default;
#  else
    bool operator==( Win32KeyedMutexAcquireReleaseInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( acquireCount == rhs.acquireCount ) &&
             ( pAcquireSyncs == rhs.pAcquireSyncs ) && ( pAcquireKeys == rhs.pAcquireKeys ) &&
             ( pAcquireTimeoutMilliseconds == rhs.pAcquireTimeoutMilliseconds ) &&
             ( releaseCount == rhs.releaseCount ) && ( pReleaseSyncs == rhs.pReleaseSyncs ) &&
             ( pReleaseKeys == rhs.pReleaseKeys );
    }

    bool operator!=( Win32KeyedMutexAcquireReleaseInfoNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType        sType         = StructureType::eWin32KeyedMutexAcquireReleaseInfoNV;
    const void *                               pNext         = {};
    uint32_t                                   acquireCount  = {};
    const VULKAN_HPP_NAMESPACE::DeviceMemory * pAcquireSyncs = {};
    const uint64_t *                           pAcquireKeys  = {};
    const uint32_t *                           pAcquireTimeoutMilliseconds = {};
    uint32_t                                   releaseCount                = {};
    const VULKAN_HPP_NAMESPACE::DeviceMemory * pReleaseSyncs               = {};
    const uint64_t *                           pReleaseKeys                = {};
  };
  static_assert( sizeof( Win32KeyedMutexAcquireReleaseInfoNV ) == sizeof( VkWin32KeyedMutexAcquireReleaseInfoNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<Win32KeyedMutexAcquireReleaseInfoNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eWin32KeyedMutexAcquireReleaseInfoNV>
  {
    using Type = Win32KeyedMutexAcquireReleaseInfoNV;
  };
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

#if defined( VK_USE_PLATFORM_WIN32_KHR )
  struct Win32SurfaceCreateInfoKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eWin32SurfaceCreateInfoKHR;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR Win32SurfaceCreateInfoKHR( VULKAN_HPP_NAMESPACE::Win32SurfaceCreateFlagsKHR flags_     = {},
                                                    HINSTANCE                                        hinstance_ = {},
                                                    HWND hwnd_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , hinstance( hinstance_ )
      , hwnd( hwnd_ )
    {}

    VULKAN_HPP_CONSTEXPR
      Win32SurfaceCreateInfoKHR( Win32SurfaceCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    Win32SurfaceCreateInfoKHR( VkWin32SurfaceCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : Win32SurfaceCreateInfoKHR( *reinterpret_cast<Win32SurfaceCreateInfoKHR const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 Win32SurfaceCreateInfoKHR &
                            operator=( Win32SurfaceCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    Win32SurfaceCreateInfoKHR & operator=( VkWin32SurfaceCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::Win32SurfaceCreateInfoKHR const *>( &rhs );
      return *this;
    }

    Win32SurfaceCreateInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    Win32SurfaceCreateInfoKHR & setFlags( VULKAN_HPP_NAMESPACE::Win32SurfaceCreateFlagsKHR flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    Win32SurfaceCreateInfoKHR & setHinstance( HINSTANCE hinstance_ ) VULKAN_HPP_NOEXCEPT
    {
      hinstance = hinstance_;
      return *this;
    }

    Win32SurfaceCreateInfoKHR & setHwnd( HWND hwnd_ ) VULKAN_HPP_NOEXCEPT
    {
      hwnd = hwnd_;
      return *this;
    }

    operator VkWin32SurfaceCreateInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkWin32SurfaceCreateInfoKHR *>( this );
    }

    operator VkWin32SurfaceCreateInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkWin32SurfaceCreateInfoKHR *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( Win32SurfaceCreateInfoKHR const & ) const = default;
#  else
    bool operator==( Win32SurfaceCreateInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( hinstance == rhs.hinstance ) && ( hwnd == rhs.hwnd );
    }

    bool operator!=( Win32SurfaceCreateInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType              sType     = StructureType::eWin32SurfaceCreateInfoKHR;
    const void *                                     pNext     = {};
    VULKAN_HPP_NAMESPACE::Win32SurfaceCreateFlagsKHR flags     = {};
    HINSTANCE                                        hinstance = {};
    HWND                                             hwnd      = {};
  };
  static_assert( sizeof( Win32SurfaceCreateInfoKHR ) == sizeof( VkWin32SurfaceCreateInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<Win32SurfaceCreateInfoKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eWin32SurfaceCreateInfoKHR>
  {
    using Type = Win32SurfaceCreateInfoKHR;
  };
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

  struct WriteDescriptorSet
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eWriteDescriptorSet;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR WriteDescriptorSet(
      VULKAN_HPP_NAMESPACE::DescriptorSet  dstSet_                    = {},
      uint32_t                             dstBinding_                = {},
      uint32_t                             dstArrayElement_           = {},
      uint32_t                             descriptorCount_           = {},
      VULKAN_HPP_NAMESPACE::DescriptorType descriptorType_            = VULKAN_HPP_NAMESPACE::DescriptorType::eSampler,
      const VULKAN_HPP_NAMESPACE::DescriptorImageInfo *  pImageInfo_  = {},
      const VULKAN_HPP_NAMESPACE::DescriptorBufferInfo * pBufferInfo_ = {},
      const VULKAN_HPP_NAMESPACE::BufferView *           pTexelBufferView_ = {} ) VULKAN_HPP_NOEXCEPT
      : dstSet( dstSet_ )
      , dstBinding( dstBinding_ )
      , dstArrayElement( dstArrayElement_ )
      , descriptorCount( descriptorCount_ )
      , descriptorType( descriptorType_ )
      , pImageInfo( pImageInfo_ )
      , pBufferInfo( pBufferInfo_ )
      , pTexelBufferView( pTexelBufferView_ )
    {}

    VULKAN_HPP_CONSTEXPR WriteDescriptorSet( WriteDescriptorSet const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    WriteDescriptorSet( VkWriteDescriptorSet const & rhs ) VULKAN_HPP_NOEXCEPT
      : WriteDescriptorSet( *reinterpret_cast<WriteDescriptorSet const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    WriteDescriptorSet(
      VULKAN_HPP_NAMESPACE::DescriptorSet  dstSet_,
      uint32_t                             dstBinding_,
      uint32_t                             dstArrayElement_,
      VULKAN_HPP_NAMESPACE::DescriptorType descriptorType_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::DescriptorImageInfo> const & imageInfo_,
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::DescriptorBufferInfo> const &
        bufferInfo_ = {},
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::BufferView> const &
        texelBufferView_ = {} )
      : dstSet( dstSet_ )
      , dstBinding( dstBinding_ )
      , dstArrayElement( dstArrayElement_ )
      , descriptorCount( static_cast<uint32_t>( !imageInfo_.empty() ? imageInfo_.size()
                                                                    : !bufferInfo_.empty() ? bufferInfo_.size()
                                                                                           : texelBufferView_.size() ) )
      , descriptorType( descriptorType_ )
      , pImageInfo( imageInfo_.data() )
      , pBufferInfo( bufferInfo_.data() )
      , pTexelBufferView( texelBufferView_.data() )
    {
#    ifdef VULKAN_HPP_NO_EXCEPTIONS
      VULKAN_HPP_ASSERT( ( !imageInfo_.empty() + !bufferInfo_.empty() + !texelBufferView_.empty() ) <= 1 );
#    else
      if ( 1 < ( !imageInfo_.empty() + !bufferInfo_.empty() + !texelBufferView_.empty() ) )
      {
        throw LogicError(
          VULKAN_HPP_NAMESPACE_STRING
          "::WriteDescriptorSet::WriteDescriptorSet: 1 < ( !imageInfo_.empty() + !bufferInfo_.empty() + !texelBufferView_.empty() )" );
      }
#    endif /*VULKAN_HPP_NO_EXCEPTIONS*/
    }
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 WriteDescriptorSet &
                            operator=( WriteDescriptorSet const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    WriteDescriptorSet & operator=( VkWriteDescriptorSet const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::WriteDescriptorSet const *>( &rhs );
      return *this;
    }

    WriteDescriptorSet & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    WriteDescriptorSet & setDstSet( VULKAN_HPP_NAMESPACE::DescriptorSet dstSet_ ) VULKAN_HPP_NOEXCEPT
    {
      dstSet = dstSet_;
      return *this;
    }

    WriteDescriptorSet & setDstBinding( uint32_t dstBinding_ ) VULKAN_HPP_NOEXCEPT
    {
      dstBinding = dstBinding_;
      return *this;
    }

    WriteDescriptorSet & setDstArrayElement( uint32_t dstArrayElement_ ) VULKAN_HPP_NOEXCEPT
    {
      dstArrayElement = dstArrayElement_;
      return *this;
    }

    WriteDescriptorSet & setDescriptorCount( uint32_t descriptorCount_ ) VULKAN_HPP_NOEXCEPT
    {
      descriptorCount = descriptorCount_;
      return *this;
    }

    WriteDescriptorSet & setDescriptorType( VULKAN_HPP_NAMESPACE::DescriptorType descriptorType_ ) VULKAN_HPP_NOEXCEPT
    {
      descriptorType = descriptorType_;
      return *this;
    }

    WriteDescriptorSet &
      setPImageInfo( const VULKAN_HPP_NAMESPACE::DescriptorImageInfo * pImageInfo_ ) VULKAN_HPP_NOEXCEPT
    {
      pImageInfo = pImageInfo_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    WriteDescriptorSet & setImageInfo(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::DescriptorImageInfo> const &
        imageInfo_ ) VULKAN_HPP_NOEXCEPT
    {
      descriptorCount = static_cast<uint32_t>( imageInfo_.size() );
      pImageInfo      = imageInfo_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    WriteDescriptorSet &
      setPBufferInfo( const VULKAN_HPP_NAMESPACE::DescriptorBufferInfo * pBufferInfo_ ) VULKAN_HPP_NOEXCEPT
    {
      pBufferInfo = pBufferInfo_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    WriteDescriptorSet & setBufferInfo(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::DescriptorBufferInfo> const &
        bufferInfo_ ) VULKAN_HPP_NOEXCEPT
    {
      descriptorCount = static_cast<uint32_t>( bufferInfo_.size() );
      pBufferInfo     = bufferInfo_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    WriteDescriptorSet &
      setPTexelBufferView( const VULKAN_HPP_NAMESPACE::BufferView * pTexelBufferView_ ) VULKAN_HPP_NOEXCEPT
    {
      pTexelBufferView = pTexelBufferView_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    WriteDescriptorSet & setTexelBufferView(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::BufferView> const & texelBufferView_ )
      VULKAN_HPP_NOEXCEPT
    {
      descriptorCount  = static_cast<uint32_t>( texelBufferView_.size() );
      pTexelBufferView = texelBufferView_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkWriteDescriptorSet const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkWriteDescriptorSet *>( this );
    }

    operator VkWriteDescriptorSet &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkWriteDescriptorSet *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( WriteDescriptorSet const & ) const = default;
#else
    bool operator==( WriteDescriptorSet const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( dstSet == rhs.dstSet ) &&
             ( dstBinding == rhs.dstBinding ) && ( dstArrayElement == rhs.dstArrayElement ) &&
             ( descriptorCount == rhs.descriptorCount ) && ( descriptorType == rhs.descriptorType ) &&
             ( pImageInfo == rhs.pImageInfo ) && ( pBufferInfo == rhs.pBufferInfo ) &&
             ( pTexelBufferView == rhs.pTexelBufferView );
    }

    bool operator!=( WriteDescriptorSet const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType                sType           = StructureType::eWriteDescriptorSet;
    const void *                                       pNext           = {};
    VULKAN_HPP_NAMESPACE::DescriptorSet                dstSet          = {};
    uint32_t                                           dstBinding      = {};
    uint32_t                                           dstArrayElement = {};
    uint32_t                                           descriptorCount = {};
    VULKAN_HPP_NAMESPACE::DescriptorType               descriptorType  = VULKAN_HPP_NAMESPACE::DescriptorType::eSampler;
    const VULKAN_HPP_NAMESPACE::DescriptorImageInfo *  pImageInfo      = {};
    const VULKAN_HPP_NAMESPACE::DescriptorBufferInfo * pBufferInfo     = {};
    const VULKAN_HPP_NAMESPACE::BufferView *           pTexelBufferView = {};
  };
  static_assert( sizeof( WriteDescriptorSet ) == sizeof( VkWriteDescriptorSet ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<WriteDescriptorSet>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eWriteDescriptorSet>
  {
    using Type = WriteDescriptorSet;
  };

  struct WriteDescriptorSetAccelerationStructureKHR
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eWriteDescriptorSetAccelerationStructureKHR;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR WriteDescriptorSetAccelerationStructureKHR(
      uint32_t                                               accelerationStructureCount_ = {},
      const VULKAN_HPP_NAMESPACE::AccelerationStructureKHR * pAccelerationStructures_    = {} ) VULKAN_HPP_NOEXCEPT
      : accelerationStructureCount( accelerationStructureCount_ )
      , pAccelerationStructures( pAccelerationStructures_ )
    {}

    VULKAN_HPP_CONSTEXPR WriteDescriptorSetAccelerationStructureKHR(
      WriteDescriptorSetAccelerationStructureKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    WriteDescriptorSetAccelerationStructureKHR( VkWriteDescriptorSetAccelerationStructureKHR const & rhs )
      VULKAN_HPP_NOEXCEPT
      : WriteDescriptorSetAccelerationStructureKHR(
          *reinterpret_cast<WriteDescriptorSetAccelerationStructureKHR const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    WriteDescriptorSetAccelerationStructureKHR(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::AccelerationStructureKHR> const &
        accelerationStructures_ )
      : accelerationStructureCount( static_cast<uint32_t>( accelerationStructures_.size() ) )
      , pAccelerationStructures( accelerationStructures_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 WriteDescriptorSetAccelerationStructureKHR &
                            operator=( WriteDescriptorSetAccelerationStructureKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    WriteDescriptorSetAccelerationStructureKHR &
      operator=( VkWriteDescriptorSetAccelerationStructureKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::WriteDescriptorSetAccelerationStructureKHR const *>( &rhs );
      return *this;
    }

    WriteDescriptorSetAccelerationStructureKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    WriteDescriptorSetAccelerationStructureKHR &
      setAccelerationStructureCount( uint32_t accelerationStructureCount_ ) VULKAN_HPP_NOEXCEPT
    {
      accelerationStructureCount = accelerationStructureCount_;
      return *this;
    }

    WriteDescriptorSetAccelerationStructureKHR & setPAccelerationStructures(
      const VULKAN_HPP_NAMESPACE::AccelerationStructureKHR * pAccelerationStructures_ ) VULKAN_HPP_NOEXCEPT
    {
      pAccelerationStructures = pAccelerationStructures_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    WriteDescriptorSetAccelerationStructureKHR & setAccelerationStructures(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::AccelerationStructureKHR> const &
        accelerationStructures_ ) VULKAN_HPP_NOEXCEPT
    {
      accelerationStructureCount = static_cast<uint32_t>( accelerationStructures_.size() );
      pAccelerationStructures    = accelerationStructures_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkWriteDescriptorSetAccelerationStructureKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkWriteDescriptorSetAccelerationStructureKHR *>( this );
    }

    operator VkWriteDescriptorSetAccelerationStructureKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkWriteDescriptorSetAccelerationStructureKHR *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( WriteDescriptorSetAccelerationStructureKHR const & ) const = default;
#else
    bool operator==( WriteDescriptorSetAccelerationStructureKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( accelerationStructureCount == rhs.accelerationStructureCount ) &&
             ( pAccelerationStructures == rhs.pAccelerationStructures );
    }

    bool operator!=( WriteDescriptorSetAccelerationStructureKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::eWriteDescriptorSetAccelerationStructureKHR;
    const void *                        pNext = {};
    uint32_t                            accelerationStructureCount                 = {};
    const VULKAN_HPP_NAMESPACE::AccelerationStructureKHR * pAccelerationStructures = {};
  };
  static_assert( sizeof( WriteDescriptorSetAccelerationStructureKHR ) ==
                   sizeof( VkWriteDescriptorSetAccelerationStructureKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<WriteDescriptorSetAccelerationStructureKHR>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eWriteDescriptorSetAccelerationStructureKHR>
  {
    using Type = WriteDescriptorSetAccelerationStructureKHR;
  };

  struct WriteDescriptorSetAccelerationStructureNV
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eWriteDescriptorSetAccelerationStructureNV;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR WriteDescriptorSetAccelerationStructureNV(
      uint32_t                                              accelerationStructureCount_ = {},
      const VULKAN_HPP_NAMESPACE::AccelerationStructureNV * pAccelerationStructures_    = {} ) VULKAN_HPP_NOEXCEPT
      : accelerationStructureCount( accelerationStructureCount_ )
      , pAccelerationStructures( pAccelerationStructures_ )
    {}

    VULKAN_HPP_CONSTEXPR WriteDescriptorSetAccelerationStructureNV(
      WriteDescriptorSetAccelerationStructureNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    WriteDescriptorSetAccelerationStructureNV( VkWriteDescriptorSetAccelerationStructureNV const & rhs )
      VULKAN_HPP_NOEXCEPT
      : WriteDescriptorSetAccelerationStructureNV(
          *reinterpret_cast<WriteDescriptorSetAccelerationStructureNV const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    WriteDescriptorSetAccelerationStructureNV(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::AccelerationStructureNV> const &
        accelerationStructures_ )
      : accelerationStructureCount( static_cast<uint32_t>( accelerationStructures_.size() ) )
      , pAccelerationStructures( accelerationStructures_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 WriteDescriptorSetAccelerationStructureNV &
                            operator=( WriteDescriptorSetAccelerationStructureNV const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    WriteDescriptorSetAccelerationStructureNV &
      operator=( VkWriteDescriptorSetAccelerationStructureNV const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::WriteDescriptorSetAccelerationStructureNV const *>( &rhs );
      return *this;
    }

    WriteDescriptorSetAccelerationStructureNV & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    WriteDescriptorSetAccelerationStructureNV &
      setAccelerationStructureCount( uint32_t accelerationStructureCount_ ) VULKAN_HPP_NOEXCEPT
    {
      accelerationStructureCount = accelerationStructureCount_;
      return *this;
    }

    WriteDescriptorSetAccelerationStructureNV & setPAccelerationStructures(
      const VULKAN_HPP_NAMESPACE::AccelerationStructureNV * pAccelerationStructures_ ) VULKAN_HPP_NOEXCEPT
    {
      pAccelerationStructures = pAccelerationStructures_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    WriteDescriptorSetAccelerationStructureNV & setAccelerationStructures(
      VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const VULKAN_HPP_NAMESPACE::AccelerationStructureNV> const &
        accelerationStructures_ ) VULKAN_HPP_NOEXCEPT
    {
      accelerationStructureCount = static_cast<uint32_t>( accelerationStructures_.size() );
      pAccelerationStructures    = accelerationStructures_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkWriteDescriptorSetAccelerationStructureNV const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkWriteDescriptorSetAccelerationStructureNV *>( this );
    }

    operator VkWriteDescriptorSetAccelerationStructureNV &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkWriteDescriptorSetAccelerationStructureNV *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( WriteDescriptorSetAccelerationStructureNV const & ) const = default;
#else
    bool operator==( WriteDescriptorSetAccelerationStructureNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) &&
             ( accelerationStructureCount == rhs.accelerationStructureCount ) &&
             ( pAccelerationStructures == rhs.pAccelerationStructures );
    }

    bool operator!=( WriteDescriptorSetAccelerationStructureNV const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType = StructureType::eWriteDescriptorSetAccelerationStructureNV;
    const void *                        pNext = {};
    uint32_t                            accelerationStructureCount                = {};
    const VULKAN_HPP_NAMESPACE::AccelerationStructureNV * pAccelerationStructures = {};
  };
  static_assert( sizeof( WriteDescriptorSetAccelerationStructureNV ) ==
                   sizeof( VkWriteDescriptorSetAccelerationStructureNV ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<WriteDescriptorSetAccelerationStructureNV>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eWriteDescriptorSetAccelerationStructureNV>
  {
    using Type = WriteDescriptorSetAccelerationStructureNV;
  };

  struct WriteDescriptorSetInlineUniformBlockEXT
  {
    static const bool                    allowDuplicate = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType =
      StructureType::eWriteDescriptorSetInlineUniformBlockEXT;

#if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR WriteDescriptorSetInlineUniformBlockEXT( uint32_t     dataSize_ = {},
                                                                  const void * pData_    = {} ) VULKAN_HPP_NOEXCEPT
      : dataSize( dataSize_ )
      , pData( pData_ )
    {}

    VULKAN_HPP_CONSTEXPR WriteDescriptorSetInlineUniformBlockEXT( WriteDescriptorSetInlineUniformBlockEXT const & rhs )
      VULKAN_HPP_NOEXCEPT = default;

    WriteDescriptorSetInlineUniformBlockEXT( VkWriteDescriptorSetInlineUniformBlockEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : WriteDescriptorSetInlineUniformBlockEXT(
          *reinterpret_cast<WriteDescriptorSetInlineUniformBlockEXT const *>( &rhs ) )
    {}

#  if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    template <typename T>
    WriteDescriptorSetInlineUniformBlockEXT( VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const T> const & data_ )
      : dataSize( static_cast<uint32_t>( data_.size() * sizeof( T ) ) ), pData( data_.data() )
    {}
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/
#endif   /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 WriteDescriptorSetInlineUniformBlockEXT &
                            operator=( WriteDescriptorSetInlineUniformBlockEXT const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    WriteDescriptorSetInlineUniformBlockEXT &
      operator=( VkWriteDescriptorSetInlineUniformBlockEXT const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::WriteDescriptorSetInlineUniformBlockEXT const *>( &rhs );
      return *this;
    }

    WriteDescriptorSetInlineUniformBlockEXT & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    WriteDescriptorSetInlineUniformBlockEXT & setDataSize( uint32_t dataSize_ ) VULKAN_HPP_NOEXCEPT
    {
      dataSize = dataSize_;
      return *this;
    }

    WriteDescriptorSetInlineUniformBlockEXT & setPData( const void * pData_ ) VULKAN_HPP_NOEXCEPT
    {
      pData = pData_;
      return *this;
    }

#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )
    template <typename T>
    WriteDescriptorSetInlineUniformBlockEXT &
      setData( VULKAN_HPP_NAMESPACE::ArrayProxyNoTemporaries<const T> const & data_ ) VULKAN_HPP_NOEXCEPT
    {
      dataSize = static_cast<uint32_t>( data_.size() * sizeof( T ) );
      pData    = data_.data();
      return *this;
    }
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    operator VkWriteDescriptorSetInlineUniformBlockEXT const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkWriteDescriptorSetInlineUniformBlockEXT *>( this );
    }

    operator VkWriteDescriptorSetInlineUniformBlockEXT &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkWriteDescriptorSetInlineUniformBlockEXT *>( this );
    }

#if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( WriteDescriptorSetInlineUniformBlockEXT const & ) const = default;
#else
    bool operator==( WriteDescriptorSetInlineUniformBlockEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( dataSize == rhs.dataSize ) && ( pData == rhs.pData );
    }

    bool operator!=( WriteDescriptorSetInlineUniformBlockEXT const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType sType    = StructureType::eWriteDescriptorSetInlineUniformBlockEXT;
    const void *                        pNext    = {};
    uint32_t                            dataSize = {};
    const void *                        pData    = {};
  };
  static_assert( sizeof( WriteDescriptorSetInlineUniformBlockEXT ) ==
                   sizeof( VkWriteDescriptorSetInlineUniformBlockEXT ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<WriteDescriptorSetInlineUniformBlockEXT>::value,
                 "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eWriteDescriptorSetInlineUniformBlockEXT>
  {
    using Type = WriteDescriptorSetInlineUniformBlockEXT;
  };

#if defined( VK_USE_PLATFORM_XCB_KHR )
  struct XcbSurfaceCreateInfoKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eXcbSurfaceCreateInfoKHR;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR XcbSurfaceCreateInfoKHR( VULKAN_HPP_NAMESPACE::XcbSurfaceCreateFlagsKHR flags_      = {},
                                                  xcb_connection_t *                             connection_ = {},
                                                  xcb_window_t window_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , connection( connection_ )
      , window( window_ )
    {}

    VULKAN_HPP_CONSTEXPR XcbSurfaceCreateInfoKHR( XcbSurfaceCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    XcbSurfaceCreateInfoKHR( VkXcbSurfaceCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : XcbSurfaceCreateInfoKHR( *reinterpret_cast<XcbSurfaceCreateInfoKHR const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 XcbSurfaceCreateInfoKHR &
                            operator=( XcbSurfaceCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    XcbSurfaceCreateInfoKHR & operator=( VkXcbSurfaceCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::XcbSurfaceCreateInfoKHR const *>( &rhs );
      return *this;
    }

    XcbSurfaceCreateInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    XcbSurfaceCreateInfoKHR & setFlags( VULKAN_HPP_NAMESPACE::XcbSurfaceCreateFlagsKHR flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    XcbSurfaceCreateInfoKHR & setConnection( xcb_connection_t * connection_ ) VULKAN_HPP_NOEXCEPT
    {
      connection = connection_;
      return *this;
    }

    XcbSurfaceCreateInfoKHR & setWindow( xcb_window_t window_ ) VULKAN_HPP_NOEXCEPT
    {
      window = window_;
      return *this;
    }

    operator VkXcbSurfaceCreateInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkXcbSurfaceCreateInfoKHR *>( this );
    }

    operator VkXcbSurfaceCreateInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkXcbSurfaceCreateInfoKHR *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( XcbSurfaceCreateInfoKHR const & ) const = default;
#  else
    bool operator==( XcbSurfaceCreateInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) &&
             ( connection == rhs.connection ) && ( memcmp( &window, &rhs.window, sizeof( xcb_window_t ) ) == 0 );
    }

    bool operator!=( XcbSurfaceCreateInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType            sType      = StructureType::eXcbSurfaceCreateInfoKHR;
    const void *                                   pNext      = {};
    VULKAN_HPP_NAMESPACE::XcbSurfaceCreateFlagsKHR flags      = {};
    xcb_connection_t *                             connection = {};
    xcb_window_t                                   window     = {};
  };
  static_assert( sizeof( XcbSurfaceCreateInfoKHR ) == sizeof( VkXcbSurfaceCreateInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<XcbSurfaceCreateInfoKHR>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eXcbSurfaceCreateInfoKHR>
  {
    using Type = XcbSurfaceCreateInfoKHR;
  };
#endif /*VK_USE_PLATFORM_XCB_KHR*/

#if defined( VK_USE_PLATFORM_XLIB_KHR )
  struct XlibSurfaceCreateInfoKHR
  {
    static const bool                    allowDuplicate              = false;
    static VULKAN_HPP_CONST_OR_CONSTEXPR StructureType structureType = StructureType::eXlibSurfaceCreateInfoKHR;

#  if !defined( VULKAN_HPP_NO_STRUCT_CONSTRUCTORS )
    VULKAN_HPP_CONSTEXPR XlibSurfaceCreateInfoKHR( VULKAN_HPP_NAMESPACE::XlibSurfaceCreateFlagsKHR flags_ = {},
                                                   Display *                                       dpy_   = {},
                                                   Window window_ = {} ) VULKAN_HPP_NOEXCEPT
      : flags( flags_ )
      , dpy( dpy_ )
      , window( window_ )
    {}

    VULKAN_HPP_CONSTEXPR XlibSurfaceCreateInfoKHR( XlibSurfaceCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    XlibSurfaceCreateInfoKHR( VkXlibSurfaceCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
      : XlibSurfaceCreateInfoKHR( *reinterpret_cast<XlibSurfaceCreateInfoKHR const *>( &rhs ) )
    {}
#  endif /*VULKAN_HPP_NO_STRUCT_CONSTRUCTORS*/

    VULKAN_HPP_CONSTEXPR_14 XlibSurfaceCreateInfoKHR &
                            operator=( XlibSurfaceCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT = default;

    XlibSurfaceCreateInfoKHR & operator=( VkXlibSurfaceCreateInfoKHR const & rhs ) VULKAN_HPP_NOEXCEPT
    {
      *this = *reinterpret_cast<VULKAN_HPP_NAMESPACE::XlibSurfaceCreateInfoKHR const *>( &rhs );
      return *this;
    }

    XlibSurfaceCreateInfoKHR & setPNext( const void * pNext_ ) VULKAN_HPP_NOEXCEPT
    {
      pNext = pNext_;
      return *this;
    }

    XlibSurfaceCreateInfoKHR & setFlags( VULKAN_HPP_NAMESPACE::XlibSurfaceCreateFlagsKHR flags_ ) VULKAN_HPP_NOEXCEPT
    {
      flags = flags_;
      return *this;
    }

    XlibSurfaceCreateInfoKHR & setDpy( Display * dpy_ ) VULKAN_HPP_NOEXCEPT
    {
      dpy = dpy_;
      return *this;
    }

    XlibSurfaceCreateInfoKHR & setWindow( Window window_ ) VULKAN_HPP_NOEXCEPT
    {
      window = window_;
      return *this;
    }

    operator VkXlibSurfaceCreateInfoKHR const &() const VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<const VkXlibSurfaceCreateInfoKHR *>( this );
    }

    operator VkXlibSurfaceCreateInfoKHR &() VULKAN_HPP_NOEXCEPT
    {
      return *reinterpret_cast<VkXlibSurfaceCreateInfoKHR *>( this );
    }

#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )
    auto operator<=>( XlibSurfaceCreateInfoKHR const & ) const = default;
#  else
    bool operator==( XlibSurfaceCreateInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return ( sType == rhs.sType ) && ( pNext == rhs.pNext ) && ( flags == rhs.flags ) && ( dpy == rhs.dpy ) &&
             ( memcmp( &window, &rhs.window, sizeof( Window ) ) == 0 );
    }

    bool operator!=( XlibSurfaceCreateInfoKHR const & rhs ) const VULKAN_HPP_NOEXCEPT
    {
      return !operator==( rhs );
    }
#  endif

  public:
    VULKAN_HPP_NAMESPACE::StructureType             sType  = StructureType::eXlibSurfaceCreateInfoKHR;
    const void *                                    pNext  = {};
    VULKAN_HPP_NAMESPACE::XlibSurfaceCreateFlagsKHR flags  = {};
    Display *                                       dpy    = {};
    Window                                          window = {};
  };
  static_assert( sizeof( XlibSurfaceCreateInfoKHR ) == sizeof( VkXlibSurfaceCreateInfoKHR ),
                 "struct and wrapper have different size!" );
  static_assert( std::is_standard_layout<XlibSurfaceCreateInfoKHR>::value, "struct wrapper is not a standard layout!" );

  template <>
  struct CppType<StructureType, StructureType::eXlibSurfaceCreateInfoKHR>
  {
    using Type = XlibSurfaceCreateInfoKHR;
  };
#endif /*VK_USE_PLATFORM_XLIB_KHR*/

}  // namespace VULKAN_HPP_NAMESPACE
#endif
