name: CI Coverage Workflow

on:
  workflow_call:
    inputs:
      os:
        required: true
        type: string
      compiler:
        required: true
        type: string
      platform:
        required: true
        type: string
      config:
        required: true
        type: string
      runs-on:
        required: true
        type: string
      build-llvm:
        required: false
        type: boolean
        default: true
      server-count:
        required: false
        type: number
        default: 8
      deploy-pages:
        required: false
        type: boolean
        default: false
      pr-comment:
        required: false
        type: boolean
        default: false

jobs:
  coverage:
    runs-on: ${{ fromJSON(inputs.runs-on) }}
    timeout-minutes: 120

    defaults:
      run:
        shell: bash

    steps:
      - uses: actions/checkout@v4
        with:
          submodules: "recursive"
          fetch-depth: "0"

      - name: Install Clang 18 and LLVM Tools
        if: inputs.compiler == 'clang-18' && inputs.os == 'linux'
        shell: bash
        run: |
          # Add LLVM APT repository
          wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key | sudo apt-key add -
          sudo add-apt-repository "deb http://apt.llvm.org/jammy/ llvm-toolchain-jammy-18 main"
          sudo apt-get update

          # Install clang-18 and LLVM coverage tools
          sudo apt-get install -y clang-18 clang++-18 llvm-18

          # Create symlinks for coverage tools (llvm-profdata, llvm-cov)
          sudo update-alternatives --install /usr/bin/llvm-profdata llvm-profdata /usr/bin/llvm-profdata-18 100
          sudo update-alternatives --install /usr/bin/llvm-cov llvm-cov /usr/bin/llvm-cov-18 100

          # Verify installation
          clang-18 --version
          clang++-18 --version
          llvm-profdata --version
          llvm-cov --version

      - name: Setup
        uses: ./.github/actions/common-setup
        with:
          os: ${{ inputs.os }}
          compiler: ${{ inputs.compiler }}
          platform: ${{ inputs.platform }}
          config: ${{ inputs.config }}
          build-llvm: ${{ inputs.build-llvm }}

      - name: Build Slang with Coverage
        run: |
          echo "cmake version: $(cmake --version)"
          echo "Building with coverage instrumentation (preset: coverage)"

          # Show ccache status if available
          if command -v ccache &> /dev/null; then
            echo "ðŸ”§ ccache configuration:"
            ccache --show-config | head -20 || true
            echo "ðŸ“Š ccache statistics (pre-build):"
            ccache --show-stats || true
          else
            echo "â„¹ï¸  ccache not available"
          fi

          # Prepare ccache launcher arguments if ccache is available
          cmake_launcher_defines=()
          if [[ -n "${ccache_symlinks_path:-}" ]]; then
            echo "ðŸ”§ Using ccache with launcher: ${ccache_symlinks_path}"
            echo "ðŸ”§ CCACHE_DIR is set to: ${CCACHE_DIR:-'not set'}"
            cmake_launcher_defines+=("-DCMAKE_C_COMPILER_LAUNCHER=${ccache_symlinks_path}")
            cmake_launcher_defines+=("-DCMAKE_CXX_COMPILER_LAUNCHER=${ccache_symlinks_path}")
          else
            echo "â„¹ï¸  ccache_symlinks_path not set - building without ccache"
          fi

          if [[ "${{ inputs.os }}" =~ "windows" && "${{ inputs.config }}" == "debug" ]]; then
            # Doing a debug build will try to link against a release built llvm, this
            # is a problem on Windows, so make slang-llvm in release build and use
            # that as though it's a fetched binary via these presets.
            cmake --workflow --preset slang-llvm

            # Configure, pointing to our just-generated slang-llvm archive
            cmake --preset coverage --fresh \
              -DSLANG_SLANG_LLVM_FLAVOR=FETCH_BINARY \
              "-DSLANG_SLANG_LLVM_BINARY_URL=$(pwd)/build/dist-release/slang-llvm.zip" \
              "${cmake_launcher_defines[@]}"
            cmake --build --preset coverage
          elif [[ "${{ inputs.build-llvm }}" = "false" ]]; then
            # linux aarch64 cannot build llvm.
            cmake --preset coverage --fresh \
              -DSLANG_SLANG_LLVM_FLAVOR=DISABLE \
              "${cmake_launcher_defines[@]}"
            cmake --build --preset coverage
          else
            # Otherwise, use the "system" llvm we have just build or got from the
            # cache in the setup phase
            cmake --preset coverage --fresh \
              -DSLANG_SLANG_LLVM_FLAVOR=USE_SYSTEM_LLVM \
              "${cmake_launcher_defines[@]}"
            cmake --build --preset coverage
          fi

          # Show ccache statistics after build
          if command -v ccache &> /dev/null; then
            echo "ðŸ“Š ccache statistics (post-build):"
            ccache --show-stats || true
          fi

      - name: Run Tests with Coverage
        run: |
          # Generate both HTML and LCOV formats
          export COVERAGE_HTML=1
          export COVERAGE_LCOV=1
          export COVERAGE_HTML_DIR="$PWD/coverage-html"
          export COVERAGE_LCOV_FILE="$PWD/coverage.lcov"

          # Run coverage with test servers and expected failure list for no-GPU environment
          ./tools/coverage/run-coverage.sh -use-test-server -server-count ${{ inputs.server-count }} -expected-failure-list tests/expected-failure-no-gpu.txt

      - name: Generate Coverage Summary
        id: coverage-summary
        run: |
          # Extract overall coverage percentage from LCOV file
          if [[ -f coverage.lcov ]]; then
            lines_found=$(grep -o "LF:[0-9]*" coverage.lcov | awk -F: '{sum+=$2} END {print sum}')
            lines_hit=$(grep -o "LH:[0-9]*" coverage.lcov | awk -F: '{sum+=$2} END {print sum}')

            if [[ $lines_found -gt 0 ]]; then
              coverage=$(awk "BEGIN {printf \"%.2f\", ($lines_hit / $lines_found) * 100}")
              echo "coverage=$coverage" >> $GITHUB_OUTPUT

              cat >> $GITHUB_STEP_SUMMARY <<EOF
          # Coverage Report
          - **Total Coverage:** ${coverage}%
          - **Lines Hit:** ${lines_hit} / ${lines_found}
          EOF
            fi
          fi

      - name: Deploy Coverage to Separate Repository
        if: ${{ inputs.deploy-pages }}
        env:
          COVERAGE_REPO_TOKEN: ${{ secrets.SLANG_COVERAGE_REPORTS_PAT }}
        run: |
          # Get current date and short commit hash
          REPORT_DATE=$(date -u +"%Y-%m-%d")
          COMMIT_SHORT=$(git rev-parse --short HEAD)
          FULL_COMMIT=$(git rev-parse HEAD)
          REPORT_DIR="reports/history/${REPORT_DATE}-${COMMIT_SHORT}"

          # Clone the coverage reports repository
          git clone https://x-access-token:${COVERAGE_REPO_TOKEN}@github.com/shader-slang/slang-coverage-reports.git coverage-repo
          cd coverage-repo

          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Create directory structure
          mkdir -p "${REPORT_DIR}"
          mkdir -p reports/latest

          # Copy coverage HTML to historical location
          cp -r ../coverage-html/* "${REPORT_DIR}/"

          # Update latest (replace entire directory)
          rm -rf reports/latest/*
          cp -r ../coverage-html/* reports/latest/

          # Create helper script to generate historical index
          bash ../tools/coverage/generate-history-index.sh reports/history

          # Commit and push if there are changes
          git add reports/
          if ! git diff --cached --quiet; then
            TIMESTAMP=$(date -u +"%Y-%m-%d %H:%M:%S UTC")
            git commit -m "Add coverage report for ${REPORT_DATE} (${COMMIT_SHORT})" \
                       -m "Generated from shader-slang/slang@${FULL_COMMIT}" \
                       -m "Date: ${TIMESTAMP}"

            git push origin main
            echo "Coverage report deployed successfully"
          else
            echo "No changes to coverage report"
          fi

      - name: Report Coverage in PR
        if: ${{ inputs.pr-comment }}
        uses: zgosalvez/github-actions-report-lcov@v4
        with:
          coverage-files: coverage.lcov
          minimum-coverage: 0
          artifact-name: coverage-report
          github-token: ${{ secrets.GITHUB_TOKEN }}
          update-comment: true

      - name: Compress and Upload LCOV Report
        run: |
          # Compress LCOV file to save space
          gzip -9 coverage.lcov
          echo "Compressed LCOV file:"
          ls -lh coverage.lcov.gz

      - name: Upload LCOV Report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-lcov-${{ inputs.os }}-${{ inputs.platform }}-${{ inputs.compiler }}
          path: coverage.lcov.gz
          retention-days: 7
          compression-level: 0 # Already compressed, no need to compress again
