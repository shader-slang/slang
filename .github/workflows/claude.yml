name: ClaudeCode - Slang Assistant

permissions:
  contents: write
  pull-requests: write
  issues: write
  actions: read
  id-token: write

on:
  workflow_dispatch:
    inputs:
      issue_number:
        description: "Issue or PR number to test with"
        required: false
        type: number
  issue_comment:
    types: [created]
  pull_request_review_comment:
    types: [created]
  issues:
    types: [opened, assigned]
  pull_request_review:
    types: [submitted]

env:
  AWS_REGION: ${{ vars.AWS_REGION }}
  AWS_ACCESS_KEY_ID: ${{ vars.AWS_ACCESS_KEY_ID }}
  AWS_SECRET_ACCESS_KEY: ${{ vars.AWS_SECRET_ACCESS_KEY }}

jobs:
  claude:
    name: Claude Code Assistant
    if: |
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'issue_comment' && contains(github.event.comment.body, '@claude')) ||
      (github.event_name == 'pull_request_review_comment' && contains(github.event.comment.body, '@claude')) ||
      (github.event_name == 'pull_request_review' && contains(github.event.review.body, '@claude')) ||
      (github.event_name == 'issues' && (contains(github.event.issue.body, '@claude')))

    runs-on: [Windows, self-hosted, GCP-T4]
    timeout-minutes: 360

    # Cancel previous runs on new pushes
    concurrency:
      group: claude-${{ github.event.issue.number || github.event.pull_request.number || github.run_id }}
      cancel-in-progress: true

    steps:
      # Windows-specific setup: Add bash to PATH (must be before any bash steps)
      - name: Add bash to PATH (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          Add-Content -Path $env:GITHUB_PATH -Value "C:\Program Files\Git\bin"
          Add-Content -Path $env:GITHUB_PATH -Value "C:\Program Files\Git\usr\bin"

      # Install jq on Windows (not pre-installed on self-hosted runners)
      # Creates wrappers for both cmd.exe and bash compatibility
      # See: https://github.com/anthropics/claude-code-action/issues/712
      - name: Install jq (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $toolsDir = "C:\Windows\ServiceProfiles\NetworkService\.local\bin"
          New-Item -ItemType Directory -Force -Path $toolsDir | Out-Null

          # Download jq
          $jqUrl = "https://github.com/jqlang/jq/releases/download/jq-1.7.1/jq-win64.exe"
          $jqExe = "$env:RUNNER_TEMP\jq-windows.exe"
          Invoke-WebRequest -Uri $jqUrl -OutFile $jqExe

          # Convert to Unix path for bash wrapper
          $jqExeUnix = $jqExe -replace '\\', '/' -replace '^([A-Za-z]):', '/$1'

          # Create jq.cmd wrapper that routes through bash for proper quoting
          $cmdWrapper = "$toolsDir\jq.cmd"
          $wrapperContent = "@echo off`r`n`"C:\Program Files\Git\bin\bash.exe`" -c '`"$jqExeUnix`" `"`$@`"' _ %*"
          Set-Content -Path $cmdWrapper -Value $wrapperContent -Encoding ASCII

          # Create jq bash script (no extension) for Git Bash compatibility
          $bashWrapper = "$toolsDir\jq"
          $bashContent = "#!/bin/bash`n`"$jqExeUnix`" `"`$@`""
          Set-Content -Path $bashWrapper -Value $bashContent -NoNewline -Encoding ASCII

          Write-Host "jq wrappers installed at $toolsDir"

          # Add tools directory to PATH
          Add-Content -Path $env:GITHUB_PATH -Value $toolsDir

      # Install Claude Code on Windows (the action's install.sh doesn't support Windows)
      - name: Install Claude Code (Windows)
        id: install-claude
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          Write-Host "Installing Claude Code on Windows..."
          irm https://claude.ai/install.ps1 | iex

          # Search for claude.exe in likely locations
          Write-Host "Searching for claude.exe..."

          $searchPaths = @(
            "$env:USERPROFILE\.local\bin",
            "$env:USERPROFILE\.claude",
            "C:\Windows\ServiceProfiles\NetworkService\.local\bin",
            "$env:LOCALAPPDATA\Claude",
            "$env:LOCALAPPDATA\Programs\Claude",
            "$env:APPDATA\Claude",
            "$env:PROGRAMFILES\Claude",
            "${env:PROGRAMFILES(x86)}\Claude"
          )

          # Debug: List contents of .claude directory if it exists
          if (Test-Path "$env:USERPROFILE\.claude") {
            Write-Host "Contents of $env:USERPROFILE\.claude:"
            Get-ChildItem -Path "$env:USERPROFILE\.claude" -Recurse -ErrorAction SilentlyContinue | ForEach-Object { Write-Host $_.FullName }
          }

          # Search for claude.exe
          $claudeExe = $null
          foreach ($searchPath in $searchPaths) {
            if (Test-Path $searchPath) {
              $found = Get-ChildItem -Path $searchPath -Filter "claude.exe" -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1
              if ($found) {
                $claudeExe = $found.FullName
                break
              }
            }
          }

          if ($claudeExe) {
            Write-Host "Claude Code found at: $claudeExe"
            echo "claude-exe-path=$claudeExe" >> $env:GITHUB_OUTPUT
            # Add directory to PATH
            $claudeDir = Split-Path $claudeExe -Parent
            Add-Content -Path $env:GITHUB_PATH -Value $claudeDir
          } else {
            Write-Host "::error::Claude Code executable not found after installation"
            Write-Host "Searched paths: $($searchPaths -join ', ')"
            exit 1
          }

      # Format setup and environment preparation
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: false

      - name: Checkout of submodules
        run: git submodule update --init --recursive --depth=1

      # Workaround for fork PRs: the action tries to fetch the branch from origin,
      # but fork branches only exist on the fork. This step adds the fork as an
      # additional fetch URL for origin so the action's fetch succeeds.
      - name: Setup fork PR remote
        if: github.event.issue.pull_request != ''
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          PR_NUMBER="${{ github.event.issue.number }}"

          # Get PR details via GitHub API (gh CLI not available on self-hosted runners)
          PR_INFO=$(curl -s -H "Authorization: token ${GITHUB_TOKEN}" \
            "https://api.github.com/repos/${{ github.repository }}/pulls/${PR_NUMBER}")

          HEAD_REF=$(echo "$PR_INFO" | jq -r '.head.ref')
          HEAD_OWNER=$(echo "$PR_INFO" | jq -r '.head.repo.owner.login // empty')
          HEAD_REPO=$(echo "$PR_INFO" | jq -r '.head.repo.name // empty')

          # Check if this is a fork PR
          if [ -n "$HEAD_OWNER" ] && [ "$HEAD_OWNER" != "${{ github.repository_owner }}" ]; then
            echo "Fork PR detected from ${HEAD_OWNER}/${HEAD_REPO}, branch: ${HEAD_REF}"

            # Add fork as additional remote fetch URL
            FORK_URL="https://github.com/${HEAD_OWNER}/${HEAD_REPO}.git"
            echo "Adding fork URL to origin: ${FORK_URL}"
            git remote set-url --add origin "${FORK_URL}"

            # Fetch the fork branch so it's available locally
            echo "Fetching branch ${HEAD_REF} from fork..."
            git fetch origin "${HEAD_REF}"

            echo "Fork remote setup complete"
          else
            echo "Not a fork PR (owner: ${HEAD_OWNER:-same}), no remote changes needed"
          fi

      - name: Format Setup and Environment Preparation
        if: runner.os != 'Windows'
        uses: ./.github/actions/format-setup

      # Complete Claude execution with authentication, setup, and execution
      - name: Run Claude Code
        id: claude
        uses: ./.github/actions/claude-code-runner
        with:
          # Authentication (these secrets must be configured in your repository)
          llmgw-id: ${{ secrets.LLMGW_ID }}
          llmgw-secret: ${{ secrets.LLMGW_SECRET }}
          llmgw-token-url: ${{ secrets.LLMGW_TOKEN_URL }}
          github-token-fallback: ${{ secrets.GITHUB_TOKEN }}

          # Direct prompt for workflow_dispatch testing
          prompt: ${{ github.event.inputs.prompt || '' }}

          # Path to pre-installed Claude Code executable (Windows only)
          claude-code-executable-path: ${{ steps.install-claude.outputs.claude-exe-path || '' }}

          # Repository-specific setup (Windows)
          setup-commands: |
            set -euo pipefail
            echo "üèóÔ∏è Setting up Windows environment..."

            # Windows self-hosted runners have pre-installed:
            # - Visual Studio 2022
            # - CUDA toolkit
            # - Vulkan SDK
            # - NVIDIA GPU drivers

            # Configure and build the project (use cmake.exe for Windows)
            cmake.exe --preset vs2022 --fresh
            cmake.exe --build --preset release

            echo "‚úÖ Environment setup completed"

          # Custom instructions for Slang
          custom-instructions: |
            ### **Build System Information:**
            - OS: Windows Server 2022 (self-hosted runner with NVIDIA T4 GPU)
            - GPU: NVIDIA T4 available for GPU tests (D3D12, Vulkan)
            - Build commands: Configure `cmake.exe --preset vs2022`, Build `cmake.exe --build --preset release`
            - Test: `./build/Release/bin/slang-test.exe tests/path/to/test.slang`
            - GPU tests: Can use `-api dx12` or `-api vk` flags for GPU-specific tests
            - Project is pre-built and ready for development tasks

            ### **IMPORTANT: Windows-Specific Notes**
            - Always use `cmake.exe` (not `cmake`) to ensure proper execution
            - Use forward slashes in paths for bash scripts, backslashes for PowerShell
            - The runner has Visual Studio 2022, CUDA toolkit, and Vulkan SDK pre-installed

            ### **IMPORTANT: Deep Repository Knowledge & Debugging**
            **Repository Knowledge Tool**: Use `mcp__deepwiki__ask_question` with repoName "shader-slang/slang" for architectural insights and implementation patterns.

            **Implementation Guidelines:**
            - Use git history (`git log -S "keyword"`) to find related features but don't spend excessive time
            - Use deepwiki for expert insights and architectural patterns
            - Think carefully about the user's request before implementing

            ### **Test-Driven Development - Strongly Encouraged**
            Write failing tests in `tests/` directory, implement fixes and verify both tests and builds succeed before submitting.

          # MCP configuration for deepwiki
          mcp-config: |
            {
              "mcpServers": {
                "deepwiki": {
                  "type": "sse",
                  "url": "https://mcp.deepwiki.com/sse"
                }
              }
            }

          # Advanced configuration (using repository variables)
          model: ${{ vars.ANTHROPIC_MODEL }}
          aws-region: ${{ vars.AWS_REGION }}
          bedrock-base-url: ${{ vars.ANTHROPIC_BEDROCK_BASE_URL }}
          small-fast-model: ${{ vars.ANTHROPIC_SMALL_FAST_MODEL }}

          # Additional tools for deepwiki
          allowed-tools: "Bash,View,GlobTool,GrepTool,BatchTool,Write,mcp__deepwiki__ask_question"
