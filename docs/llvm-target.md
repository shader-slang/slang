Slang LLVM Target Support
========================

Slang has a general LLVM target, capable of creating LLVM IR and object code
for arbitrary target triples (`<machine>-<vendor>-<os>`, e.g.
`x86_64-unknown-linux`). The direct LLVM emitter allows for highly performant
and debuggable Slang code on almost any platform.

# Targets

* `-target llvm-ir` generates LLVM IR in the text representation.
* `-target llvm-obj` generates position-independent object code, which can be 
linked into an executable or a static or dynamic library.
* `-target llvm-shader-ir` is like `llvm-ir` but generates a dispatch function for compute shader entry points.
* `-target llvm-shader-obj` is like `llvm-obj` but generates a dispatch function for compute shader entry points.

Direct-to-executable or library targets may be added later, once the LLVM target
has stabilized. To set the LLVM target triple, use
`-llvm-target-triple <target-triple>`. The default is the host machine's triple.

# Features

* Compile stand-alone programs in Slang for platforms supported by LLVM
* Focus on memory layout correctness: scalar layout, etc. semantics are handled correctly
* Does not depend on external compilers (although, currently depends on external linkers!)
* Works well with debuggers!

# Standalone programs

You can write functions decorated with `export __extern_cpp` to make them visible
from the resulting object code. So, for a standalone Slang application, the entry
point is:

```slang
export __extern_cpp int main(int argc, NativeString* argv)
{
    // Do whatever you want here!
    return 0;
}
```

To cross-compile, you can use `-llvm-target-triple <target-triple>`.

# Application Binary Interface

This section defines the ABI rules which code generated by the LLVM target
follows and expects of external code calling into it.

## Types and resources

* `StructuredBuffer` and `ByteAddressBuffer` are stored as `{ Type* data; intptr_t size; }`,
where `size` is the number of elements in `data`.

* Vectors are passed as LLVM vector types; there's no direct equivalent in standard C or C++.
They're target-dependent, but usually follow std430-style rules, where
`float3` aligns to 16 bytes, while the rest are unsurprising.

* Matrix types are lowered into arrays of vectors. Column and row major matrices are supported as normal.

* `bool` is 1 byte by default, unless otherwise defined by `-fvk-use-scalar-layout`.

## Aggregate memory layout

By default, the LLVM target uses the LLVM's default data layout for the target
triple. This is basically the layout you'd expect in C, except vectors and
matrices are automatically aligned to the requirements of the widest applicable
vector instructions.

If you specify the `-fvk-use-c-layout` or `-fvk-use-scalar-layout` flags,
all structure and array types on the stack and heap will follow the specified
layout rules.

## Aggregate parameters

All aggregates (structs and arrays) are always passed by reference in Slang's
LLVM emitter. Other than that, the target platform's C calling conventions are
followed. This stems from [LLVM not handling aggregates correctly](https://discourse.llvm.org/t/passing-structs-to-c-functions/83938/8) in calling conventions, and requiring every frontend to painstakingly
reimplement the same per-target logic.

This means that if you declare a function like this in Slang:
```slang
export __extern_cpp MyStruct func(MyStruct val);
```

It would have the following signature in C:
```slang
void func(const MyStruct *val, MyStruct *returnval);
```

In other words, aggregate parameters are turned into pointers and aggregate
return values are turned into an additional pointer-typed parameter at the end
of the parameter list.

## C foreign function interface

Due to the aggregate parameter passing limitation of LLVM, calling arbitrary C
functions from Slang is complicated, and a hypothetical binding generator would
need to generate calling convention adapters like this:

```slang
// Struct declarations can usually be the same between C and Slang.
// Take care with bitfields and unions, though!
struct MyStruct
{
    int a;
    int b;
}

[ForceInline]
void funcAdapter(MyStruct* val, MyStruct* returnval)
{
    __requirePrelude(R"(declare i64 @func(i64))");
    __intrinsic_asm R"(
      %0 = load i64, $0, align 4
      %call = tail call i64 @func(i64 %0)
      store i64 %call, $1, align 4
      ret void
    )";
}

// This 'func' name gets mangled because it's not marked as __extern_cpp,
// which is good, since it isn't an external function but just calls into one.
[ForceInline]
public MyStruct func(MyStruct val)
{
    MyStruct returnval;
    funcAdapter(&val, &returnval);
    return returnval;
}
```

A binding generator would be a useful tool to include, but remains as future
work.

# Limitations

The LLVM target support is work-in-progress, and there are currently many
limitations.

## CPU targets only

Currently, support is limited to conventional CPU targets. The emitted LLVM IR
is not compatible with LLVMs SPIR-V target, for example. At least resource
bindings and pointer address spaces would have to be accounted for to expand
support to GPU targets. Slang already has native emitters for GPU targets, so
you can use those instead of going through LLVM.

## Pointer size

Currently, the Slang compiler assumes that the size of pointers matches the
compiler's host platform. This means that on a 64-bit PC, only target triples
with 64-bit pointers generate correct code. This can be a difficulty if one
wants to build Slang programs for a 32-bit microcontroller, and should
hopefully be fixed eventually.

## C standard library dependency

The generated IR and object code currently require printf and some math
functions to be linked from outside.

Fully Slang-written implementations of math functions would be possible and
nice to have as they don't need to communicate with the OS. Reducing the
required amount of C standard library support would be useful for running Slang
on bare metal.

## Missing compute shader features

* No `groupshared`
* No barriers.
* No atomics.
* No wave operations.

These limitations stem from the fact that work items / threads of a work group
are currently run serially instead of actually being in parallel. This may be
improved upon later.

## Limited vectorization

Vector instructions are vectorized in the way typical CPU math libraries
(e.g. GLM) vectorize, as long as the target triple allows for vector
instructions. This is different from how GPUs do it, where each work item /
thread gets a SIMD lane, and likely results in worse performance. This may be
improved upon later.

## Compatibility with prior CPU Slang features

There are limitations regarding features of the existing C++ based [CPU target](./cpu-target.md).
The following features are not yet supported:

* `String` type.
* `new`.
* `class`.
* COM interfaces.

These features heavily relied on C++ features, and are not trivial to implement
in LLVM. Support for them may be added later.

## Missing types

* No texture or sampler types.
* No acceleration structures.

These are missing due to limitation of scope for the initial implementation,
and may be added later. That said, both require non-trivial code where there is
no single obviously correct option:

* Should we store pixels in a Z-order curve for cache benefits, or row-by-row for simplicity?
* What kind of acceleration structure? Should CPU RT use an external library like Embree etc.?

# Gotchas

## Out-of-bounds buffer access

Attempting to index past the end of any buffer type is undefined behaviour. It
is not guaranteed to return zero as in HLSL; segmentation faults and memory
corruption are more than likely to occur!

## `sizeof`

Slang's `sizeof` may appear to "lie" to you about structs that contain padding,
unless you specify `-fvk-use-scalar-layout`. That's because it queries layout
information without knowing about the actual layout being used. Use `__sizeOf`
instead to get accurate sizes from LLVM, e.g. for memory allocation purposes.
