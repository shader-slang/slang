// Test permuto encoder interface with precomputed constants
// This test verifies the ITrainableEncoder interface implementation using
// link-time constant HyperParameters (simulating JIT-compiled constants)

// The purpose of this test is to mimic the actual usage of the PermutoEncoder in the training loop.
// Usually developers will generate all the hyper parameters and per-level info during runtime of
// the pipeline creation, so we make all precomputed constants to "permuto-encoder-precomputed-constants.slang",
// which can be generated by host. And import that file as a slang module into the main encoder slang module.

// TEST(compute):COMPARE_COMPUTE_EX(filecheck-buffer=BUF):-cuda -compute -shaderobj -output-using-type -xslang -experimental-feature
// TEST(compute):COMPARE_COMPUTE_EX(filecheck-buffer=BUF):-vk -compute -shaderobj -output-using-type -xslang -experimental-feature -emit-spirv-directly

import neural;
import "permuto-encoder-precomputed-constants";
import "permuto-reference-data";

static const float EPSILON = 0.1f;  // Allow for floating-point precision differences

// Type aliases using precomputed constants
typealias InArray = InlineVector<float, lc_nPosDims>;
typealias OutArray = InlineVector<float, lc_nFeatures>;
typealias Encoder = PermutoEncoder<float, lc_nPosDims, lc_featureDimPerEntry, lc_log2HashmapSize, lc_nLevels, InArray, OutArray>;

// ============================================================================
// Build HyperParameters from precomputed flat arrays
// ============================================================================

Encoder.HyperParameters buildHyperParameters()
{
    Encoder.HyperParameters params;
    params.maxLevel = lc_maxLevel;

    [ForceUnroll]
    for (uint level = 0; level < lc_nLevels; ++level)
    {
        params.levelInfo[level].currentLevelIndex = lc_levelIndices[level];
        params.levelInfo[level].offsetOfFeatureTable = lc_offsets[level];
        params.levelInfo[level].featureTableSize = lc_tableSizes[level];
        params.levelInfo[level].scale = lc_scales[level];

        [ForceUnroll]
        for (uint dim = 0; dim < lc_nPosDims; ++dim)
        {
            params.levelInfo[level].scalesPerDim[dim] = lc_scalesPerDim[level * lc_nPosDims + dim];
            params.levelInfo[level].shiftsPerDim[dim] = lc_shiftsPerDim[level * lc_nPosDims + dim];
        }
    }

    return params;
}

// ============================================================================
// Buffers
// ============================================================================

// Feature table buffer: will be initialized by threads with value[i] = i
// Total size: 1024 * 2 = 2048 floats
//TEST_INPUT: set gFeatureTable = ubuffer(count=2048, stride=4)
uniform RWStructuredBuffer<float>.Handle gFeatureTable;

// Output buffer: store all results (N_POSITIONS * N_FEATURES = 2048 floats)
//TEST_INPUT:ubuffer(count=2048, stride=4):name=gOutputBuffer
RWStructuredBuffer<float> gOutputBuffer;

// Verification result buffer: pass count
//TEST_INPUT:ubuffer(count=1, stride=4):out,name=gVerifyBuffer
RWStructuredBuffer<uint> gVerifyBuffer;

// ============================================================================
// Helper Functions
// ============================================================================

/// Verify a position's output features against expected values
bool verifyPosition(uint verifyIdx, uint posIdx)
{
    [ForceUnroll]
    for (uint f = 0; f < lc_nFeatures; ++f)
    {
        uint outIdx = posIdx * lc_nFeatures + f;
        uint expectedIdx = verifyIdx * lc_nFeatures + f;
        float expected = EXPECTED_FORWARD_VALUES[expectedIdx];
        float actual = gOutputBuffer[outIdx];
        float diff = abs(actual - expected);
        if (diff > EPSILON)
        {
            return false;
        }
    }
    return true;
}

// ============================================================================
// Main Compute Shader
// ============================================================================

[shader("compute")]
[numthreads(256, 1, 1)]
void computeMain(uint3 dispatchThreadID : SV_DispatchThreadID)
{
    uint posIdx = dispatchThreadID.x;
    if (posIdx >= lc_nPositions) return;

    // Initialize feature table: value[i] = i
    // Each thread handles 8 values
    uint baseIdx = posIdx * 8;
    [ForceUnroll]
    for (uint i = 0; i < 8; ++i)
    {
        uint idx = baseIdx + i;
        if (idx < lc_featureTableSize)
        {
            gFeatureTable[idx] = idx;
        }
    }

    // Barrier to ensure all threads have finished initializing
    AllMemoryBarrierWithGroupSync();

    // Compute position: center of grid cell in [0, 1]
    uint x = posIdx % lc_gridSize;
    uint y = posIdx / lc_gridSize;
    InArray position;
    position[0] = (float(x) + 0.5f) / float(lc_gridSize);
    position[1] = (float(y) + 0.5f) / float(lc_gridSize);

    // Create address for feature table
    BindlessAddress<float> featureAddress = BindlessAddress<float>(gFeatureTable);

    // Build HyperParameters from precomputed flat arrays
    Encoder.HyperParameters hyperParams = buildHyperParameters();

    // Encode using the interface with precomputed HyperParameters
    Encoder encoder = Encoder(hyperParams);
    OutArray output = encoder.encode<BindlessAddress<float>>(position, featureAddress);

    // Write output to buffer
    [ForceUnroll]
    for (uint f = 0; f < lc_nFeatures; ++f)
    {
        gOutputBuffer[posIdx * lc_nFeatures + f] = output[f];
    }

    // Barrier to ensure all threads have finished writing
    AllMemoryBarrierWithGroupSync();

    // Only thread 0 does verification
    if (posIdx != 0) return;

    // Verify 16 selected positions
    uint passCount = 0;
    [ForceUnroll]
    for (uint i = 0; i < NUM_VERIFY_POSITIONS; ++i)
    {
        if (verifyPosition(i, VERIFY_POSITIONS[i]))
        {
            passCount++;
        }
    }

    gVerifyBuffer[0] = passCount;
}

// Expected output: all 16 position verifications should pass
// BUF: 16
